Directory structure:
â””â”€â”€ 11cafe-jaaz/
    â”œâ”€â”€ README.md
    â”œâ”€â”€ entitlements.mac.plist
    â”œâ”€â”€ LICENSE
    â”œâ”€â”€ package.json
    â”œâ”€â”€ pyproject.toml
    â”œâ”€â”€ README-zh.md
    â”œâ”€â”€ README_zh.md
    â”œâ”€â”€ vitest.config.js
    â”œâ”€â”€ .prettierignore
    â”œâ”€â”€ .prettierrc.json
    â”œâ”€â”€ electron/
    â”‚   â”œâ”€â”€ comfyUIInstaller.js
    â”‚   â”œâ”€â”€ comfyUIManager.js
    â”‚   â”œâ”€â”€ gemin_service.ts
    â”‚   â”œâ”€â”€ ipcHandlers.js
    â”‚   â”œâ”€â”€ main.js
    â”‚   â”œâ”€â”€ preload.js
    â”‚   â”œâ”€â”€ settingsService.js
    â”‚   â”œâ”€â”€ tsconfig.json
    â”‚   â””â”€â”€ test/
    â”‚       â””â”€â”€ comfyUIInstaller/
    â”‚           â”œâ”€â”€ core-functions.test.js
    â”‚           â”œâ”€â”€ download-functions.test.js
    â”‚           â””â”€â”€ process-management.test.js
    â”œâ”€â”€ react/
    â”‚   â”œâ”€â”€ README.md
    â”‚   â”œâ”€â”€ components.json
    â”‚   â”œâ”€â”€ eslint.config.js
    â”‚   â”œâ”€â”€ index.html
    â”‚   â”œâ”€â”€ package.json
    â”‚   â”œâ”€â”€ tsconfig.app.json
    â”‚   â”œâ”€â”€ tsconfig.json
    â”‚   â”œâ”€â”€ tsconfig.lib.json
    â”‚   â”œâ”€â”€ tsconfig.node.json
    â”‚   â”œâ”€â”€ vite.config.ts
    â”‚   â””â”€â”€ src/
    â”‚       â”œâ”€â”€ App.tsx
    â”‚       â”œâ”€â”€ constants.ts
    â”‚       â”œâ”€â”€ index.d.ts
    â”‚       â”œâ”€â”€ index.ts
    â”‚       â”œâ”€â”€ main.tsx
    â”‚       â”œâ”€â”€ route-tree.gen.ts
    â”‚       â”œâ”€â”€ vite-env.d.ts
    â”‚       â”œâ”€â”€ api/
    â”‚       â”‚   â”œâ”€â”€ auth.ts
    â”‚       â”‚   â”œâ”€â”€ billing.ts
    â”‚       â”‚   â”œâ”€â”€ canvas.ts
    â”‚       â”‚   â”œâ”€â”€ chat.ts
    â”‚       â”‚   â”œâ”€â”€ config.ts
    â”‚       â”‚   â”œâ”€â”€ knowledge.ts
    â”‚       â”‚   â”œâ”€â”€ magic.ts
    â”‚       â”‚   â”œâ”€â”€ model.ts
    â”‚       â”‚   â”œâ”€â”€ settings.ts
    â”‚       â”‚   â””â”€â”€ upload.ts
    â”‚       â”œâ”€â”€ assets/
    â”‚       â”‚   â””â”€â”€ style/
    â”‚       â”‚       â”œâ”€â”€ animations.css
    â”‚       â”‚       â”œâ”€â”€ App.css
    â”‚       â”‚       â”œâ”€â”€ canvas.css
    â”‚       â”‚       â”œâ”€â”€ index.css
    â”‚       â”‚       â””â”€â”€ shiny-text.css
    â”‚       â”œâ”€â”€ components/
    â”‚       â”‚   â”œâ”€â”€ TopMenu.tsx
    â”‚       â”‚   â”œâ”€â”€ agent_studio/
    â”‚       â”‚   â”‚   â”œâ”€â”€ AgentNode.tsx
    â”‚       â”‚   â”‚   â”œâ”€â”€ AgentSettings.tsx
    â”‚       â”‚   â”‚   â””â”€â”€ AgentStudio.tsx
    â”‚       â”‚   â”œâ”€â”€ auth/
    â”‚       â”‚   â”‚   â”œâ”€â”€ LoginDialog.tsx
    â”‚       â”‚   â”‚   â”œâ”€â”€ PointsDisplay.tsx
    â”‚       â”‚   â”‚   â””â”€â”€ UserMenu.tsx
    â”‚       â”‚   â”œâ”€â”€ canvas/
    â”‚       â”‚   â”‚   â”œâ”€â”€ CanvasExcali.tsx
    â”‚       â”‚   â”‚   â”œâ”€â”€ CanvasExport.tsx
    â”‚       â”‚   â”‚   â”œâ”€â”€ CanvasHeader.tsx
    â”‚       â”‚   â”‚   â”œâ”€â”€ VideoElement.tsx
    â”‚       â”‚   â”‚   â”œâ”€â”€ menu/
    â”‚       â”‚   â”‚   â”‚   â”œâ”€â”€ CanvasMenuButton.tsx
    â”‚       â”‚   â”‚   â”‚   â”œâ”€â”€ CanvasMenuIcon.tsx
    â”‚       â”‚   â”‚   â”‚   â”œâ”€â”€ CanvasToolMenu.tsx
    â”‚       â”‚   â”‚   â”‚   â”œâ”€â”€ CanvasViewMenu.tsx
    â”‚       â”‚   â”‚   â”‚   â””â”€â”€ index.tsx
    â”‚       â”‚   â”‚   â””â”€â”€ pop-bar/
    â”‚       â”‚   â”‚       â”œâ”€â”€ CanvasMagicGenerator.tsx
    â”‚       â”‚   â”‚       â”œâ”€â”€ CanvasPopbar.tsx
    â”‚       â”‚   â”‚       â”œâ”€â”€ CanvasPopbarContainer.tsx
    â”‚       â”‚   â”‚       â””â”€â”€ index.tsx
    â”‚       â”‚   â”œâ”€â”€ chat/
    â”‚       â”‚   â”‚   â”œâ”€â”€ Chat.tsx
    â”‚       â”‚   â”‚   â”œâ”€â”€ ChatHistory.tsx
    â”‚       â”‚   â”‚   â”œâ”€â”€ ChatMagicGenerator.tsx
    â”‚       â”‚   â”‚   â”œâ”€â”€ ChatTextarea.tsx
    â”‚       â”‚   â”‚   â”œâ”€â”€ IconCarousel.tsx
    â”‚       â”‚   â”‚   â”œâ”€â”€ Markdown.tsx
    â”‚       â”‚   â”‚   â”œâ”€â”€ ModelSelectorV2.tsx
    â”‚       â”‚   â”‚   â”œâ”€â”€ ModelSelectorV3.tsx
    â”‚       â”‚   â”‚   â”œâ”€â”€ MultiChoicePrompt.tsx
    â”‚       â”‚   â”‚   â”œâ”€â”€ SessionSelector.tsx
    â”‚       â”‚   â”‚   â”œâ”€â”€ ShareTemplateDialog.tsx
    â”‚       â”‚   â”‚   â”œâ”€â”€ SingleChoicePrompt.tsx
    â”‚       â”‚   â”‚   â”œâ”€â”€ Spinner.tsx
    â”‚       â”‚   â”‚   â”œâ”€â”€ ToolcallProgressUpdate.tsx
    â”‚       â”‚   â”‚   â””â”€â”€ Message/
    â”‚       â”‚   â”‚       â”œâ”€â”€ Image.tsx
    â”‚       â”‚   â”‚       â”œâ”€â”€ MixedContent.tsx
    â”‚       â”‚   â”‚       â”œâ”€â”€ Regular.tsx
    â”‚       â”‚   â”‚       â”œâ”€â”€ TextFoldTag.tsx
    â”‚       â”‚   â”‚       â”œâ”€â”€ ToolCallContent.tsx
    â”‚       â”‚   â”‚       â”œâ”€â”€ ToolCallTag.tsx
    â”‚       â”‚   â”‚       â””â”€â”€ WritePlanToolcall.tsx
    â”‚       â”‚   â”œâ”€â”€ comfyui/
    â”‚       â”‚   â”‚   â”œâ”€â”€ InstallComfyUIDialog.tsx
    â”‚       â”‚   â”‚   â”œâ”€â”€ InstallProgressDialog.tsx
    â”‚       â”‚   â”‚   â””â”€â”€ UninstallProgressDialog.tsx
    â”‚       â”‚   â”œâ”€â”€ common/
    â”‚       â”‚   â”‚   â”œâ”€â”€ Blur.tsx
    â”‚       â”‚   â”‚   â”œâ”€â”€ DialogContent.tsx
    â”‚       â”‚   â”‚   â”œâ”€â”€ ErrorBoundary.tsx
    â”‚       â”‚   â”‚   â”œâ”€â”€ LanguageSwitcher.tsx
    â”‚       â”‚   â”‚   â”œâ”€â”€ NotificationPanel.tsx
    â”‚       â”‚   â”‚   â””â”€â”€ UpdateNotificationDialog.tsx
    â”‚       â”‚   â”œâ”€â”€ home/
    â”‚       â”‚   â”‚   â”œâ”€â”€ CanvasCard.tsx
    â”‚       â”‚   â”‚   â”œâ”€â”€ CanvasDeleteDialog.tsx
    â”‚       â”‚   â”‚   â””â”€â”€ CanvasList.tsx
    â”‚       â”‚   â”œâ”€â”€ knowledge/
    â”‚       â”‚   â”‚   â”œâ”€â”€ Editor.tsx
    â”‚       â”‚   â”‚   â””â”€â”€ Knowledge.tsx
    â”‚       â”‚   â”œâ”€â”€ material/
    â”‚       â”‚   â”‚   â”œâ”€â”€ FilePreviewModal.tsx
    â”‚       â”‚   â”‚   â””â”€â”€ MaterialManager.tsx
    â”‚       â”‚   â”œâ”€â”€ settings/
    â”‚       â”‚   â”‚   â”œâ”€â”€ AddModelsList.tsx
    â”‚       â”‚   â”‚   â”œâ”€â”€ AddProviderDialog.tsx
    â”‚       â”‚   â”‚   â”œâ”€â”€ ComfyuiSetting.tsx
    â”‚       â”‚   â”‚   â”œâ”€â”€ ComfyuiWorkflowSetting.tsx
    â”‚       â”‚   â”‚   â”œâ”€â”€ CommonSetting.tsx
    â”‚       â”‚   â”‚   â”œâ”€â”€ JaazSetting.tsx
    â”‚       â”‚   â”‚   â””â”€â”€ dialog/
    â”‚       â”‚   â”‚       â”œâ”€â”€ index.tsx
    â”‚       â”‚   â”‚       â”œâ”€â”€ providers.tsx
    â”‚       â”‚   â”‚       â”œâ”€â”€ proxy.tsx
    â”‚       â”‚   â”‚       â””â”€â”€ sidebar.tsx
    â”‚       â”‚   â”œâ”€â”€ theme/
    â”‚       â”‚   â”‚   â”œâ”€â”€ ThemeButton.tsx
    â”‚       â”‚   â”‚   â””â”€â”€ ThemeProvider.tsx
    â”‚       â”‚   â””â”€â”€ ui/
    â”‚       â”‚       â”œâ”€â”€ avatar.tsx
    â”‚       â”‚       â”œâ”€â”€ badge.tsx
    â”‚       â”‚       â”œâ”€â”€ button.tsx
    â”‚       â”‚       â”œâ”€â”€ card.tsx
    â”‚       â”‚       â”œâ”€â”€ checkbox.tsx
    â”‚       â”‚       â”œâ”€â”€ combobox.tsx
    â”‚       â”‚       â”œâ”€â”€ context-menu.tsx
    â”‚       â”‚       â”œâ”€â”€ dialog.tsx
    â”‚       â”‚       â”œâ”€â”€ dropdown-menu.tsx
    â”‚       â”‚       â”œâ”€â”€ hotkey.tsx
    â”‚       â”‚       â”œâ”€â”€ input.tsx
    â”‚       â”‚       â”œâ”€â”€ label.tsx
    â”‚       â”‚       â”œâ”€â”€ popover.tsx
    â”‚       â”‚       â”œâ”€â”€ progress.tsx
    â”‚       â”‚       â”œâ”€â”€ resizable.tsx
    â”‚       â”‚       â”œâ”€â”€ scroll-area.tsx
    â”‚       â”‚       â”œâ”€â”€ select.tsx
    â”‚       â”‚       â”œâ”€â”€ separator.tsx
    â”‚       â”‚       â”œâ”€â”€ sheet.tsx
    â”‚       â”‚       â”œâ”€â”€ shiny-text.tsx
    â”‚       â”‚       â”œâ”€â”€ sidebar.tsx
    â”‚       â”‚       â”œâ”€â”€ skeleton.tsx
    â”‚       â”‚       â”œâ”€â”€ slider.tsx
    â”‚       â”‚       â”œâ”€â”€ sonner.tsx
    â”‚       â”‚       â”œâ”€â”€ Spinner.tsx
    â”‚       â”‚       â”œâ”€â”€ switch.tsx
    â”‚       â”‚       â”œâ”€â”€ textarea.tsx
    â”‚       â”‚       â”œâ”€â”€ tooltip.tsx
    â”‚       â”‚       â””â”€â”€ video-player.tsx
    â”‚       â”œâ”€â”€ contexts/
    â”‚       â”‚   â”œâ”€â”€ AuthContext.tsx
    â”‚       â”‚   â”œâ”€â”€ canvas.tsx
    â”‚       â”‚   â”œâ”€â”€ configs.tsx
    â”‚       â”‚   â”œâ”€â”€ socket.tsx
    â”‚       â”‚   â””â”€â”€ theme.tsx
    â”‚       â”œâ”€â”€ examples/
    â”‚       â”‚   â””â”€â”€ exampleMessages.ts
    â”‚       â”œâ”€â”€ hooks/
    â”‚       â”‚   â”œâ”€â”€ use-balance.ts
    â”‚       â”‚   â”œâ”€â”€ use-debounce.ts
    â”‚       â”‚   â”œâ”€â”€ use-language.ts
    â”‚       â”‚   â”œâ”€â”€ use-mobile.ts
    â”‚       â”‚   â”œâ”€â”€ use-notifications.ts
    â”‚       â”‚   â””â”€â”€ use-theme.ts
    â”‚       â”œâ”€â”€ i18n/
    â”‚       â”‚   â”œâ”€â”€ README.md
    â”‚       â”‚   â”œâ”€â”€ index.ts
    â”‚       â”‚   â””â”€â”€ locales/
    â”‚       â”‚       â”œâ”€â”€ en/
    â”‚       â”‚       â”‚   â”œâ”€â”€ canvas.json
    â”‚       â”‚       â”‚   â”œâ”€â”€ chat.json
    â”‚       â”‚       â”‚   â”œâ”€â”€ common.json
    â”‚       â”‚       â”‚   â”œâ”€â”€ home.json
    â”‚       â”‚       â”‚   â””â”€â”€ settings.json
    â”‚       â”‚       â””â”€â”€ zh-CN/
    â”‚       â”‚           â”œâ”€â”€ canvas.json
    â”‚       â”‚           â”œâ”€â”€ chat.json
    â”‚       â”‚           â”œâ”€â”€ common.json
    â”‚       â”‚           â”œâ”€â”€ home.json
    â”‚       â”‚           â””â”€â”€ settings.json
    â”‚       â”œâ”€â”€ lib/
    â”‚       â”‚   â”œâ”€â”€ event.ts
    â”‚       â”‚   â”œâ”€â”€ notifications.ts
    â”‚       â”‚   â”œâ”€â”€ socket.ts
    â”‚       â”‚   â””â”€â”€ utils.ts
    â”‚       â”œâ”€â”€ routes/
    â”‚       â”‚   â”œâ”€â”€ __root.tsx
    â”‚       â”‚   â”œâ”€â”€ agent_studio.tsx
    â”‚       â”‚   â”œâ”€â”€ assets.tsx
    â”‚       â”‚   â”œâ”€â”€ canvas.$id.tsx
    â”‚       â”‚   â”œâ”€â”€ index.tsx
    â”‚       â”‚   â””â”€â”€ knowledge.tsx
    â”‚       â”œâ”€â”€ stores/
    â”‚       â”‚   â”œâ”€â”€ canvas.ts
    â”‚       â”‚   â””â”€â”€ configs.ts
    â”‚       â”œâ”€â”€ types/
    â”‚       â”‚   â”œâ”€â”€ electron.d.ts
    â”‚       â”‚   â”œâ”€â”€ socket.ts
    â”‚       â”‚   â””â”€â”€ types.ts
    â”‚       â””â”€â”€ utils/
    â”‚           â”œâ”€â”€ formatDate.ts
    â”‚           â”œâ”€â”€ imageUtils.ts
    â”‚           â””â”€â”€ pngMetadata.ts
    â”œâ”€â”€ scripts/
    â”‚   â””â”€â”€ notarize.js
    â”œâ”€â”€ server/
    â”‚   â”œâ”€â”€ common.py
    â”‚   â”œâ”€â”€ main.py
    â”‚   â”œâ”€â”€ main.spec
    â”‚   â”œâ”€â”€ requirements.txt
    â”‚   â”œâ”€â”€ asset/
    â”‚   â”‚   â”œâ”€â”€ default_comfy_t2i_workflow.json
    â”‚   â”‚   â””â”€â”€ flux_comfy_workflow.json
    â”‚   â”œâ”€â”€ models/
    â”‚   â”‚   â”œâ”€â”€ __init__.py
    â”‚   â”‚   â”œâ”€â”€ config_model.py
    â”‚   â”‚   â”œâ”€â”€ db_model.py
    â”‚   â”‚   â””â”€â”€ tool_model.py
    â”‚   â”œâ”€â”€ routers/
    â”‚   â”‚   â”œâ”€â”€ __init__.py
    â”‚   â”‚   â”œâ”€â”€ canvas.py
    â”‚   â”‚   â”œâ”€â”€ chat_router.py
    â”‚   â”‚   â”œâ”€â”€ comfyui_execution.py
    â”‚   â”‚   â”œâ”€â”€ config_router.py
    â”‚   â”‚   â”œâ”€â”€ image_router.py
    â”‚   â”‚   â”œâ”€â”€ root_router.py
    â”‚   â”‚   â”œâ”€â”€ settings.py
    â”‚   â”‚   â”œâ”€â”€ ssl_test.py
    â”‚   â”‚   â”œâ”€â”€ tool_confirmation.py
    â”‚   â”‚   â”œâ”€â”€ websocket_router.py
    â”‚   â”‚   â””â”€â”€ workspace.py
    â”‚   â”œâ”€â”€ services/
    â”‚   â”‚   â”œâ”€â”€ __init__.py
    â”‚   â”‚   â”œâ”€â”€ chat_service.py
    â”‚   â”‚   â”œâ”€â”€ config_service.py
    â”‚   â”‚   â”œâ”€â”€ db_service.py
    â”‚   â”‚   â”œâ”€â”€ jaaz_service.py
    â”‚   â”‚   â”œâ”€â”€ knowledge_service.py
    â”‚   â”‚   â”œâ”€â”€ magic_service.py
    â”‚   â”‚   â”œâ”€â”€ mcp.py
    â”‚   â”‚   â”œâ”€â”€ settings_service.py
    â”‚   â”‚   â”œâ”€â”€ stream_service.py
    â”‚   â”‚   â”œâ”€â”€ tool_confirmation_manager.py
    â”‚   â”‚   â”œâ”€â”€ tool_service.py
    â”‚   â”‚   â”œâ”€â”€ websocket_service.py
    â”‚   â”‚   â”œâ”€â”€ websocket_state.py
    â”‚   â”‚   â”œâ”€â”€ langgraph_service/
    â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
    â”‚   â”‚   â”‚   â”œâ”€â”€ agent_manager.py
    â”‚   â”‚   â”‚   â”œâ”€â”€ agent_service.py
    â”‚   â”‚   â”‚   â”œâ”€â”€ StreamProcessor.py
    â”‚   â”‚   â”‚   â””â”€â”€ configs/
    â”‚   â”‚   â”‚       â”œâ”€â”€ __init__.py
    â”‚   â”‚   â”‚       â”œâ”€â”€ base_config.py
    â”‚   â”‚   â”‚       â”œâ”€â”€ image_designer_config.py
    â”‚   â”‚   â”‚       â”œâ”€â”€ image_vide_creator_config.py
    â”‚   â”‚   â”‚       â”œâ”€â”€ planner_config.py
    â”‚   â”‚   â”‚       â””â”€â”€ video_designer_config.py
    â”‚   â”‚   â”œâ”€â”€ migrations/
    â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
    â”‚   â”‚   â”‚   â”œâ”€â”€ manager.py
    â”‚   â”‚   â”‚   â”œâ”€â”€ v1_initial_schema.py
    â”‚   â”‚   â”‚   â”œâ”€â”€ v2_add_canvases.py
    â”‚   â”‚   â”‚   â””â”€â”€ v3_add_comfy_workflow.py
    â”‚   â”‚   â””â”€â”€ OpenAIAgents_service/
    â”‚   â”‚       â”œâ”€â”€ __init__.py
    â”‚   â”‚       â”œâ”€â”€ jaaz_magic_agent.py
    â”‚   â”‚       â””â”€â”€ test.py
    â”‚   â”œâ”€â”€ tools/
    â”‚   â”‚   â”œâ”€â”€ comfy_dynamic.py
    â”‚   â”‚   â”œâ”€â”€ generate_image_by_doubao_seededit_3_volces.py
    â”‚   â”‚   â”œâ”€â”€ generate_image_by_doubao_seedream_3_jaaz.py
    â”‚   â”‚   â”œâ”€â”€ generate_image_by_doubao_seedream_3_volces.py
    â”‚   â”‚   â”œâ”€â”€ generate_image_by_flux_1_1_pro_jaaz.py
    â”‚   â”‚   â”œâ”€â”€ generate_image_by_flux_kontext_max_jaaz.py
    â”‚   â”‚   â”œâ”€â”€ generate_image_by_flux_kontext_max_replicate.py
    â”‚   â”‚   â”œâ”€â”€ generate_image_by_flux_kontext_pro_jaaz.py
    â”‚   â”‚   â”œâ”€â”€ generate_image_by_flux_kontext_pro_replicate.py
    â”‚   â”‚   â”œâ”€â”€ generate_image_by_gpt_image_1_jaaz.py
    â”‚   â”‚   â”œâ”€â”€ generate_image_by_ideogram3_bal_jaaz.py
    â”‚   â”‚   â”œâ”€â”€ generate_image_by_imagen_4_jaaz.py
    â”‚   â”‚   â”œâ”€â”€ generate_image_by_imagen_4_replicate.py
    â”‚   â”‚   â”œâ”€â”€ generate_image_by_midjourney_jaaz.py
    â”‚   â”‚   â”œâ”€â”€ generate_image_by_recraft_v3_jaaz.py
    â”‚   â”‚   â”œâ”€â”€ generate_image_by_recraft_v3_replicate.py
    â”‚   â”‚   â”œâ”€â”€ generate_video_by_hailuo_02_jaaz.py
    â”‚   â”‚   â”œâ”€â”€ generate_video_by_kling_v2_jaaz.py
    â”‚   â”‚   â”œâ”€â”€ generate_video_by_seedance_v1_jaaz.py
    â”‚   â”‚   â”œâ”€â”€ generate_video_by_seedance_v1_lite_volces.py
    â”‚   â”‚   â”œâ”€â”€ generate_video_by_seedance_v1_pro_volces.py
    â”‚   â”‚   â”œâ”€â”€ generate_video_by_veo3_fast_jaaz.py
    â”‚   â”‚   â”œâ”€â”€ video_generation_utils.py
    â”‚   â”‚   â”œâ”€â”€ write_plan.py
    â”‚   â”‚   â”œâ”€â”€ image_providers/
    â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
    â”‚   â”‚   â”‚   â”œâ”€â”€ comfyui_provider.py
    â”‚   â”‚   â”‚   â”œâ”€â”€ image_base_provider.py
    â”‚   â”‚   â”‚   â”œâ”€â”€ jaaz_provider.py
    â”‚   â”‚   â”‚   â”œâ”€â”€ openai_provider.py
    â”‚   â”‚   â”‚   â”œâ”€â”€ replicate_provider.py
    â”‚   â”‚   â”‚   â”œâ”€â”€ volces_provider.py
    â”‚   â”‚   â”‚   â””â”€â”€ wavespeed_provider.py
    â”‚   â”‚   â”œâ”€â”€ utils/
    â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
    â”‚   â”‚   â”‚   â”œâ”€â”€ comfyui.py
    â”‚   â”‚   â”‚   â”œâ”€â”€ image_canvas_utils.py
    â”‚   â”‚   â”‚   â”œâ”€â”€ image_generation_core.py
    â”‚   â”‚   â”‚   â””â”€â”€ image_utils.py
    â”‚   â”‚   â”œâ”€â”€ video_generation/
    â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
    â”‚   â”‚   â”‚   â”œâ”€â”€ video_canvas_utils.py
    â”‚   â”‚   â”‚   â””â”€â”€ video_generation_core.py
    â”‚   â”‚   â””â”€â”€ video_providers/
    â”‚   â”‚       â”œâ”€â”€ __init__.py
    â”‚   â”‚       â”œâ”€â”€ video_base_provider.py
    â”‚   â”‚       â””â”€â”€ volces_provider.py
    â”‚   â””â”€â”€ utils/
    â”‚       â”œâ”€â”€ canvas.py
    â”‚       â””â”€â”€ http_client.py
    â””â”€â”€ .github/
        â””â”€â”€ workflows/
            â””â”€â”€ build.yml

================================================
FILE: README.md
================================================
[Binary file]


================================================
FILE: entitlements.mac.plist
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
  <dict>
    <key>com.apple.security.cs.allow-jit</key>
    <true/>
    <key>com.apple.security.cs.allow-unsigned-executable-memory</key>
    <true/>
    <key>com.apple.security.cs.disable-library-validation</key>
    <true/>
    <key>com.apple.security.inherit</key>
    <true/>
  </dict>
</plist> 


================================================
FILE: LICENSE
================================================
Jaaz Licensing Policy (Dual License: Community & Commercial)

Jaaz is released under a dual-license model: the Jaaz Community License (free) and a Commercial License (paid).

1. Jaaz Community License

Permitted Uses (Free):

Individuals (Personal Use):

Granted a free, perpetual license to use all standard Jaaz functions.

Content created using Jaaz may be used for personal or commercial projects.

Organizations (Limited Use):

Organizations may use Jaaz only in its standard, unmodified, out-of-the-box form for evaluation or non-commercial purposes.

Strictly Prohibited Without a Commercial License:

Team Deployment: Installing, hosting, or operating Jaaz for simultaneous use by multiple users in an organization (e.g., on shared servers, internal networks, or private clouds).

Code Modification or Derivative Works: Modifying, translating, reverse-engineering, or creating derivative products based on Jaaz source code.

Redistribution: Redistributing Jaaz (modified or unmodified) as part of another product or service.

Competitive Offering: Using Jaaz (in whole or in part) as the foundation of a competing commercial product.

2. Commercial License

A Commercial License is REQUIRED for any of the following:

Internal multi-user or team deployment.

Any secondary development, customization, or modification of the source code.

Embedding or redistributing Jaaz as part of your own commercial offering.

Access to official technical support, warranties, or indemnification.

A Commercial License grants you the legal right to use Jaaz for enterprise purposes and to adapt its source code for your organizationâ€™s needs.

ğŸ‘‰ To obtain a Commercial License, please contact: aifoxdw@gmail.com

3. Contributions

By submitting contributions, you agree to grant the Jaaz maintainers a perpetual, worldwide, royalty-free, irrevocable license to use, modify, and sublicense your contributions under both the Community and Commercial Licenses.

4. Trademarks & UI

The Jaaz name, logo, and visual/interaction design are protected intellectual property and trademarks.

You may not use Jaaz branding, trademarks, or UI/UX designs for derivative or resale products without explicit permission.

Â© 2025 Jaaz Contributors & 11cafe Studio. All rights reserved.
Jaaz è®¸å¯åè®®ï¼ˆåŒé‡è®¸å¯ï¼šç¤¾åŒºç‰ˆ & å•†ä¸šç‰ˆï¼‰

Jaaz é‡‡ç”¨åŒé‡è®¸å¯æ¨¡å¼å‘å¸ƒï¼šJaaz ç¤¾åŒºè®¸å¯è¯ï¼ˆå…è´¹ï¼‰ å’Œ å•†ä¸šè®¸å¯è¯ï¼ˆä»˜è´¹ï¼‰ã€‚

1. Jaaz ç¤¾åŒºè®¸å¯è¯ï¼ˆå…è´¹ï¼‰

å…è®¸çš„ä½¿ç”¨ï¼š

ä¸ªäººç”¨æˆ·ï¼ˆä¸ªäººä½¿ç”¨ï¼‰ï¼š

å…è´¹ã€æ°¸ä¹…åœ°ä½¿ç”¨ Jaaz çš„æ‰€æœ‰æ ‡å‡†åŠŸèƒ½ã€‚

ä½¿ç”¨ Jaaz ç”Ÿæˆçš„å†…å®¹å¯ç”¨äºä¸ªäººæˆ–å•†ä¸šé¡¹ç›®ã€‚

ç»„ç»‡ç”¨æˆ·ï¼ˆæœ‰é™ä½¿ç”¨ï¼‰ï¼š

ç»„ç»‡ä»…å¯åœ¨ æœªç»ä¿®æ”¹ã€åŸæ ·çš„æ ‡å‡†ç‰ˆæœ¬ ä¸‹ä½¿ç”¨ Jaazï¼Œç”¨äºè¯„ä¼°æˆ–éå•†ä¸šç›®çš„ã€‚

åœ¨æœªè·å¾—å•†ä¸šè®¸å¯è¯çš„æƒ…å†µä¸‹ï¼Œä¸¥æ ¼ç¦æ­¢ä»¥ä¸‹è¡Œä¸ºï¼š

å›¢é˜Ÿéƒ¨ç½²ï¼š åœ¨ç»„ç»‡å†…éƒ¨ä»¥å¤šäººåŒæ—¶è®¿é—®çš„æ–¹å¼å®‰è£…ã€æ‰˜ç®¡æˆ–è¿è¡Œ Jaazï¼ˆä¾‹å¦‚ï¼šå…±äº«æœåŠ¡å™¨ã€å†…éƒ¨ç½‘ç»œæˆ–ç§æœ‰äº‘ç¯å¢ƒï¼‰ã€‚

ä»£ç ä¿®æ”¹æˆ–è¡ç”Ÿä½œå“ï¼š ä¿®æ”¹ã€ç¿»è¯‘ã€é€†å‘å·¥ç¨‹ã€åç¼–è¯‘æˆ–åŸºäº Jaaz æºä»£ç åˆ›å»ºè¡ç”Ÿäº§å“ã€‚

å†åˆ†å‘ï¼š å°† Jaazï¼ˆæ— è®ºæ˜¯å¦ä¿®æ”¹ï¼‰ä½œä¸ºå…¶ä»–äº§å“æˆ–æœåŠ¡çš„ä¸€éƒ¨åˆ†è¿›è¡Œå†åˆ†å‘ã€‚

ç«äº‰æ€§äº§å“ï¼š å°† Jaazï¼ˆæ•´ä½“æˆ–éƒ¨åˆ†ï¼‰ä½œä¸ºç«äº‰æ€§å•†ä¸šäº§å“æˆ–æœåŠ¡çš„åŸºç¡€ã€‚

2. å•†ä¸šè®¸å¯è¯ï¼ˆä»˜è´¹ï¼‰

ä»¥ä¸‹ä»»ä½•æƒ…å†µ å¿…é¡»è´­ä¹°å•†ä¸šè®¸å¯è¯ï¼š

å†…éƒ¨å¤šç”¨æˆ·æˆ–å›¢é˜Ÿéƒ¨ç½²ã€‚

å¯¹ Jaaz æºä»£ç çš„ä»»ä½•äºŒæ¬¡å¼€å‘ã€å®šåˆ¶æˆ–ä¿®æ”¹ã€‚

å°† Jaaz åµŒå…¥æˆ–å†åˆ†å‘ä¸ºæ‚¨è‡ªå·±çš„å•†ä¸šäº§å“æˆ–æœåŠ¡çš„ä¸€éƒ¨åˆ†ã€‚

è·å–å®˜æ–¹çš„æŠ€æœ¯æ”¯æŒã€è´¨é‡ä¿è¯æˆ–èµ”å¿ä¿éšœã€‚

å•†ä¸šè®¸å¯è¯ä¸ºæ‚¨æä¾›åœ¨ä¼ä¸šç¯å¢ƒä¸­åˆæ³•ä½¿ç”¨ Jaaz çš„æƒåˆ©ï¼Œå¹¶å…è®¸æ ¹æ®ç»„ç»‡éœ€æ±‚ä¿®æ”¹å…¶æºä»£ç ã€‚

ğŸ‘‰ è·å–å•†ä¸šè®¸å¯è¯ï¼Œè¯·è”ç³»ï¼šaifoxdw@gmail.com

3. è´¡çŒ®è€…æ¡æ¬¾

é€šè¿‡æäº¤ä»£ç æˆ–å…¶ä»–è´¡çŒ®ï¼Œæ‚¨åŒæ„æˆäºˆ Jaaz é¡¹ç›®ç»´æŠ¤è€…ä¸€é¡¹ æ°¸ä¹…çš„ã€å…¨çƒæ€§çš„ã€å…è´¹çš„ã€å…ç‰ˆç¨çš„ã€ä¸å¯æ’¤é”€çš„è®¸å¯ï¼Œå…è®¸å…¶åœ¨ ç¤¾åŒºè®¸å¯è¯å’Œå•†ä¸šè®¸å¯è¯ ä¸‹ä½¿ç”¨ã€ä¿®æ”¹å’Œå†è®¸å¯æ‚¨çš„è´¡çŒ®ã€‚

4. å•†æ ‡ä¸ç•Œé¢ä¿æŠ¤

Jaaz åç§°ã€Logo åŠå…¶è§†è§‰/äº¤äº’è®¾è®¡ å—çŸ¥è¯†äº§æƒå’Œå•†æ ‡æ³•ä¿æŠ¤ã€‚

æœªç»æ˜ç¡®æˆæƒï¼Œä¸å¾—å°† Jaaz çš„å“ç‰Œã€å•†æ ‡æˆ– UI/UX è®¾è®¡ç”¨äºè¡ç”Ÿæˆ–å†é”€å”®çš„äº§å“ã€‚

Â© 2025 Jaaz è´¡çŒ®è€… & 11cafe Studio. ç‰ˆæƒæ‰€æœ‰ã€‚



================================================
FILE: package.json
================================================
{
  "name": "jaaz",
  "version": "1.0.30",
  "description": "AI design agent local desktop app",
  "author": "weixuanfu",
  "main": "electron/main.js",
  "scripts": {
    "start": "cd react && npx vite build && cd .. && npm run start:electron",
    "dev:react": "cd react && npm run dev",
    "dev:electron": "cross-env NODE_ENV=development npx electron electron/main.js",
    "dev": "concurrently \"npm run dev:react\" \"npm run dev:electron\"",
    "start:frontend": "cd frontend && npm run dev",
    "start:electron": "npx electron electron/main.js",
    "build:electron": "electron-builder",
    "build:win": "electron-builder --win",
    "build:mac": "electron-builder --mac",
    "build:linux": "electron-builder --linux",
    "build:ts": "cd electron && tsc",
    "watch:ts": "cd electron && tsc --watch",
    "clean:ts": "cd electron && rm -rf dist",
    "test": "vitest",
    "test:run": "vitest run",
    "test:watch": "vitest --watch"
  },
  "publish": "always",
  "build": {
    "appId": "com.jaaz.app",
    "productName": "Jaaz",
    "publish": {
      "provider": "github",
      "releaseType": "draft"
    },
    "directories": {
      "output": "dist"
    },
    "files": [
      "electron/**/*",
      "package.json",
      "assets/icons/*"
    ],
    "extraResources": [
      {
        "from": "server/dist/",
        "to": "server/dist/"
      },
      {
        "from": "react/dist/",
        "to": "react/dist/"
      }
    ],
    "mac": {
      "category": "public.app-category.utilities",
      "icon": "assets/icons/jaaz.icns",
      "target": [
        "dmg",
        "zip"
      ],
      "gatekeeperAssess": false,
      "hardenedRuntime": true,
      "entitlements": "entitlements.mac.plist",
      "entitlementsInherit": "entitlements.mac.plist",
      "notarize": false
    },
    "afterSign": "scripts/notarize.js",
    "win": {
      "icon": "assets/icons/jaaz.ico",
      "target": [
        "nsis"
      ]
    },
    "nsis": {
      "oneClick": false,
      "allowToChangeInstallationDirectory": true
    },
    "linux": {
      "target": [
        "AppImage",
        "deb"
      ]
    }
  },
  "devDependencies": {
    "@electron/notarize": "^3.0.1",
    "@types/electron": "^1.4.38",
    "@types/node": "^20.19.4",
    "concurrently": "^9.1.2",
    "cross-env": "^7.0.3",
    "electron": "^35.1.0",
    "electron-builder": "^24.0.0",
    "ts-node": "^10.9.2",
    "typescript": "^5.8.3",
    "vitest": "^3.2.1"
  },
  "dependencies": {
    "@google/gemini-cli-core": "^0.1.9",
    "7zip-min": "^2.1.0",
    "electron-updater": "^6.6.2",
    "got": "11.8.6",
    "os-proxy-config": "^1.1.2",
    "playwright": "^1.52.0",
    "playwright-extra": "^4.3.6",
    "playwright-extra-plugin-stealth": "^0.0.1"
  }
}



================================================
FILE: pyproject.toml
================================================
[tool.black]
line-length = 88
target-version = ['py38', 'py39', 'py310', 'py311', 'py312', 'py313']
include = '\.pyi?$'
extend-exclude = '''
/(
  # directories
  \.eggs
  | \.git
  | \.hg
  | \.mypy_cache
  | \.tox
  | \.venv
  | build
  | dist
  | migrations
)/
'''
skip-string-normalization = true
skip-magic-trailing-comma = false
preview = false

[tool.isort]
profile = "black"
multi_line_output = 3
line_length = 88
known_first_party = ["server"]
known_third_party = ["fastapi", "uvicorn", "pydantic"]
sections = ["FUTURE", "STDLIB", "THIRDPARTY", "FIRSTPARTY", "LOCALFOLDER"]

[tool.ruff]
line-length = 88
target-version = "py38"
select = [
    "E",  # pycodestyle errors
    "W",  # pycodestyle warnings
    "F",  # pyflakes
    "I",  # isort
    "B",  # flake8-bugbear
    "C4", # flake8-comprehensions
    "UP", # pyupgrade
]
ignore = [
    "E501",  # line too long, handled by black
    "B008",  # do not perform function calls in argument defaults
    "C901",  # too complex
]

[tool.ruff.per-file-ignores]
"__init__.py" = ["F401"] 


================================================
FILE: README-zh.md
================================================
# ğŸ§  Jaaz â€“ AIè‡ªåŠ¨åŒ–è¥é”€AgentåŠ©æ‰‹ é€šç”¨æ™ºèƒ½åŠ©æ‰‹

ä¸€æ¬¾æœ¬åœ°æ¡Œé¢ç‰ˆçš„ Manus AI Agent åº”ç”¨ç¨‹åºï¼Œæ”¯æŒä¸€é”®å®‰è£…åˆ° Mac å’Œ Windows ç”µè„‘ä¸Šã€‚é€šç”¨ai agentåŠ©æ‰‹ï¼Œæ“…é•¿è¥é”€è¿è¥è‡ªåŠ¨åŒ–ã€‚å…è´¹ä½¿ç”¨ã€‚

---

## ğŸš€ å½“å‰å¤„äºå†…æµ‹é˜¶æ®µ 
å¦‚æœä½ å¸Œæœ›æå‰ä½“éªŒï¼Œè¯·ç«‹å³åŠ å…¥æˆ‘ä»¬çš„å†…æµ‹åå•ï¼š[https://tally.so/r/nPgeKQ](https://tally.so/r/nPgeKQ)ï¼Œæˆ‘ä»¬å°†å‘é€ä½ ä¸‹è½½é“¾æ¥ä½“éªŒï¼ä½ çš„åé¦ˆå°†æœ‰åŠ©äºå¡‘é€  Jaaz çš„æœªæ¥æ–¹å‘å¹¶åŠ å¿«å…¶æ­£å¼å‘å¸ƒã€‚


---

## âœ¨ æ ¸å¿ƒåŠŸèƒ½

### **ğŸ¤– å†…ç½® AI è¥é”€å†…å®¹å†™ä½œåŠ©æ‰‹**

- æ™ºèƒ½è‡ªåŠ¨è¡¥å…¨ & ç¼–è¾‘å»ºè®®
- åªéœ€æä¾›ä¸€å¼ å›¾ç‰‡æˆ–è§†é¢‘ï¼Œå³å¯ç”Ÿæˆæ•´ç¯‡å†…å®¹

### **ğŸ” ä¸€é”®è·¨å¹³å°å‘å¸ƒ**

- AI è‡ªåŠ¨è°ƒæ•´å†…å®¹é£æ ¼å’Œæ ¼å¼ä»¥é€‚é…ä¸åŒå¹³å°
- æ”¯æŒä¸€æ¬¡å‘å¸ƒåˆ°å¤šä¸ªå¹³å°ï¼ˆå¦‚ å°çº¢ä¹¦ã€æŠ–éŸ³ã€Bç«™ã€å¾®ä¿¡è§†é¢‘å·ã€Youtubeç­‰ï¼‰
- å¯è¿½è¸ªæ‰€æœ‰å¸–å­çš„è¡¨ç°å¹¶æŸ¥çœ‹åˆ†ææ•°æ®

### **ğŸ’¬ AI â€œReplyGuyâ€ è‡ªåŠ¨å›å¤åŠ©æ‰‹**

- è‡ªåŠ¨å¯»æ‰¾é€‚åˆæåŠä½ äº§å“çš„å¸–å­ï¼ˆå¦‚ Reddit ç­‰ï¼‰
- ç”Ÿæˆè‡ªç„¶èå…¥å¯¹è¯çš„äº§å“æ¨èå›å¤
- å¯é€‰æ‹©åœ¨æäº¤å‰è®©ä½ ç¡®è®¤å†…å®¹ï¼ˆå¯å…³é—­ï¼‰

### **ğŸ–¼ï¸ \[å³å°†ä¸Šçº¿] å›¾åƒä¸è§†é¢‘å¢å¼ºåŠŸèƒ½**

- æ·»åŠ  TikTok/CapCut é£æ ¼çš„æ–‡å­—ç‰¹æ•ˆ
- è‡ªåŠ¨ç”Ÿæˆæ’å›¾å¼å›¾åƒç”¨äºå†…å®¹åˆ›ä½œ

<img width="900" alt="Screenshot 2025-05-11 at 11 28 29 PM" src="https://github.com/user-attachments/assets/739cb0ca-d197-40d9-a0f7-2328b26d210c" />

---

- æ”¯æŒ **macOS** å’Œ **Windows**
- å¯è‡ªç”±é€‰æ‹© AI æ¨¡å‹ï¼šæ¥å…¥ Claudeã€OpenAIã€Gemini APIï¼Œæˆ–ä½¿ç”¨ [Ollama](https://github.com/ollama/ollama) å®ç°**å®Œå…¨å…è´¹**çš„æœ¬åœ°è¿è¡Œ




---

## ğŸ“¦ Manus AI Agent â€” æœ€ä¼šå¸®ä½ æ¨å¹¿è¥é”€ã€æµè§ˆå™¨è‡ªåŠ¨åŒ–æ‰§è¡Œçš„æœ¬åœ° Agentï¼

**æœ¬åœ° Agent çš„æœ€å¤§ä¼˜åŠ¿åœ¨äºå®ƒå¯ä»¥å…±äº«ä½ æœ¬åœ°æµè§ˆå™¨çš„ç™»å½•çŠ¶æ€**ï¼Œè®© Agent èƒ½å¤Ÿç™»å½•ä»»æ„ç½‘ç«™å¹¶æ‰§è¡Œä»»åŠ¡ã€‚è®¸å¤šç½‘ç«™ï¼ˆå¦‚å°çº¢ä¹¦ã€æŠ–éŸ³ç­‰ï¼‰éƒ½éœ€è¦ç™»å½•æ‰èƒ½è¿›è¡Œæœç´¢æˆ–å‘å¸ƒå†…å®¹ï¼Œè€Œäº‘ä¸Šçš„ Agent åˆ™æ— æ³•è®¿é—®è¿™äº›æ•°æ®æˆ–æ‰§è¡Œç¤¾äº¤å¹³å°çš„ç›¸å…³æ“ä½œã€‚

Manus æ·±åº¦é›†æˆäº†æµè§ˆå™¨è‡ªåŠ¨åŒ–ã€æ–‡ä»¶è¯»å†™ã€ä»£ç è¿è¡Œã€å›¾åƒä¸è§†é¢‘ç¼–è¾‘ç­‰å¤šé¡¹åŠŸèƒ½ã€‚å®ƒæœ€æ“…é•¿çš„å°±æ˜¯æ“ä½œæµè§ˆå™¨ï¼Œè®© AI ä¸åªæ˜¯å‘Šè¯‰ä½ æ€ä¹ˆåšï¼Œè€Œæ˜¯ç›´æ¥å¸®ä½ å®Œæˆä»»åŠ¡ï¼

---

## ğŸ”’ å®‰å…¨æœºåˆ¶

- æ‰€æœ‰æ•æ„Ÿæ“ä½œï¼ˆå¦‚ç™»å½•ã€å‘å¸–ã€å›å¸–ï¼‰å‡å¯è®¾ç½®ä¸ºå¿…é¡»æ‰‹åŠ¨ç¡®è®¤
- å¯ä»…ä½¿ç”¨ä¸“ç”¨è¥é”€è´¦å·ç™»å½•ï¼Œé¿å…æ¶‰åŠä¸ªäººæ•æ„Ÿä¿¡æ¯æˆ–æ”¯ä»˜æ–¹å¼
- æ‰€æœ‰ AI è¡Œä¸ºéƒ½ä¼šè¢«è®°å½•ä¸ºæ–‡æœ¬+æˆªå›¾ï¼Œä¾¿äºéšæ—¶å®¡æŸ¥é£é™©
- æœªæ¥è®¡åˆ’ï¼šå¢åŠ æ™ºèƒ½é˜²æŠ¤ç³»ç»Ÿï¼Œè‡ªåŠ¨æ£€æµ‹å¹¶é˜»æ­¢æ½œåœ¨é£é™©è¡Œä¸º

---

## ğŸ“· æˆªå›¾å±•ç¤º

#### âœ¨ ä¸€é”®è·¨å¹³å°å‘å¸ƒï¼šå›¾æ–‡è§†é¢‘ä¸€é½æå®šï¼

<img width="700" alt="cross-posting-dropdown" src="https://github.com/user-attachments/assets/c03367a3-0515-49ae-97be-cb470c3d3e78" />

#### âœï¸ AI å†…å®¹ç¼–è¾‘å™¨ï¼šè‡ªåŠ¨è¡¥å…¨æ–‡æ¡ˆ

<img width="700" alt="auto-complete" src="https://github.com/user-attachments/assets/bed9858d-20d5-40c0-b580-9b9236414663" />

#### ğŸŒ AI ä¼šå¼•å¯¼ä½ ç™»å½•è´¦å·ï¼šåªéœ€æ‰“å¼€æµè§ˆå™¨å®Œæˆå¸¸è§„ç™»å½•å³å¯

<img width="700" alt="Screenshot 2025-05-11 at 10 53 19 PM" src="https://github.com/user-attachments/assets/ca6052e5-9522-4a69-b73e-8806404071cd" />

ä¾‹å¦‚ï¼Œåœ¨ AI æç¤ºä¸­ç‚¹å‡»â€œopen browserâ€é“¾æ¥ï¼Œå°±ä¼šè‡ªåŠ¨æ‰“å¼€ Instagram ç™»å½•é¡µé¢ï¼Œæ­£å¸¸ç™»å½•åå³å¯ä¿å­˜çŠ¶æ€ï¼š

<img width="400" alt="Screenshot 2025-05-11 at 11 59 24 PM" src="https://github.com/user-attachments/assets/b6395a86-3d5c-4432-8435-564f04388aec" />

#### ğŸ’¬ AI â€œReplyGuyâ€ - è‡ªåŠ¨æœç´¢ç›¸å…³å¸–å­å¹¶å¸®ä½ è‡ªç„¶æ¤å…¥äº§å“ä¿¡æ¯

ä½ å¯ä»¥ä» AI æ¨èçš„å¸–å­ä¸­é€‰æ‹©è¦å›å¤çš„å†…å®¹ï¼š

<img width="700" alt="replyguy" src="https://github.com/user-attachments/assets/d03482b1-3d6c-423a-a193-e1eeb96923e7" />

AI è¿˜å¯ä»¥è®©ä½ åœ¨æäº¤å›å¤å‰è¿›è¡Œç¡®è®¤ï¼š

<img width="500" alt="replyguy-confirm-reply-content" src="https://github.com/user-attachments/assets/7371dc11-e3fd-4966-88b0-73070fbbd1be" />

---

## å¼€å‘æŒ‡å—

```bash
cd react && npm i
cd react && npm run dev
cd server && python main.py
```

---



================================================
FILE: README_zh.md
================================================
<h1 align="center">
  <a href="https://jaaz.app" target="_blank"> Jaaz.app</a>
  <p align="center">ä¸–ç•Œä¸Šé¦–ä¸ªå¼€æºäººå·¥æ™ºèƒ½è®¾è®¡ä»£ç†</p>
  <p align="center">æœ¬åœ°ç‰ˆCanva + Manus</p>

</h2>
[ä¸­æ–‡å…¥é—¨æŒ‡å—](https://mxnpt25l6k.feishu.cn/docx/LvcTdlVbFoRAZWxnhBYcqVydnpc)

ä¸–ç•Œä¸Šé¦–ä¸ªå¼€æºå¤šæ¨¡æ€åˆ›æ„ä»£ç†ï¼Œè¿™æ˜¯ä¸€æ¬¾æ³¨é‡éšç§ã€æœ¬åœ°ä½¿ç”¨å’Œæ˜“ç”¨æ€§çš„åˆ›æ„å·¥å…·ï¼Œ Lovartã€Manus å’Œ Figma çš„ç»“åˆäº§å“ã€‚

[Join our Discord](https://discord.gg/dS7kuT66wc) to get latest updates!

<div align="center"> <a href="https://jaaz.app/api/downloads/mac-latest"> <img src="https://user-images.githubusercontent.com/37590873/219133640-8b7a0179-20a7-4e02-8887-fbbd2eaad64b.png" alt="Download for macOS" width="300"/> </a> &nbsp;&nbsp; <a href="https://jaaz.app/api/downloads/windows-latest"> <img width="300" src="https://cdn.intheloop.io/wp-content/uploads/2020/08/windows-button.png" alt="Download for Windows" /> </a> </div>

## âœ¨ä¿æŒå…³æ³¨

ç»™æˆ‘ä»¬ç‚¹ä¸ª Starï¼Œä½ å°†èƒ½ç¬¬ä¸€æ—¶é—´ä» GitHub æ”¶åˆ°æ‰€æœ‰æ–°ç‰ˆæœ¬çš„å‘å¸ƒé€šçŸ¥ï¼
<img width="900" alt="Screenshot 2025-06-02 at 3 03 49 PM" src="https://github.com/user-attachments/assets/1c9a3661-80a4-4fba-a30f-f469898b0aec" />

## âœ¨ä¸»è¦åŠŸèƒ½

æ™ºèƒ½æç¤ºè¯ä»£ç†
ç”±å¤§è¯­è¨€æ¨¡å‹ï¼ˆLLMï¼‰é©±åŠ¨ï¼ŒJaaz èƒ½ç†è§£ä½ çš„æƒ³æ³•å¹¶ç”Ÿæˆä¼˜åŒ–çš„æç¤ºè¯ï¼Œç”¨äºåˆ›ä½œé«˜è´¨é‡çš„å›¾åƒæˆ–æ•…äº‹æ¿ã€‚

æ··åˆæ¨¡å‹éƒ¨ç½²
æ”¯æŒé€šè¿‡ Ollamaã€ComfyUI è¿è¡Œæœ¬åœ°æ¨¡å‹ï¼Œä¹Ÿæ”¯æŒ Replicateã€OpenAI æˆ– Claude ç­‰è¿œç¨‹ APIã€‚å¯å®ç° 100% æœ¬åœ°è¿è¡Œæˆ–è¿æ¥åˆ°äº‘ç«¯ã€‚

è½»æ¾æ¥å…¥æ‰€æœ‰æœ€å¼º API
ç™»å½•åï¼Œä½ å¯ä»¥ä½¿ç”¨æ‰€æœ‰æœ€æ–°çš„æ¨¡å‹ï¼ˆgpt-image-1, flux kntext, googleâ€¦â€¦ï¼‰ã€‚

äº¤äº’å¼å›¾åƒç¼–è¾‘
æ”¯æŒå¯¹è±¡æ’å…¥ã€é£æ ¼è¿ç§»å’Œé€šè¿‡ Flux Kontext å®ç°å¤šè§’è‰²ä¸€è‡´æ€§ç­‰é«˜çº§æ“ä½œâ€”â€”æ‰€æœ‰è¿™äº›éƒ½å¯ä»¥é€šè¿‡èŠå¤©æ¥æ§åˆ¶ã€‚

æ— é™ç”»å¸ƒ & æ•…äº‹æ¿
é€šè¿‡ç®€å•çš„æ‹–æ”¾æ“ä½œå³å¯è®¾è®¡å¸ƒå±€ã€è§„åˆ’åœºæ™¯å’Œåˆ›å»ºè§†è§‰å™äº‹æµç¨‹ã€‚


---

## ä½¿ç”¨æ–¹æ³•

1. ç‚¹å‡»ç¨‹åºä¸»é¡µå³ä¸Šè§’çš„â€œç™»å½•â€æŒ‰é’®ï¼Œå³å¯ä½¿ç”¨å„ä¸ªæ¨¡å‹çš„ APIã€‚æ”¯ä»˜å°‘é‡è´¹ç”¨ï¼Œä½ å°±å¯ä»¥é¡ºç•…åœ°ä½¿ç”¨API æ¨¡å‹ï¼Œåˆ‡ç§¯åˆ†æ°¸ä¸è¿‡æœŸã€‚

<img width="400" alt="Screenshot 2025-06-02 at 3 08 51 PM" src="https://github.com/user-attachments/assets/0055557d-c247-4801-ac3f-01ed4fa775ae" />

2. ä½ ä¹Ÿå¯ä»¥è‡ªå®šä¹‰ç»‘å®šçš„ APIï¼Œæ·»åŠ åƒ OpenAI æˆ– Claude è¿™æ ·çš„ LLM API å¯†é’¥ï¼Œæˆ–è€…å®‰è£… Ollama æ¥ä½¿ç”¨æœ¬åœ°æ¨¡å‹ã€‚

æ·»åŠ åƒ Replicate è¿™æ ·çš„å›¾åƒç”Ÿæˆ API å¯†é’¥ã€‚ [Replicate](https://replicate.com/)

<img width="1485" alt="Screenshot 2025-06-02 at 3 08 51 PM" src="https://github.com/user-attachments/assets/80bf76b1-229b-4491-893e-3f5102062a37" />

3. å¼€å§‹èŠå¤©æ¡†è¾“å…¥ï¼Œç”Ÿæˆå›¾ç‰‡æˆ–è§†é¢‘ï¼

<img width="900" alt="Screenshot 2025-06-18 at 16 09 05" src="https://github.com/user-attachments/assets/eacee793-3bc4-4fa2-9e23-94efa1e1f087" />

## æ¡ˆä¾‹

- æç¤ºè¯: å¸®æˆ‘æŠŠè¿™ä¸ªè§’è‰²æ”¾ç½®åœ¨å…­ä¸ªä¸åŒçš„åœºæ™¯ä¸­ï¼Œéƒ½åœ¨ä¸–ç•Œå„åœ°çš„åœ°æ ‡å»ºç­‘å‰ã€‚å…‰çº¿å’Œè°ã€‚ä»–åœ¨ä¸–ç•Œå„åœ°æ‹ç…§ï¼Œé£æ ¼å†™å®ï¼Œæš–å…‰ï¼Œç”»è´¨é«˜ï¼Œå›¾ç‰‡æ¯”ä¾‹ä¸º9:16ã€‚

![814c563b08f6ef44de0c2c31f0fdd00b-min](https://github.com/user-attachments/assets/4e2634b3-9068-47cd-a18f-ddde8f218d25)

<img width="1000" alt="Screenshot 2025-06-02 at 3 51 56 AM" src="https://github.com/user-attachments/assets/5d8efe74-99b0-41bc-aa3e-6f7b92b69c36" />
<img width="900" alt="Screenshot 2025-06-02 at 3 51 56 AM" src="https://github.com/user-attachments/assets/56a15432-65ff-4e71-a2f2-4f159ffb304a" />

<img width="900" alt="Screenshot 2025-06-02 at 3 51 56 AM" src="https://github.com/user-attachments/assets/186982a9-5e4e-4ac1-a42c-c840092fd616" />

<img width="900" alt="Screenshot 2025-06-02 at 3 03 49 PM" src="https://github.com/user-attachments/assets/b8508efd-def8-40ed-8ab5-62ed3c26de67" />
<img width="1000" alt="Screenshot 2025-06-02 at 3 03 49 PM" src="https://github.com/user-attachments/assets/6001af3a-2e2d-4bce-8112-7ee81cc75670" />

## å›¢é˜Ÿä¸ä¼ä¸šæ”¯æŒï¼š
æ”¯æŒä¼ä¸šå›¢é˜Ÿçš„å¤šç”¨æˆ·ç§æœ‰åŒ–éƒ¨ç½²ï¼Œä¿è¯éšç§å’Œå®‰å…¨ã€‚

è¯·é€šè¿‡é‚®ä»¶è”ç³»ï¼šaifoxdw@gmail.com

å¾®ä¿¡ï¼šaifox1



## æ‰‹åŠ¨å®‰è£… (é€‚ç”¨äº Linux æˆ–æœ¬åœ°æ„å»º)

ğŸŸ  **Need Python version >=3.12**

é¦–å…ˆ git clone è¿™ä¸ªä»“åº“ï¼š

`git clone https://github.com/11cafe/localart`

`cd react`

`npm install --force`

`npx vite build`

`cd ../server`

`pip install -r requirements.txt`

`python main.py`

## å¼€å‘

ğŸŸ  **Need Python version >=3.12**

VSCode/Cursor Install Extensionsï¼š

- Black Formatter by ms-python (ms-python.black-formatter)

`cd react`

`npm install --force && npm run dev`

`cd server`

`pip install -r requirements.txt`

`python main.py`




================================================
FILE: vitest.config.js
================================================
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    environment: 'node',
    globals: true,
    testTimeout: 15000,
    include: ['**/*.test.js'],
    exclude: ['node_modules/**', 'dist/**'],
    threads: false,
    isolate: false,
    pool: 'forks',
    poolOptions: {
      forks: {
        singleFork: true,
      },
    },
  },
  resolve: {
    alias: {
      '@': new URL('./electron', import.meta.url).pathname,
    },
  },
})



================================================
FILE: .prettierignore
================================================
# Auto-generated files
react/src/route-tree.gen.ts


================================================
FILE: .prettierrc.json
================================================
{
  "semi": false,
  "singleQuote": true,
  "arrowParens": "always",
  "printWidth": 100,
  "tabWidth": 2,
  "trailingComma": "es5",
  "bracketSpacing": true,
  "bracketSameLine": false,
  "endOfLine": "lf",
  "quoteProps": "as-needed",
  "jsxSingleQuote": true,
  "proseWrap": "preserve",
  "htmlWhitespaceSensitivity": "css",
  "vueIndentScriptAndStyle": false,
  "embeddedLanguageFormatting": "auto",
  "singleAttributePerLine": false,
  "useTabs": false,
  "insertPragma": false,
  "requirePragma": false,
  "overrides": [
    {
      "files": "*.md",
      "options": {
        "proseWrap": "always",
        "printWidth": 100
      }
    },
    {
      "files": "*.json",
      "options": {
        "printWidth": 120
      }
    },
    {
      "files": "*.yml",
      "options": {
        "printWidth": 120
      }
    }
  ]
}



================================================
FILE: electron/comfyUIInstaller.js
================================================
// comfyUIInstaller.js - ComfyUIå®‰è£…å™¨
const path = require('path')
const fs = require('fs')
const https = require('https')
const { spawn } = require('child_process')
const { createWriteStream } = require('fs')
const _7z = require('7zip-min')
const got = require('got')
const { pipeline } = require('stream/promises')
const crypto = require('crypto')

// Check if running in worker process
const isWorkerProcess =
  process.send !== undefined || process.env.IS_WORKER_PROCESS === 'true'

// Import electron modules only if not in worker process
let app, BrowserWindow
if (!isWorkerProcess) {
  const electron = require('electron')
  app = electron.app
  BrowserWindow = electron.BrowserWindow
}

// Global cancellation flag
let installationCancelled = false
let currentDownloadRequest = null
let currentChildProcess = null

/**
 * Get user data directory
 * @returns {string} - User data directory path
 */
function getUserDataDir() {
  if (isWorkerProcess) {
    // In worker process, use environment variable
    return process.env.USER_DATA_DIR
  } else {
    // In main process, use app.getPath
    return app.getPath('userData')
  }
}

/**
 * Cancel the current ComfyUI installation
 */
function cancelInstallation() {
  console.log('ğŸ¦„ Cancelling ComfyUI installation...')
  installationCancelled = true

  // Cancel ongoing download
  if (currentDownloadRequest) {
    currentDownloadRequest.destroy()
    currentDownloadRequest = null
  }

  // Kill child processes
  if (currentChildProcess) {
    currentChildProcess.kill('SIGTERM')
    currentChildProcess = null
  }

  sendCancelled('Installation cancelled by user')
}

/**
 * Reset cancellation state
 */
function resetCancellationState() {
  installationCancelled = false
  currentDownloadRequest = null
  currentChildProcess = null
}

/**
 * Check if installation is cancelled
 * @returns {boolean} - True if cancelled
 */
function isInstallationCancelled() {
  return installationCancelled
}

/**
 * Get the latest ComfyUI release information from GitHub
 * @returns {Promise<{version: string, downloadUrl: string}>} - Promise resolving to latest release info
 */
async function getLatestComfyUIRelease() {
  return new Promise((resolve, reject) => {
    const options = {
      hostname: 'api.github.com',
      path: '/repos/comfyanonymous/ComfyUI/releases/latest',
      method: 'GET',
      headers: {
        'User-Agent': 'Jaaz-App/1.0.0',
        Accept: 'application/vnd.github.v3+json',
      },
    }

    const req = https.request(options, (res) => {
      let data = ''

      res.on('data', (chunk) => {
        data += chunk
      })

      res.on('end', () => {
        try {
          const release = JSON.parse(data)

          if (res.statusCode !== 200) {
            reject(
              new Error(
                `GitHub API error: ${res.statusCode} - ${
                  release.message || 'Unknown error'
                }`
              )
            )
            return
          }

          // Find the Windows portable NVIDIA version
          const windowsPortableAsset = release.assets.find(
            (asset) =>
              asset.name.includes('windows_portable') &&
              asset.name.includes('nvidia') &&
              (asset.name.endsWith('.7z') || asset.name.endsWith('.zip'))
          )

          if (!windowsPortableAsset) {
            // Fallback to any Windows portable version
            const fallbackAsset = release.assets.find(
              (asset) =>
                asset.name.includes('windows_portable') &&
                (asset.name.endsWith('.7z') || asset.name.endsWith('.zip'))
            )

            if (!fallbackAsset) {
              reject(
                new Error(
                  'No suitable Windows portable version found in latest release'
                )
              )
              return
            }

            resolve({
              version: release.tag_name,
              downloadUrl: fallbackAsset.browser_download_url,
              fileName: fallbackAsset.name,
              size: fallbackAsset.size,
              digest: fallbackAsset.digest,
            })
            return
          }

          resolve({
            version: release.tag_name,
            downloadUrl: windowsPortableAsset.browser_download_url,
            fileName: windowsPortableAsset.name,
            size: windowsPortableAsset.size,
            digest: windowsPortableAsset.digest,
          })
        } catch (error) {
          reject(
            new Error(`Failed to parse GitHub API response: ${error.message}`)
          )
        }
      })
    })

    req.on('error', (error) => {
      reject(new Error(`GitHub API request failed: ${error.message}`))
    })

    req.setTimeout(10000, () => {
      req.destroy()
      reject(new Error('GitHub API request timeout'))
    })

    req.end()
  })
}

/**
 * Send progress update to main window or parent process
 * @param {number} percent - Progress percentage
 * @param {string} status - Status message
 */
function sendProgress(percent, status) {
  if (isWorkerProcess) {
    // In worker process, send to parent process
    if (process.send) {
      process.send({
        type: 'progress',
        percent: percent,
        status: status,
      })
    }
  } else {
    // In main process, send to renderer
    const mainWindow = BrowserWindow.getAllWindows()[0]
    if (mainWindow) {
      mainWindow.webContents.executeJavaScript(`
        window.dispatchEvent(new CustomEvent('comfyui-install-progress', {
          detail: { percent: ${percent}, status: "${status.replace(
        /"/g,
        '\\"'
      )}" }
        }));
      `)
    }
  }
}

/**
 * Send log message to main window or parent process
 * @param {string} message - Log message
 */
function sendLog(message) {
  if (isWorkerProcess) {
    // In worker process, send to parent process
    if (process.send) {
      process.send({
        type: 'log',
        message: message,
      })
    }
  } else {
    // In main process, send to renderer
    const mainWindow = BrowserWindow.getAllWindows()[0]
    if (mainWindow) {
      mainWindow.webContents.executeJavaScript(`
        window.dispatchEvent(new CustomEvent('comfyui-install-log', {
          detail: { message: "${message.replace(/"/g, '\\"')}" }
        }));
      `)
    }
  }
  console.log(`[ComfyUI Install] ${message}`)
}

/**
 * Send error message to main window or parent process
 * @param {string} error - Error message
 */
function sendError(error) {
  const errorMessage = error || 'Unknown error occurred'

  if (isWorkerProcess) {
    // In worker process, send to parent process
    if (process.send) {
      process.send({
        type: 'error',
        error: errorMessage,
      })
    }
  } else {
    // In main process, send to renderer
    const mainWindow = BrowserWindow.getAllWindows()[0]
    if (mainWindow) {
      mainWindow.webContents.executeJavaScript(`
        window.dispatchEvent(new CustomEvent('comfyui-install-error', {
          detail: { error: "${errorMessage.replace(/"/g, '\\"')}" }
        }));
      `)
    }
  }
}

/**
 * Send cancellation message to main window or parent process
 * @param {string} message - Cancellation message
 */
function sendCancelled(message) {
  const cancelMessage = message || 'Installation cancelled'

  if (isWorkerProcess) {
    // In worker process, send to parent process
    if (process.send) {
      process.send({
        type: 'cancelled',
        message: cancelMessage,
      })
    }
  } else {
    // In main process, send to renderer
    const mainWindow = BrowserWindow.getAllWindows()[0]
    if (mainWindow) {
      mainWindow.webContents.executeJavaScript(`
        window.dispatchEvent(new CustomEvent('comfyui-install-cancelled', {
          detail: { message: "${cancelMessage.replace(/"/g, '\\"')}" }
        }));
      `)
    }
  }
  console.log(`[ComfyUI Install Cancelled] ${cancelMessage}`)
}

/**
 * Calculate SHA256 hash of a file
 * @param {string} filePath - Path to the file
 * @returns {Promise<string>} - Promise resolving to SHA256 hash in hex format
 */
async function calculateFileHash(filePath) {
  return new Promise((resolve, reject) => {
    const hash = crypto.createHash('sha256')
    const stream = fs.createReadStream(filePath)

    stream.on('data', (data) => {
      hash.update(data)
    })

    stream.on('end', () => {
      resolve(hash.digest('hex'))
    })

    stream.on('error', (error) => {
      reject(new Error(`Failed to calculate file hash: ${error.message}`))
    })
  })
}

/**
 * Verify file integrity using SHA256 hash
 * @param {string} filePath - Path to the file
 * @param {string} expectedDigest - Expected digest in format "sha256:hash" or just "hash"
 * @returns {Promise<boolean>} - Promise resolving to true if hash matches
 */
async function verifyFileIntegrity(filePath, expectedDigest) {
  if (!expectedDigest) {
    return false // Can't verify without expected hash
  }

  try {
    const fileHash = await calculateFileHash(filePath)

    // Extract hash from digest (handle "sha256:hash" format)
    const expectedHash = expectedDigest.startsWith('sha256:')
      ? expectedDigest.substring(7)
      : expectedDigest

    return fileHash.toLowerCase() === expectedHash.toLowerCase()
  } catch (error) {
    console.error('Error verifying file integrity:', error)
    return false
  }
}

/**
 * Helper function to download files with resume support and retry mechanism using Got
 * @param {string} url - Download URL
 * @param {string} filePath - Local file path
 * @param {Function} onProgress - Progress callback
 * @param {Object} options - Download options
 * @returns {Promise<void>}
 */
async function downloadFile(url, filePath, onProgress, options = {}) {
  const { maxRetries = 5, timeout = 60000, retryDelay = 2000 } = options

  // Outer retry loop for full download attempts
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      sendLog(`Download attempt ${attempt}/${maxRetries}`)

      // Check if file already exists for resume
      let resumeSize = 0
      if (fs.existsSync(filePath)) {
        try {
          const stats = fs.statSync(filePath)
          resumeSize = stats.size
          if (resumeSize > 0) {
            sendLog(
              `Resuming download from ${Math.round(resumeSize / 1024 / 1024)}MB`
            )
          }
        } catch (error) {
          sendLog('Could not get existing file size, starting fresh download')
          resumeSize = 0
        }
      }

      const downloadOptions = {
        retry: {
          limit: 3,
          methods: ['GET'],
          statusCodes: [408, 413, 429, 500, 502, 503, 504, 521, 522, 524],
          errorCodes: [
            'ETIMEDOUT',
            'ECONNRESET',
            'EADDRINUSE',
            'ECONNREFUSED',
            'EPIPE',
            'ENOTFOUND',
            'ENETUNREACH',
            'EAI_AGAIN',
          ],
        },
        timeout: {
          request: timeout,
        },
        headers: {
          'User-Agent': 'Jaaz-App/1.0.0',
        },
      }

      // Add range header for resume
      if (resumeSize > 0) {
        downloadOptions.headers.Range = `bytes=${resumeSize}-`
      }

      // Check cancellation before starting
      if (isInstallationCancelled()) {
        throw new Error('Installation cancelled')
      }

      // Create write stream (append mode for resume)
      const writeStream = createWriteStream(filePath, {
        flags: resumeSize > 0 ? 'a' : 'w',
      })

      let totalSize = 0
      let downloadedSize = resumeSize
      let lastProgressUpdate = Date.now()

      // Create download stream using Got
      const downloadStream = got.stream(url, downloadOptions)
      currentDownloadRequest = downloadStream

      let streamError = null

      // Handle response to get total size
      downloadStream.on('response', (response) => {
        if (isInstallationCancelled()) {
          downloadStream.destroy()
          writeStream.destroy()
          return
        }

        if (response.headers['content-length']) {
          const contentLength = parseInt(response.headers['content-length'])
          if (response.statusCode === 206) {
            // Partial content - get total size from content-range header
            const contentRange = response.headers['content-range']
            if (contentRange) {
              const match = contentRange.match(/bytes \d+-\d+\/(\d+)/)
              if (match) {
                totalSize = parseInt(match[1])
              }
            }
          } else {
            totalSize = contentLength
          }
        }

        sendLog(`Total file size: ${Math.round(totalSize / 1024 / 1024)}MB`)

        if (response.statusCode === 206) {
          sendLog('Server supports resume, continuing download')
        } else if (resumeSize > 0) {
          sendLog('Server does not support resume, restarting download')
          writeStream.destroy()
          downloadedSize = 0
          try {
            fs.unlinkSync(filePath)
          } catch (error) {
            // Ignore if file doesn't exist
          }
        }
      })

      // Handle download progress
      downloadStream.on('data', (chunk) => {
        if (isInstallationCancelled()) {
          downloadStream.destroy()
          writeStream.destroy()
          return
        }

        downloadedSize += chunk.length

        // Throttle progress updates
        const now = Date.now()
        if (
          totalSize > 0 &&
          (now - lastProgressUpdate > 500 || downloadedSize >= totalSize)
        ) {
          const progress = downloadedSize / totalSize
          onProgress(progress)
          lastProgressUpdate = now
        }
      })

      // Handle errors
      downloadStream.on('error', (error) => {
        streamError = error
        if (writeStream && !writeStream.destroyed) {
          writeStream.destroy()
        }
        currentDownloadRequest = null
      })

      // Handle stream end
      downloadStream.on('end', () => {
        currentDownloadRequest = null
      })

      // Use pipeline for proper error handling and cleanup
      try {
        await pipeline(downloadStream, writeStream)
      } catch (pipelineError) {
        // If there was a stream error, use that instead
        throw streamError || pipelineError
      }

      // Check for stream errors after pipeline completes
      if (streamError) {
        throw streamError
      }

      // Verify file size if known
      if (totalSize > 0) {
        const stats = fs.statSync(filePath)
        if (stats.size !== totalSize) {
          throw new Error(
            `File size mismatch: expected ${totalSize}, got ${stats.size}`
          )
        }
      }

      sendLog('Download completed successfully')
      return // Success, exit retry loop
    } catch (error) {
      currentDownloadRequest = null

      // Check if it's a cancellation
      if (isInstallationCancelled()) {
        throw new Error('Installation cancelled')
      }

      sendLog(`Download attempt ${attempt} failed: ${error.message}`)

      // If this is not the last attempt, wait and retry
      if (attempt < maxRetries) {
        // Keep partial file for network errors, remove for others
        const isNetworkError =
          error.code &&
          [
            'ETIMEDOUT',
            'ECONNRESET',
            'ECONNREFUSED',
            'ENOTFOUND',
            'ENETUNREACH',
            'EPIPE',
          ].includes(error.code)

        if (!isNetworkError && fs.existsSync(filePath)) {
          try {
            fs.unlinkSync(filePath)
            sendLog('Removed corrupted partial file, will restart download')
          } catch (cleanupError) {
            // Ignore cleanup errors
          }
        } else {
          sendLog('Keeping partial file for resume')
        }

        // Wait before retry with exponential backoff
        // const delay = Math.min(retryDelay * Math.pow(2, attempt - 1), 30000)
        const delay = 3000 // 3s for quick retry
        sendLog(`Waiting ${Math.round(delay / 1000)}s before retry...`)
        await new Promise((resolve) => setTimeout(resolve, delay))

        // Check cancellation after delay
        if (isInstallationCancelled()) {
          throw new Error('Installation cancelled')
        }

        continue // Try next attempt
      } else {
        // Last attempt failed, clean up and throw
        if (fs.existsSync(filePath)) {
          try {
            fs.unlinkSync(filePath)
          } catch (cleanupError) {
            // Ignore cleanup errors
          }
        }
        throw new Error(
          `Download failed after ${maxRetries} attempts: ${error.message}`
        )
      }
    }
  }
}

/**
 * Find ComfyUI main directory (may be in subdirectory after extraction)
 * @param {string} comfyUIDir - ComfyUI installation directory
 * @returns {string|null} - Main directory path or null if not found
 */
function findComfyUIMainDir(comfyUIDir) {
  const possibleDirs = ['ComfyUI_windows_portable']

  for (const dir of possibleDirs) {
    const dirPath = path.join(comfyUIDir, dir)
    if (fs.existsSync(dirPath)) {
      return dirPath
    }
  }

  return null
}

/**
 * Update configuration, add ComfyUI models
 * @returns {Promise<void>}
 */
async function updateConfigWithComfyUI() {
  try {
    // Call backend API to update configuration
    const response = await fetch(
      'http://127.0.0.1:57988/api/comfyui/update_config',
      {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
      }
    )

    if (response.ok) {
      const result = await response.json()
      console.log('ComfyUI configuration updated successfully:', result.message)
    } else {
      const error = await response.text()
      console.error('Configuration update failed:', error)
      throw new Error(`Configuration update failed: ${error}`)
    }
  } catch (error) {
    console.error('Configuration update failed:', error)
    throw error
  }
}

/**
 * Uninstall ComfyUI
 * @returns {Promise<{success: boolean}>} - Promise resolving to uninstallation result
 */
async function uninstallComfyUI() {
  console.log('ğŸ¦„ Starting ComfyUI uninstallation...')

  try {
    // Get user data directory
    const userDataDir = getUserDataDir()
    if (!userDataDir) {
      throw new Error('Unable to get user data directory')
    }

    const comfyUIDir = path.join(userDataDir, 'comfyui')
    const tempDir = path.join(userDataDir, 'temp')

    sendLog('Starting ComfyUI uninstallation...')
    sendProgress(10, 'Checking ComfyUI installation...')

    // Check if ComfyUI directory exists
    if (!fs.existsSync(comfyUIDir)) {
      sendLog('ComfyUI directory not found, nothing to uninstall')
      sendProgress(100, 'ComfyUI is not installed')
      return { success: true, message: 'ComfyUI is not installed' }
    }

    sendProgress(30, 'Removing ComfyUI files...')
    sendLog('Removing ComfyUI installation directory...')

    // Remove ComfyUI directory
    fs.rmSync(comfyUIDir, { recursive: true, force: true })
    sendLog('ComfyUI directory removed successfully')

    sendProgress(80, 'Cleaning up temporary files...')
    sendLog('Cleaning up temporary installation files...')

    // Clean up ComfyUI temp download 7z file
    if (fs.existsSync(tempDir)) {
      const tempFiles = fs.readdirSync(tempDir)
      const comfyUIFiles = tempFiles.filter(
        (file) => file.includes('ComfyUI') && file.endsWith('.7z')
      )

      for (const file of comfyUIFiles) {
        try {
          fs.unlinkSync(path.join(tempDir, file))
          sendLog(`Removed temporary file: ${file}`)
        } catch (error) {
          sendLog(`Failed to remove temporary file ${file}`)
        }
      }
    }

    sendProgress(100, 'Uninstallation completed!')
    sendLog('ComfyUI uninstallation completed successfully!')

    return { success: true }
  } catch (error) {
    console.error('ComfyUI uninstallation failed:', error)
    sendError(error.message)
    return { success: false, error: error.message }
  }
}

/**
 * Install ComfyUI
 * @returns {Promise<{success: boolean}>} - Promise resolving to installation result
 */
async function installComfyUI() {
  console.log('ğŸ¦„ Starting ComfyUI installation...')

  try {
    // Reset cancellation state at start
    resetCancellationState()

    // Get user data directory and temp directory
    const userDataDir = getUserDataDir()
    if (!userDataDir) {
      throw new Error('Unable to get user data directory')
    }

    const tempDir = path.join(userDataDir, 'temp')
    const comfyUIDir = path.join(userDataDir, 'comfyui')

    // Ensure directory exists
    if (!fs.existsSync(tempDir)) {
      fs.mkdirSync(tempDir, { recursive: true })
    }

    sendLog('Starting ComfyUI installation...')
    sendProgress(5, 'Fetching latest ComfyUI version...')

    // Check cancellation
    if (isInstallationCancelled()) {
      throw new Error('Installation cancelled')
    }

    // Get latest ComfyUI release information
    let releaseInfo
    try {
      sendLog('Fetching latest ComfyUI release from GitHub...')
      releaseInfo = await getLatestComfyUIRelease()
      sendLog(`Found latest version: ${releaseInfo.version}`)
      sendLog(
        `Download file: ${releaseInfo.fileName} (${Math.round(
          releaseInfo.size / 1024 / 1024
        )}MB)`
      )
    } catch (error) {
      sendLog(`Failed to fetch latest release: ${error.message}`)
      sendLog('Falling back to default version...')
      // Fallback to hardcoded version
      releaseInfo = {
        version: 'v0.3.39',
        downloadUrl:
          'https://github.com/comfyanonymous/ComfyUI/releases/download/v0.3.39/ComfyUI_windows_portable_nvidia.7z',
        fileName: 'ComfyUI_windows_portable_nvidia.7z',
      }
    }

    // Check cancellation
    if (isInstallationCancelled()) {
      throw new Error('Installation cancelled')
    }

    sendProgress(10, 'Checking existing files...')

    const zipPath = path.join(tempDir, releaseInfo.fileName)

    // Check if already downloaded
    let shouldDownload = true
    if (fs.existsSync(zipPath)) {
      sendLog('Found existing installation package, checking integrity...')
      try {
        // Try SHA256 verification first if digest is available
        if (releaseInfo.digest) {
          sendLog('Verifying file integrity using SHA256...')
          const isValid = await verifyFileIntegrity(zipPath, releaseInfo.digest)
          if (isValid) {
            sendLog('File integrity verified successfully, skipping download')
            shouldDownload = false
          } else {
            sendLog('File integrity verification failed, re-downloading')
            fs.unlinkSync(zipPath)
          }
        } else {
          // Fallback to size check for older releases without digest
          sendLog('No SHA256 digest available, using size check...')
          const stats = fs.statSync(zipPath)
          if (stats.size > 1000000) {
            // At least 1MB, simple integrity check
            sendLog(
              'Installation package appears complete based on size, skipping download'
            )
            shouldDownload = false
          } else {
            sendLog('Installation package is incomplete, re-downloading')
            fs.unlinkSync(zipPath)
          }
        }
      } catch (error) {
        sendLog(
          `Error checking installation package: ${error.message}, re-downloading`
        )
        shouldDownload = true
      }
    }

    // Check cancellation
    if (isInstallationCancelled()) {
      throw new Error('Installation cancelled')
    }

    if (shouldDownload) {
      sendProgress(15, 'Starting ComfyUI download...')
      sendLog(
        `Downloading ComfyUI ${releaseInfo.version} from ${releaseInfo.downloadUrl}...`
      )

      // Download with enhanced retry configuration for large files
      await downloadFile(
        releaseInfo.downloadUrl,
        zipPath,
        (progress) => {
          const percent = 15 + progress * 60 // 15-75% for download
          sendProgress(percent, `Downloading... ${Math.round(progress * 100)}%`)
        },
        {
          maxRetries: 10, // Increase retry attempts for large files
          timeout: 120000, // 2 minutes timeout per request
          retryDelay: 3000, // Start with 3 second delay
        }
      )

      sendLog('Download completed')
    }

    // Check cancellation
    if (isInstallationCancelled()) {
      throw new Error('Installation cancelled')
    }

    sendProgress(75, 'Extracting installation package...')
    sendLog('Starting ComfyUI extraction...')

    // Extract files
    if (fs.existsSync(comfyUIDir)) {
      sendLog('Removing old ComfyUI directory...')
      fs.rmSync(comfyUIDir, { recursive: true, force: true })
    }

    // Check cancellation
    if (isInstallationCancelled()) {
      throw new Error('Installation cancelled')
    }

    try {
      // ComfyUI packages are only available in 7z format
      sendLog('Extracting 7z archive...')
      await _7z.unpack(zipPath, comfyUIDir)
      sendLog('Extraction completed')
    } catch (error) {
      sendLog(`Extraction failed: ${error.message}`)
      throw error
    }

    // Check cancellation
    if (isInstallationCancelled()) {
      throw new Error('Installation cancelled')
    }

    sendProgress(85, 'Configuring ComfyUI...')
    sendLog('Configuring ComfyUI environment...')

    // Find ComfyUI main directory (may be in subdirectory after extraction)
    const comfyUIMainDir = findComfyUIMainDir(comfyUIDir)
    if (!comfyUIMainDir) {
      throw new Error('ComfyUI main directory not found')
    }

    sendLog(`Found ComfyUI main directory: ${comfyUIMainDir}`)

    // Check cancellation
    if (isInstallationCancelled()) {
      throw new Error('Installation cancelled')
    }

    sendProgress(90, 'Updating configuration...')
    sendLog('Updating application configuration...')

    // Update configuration, add ComfyUI as image model
    try {
      await updateConfigWithComfyUI()
      sendLog('Configuration updated successfully')
    } catch (error) {
      sendLog(`Configuration update failed: ${error.message}`)
      // Don't fail the installation if config update fails
    }

    // Check cancellation
    if (isInstallationCancelled()) {
      throw new Error('Installation cancelled')
    }

    sendProgress(100, 'Installation completed!')
    sendLog('ComfyUI installation completed successfully!')
    sendLog('ComfyUI is ready to use at http://127.0.0.1:8188')
    sendLog('You can now enable ComfyUI in settings to start the service.')

    return { success: true }
  } catch (error) {
    console.error('ComfyUI installation failed:', error)

    if (error.message === 'Installation cancelled') {
      sendCancelled('Installation was cancelled by user')
      return { cancelled: true }
    } else {
      sendError(error.message)
      return { success: false, error: error.message }
    }
  }
}

// Worker process logic
if (isWorkerProcess) {
  console.log('ğŸ¦„ ComfyUI install worker process started and ready')

  // Handle uncaught exceptions to prevent process crash
  process.on('uncaughtException', (error) => {
    console.error('ğŸ¦„ Uncaught exception in worker process:', error)

    // Send error message to parent process
    if (process.send) {
      process.send({
        type: 'install-error',
        success: false,
        error: `Uncaught exception: ${error.message}`,
      })
    }

    // Don't exit, let the parent process handle it
  })

  // Handle unhandled promise rejections
  process.on('unhandledRejection', (reason, promise) => {
    console.error('ğŸ¦„ Unhandled promise rejection in worker process:', reason)

    // Send error message to parent process
    if (process.send) {
      process.send({
        type: 'install-error',
        success: false,
        error: `Unhandled promise rejection: ${reason}`,
      })
    }

    // Don't exit, let the parent process handle it
  })

  // Handle process messages
  process.on('message', async (message) => {
    if (message.type === 'start-install') {
      try {
        console.log('ğŸ¦„ Starting ComfyUI installation in worker process...')
        const result = await installComfyUI()

        // Check if installation was cancelled
        if (result.cancelled) {
          process.send({
            type: 'install-cancelled',
            success: true,
            message: result.message || 'Installation cancelled',
          })
        } else if (result.success) {
          // Send success result back to main process
          process.send({
            type: 'install-complete',
            success: true,
            result: result,
          })
        } else {
          // Send error result back to main process
          process.send({
            type: 'install-error',
            success: false,
            error: result.error || 'Unknown error occurred',
          })
        }
      } catch (error) {
        console.error(
          'ğŸ¦„ ComfyUI installation failed in worker process:',
          error
        )

        // Send error result back to main process
        process.send({
          type: 'install-error',
          success: false,
          error: error.message || 'Unknown error occurred',
        })
      }
    } else if (message.type === 'start-uninstall') {
      try {
        console.log('ğŸ¦„ Starting ComfyUI uninstallation in worker process...')
        const result = await uninstallComfyUI()

        if (result.success) {
          // Send success result back to main process
          process.send({
            type: 'uninstall-complete',
            success: true,
            result: result,
          })
        } else {
          // Send error result back to main process
          process.send({
            type: 'uninstall-error',
            success: false,
            error: result.error || 'Unknown error occurred',
          })
        }
      } catch (error) {
        console.error(
          'ğŸ¦„ ComfyUI uninstallation failed in worker process:',
          error
        )

        // Send error result back to main process
        process.send({
          type: 'uninstall-error',
          success: false,
          error: error.message || 'Unknown error occurred',
        })
      }
    } else if (message.type === 'cancel-install') {
      console.log('ğŸ¦„ Received cancellation request in worker process')
      cancelInstallation()

      process.send({
        type: 'install-cancelled',
        success: true,
        message: 'Installation cancelled',
      })
    }
  })

  // Handle process exit
  process.on('exit', (code) => {
    console.log(`ğŸ¦„ ComfyUI install worker process exiting with code ${code}`)
  })

  process.on('SIGTERM', () => {
    console.log('ğŸ¦„ ComfyUI install worker process received SIGTERM')
    process.exit(0)
  })

  process.on('SIGINT', () => {
    console.log('ğŸ¦„ ComfyUI install worker process received SIGINT')
    process.exit(0)
  })
}

module.exports = {
  installComfyUI,
  uninstallComfyUI,
  cancelInstallation,
  resetCancellationState,
  isInstallationCancelled,
  getLatestComfyUIRelease,
  downloadFile,
  findComfyUIMainDir,
  updateConfigWithComfyUI,
  calculateFileHash,
  verifyFileIntegrity,
}



================================================
FILE: electron/comfyUIManager.js
================================================
// comfyUIManager.js - ComfyUIè¿›ç¨‹ç®¡ç†å™¨
const path = require('path')
const fs = require('fs')
const { spawn } = require('child_process')

// Check if running in worker process
const isWorkerProcess =
  process.send !== undefined || process.env.IS_WORKER_PROCESS === 'true'

// Import electron modules only if not in worker process
let app
if (!isWorkerProcess) {
  const electron = require('electron')
  app = electron.app
}

// Global ComfyUI process management
let comfyUIProcess = null
let comfyUIProcessPid = null

// Setup cleanup handlers for main process exit
if (!isWorkerProcess) {
  const setupCleanupHandlers = () => {
    const cleanup = async () => {
      if (comfyUIProcess && !comfyUIProcess.killed) {
        console.log('ğŸ¦„ Main process exiting, cleaning up ComfyUI process...')
        await stopComfyUIProcess()
      }
    }

    // Handle different exit scenarios
    process.on('exit', cleanup)
    process.on('SIGINT', cleanup)
    process.on('SIGTERM', cleanup)
    process.on('uncaughtException', cleanup)

    // Handle Electron app events if available
    if (app) {
      app.on('before-quit', cleanup)
      app.on('window-all-closed', cleanup)
    }
  }

  // Setup cleanup handlers when this module is loaded
  setupCleanupHandlers()
}

/**
 * Get user data directory
 * @returns {string} - User data directory path
 */
function getUserDataDir() {
  if (isWorkerProcess) {
    // In worker process, use environment variable
    return process.env.USER_DATA_DIR
  } else {
    // In main process, use app.getPath
    return app.getPath('userData')
  }
}

/**
 * Find ComfyUI main directory (may be in subdirectory after extraction)
 * @param {string} comfyUIDir - ComfyUI installation directory
 * @returns {string|null} - Main directory path or null if not found
 */
function findComfyUIMainDir(comfyUIDir) {
  const possibleDirs = ['ComfyUI_windows_portable']

  for (const dir of possibleDirs) {
    const dirPath = path.join(comfyUIDir, dir)
    if (fs.existsSync(dirPath)) {
      return dirPath
    }
  }

  return null
}

/**
 * Find run script
 * @param {string} comfyUIDir - ComfyUI directory
 * @returns {string|null} - Script path or null if not found
 */
function findRunScript(comfyUIDir) {
  const possibleScripts = [
    'run_nvidia_gpu.bat',
    'run_nvidia_gpu_fast_fp16_accumulation.bat',
    'run_cpu.bat',
    'run.bat',
  ]

  for (const script of possibleScripts) {
    const scriptPath = path.join(comfyUIDir, script)
    if (fs.existsSync(scriptPath)) {
      return scriptPath
    }
  }

  return null
}

/**
 * Detect if NVIDIA GPU is available and has drivers
 * @returns {Promise<boolean>} - True if NVIDIA GPU is available
 */
async function detectNvidiaGPU() {
  return new Promise((resolve) => {
    try {
      // Try to run nvidia-smi to check for NVIDIA GPU
      const nvidiaSmi = spawn(
        'nvidia-smi',
        ['--query-gpu=name', '--format=csv,noheader'],
        {
          stdio: ['ignore', 'pipe', 'pipe'],
        }
      )

      let hasOutput = false

      nvidiaSmi.stdout.on('data', (data) => {
        const output = data.toString().trim()
        if (output && !output.includes('No devices were found')) {
          hasOutput = true
        }
      })

      nvidiaSmi.on('close', (code) => {
        resolve(hasOutput && code === 0)
      })

      nvidiaSmi.on('error', () => {
        resolve(false)
      })

      // Timeout after 3 seconds
      setTimeout(() => {
        nvidiaSmi.kill()
        resolve(false)
      }, 3000)
    } catch (error) {
      resolve(false)
    }
  })
}

/**
 * Get preferred ComfyUI startup script based on GPU availability
 * @param {string} comfyUIMainDir - ComfyUI main directory
 * @returns {Promise<{script: string, mode: string}>}
 */
async function getPreferredStartupScript(comfyUIMainDir) {
  // Detect GPU support
  const hasNvidiaGPU = await detectNvidiaGPU()
  console.log(`ğŸ¦„ NVIDIA GPU detected: ${hasNvidiaGPU}`)

  // Define script priority based on GPU availability
  const preferredScripts = hasNvidiaGPU
    ? [
        'run_nvidia_gpu.bat',
        'run_nvidia_gpu_fast_fp16_accumulation.bat',
        'run_cpu.bat',
      ]
    : [
        'run_cpu.bat',
        'run_nvidia_gpu.bat',
        'run_nvidia_gpu_fast_fp16_accumulation.bat',
      ]

  // Find the first available script
  for (const script of preferredScripts) {
    const scriptPath = path.join(comfyUIMainDir, script)
    if (fs.existsSync(scriptPath)) {
      const mode = script.includes('cpu') ? 'CPU' : 'GPU'
      console.log(`ğŸ¦„ Selected startup script: ${script} (${mode} mode)`)
      return { script: scriptPath, mode }
    }
  }

  // Fallback to any available script
  const runScript = findRunScript(comfyUIMainDir)
  if (runScript) {
    const mode = runScript.includes('cpu') ? 'CPU' : 'GPU'
    console.log(`ğŸ¦„ Fallback to: ${path.basename(runScript)} (${mode} mode)`)
    return { script: runScript, mode }
  }

  throw new Error('No startup script found')
}

/**
 * Check if ComfyUI is installed
 * @returns {boolean} - True if ComfyUI is installed
 */
function isComfyUIInstalled() {
  const userDataDir = getUserDataDir()
  if (!userDataDir) return false

  const comfyUIDir = path.join(userDataDir, 'comfyui')
  const comfyUIMainDir = findComfyUIMainDir(comfyUIDir)

  if (!comfyUIMainDir) return false

  // Only check if run script (bat file) exists
  const runScript = findRunScript(comfyUIMainDir)
  return !!runScript
}

/**
 * Parse bat file to extract Python command
 * @param {string} batFilePath - Path to the bat file
 * @returns {Object} - {pythonPath, args, workingDir}
 */
function parseBatFile(batFilePath) {
  try {
    const batContent = fs.readFileSync(batFilePath, 'utf8')
    const workingDir = path.dirname(batFilePath)

    // Find the python command line (skip pause and empty lines)
    const pythonLine = batContent
      .split('\n')
      .map((line) => line.trim())
      .find((line) => line.includes('python.exe') && line.includes('main.py'))

    if (!pythonLine) return null

    // Split command and convert relative paths to absolute
    const parts = pythonLine.split(' ')
    const pythonPath = path.join(workingDir, parts[0].replace(/\.\\/g, ''))
    const args = parts.slice(1).map((arg) => {
      if (arg.includes('\\') && !arg.startsWith('-')) {
        return path.join(workingDir, arg.replace(/\\/g, path.sep))
      }
      return arg
    })

    return { pythonPath, args, workingDir }
  } catch (error) {
    console.error('Failed to parse bat file:', error)
    return null
  }
}

/**
 * Start ComfyUI process
 * @returns {Promise<{success: boolean, message?: string}>}
 */
async function startComfyUIProcess() {
  try {
    // Check if already running
    if (comfyUIProcess && !comfyUIProcess.killed) {
      return { success: false, message: 'ComfyUI is already running' }
    }

    // Check if ComfyUI is installed
    if (!isComfyUIInstalled()) {
      return { success: false, message: 'ComfyUI is not installed' }
    }

    const userDataDir = getUserDataDir()
    const comfyUIDir = path.join(userDataDir, 'comfyui')
    const comfyUIMainDir = findComfyUIMainDir(comfyUIDir)

    console.log('ğŸ¦„ Starting ComfyUI process...')

    // Get preferred startup script
    const { script, mode } = await getPreferredStartupScript(comfyUIMainDir)

    console.log(`ğŸ¦„ Startup mode: ${mode}`)

    let command, args, spawnOptions

    if (script) {
      console.log(`ğŸ¦„ Using startup script: ${script}`)

      const isWindows = process.platform === 'win32'

      if (isWindows && script.endsWith('.bat')) {
        // Parse bat file to extract the actual command
        const parsedCommand = parseBatFile(script)

        if (parsedCommand) {
          console.log(
            `ğŸ¦„ Parsed command from bat file: ${
              parsedCommand.pythonPath
            } ${parsedCommand.args.join(' ')}`
          )

          // Run the Python command directly
          command = parsedCommand.pythonPath
          args = parsedCommand.args

          spawnOptions = {
            cwd: parsedCommand.workingDir,
            detached: false, // Keep attached to parent process
            stdio: ['ignore', 'pipe', 'pipe'],
            windowsHide: true, // Hide any potential windows
            shell: false, // Don't use shell to avoid window
            env: { ...process.env, PYTHONUNBUFFERED: '1' },
          }
        } else {
          // Fallback to running bat file if parsing fails
          console.log(
            `ğŸ¦„ Failed to parse bat file, falling back to direct execution`
          )
          command = 'cmd.exe'
          args = ['/C', 'start', '/b', script]

          spawnOptions = {
            cwd: path.dirname(script),
            detached: false, // Keep attached to parent process
            stdio: ['ignore', 'pipe', 'pipe'],
            windowsHide: true,
            shell: false,
            windowsVerbatimArguments: false,
            env: { ...process.env, PYTHONUNBUFFERED: '1' },
          }
        }
      } else {
        // Non-Windows or non-bat files
        command = script
        args = []
        spawnOptions = {
          cwd: path.dirname(script),
          detached: false, // Keep attached to parent process
          stdio: ['ignore', 'pipe', 'pipe'],
          shell: false,
          env: { ...process.env, PYTHONUNBUFFERED: '1' },
        }
      }
    } else {
      throw new Error('No startup script found')
    }

    console.log(`ğŸ¦„ Executing command: ${command} ${args.join(' ')}`)

    comfyUIProcess = spawn(command, args, spawnOptions)

    comfyUIProcessPid = comfyUIProcess.pid
    console.log(`ğŸ¦„ ComfyUI process started with PID: ${comfyUIProcessPid}`)

    // Handle process output
    comfyUIProcess.stdout.on('data', (data) => {
      const output = data.toString()
      console.log(`[ComfyUI] ${output.trim()}`)
    })

    comfyUIProcess.stderr.on('data', (data) => {
      const output = data.toString()
      console.log(`[ComfyUI Error] ${output.trim()}`)
    })

    // Handle process exit
    comfyUIProcess.on('exit', (code, signal) => {
      console.log(
        `ğŸ¦„ ComfyUI process exited with code ${code}, signal ${signal}`
      )
      comfyUIProcess = null
      comfyUIProcessPid = null
    })

    comfyUIProcess.on('error', (error) => {
      console.error(`ğŸ¦„ ComfyUI process error: ${error.message}`)
      console.error(`ğŸ¦„ Error details:`, error)
      comfyUIProcess = null
      comfyUIProcessPid = null
    })

    // Keep process attached to main process for proper cleanup

    // Wait a moment to see if the process starts successfully
    await new Promise((resolve) => setTimeout(resolve, 3000))

    // Check if process is still running after 3 seconds
    if (comfyUIProcess && !comfyUIProcess.killed) {
      console.log(`ğŸ¦„ ComfyUI process appears to be running successfully`)
      return {
        success: true,
        message: `ComfyUI started successfully in ${mode} mode`,
        mode: mode,
      }
    } else {
      console.log(`ğŸ¦„ ComfyUI process failed to start or exited immediately`)
      return {
        success: false,
        message:
          'ComfyUI process failed to start or exited immediately. Check the logs for details.',
      }
    }
  } catch (error) {
    console.error('ğŸ¦„ Failed to start ComfyUI process:', error)
    comfyUIProcess = null
    comfyUIProcessPid = null
    return {
      success: false,
      message: `Failed to start ComfyUI: ${error.message}`,
    }
  }
}

/**
 * Stop ComfyUI process
 * @returns {Promise<{success: boolean, message?: string}>}
 */
async function stopComfyUIProcess() {
  try {
    if (!comfyUIProcess || comfyUIProcess.killed) {
      return { success: false, message: 'ComfyUI process is not running' }
    }

    console.log(`ğŸ¦„ Stopping ComfyUI process (PID: ${comfyUIProcessPid})...`)

    const isWindows = process.platform === 'win32'

    if (isWindows) {
      // On Windows, use taskkill for more reliable process termination
      try {
        // First try graceful termination
        console.log('ğŸ¦„ Attempting graceful shutdown...')
        const gracefulKill = spawn(
          'taskkill',
          ['/pid', comfyUIProcessPid.toString(), '/t'],
          {
            stdio: 'ignore',
            windowsHide: true,
          }
        )

        await new Promise((resolve) => {
          gracefulKill.on('close', resolve)
          setTimeout(resolve, 3000) // 3 second timeout
        })

        // Check if process is still running
        if (comfyUIProcess && !comfyUIProcess.killed) {
          console.log('ğŸ¦„ Graceful shutdown failed, force killing...')
          const forceKill = spawn(
            'taskkill',
            ['/pid', comfyUIProcessPid.toString(), '/t', '/f'],
            {
              stdio: 'ignore',
              windowsHide: true,
            }
          )

          await new Promise((resolve) => {
            forceKill.on('close', resolve)
            setTimeout(resolve, 2000) // 2 second timeout
          })
        }
      } catch (killError) {
        console.log(
          'ğŸ¦„ taskkill failed, using Node.js kill:',
          killError.message
        )
        // Fallback to Node.js kill
        comfyUIProcess.kill('SIGTERM')
        await new Promise((resolve) => setTimeout(resolve, 2000))

        if (comfyUIProcess && !comfyUIProcess.killed) {
          comfyUIProcess.kill('SIGKILL')
        }
      }
    } else {
      // Unix-like systems
      comfyUIProcess.kill('SIGTERM')
      await new Promise((resolve) => setTimeout(resolve, 3000))

      if (comfyUIProcess && !comfyUIProcess.killed) {
        console.log('ğŸ¦„ Force killing ComfyUI process...')
        comfyUIProcess.kill('SIGKILL')
      }
    }

    // Clean up references
    comfyUIProcess = null
    comfyUIProcessPid = null

    console.log('ğŸ¦„ ComfyUI process stopped successfully')
    return { success: true, message: 'ComfyUI process stopped successfully' }
  } catch (error) {
    console.error('ğŸ¦„ Failed to stop ComfyUI process:', error)

    // Force cleanup even if stop failed
    comfyUIProcess = null
    comfyUIProcessPid = null

    return {
      success: false,
      message: `Failed to stop ComfyUI: ${error.message}`,
    }
  }
}

/**
 * Check if ComfyUI process is running
 * @returns {boolean} - True if ComfyUI process is running
 */
function isComfyUIProcessRunning() {
  return comfyUIProcess && !comfyUIProcess.killed
}

/**
 * Get ComfyUI process status
 * @returns {{running: boolean, pid?: number}}
 */
function getComfyUIProcessStatus() {
  return {
    running: isComfyUIProcessRunning(),
    pid: comfyUIProcessPid,
  }
}

module.exports = {
  isComfyUIInstalled,
  startComfyUIProcess,
  stopComfyUIProcess,
  isComfyUIProcessRunning,
  getComfyUIProcessStatus,
  detectNvidiaGPU,
  getPreferredStartupScript,
  findComfyUIMainDir,
  findRunScript,
}



================================================
FILE: electron/gemin_service.ts
================================================
import { GeminiClient } from '@google/gemini-cli-core'

// å¯¼å‡ºé»˜è®¤å®ä¾‹
// export const service = new GeminiClient()
console.log('GeminiClient11', GeminiClient)



================================================
FILE: electron/ipcHandlers.js
================================================
// ipcHandlers.js
const { chromium, BrowserContext } = require('playwright')
const path = require('path')
const { app, BrowserWindow, shell } = require('electron')
const fs = require('fs')
const { spawn, fork } = require('child_process')

// Track installation process
let installationWorker = null
let installationPromise = null

module.exports = {
  // å¤„ç†æ‰“å¼€æµè§ˆå™¨çš„è¯·æ±‚
  'open-browser-url': async (event, url) => {
    try {
      await shell.openExternal(url)
      return { success: true }
    } catch (error) {
      console.error('Failed to open browser:', error)
      return { success: false, error: error.message }
    }
  },

  publishPost: async (event, data) => {
    console.log('ğŸ¦„ğŸ¦„publishPost called with data:', data)
    try {
      if (data.channel === 'xiaohongshu') {
        await publishXiaohongshu(data)
      } else if (data.channel === 'bilibili') {
        await publishBilibili(data)
      } else if (data.channel === 'youtube') {
        await publishYoutube(data)
      }
    } catch (error) {
      console.error('Error in publish post:', error)
      return { error: error.message }
    }
  },
  'install-comfyui': async (event) => {
    console.log('ğŸ¦„ğŸ¦„install-comfyui called')

    // Prevent multiple installations
    if (installationWorker) {
      return { error: 'Installation already in progress' }
    }

    try {
      // Create a promise to track the installation
      installationPromise = new Promise((resolve, reject) => {
        // Fork a child process to run the installation
        const workerPath = path.join(__dirname, 'comfyUIInstaller.js')

        // Prepare environment variables for the child process
        const env = {
          ...process.env,
          USER_DATA_DIR: app.getPath('userData'),
          IS_WORKER_PROCESS: 'true',
        }

        installationWorker = fork(workerPath, [], {
          stdio: ['pipe', 'pipe', 'pipe', 'ipc'],
          env: env,
        })

        console.log('ğŸ¦„ Started ComfyUI installation worker process')

        // Handle messages from worker process
        installationWorker.on('message', (message) => {
          console.log('ğŸ¦„ Received message from worker:', message)

          // Forward progress, log, error, and cancelled messages to renderer
          const mainWindow = BrowserWindow.getAllWindows()[0]
          if (mainWindow) {
            if (message.type === 'progress') {
              mainWindow.webContents.executeJavaScript(`
                window.dispatchEvent(new CustomEvent('comfyui-install-progress', {
                  detail: { percent: ${message.percent}, status: "${(
                message.status || ''
              ).replace(/"/g, '\\"')}" }
                }));
              `)
            } else if (message.type === 'log') {
              mainWindow.webContents.executeJavaScript(`
                window.dispatchEvent(new CustomEvent('comfyui-install-log', {
                  detail: { message: "${(message.message || '').replace(
                    /"/g,
                    '\\"'
                  )}" }
                }));
              `)
            } else if (message.type === 'error') {
              mainWindow.webContents.executeJavaScript(`
                window.dispatchEvent(new CustomEvent('comfyui-install-error', {
                  detail: { error: "${(
                    message.error || 'Unknown error occurred'
                  ).replace(/"/g, '\\"')}" }
                }));
              `)
            } else if (message.type === 'cancelled') {
              mainWindow.webContents.executeJavaScript(`
                window.dispatchEvent(new CustomEvent('comfyui-install-cancelled', {
                  detail: { message: "${(
                    message.message || 'Installation cancelled'
                  ).replace(/"/g, '\\"')}" }
                }));
              `)
            }
          }

          if (message.type === 'install-complete') {
            installationWorker = null
            installationPromise = null
            resolve(message.result)
          } else if (message.type === 'install-error') {
            installationWorker = null
            installationPromise = null
            reject(new Error(message.error || 'Unknown error occurred'))
          } else if (message.type === 'install-cancelled') {
            installationWorker = null
            installationPromise = null
            resolve({
              cancelled: true,
              message: message.message || 'Installation cancelled',
            })
          }
        })

        // Handle worker process errors
        installationWorker.on('error', (error) => {
          console.error('ğŸ¦„ Worker process error:', error)
          installationWorker = null
          installationPromise = null
          reject(error)
        })

        // Handle worker process exit
        installationWorker.on('exit', (code, signal) => {
          console.log(
            `ğŸ¦„ Worker process exited with code ${code}, signal ${signal}`
          )
          if (installationWorker) {
            installationWorker = null
            installationPromise = null
            if (code !== 0) {
              reject(new Error(`Installation process exited with code ${code}`))
            }
          }
        })

        // Start the installation
        installationWorker.send({ type: 'start-install' })
      })

      const result = await installationPromise
      return result
    } catch (error) {
      console.error('Error installing ComfyUI:', error)

      // Clean up worker if it still exists
      if (installationWorker) {
        installationWorker.kill('SIGTERM')
        installationWorker = null
        installationPromise = null
      }

      return { error: error.message }
    }
  },
  'cancel-comfyui-install': async (event) => {
    console.log('ğŸ¦„ğŸ¦„cancel-comfyui-install called')

    try {
      if (!installationWorker) {
        return { error: 'No installation in progress' }
      }

      // Send cancellation message to worker process
      installationWorker.send({ type: 'cancel-install' })

      return { success: true, message: 'Installation cancellation requested' }
    } catch (error) {
      console.error('Error cancelling ComfyUI installation:', error)

      // Force kill the worker if message sending fails
      if (installationWorker) {
        installationWorker.kill('SIGTERM')
        installationWorker = null
        installationPromise = null
      }

      return { error: error.message }
    }
  },
  'check-comfyui-installed': async (event) => {
    console.log('ğŸ¦„ğŸ¦„check-comfyui-installed called')

    try {
      const { isComfyUIInstalled } = require('./comfyUIManager')
      return isComfyUIInstalled()
    } catch (error) {
      console.error('Error checking ComfyUI installation:', error)
      return false
    }
  },
  'start-comfyui-process': async (event) => {
    console.log('ğŸ¦„ğŸ¦„start-comfyui-process called')

    try {
      const { startComfyUIProcess } = require('./comfyUIManager')
      const result = await startComfyUIProcess()
      return result
    } catch (error) {
      console.error('Error starting ComfyUI process:', error)
      return { success: false, message: error.message }
    }
  },
  'stop-comfyui-process': async (event) => {
    console.log('ğŸ¦„ğŸ¦„stop-comfyui-process called')

    try {
      const { stopComfyUIProcess } = require('./comfyUIManager')
      const result = await stopComfyUIProcess()
      return result
    } catch (error) {
      console.error('Error stopping ComfyUI process:', error)
      return { success: false, message: error.message }
    }
  },
  'get-comfyui-process-status': async (event) => {
    console.log('ğŸ¦„ğŸ¦„get-comfyui-process-status called')

    try {
      const { getComfyUIProcessStatus } = require('./comfyUIManager')
      const status = getComfyUIProcessStatus()
      return status
    } catch (error) {
      console.error('Error getting ComfyUI process status:', error)
      return { running: false }
    }
  },
  'uninstall-comfyui': async (event) => {
    console.log('ğŸ¦„ğŸ¦„uninstall-comfyui called')

    // Prevent multiple uninstallations
    if (installationWorker) {
      return { error: 'Installation/uninstallation already in progress' }
    }

    try {
      // Create a promise to track the uninstallation
      installationPromise = new Promise((resolve, reject) => {
        // Fork a child process to run the uninstallation
        const workerPath = path.join(__dirname, 'comfyUIInstaller.js')

        // Prepare environment variables for the child process
        const env = {
          ...process.env,
          USER_DATA_DIR: app.getPath('userData'),
          IS_WORKER_PROCESS: 'true',
        }

        installationWorker = fork(workerPath, [], {
          stdio: ['pipe', 'pipe', 'pipe', 'ipc'],
          env: env,
        })

        console.log('ğŸ¦„ Started ComfyUI uninstallation worker process')

        // Handle messages from worker process
        installationWorker.on('message', (message) => {
          console.log('ğŸ¦„ Received message from worker:', message)

          // Forward progress, log, and error messages to renderer
          const mainWindow = BrowserWindow.getAllWindows()[0]
          if (mainWindow) {
            if (message.type === 'progress') {
              mainWindow.webContents.executeJavaScript(`
                window.dispatchEvent(new CustomEvent('comfyui-uninstall-progress', {
                  detail: { percent: ${message.percent}, status: "${(
                message.status || ''
              ).replace(/"/g, '\\"')}" }
                }));
              `)
            } else if (message.type === 'log') {
              mainWindow.webContents.executeJavaScript(`
                window.dispatchEvent(new CustomEvent('comfyui-uninstall-log', {
                  detail: { message: "${(message.message || '').replace(
                    /"/g,
                    '\\"'
                  )}" }
                }));
              `)
            } else if (message.type === 'error') {
              mainWindow.webContents.executeJavaScript(`
                window.dispatchEvent(new CustomEvent('comfyui-uninstall-error', {
                  detail: { error: "${(
                    message.error || 'Unknown error occurred'
                  ).replace(/"/g, '\\"')}" }
                }));
              `)
            }
          }

          if (message.type === 'uninstall-complete') {
            installationWorker = null
            installationPromise = null
            resolve(message.result)
          } else if (message.type === 'uninstall-error') {
            installationWorker = null
            installationPromise = null
            reject(new Error(message.error || 'Unknown error occurred'))
          }
        })

        // Handle worker process errors
        installationWorker.on('error', (error) => {
          console.error('ğŸ¦„ Worker process error:', error)
          installationWorker = null
          installationPromise = null
          reject(error)
        })

        // Handle worker process exit
        installationWorker.on('exit', (code, signal) => {
          console.log(
            `ğŸ¦„ Worker process exited with code ${code}, signal ${signal}`
          )
          if (installationWorker) {
            installationWorker = null
            installationPromise = null
            if (code !== 0) {
              reject(
                new Error(`Uninstallation process exited with code ${code}`)
              )
            }
          }
        })

        // Start the uninstallation
        installationWorker.send({ type: 'start-uninstall' })
      })

      const result = await installationPromise
      return result
    } catch (error) {
      console.error('Error uninstalling ComfyUI:', error)

      // Clean up worker if it still exists
      if (installationWorker) {
        installationWorker.kill('SIGTERM')
        installationWorker = null
        installationPromise = null
      }

      return { error: error.message }
    }
  },
}

const userDataDir = app.getPath('userData')
/** @type {BrowserContext | null} */
let browser

async function launchBrowser() {
  const context = await chromium.launchPersistentContext(
    path.join(userDataDir, 'browser_data'),
    {
      headless: false,
      channel: 'chrome',
      args: [
        '--disable-blink-features=AutomationControlled',
        '--disable-infobars', // hides "Chrome is being controlled" banner
      ],
      userAgent:
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0.0.0 Safari/537.36',
      viewport: null,
      ignoreDefaultArgs: ['--enable-automation'],
    }
  )

  return context
}

/**
 * @typedef {Object} PublishData
 * @property {"youtube" | "bilibili" | "douyin" | "xiaohongshu"} channel - The platform to publish to
 * @property {string} title - The title of the post
 * @property {string} content - The content of the post
 * @property {string[]} images - Array of image paths
 * @property {string} video - Path to the video file
 */

/**
 * @param {PublishData} data - The data for publishing the post
 */
async function publishXiaohongshu(data) {
  if (!browser) {
    browser = await launchBrowser()
  }
  const page = await browser.newPage()
  await page.addInitScript(() => {
    Object.defineProperty(navigator, 'webdriver', {
      get: () => false,
    })
  })
  try {
    await page.goto('https://creator.xiaohongshu.com/publish/publish')

    // Wait for the upload container to be visible
    try {
      await page.waitForSelector('.upload-container', { timeout: 5000 })
    } catch (error) {
      throw new Error('Please login to Xiaohongshu first')
    }

    // Check if video upload tab exists
    const videoTab = await page.$('.creator-tab:has-text("ä¸Šä¼ è§†é¢‘")')
    if (!videoTab) {
      throw new Error('Video upload tab not found on the page')
    }

    // Click on "ä¸Šä¼ è§†é¢‘" (Upload Video) button
    await videoTab.click()

    // Wait for the file input to be visible
    await page.waitForSelector('input[type="file"]')

    // Check if video path exists in data
    if (!data.video) {
      throw new Error('No video file path provided in data')
    }

    // Upload the video file
    await page.setInputFiles('input[type="file"]', data.video)

    // Wait for upload progress to appear
    await page.waitForSelector('.uploading', { timeout: 10000 })

    // Wait a bit more to ensure the upload is fully processed
    await page.waitForTimeout(1000)

    const [content, uploadComplete] = await Promise.all([
      fillXiaohongshuContent(page, data.title, data.content),
      waitForXiaohongshuUploadComplete(page),
    ])

    console.log('ğŸ¦„ğŸ¦„uploadComplete:', uploadComplete)

    // Wait a bit to ensure content is properly set
    await page.waitForTimeout(1000)
  } catch (error) {
    console.error('Error during video upload:', error)
    throw error
  } finally {
    // await page.close();
  }
}

async function fillXiaohongshuContent(page, title, content) {
  // fill in title
  await page.waitForSelector(
    'input.d-text[placeholder="å¡«å†™æ ‡é¢˜ä¼šæœ‰æ›´å¤šèµå“¦ï½"]',
    { timeout: 10000 } // Increase timeout if necessary
  )

  // Focus on the input field
  await page.focus('input.d-text[placeholder="å¡«å†™æ ‡é¢˜ä¼šæœ‰æ›´å¤šèµå“¦ï½"]')
  await page.fill(
    'input.d-text[placeholder="å¡«å†™æ ‡é¢˜ä¼šæœ‰æ›´å¤šèµå“¦ï½"]',
    title || ''
  )

  await page.waitForTimeout(1000)
  await page.waitForSelector('.ql-editor')
  await page.focus('.ql-editor')
  const { tags, content: contentWithoutTags } = getTagsFromContent(
    content || ''
  )

  // Fill in the content by clipboard copying pasting
  await copyPasteContent(page, contentWithoutTags)
  await page.waitForTimeout(2000)

  await page.keyboard.press('Enter')

  await page.waitForTimeout(1000)

  // Add hashtags
  console.log('ğŸ¦„ğŸ¦„tags:', tags)
  for (const tag of tags) {
    await copyPasteContent(page, `#${tag}`)
    await page.waitForTimeout(2000)
    await page.keyboard.press('Enter')
    await page.waitForTimeout(1000)
  }

  await page.waitForTimeout(1000)

  return true
}

async function waitForXiaohongshuUploadComplete(page) {
  // Wait for upload to complete (100%)
  while (true) {
    const progressText = await page.evaluate(() => {
      return document.querySelector('.stage')?.textContent || ''
    })

    // Check if the text contains "ä¸Šä¼ æˆåŠŸ" (Upload Successful)
    if (progressText.includes('ä¸Šä¼ æˆåŠŸ')) {
      console.log('Upload completed!')
      return true
    }

    // Match the text that contains "ä¸Šä¼ ä¸­" followed by a percentage
    const progressMatch = progressText.match(/ä¸Šä¼ ä¸­\s*(\d+)%/)

    if (!progressMatch) {
      throw new Error('Could not find upload progress percentage')
    }

    const progress = parseInt(progressMatch[1])
    console.log(`â³Upload progress: ${progress}%`)

    if (progress === 99) {
      console.log('Upload completed!')
      break
    }

    // Wait a bit before checking again
    await page.waitForTimeout(3000)
  }
  return false
}

/**
 * @param {PublishData} data - The data for publishing the post
 */

async function publishBilibili(data) {
  if (!browser) {
    browser = await launchBrowser()
  }
  const page = await browser.newPage()
  try {
    await page.goto('https://member.bilibili.com/platform/upload/video/frame')
    await page.waitForTimeout(3000) // Let Vue UI settle

    // Ensure the "ä¸Šä¼ è§†é¢‘" button is visible and clickable
    const uploadButton = await page.waitForSelector('.bcc-upload-wrapper', {
      timeout: 10000,
      state: 'visible',
    })

    // Listen for the file chooser BEFORE clicking
    const [fileChooser] = await Promise.all([
      page.waitForEvent('filechooser'),
      uploadButton.click(), // This triggers file picker
    ])

    // Use the filechooser to set your file
    await fileChooser.setFiles(data.video)
    // fill in title
    await page.locator('input[placeholder="è¯·è¾“å…¥ç¨¿ä»¶æ ‡é¢˜"]').click()
    await page.keyboard.press(
      process.platform === 'darwin' ? 'Meta+A' : 'Control+A'
    )
    await page.keyboard.press('Delete')
    await copyPasteContent(page, data.title)

    const { tags, content: contentWithoutTags } = getTagsFromContent(
      data.content || ''
    )
    // fill in content
    await page.focus('.ql-editor')
    await copyPasteContent(page, contentWithoutTags)
    await page.waitForTimeout(1000)
    // fill in tags
    const tagInput = await page
      .locator('input[placeholder="æŒ‰å›è½¦é”®Enteråˆ›å»ºæ ‡ç­¾"]')
      .nth(0)
    await tagInput.click()
    await page.waitForTimeout(1000)
    for (const tag of tags) {
      await copyPasteContent(page, `${tag}`)
      await page.waitForTimeout(1000)
      await page.keyboard.press('Enter')
      await page.waitForTimeout(1000)
    }

    await page.waitForTimeout(2000)
  } catch (err) {
    console.error('Upload error:', err)
    throw err
  }
}

async function publishYoutube(data) {
  if (!browser) {
    browser = await launchBrowser()
  }
  const page = await browser.newPage()
  try {
    await page.goto('https://www.youtube.com/upload')
    await page.waitForTimeout(3000) // Let Vue UI settle
  } catch (err) {
    console.error('Upload error:', err)
    throw err
  }
}
/**
 * @param {string} content - The content of the post
 * @returns {{tags: string[], content: string}} - The tags of the post and the content without tags
 */
function getTagsFromContent(content) {
  const tags = content.match(/#(\w+)/g)
  const ret = tags ? tags.map((tag) => tag.slice(1)) : []
  console.log('ğŸ¦„ğŸ¦„ret:', ret)
  // remove tags from content
  for (const tag of ret) {
    content = content.replace(`#${tag}`, '')
  }
  // remove spaces and trailing \n from content
  content = content.trim().replace(/\n+$/, '')

  return { tags: ret, content }
}
async function copyPasteContent(page, content) {
  await page.evaluate(async (text) => {
    await navigator.clipboard.writeText(text)
  }, content || '')
  await page.keyboard.press(
    process.platform === 'darwin' ? 'Meta+V' : 'Control+V'
  )
}



================================================
FILE: electron/main.js
================================================
// electron/main.js
// npx electron electron/main.js

const fs = require('fs')
const path = require('path')
const os = require('os')
// to import a ts module, we need to import like below
// const gemini = require('./dist/gemin_service')
const logPath = path.join(os.homedir(), 'jaaz-log.txt')
// Check if the log file exists and delete it
if (fs.existsSync(logPath)) {
  fs.unlinkSync(logPath)
}

const logStream = fs.createWriteStream(logPath, { flags: 'a' })

// Redirect all stdout and stderr to the log file
process.stdout.write = process.stderr.write = logStream.write.bind(logStream)

// Optional: Add timestamps to log output
const origLog = console.log
console.log = (...args) => {
  const time = new Date().toISOString()
  origLog(`[${time}]`, ...args)
}

console.error = (...args) => {
  const time = new Date().toISOString()
  origLog(`[${time}][ERROR]`, ...args)
}

// Initial log entry
console.log('ğŸŸ¢ Jaaz Electron app starting...')

const { app, BrowserWindow, ipcMain, dialog, session } = require('electron')
const { spawn } = require('child_process')

const { autoUpdater } = require('electron-updater')

const net = require('net')

// Initialize settings service
const settingsService = require('./settingsService')

function findAvailablePort(startPort, maxAttempts = 100) {
  return new Promise((resolve, reject) => {
    let attempts = 0

    const tryPort = (port) => {
      attempts++
      if (attempts > maxAttempts) {
        reject(new Error(`Could not find available port after ${maxAttempts} attempts`))
        return
      }

      const server = net.createServer()

      server.on('error', (err) => {
        if (err.code === 'EADDRINUSE') {
          console.log(`Port ${port} is in use, trying next port...`)
          server.close()
          tryPort(port + 1)
        } else {
          reject(err)
        }
      })

      // æ˜ç¡®æŒ‡å®š host ä¸º 127.0.0.1ï¼Œç¡®ä¿æ£€æµ‹åˆ°ç«¯å£å ç”¨
      server.listen(port, '127.0.0.1', () => {
        server.close(() => {
          console.log(`Found available port: ${port}`)
          resolve(port)
        })
      })
    }

    tryPort(startPort)
  })
}

let mainWindow
let pyProc = null
let pyPort = null
let childWindows = [] // Track all child windows

// check for updates after the app is ready
// Auto-updater event handlers
autoUpdater.on('checking-for-update', () => {
  console.log('Checking for update...')
})

autoUpdater.on('update-available', (info) => {
  console.log('Update available.')
  console.log('Version:', info.version)
  console.log('Release date:', info.releaseDate)
  // Automatically download the update when available
  autoUpdater.downloadUpdate()
})

autoUpdater.on('update-not-available', (info) => {
  console.log('Update not available:', info)
})

autoUpdater.on('error', (err) => {
  console.log('Error in auto-updater. ' + err)
})

autoUpdater.on('download-progress', (progressObj) => {
  let log_message = 'Download speed: ' + progressObj.bytesPerSecond
  log_message = log_message + ' - Downloaded ' + progressObj.percent + '%'
  log_message = log_message + ' (' + progressObj.transferred + '/' + progressObj.total + ')'
  console.log(log_message)
})

autoUpdater.on('update-downloaded', (info) => {
  console.log('new Jaaz version downloaded:', info.version)

  // send message to renderer process
  if (mainWindow) {
    mainWindow.webContents.send('update-downloaded', info)
  }
})

const createWindow = (pyPort) => {
  mainWindow = new BrowserWindow({
    width: 1200,
    height: 800,
    icon: path.join(__dirname, '../assets/icons/jaaz.png'), // âœ… Use .png for dev
    autoHideMenuBar: true, // Hide menu bar (can be toggled with Alt key)
    webPreferences: {
      preload: path.join(__dirname, 'preload.js'),
      contextIsolation: true,
      nodeIntegration: false,
      // for showing local image and video files
      webSecurity: false,
      allowRunningInsecureContent: true,
    },
  })

  // Handle window closed event
  mainWindow.on('closed', () => {
    // Close all child windows
    childWindows.forEach((window) => {
      if (!window.isDestroyed()) {
        window.close()
      }
    })
    childWindows = []
    mainWindow = null
  })

  // Handle all navigation requests (intercept all link clicks)
  // ä¸»è¦ç”¨äºå¤„ç†è§†é¢‘é“¾æ¥å¯¼è‡´çš„é¡µé¢è·³è½¬
  mainWindow.webContents.on('will-navigate', (event, navigationUrl) => {
    console.log('Navigation requested:', navigationUrl)
    event.preventDefault()

    // Create new window for external links
    const newWindow = new BrowserWindow({
      width: 800,
      height: 600,
      title: 'Jaaz Preview',
      icon: path.join(__dirname, '../assets/icons/jaaz.png'),
      autoHideMenuBar: true,
      webPreferences: {
        nodeIntegration: false,
        contextIsolation: true,
        webSecurity: false,
        allowRunningInsecureContent: true,
      },
    })
    newWindow.loadURL(navigationUrl)

    // Add to child windows array
    childWindows.push(newWindow)

    // Handle new window closed event
    newWindow.on('closed', () => {
      // Remove from child windows array
      const index = childWindows.indexOf(newWindow)
      if (index > -1) {
        childWindows.splice(index, 1)
      }
    })
  })

  // In development, use Vite dev server
  if (process.env.NODE_ENV === 'development') {
    mainWindow.loadURL('http://localhost:5174', {
      extraHeaders: 'pragma: no-cache\n',
    })
    mainWindow.webContents.openDevTools()
  } else {
    // In production, load built files
    mainWindow.loadURL(`http://127.0.0.1:${pyPort}`, {
      extraHeaders: 'pragma: no-cache\n',
    })
  }
}

// è·å– app.asar å†…éƒ¨çš„æ ¹è·¯å¾„
const appRoot = app.getAppPath()

const startPythonApi = async () => {
  // Find an available port
  pyPort = await findAvailablePort(57988)
  console.log('available pyPort:', pyPort)

  // åœ¨æŸäº›å¼€å‘æƒ…å†µï¼Œæˆ‘ä»¬å¸Œæœ› python server ç‹¬ç«‹è¿è¡Œï¼Œé‚£ä¹ˆå°±ä¸é€šè¿‡ electron å¯åŠ¨
  if (process.env.NODE_ENV === 'development') {
    try {
      const response = await fetch(`http://127.0.0.1:${pyPort}`)
      if (response.ok) {
        console.log('Python service already running on port:', pyPort)
        return pyPort
      }
    } catch (error) {
      console.log('Starting Python service on port:', pyPort)
    }
  } else {
    console.log('Starting Python service on port:', pyPort)
  }

  // ç¡®å®šUI distç›®å½•
  const env = {
    ...process.env,
  }
  env.PYTHONIOENCODING = 'utf-8'
  env.DEFAULT_PORT = pyPort // æ·»åŠ ç«¯å£åˆ°ç¯å¢ƒå˜é‡
  if (app.isPackaged) {
    env.UI_DIST_DIR = path.join(process.resourcesPath, 'react', 'dist')
    env.USER_DATA_DIR = app.getPath('userData')
    env.IS_PACKAGED = '1'
  }

  // Set BASE_API_URL based on environment
  env.BASE_API_URL =
    process.env.NODE_ENV === 'development' ? 'http://localhost:3000' : 'https://jaaz.app'
  console.log('BASE_API_URL:', env.BASE_API_URL)

  // Apply proxy settings and get environment variables
  try {
    const proxyEnvVars = await settingsService.getProxyEnvironmentVariables()

    // Merge proxy environment variables into env
    Object.assign(env, proxyEnvVars)
  } catch (error) {
    console.error('Failed to get proxy environment variables:', error)
  }

  // Determine the Python executable path (considering packaged app)
  const isWindows = process.platform === 'win32'
  const pythonExecutable = app.isPackaged
    ? path.join(process.resourcesPath, 'server', 'dist', 'main', isWindows ? 'main.exe' : 'main')
    : 'python'
  console.log('Resolved Python executable:', pythonExecutable)

  const fs = require('fs')

  console.log('Exists?', fs.existsSync(pythonExecutable))

  // fs.chmodSync(pythonExecutable, "755");

  console.log('Python executable path:', pythonExecutable)
  console.log('Python executable exists?', fs.existsSync(pythonExecutable))
  console.log('env:', env)
  const scriptPath = path.join(__dirname, '../server/main.py')

  // Start the FastAPI process
  pyProc = spawn(
    pythonExecutable,
    app.isPackaged ? [`--port`, pyPort] : [scriptPath, `--port`, pyPort],
    { env: env }
  )

  // Log output to logStream (shared with console.log)
  pyProc.stdout.on('data', (data) => {
    const log = `[${new Date().toISOString()}][PYTHON stdout] ${data}`
    logStream.write(log)
    process.stdout.write(log) // optional: echo to terminal if running from CLI
  })

  pyProc.stderr.on('data', (data) => {
    const log = `[${new Date().toISOString()}][PYTHON stderr] ${data}`
    logStream.write(log)
    process.stderr.write(log) // optional: echo to terminal if running from CLI
  })

  // Optional: log if spawn fails
  pyProc.on('error', (err) => {
    const log = `[${new Date().toISOString()}][PYTHON spawn error] ${err.toString()}\n`
    logStream.write(log)
    process.stderr.write(log)
  })

  // Optional: log process exit
  pyProc.on('exit', (code, signal) => {
    const log = `[${new Date().toISOString()}][PYTHON exited] code=${code}, signal=${signal}\n`
    logStream.write(log)
  })

  return pyPort
}

// Add these handlers before app.whenReady()
ipcMain.handle('pick-image', async () => {
  const result = await dialog.showOpenDialog({
    properties: ['openFile', 'multiSelections'],
    filters: [{ name: 'Images', extensions: ['jpg', 'jpeg', 'png', 'gif', 'webp'] }],
  })

  if (!result.canceled && result.filePaths.length > 0) {
    return result.filePaths
  }
  return null
})

ipcMain.handle('pick-video', async () => {
  const result = await dialog.showOpenDialog({
    properties: ['openFile'],
    filters: [{ name: 'Videos', extensions: ['mp4', 'webm', 'mov', 'avi'] }],
  })

  if (!result.canceled && result.filePaths.length > 0) {
    return result.filePaths[0]
  }
  return null
})

// Add IPC handlers for manual update check
ipcMain.handle('check-for-updates', () => {
  if (app.isPackaged) {
    autoUpdater.checkForUpdatesAndNotify()
    return { message: 'Checking for updates...' }
  } else {
    return { message: 'Auto-updater is disabled in development mode' }
  }
})

// restart and install the new version
ipcMain.handle('restart-and-install', () => {
  autoUpdater.quitAndInstall()
})

const ipcHandlers = require('./ipcHandlers')

for (const [channel, handler] of Object.entries(ipcHandlers)) {
  ipcMain.handle(channel, handler)
}

// Make this app a single instance app
const gotTheLock = app.requestSingleInstanceLock()

if (!gotTheLock) {
  // Another instance is already running, quit this one
  app.quit()
} else {
  // This is the first instance, set up second-instance handler
  app.on('second-instance', (event, commandLine, workingDirectory) => {
    // Someone tried to run a second instance, focus our window instead
    if (mainWindow) {
      if (mainWindow.isMinimized()) mainWindow.restore()
      mainWindow.focus()
    }
  })

  app.whenReady().then(async () => {
    // Initialize proxy settings for Electron sessions
    try {
      await settingsService.applyProxySettings()
      console.log('Proxy settings applied for Electron sessions')
    } catch (error) {
      console.error('Failed to apply proxy settings for Electron sessions:', error)
    }

    // Check for updates in production every time app starts
    if (process.env.NODE_ENV !== 'development' && app.isPackaged) {
      // Wait a bit for the app to fully load before checking updates
      setTimeout(() => {
        autoUpdater.checkForUpdatesAndNotify()
      }, 3000)
    }

    // Start Python API in both development and production
    const pyPort = await startPythonApi()

    while (true) {
      await new Promise((resolve) => setTimeout(resolve, 1000))
      // wait for the server to start
      let status = await fetch(`http://127.0.0.1:${pyPort}`)
        .then((res) => {
          return res.ok
        })
        .catch((err) => {
          console.error(err)
          return false
        })
      if (status) {
        break
      }
    }

    createWindow(pyPort)
  })
}

// Quit the app and clean up the Python process
app.on('will-quit', async (event) => {
  event.preventDefault()

  try {
    // clear cache
    await session.defaultSession.clearCache()
    console.log('Cache cleared on app exit')
  } catch (error) {
    console.error('Failed to clear cache:', error)
  }

  // kill python process
  if (pyProc) {
    pyProc.kill()
    pyProc = null
  }

  app.exit()
})

app.on('window-all-closed', () => {
  app.quit()
})

// ipcMain.handle("reveal-in-explorer", async (event, filePath) => {
//   try {
//     // Convert relative path to absolute path
//     const fullPath = path.join(app.getPath("userData"), "workspace", filePath);

//     // Use shell.openPath which is the recommended way in Electron
//     await shell.showItemInFolder(fullPath);
//     return { success: true };
//   } catch (error) {
//     console.error("Error revealing file:", error);
//     return { error: error.message };
//   }
// });



================================================
FILE: electron/preload.js
================================================
const { contextBridge, ipcRenderer } = require('electron')

// const ipcHandlers = require("./ipcHandlers");

// console.log("Available IPC handlers:", Object.keys(ipcHandlers));

// // Dynamically build API based on handler function names
// const exposedAPI = {};
// for (const name of Object.keys(ipcHandlers)) {
//   exposedAPI[name] = (...args) => {
//     console.log(`Calling IPC handler: ${name} with args:`, args);
//     return ipcRenderer.invoke(name, ...args);
//   };
// }

// console.log("Exposing API with methods:", Object.keys(exposedAPI));

contextBridge.exposeInMainWorld('electronAPI', {
  openBrowserUrl: (url) => ipcRenderer.invoke('open-browser-url', url),

  publishPost: (...args) => {
    return ipcRenderer.invoke('publishPost', ...args)
  },
  // Add new file picker methods
  pickImage: () => ipcRenderer.invoke('pick-image'),
  pickVideo: () => ipcRenderer.invoke('pick-video'),
  // Add ComfyUI installation methods
  installComfyUI: () => ipcRenderer.invoke('install-comfyui'),
  uninstallComfyUI: () => ipcRenderer.invoke('uninstall-comfyui'),
  cancelComfyUIInstall: () => ipcRenderer.invoke('cancel-comfyui-install'),
  checkComfyUIInstalled: () => ipcRenderer.invoke('check-comfyui-installed'),
  // Add ComfyUI process management methods
  startComfyUIProcess: () => ipcRenderer.invoke('start-comfyui-process'),
  stopComfyUIProcess: () => ipcRenderer.invoke('stop-comfyui-process'),
  getComfyUIProcessStatus: () =>
    ipcRenderer.invoke('get-comfyui-process-status'),
  // Add auto-updater methods
  checkForUpdates: () => ipcRenderer.invoke('check-for-updates'),
  restartAndInstall: () => ipcRenderer.invoke('restart-and-install'),
  // Listen for update events
  onUpdateDownloaded: (callback) => {
    ipcRenderer.on('update-downloaded', (event, info) => callback(info))
  },
  removeUpdateDownloadedListener: () => {
    ipcRenderer.removeAllListeners('update-downloaded')
  },
})



================================================
FILE: electron/settingsService.js
================================================
[Binary file]


================================================
FILE: electron/tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "CommonJS",
    "lib": ["ES2020"],
    "outDir": "./dist",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "removeComments": false,
    "noEmitOnError": true,
    "typeRoots": ["./node_modules/@types", "../node_modules/@types"],
    "types": ["node", "electron"]
  },
  "include": ["*.ts", "**/*.ts"],
  "exclude": ["node_modules", "dist", "test"]
}



================================================
FILE: electron/test/comfyUIInstaller/core-functions.test.js
================================================
// core-functions.test.js - ComfyUI å®‰è£…å™¨æ ¸å¿ƒåŠŸèƒ½æµ‹è¯•
import path from 'path'

// Set up test environment
process.env.IS_WORKER_PROCESS = 'false'

// Mock electron modules
const mockElectron = {
  app: {
    getPath: () => '/mock/user/data',
  },
  BrowserWindow: {
    getAllWindows: () => [],
  },
}

// Mock modules
const Module = await import('module')
const originalRequire = Module.default.prototype.require

Module.default.prototype.require = function (id) {
  if (id === 'electron') {
    return mockElectron
  }
  if (id === 'child_process') {
    return { spawn: () => {} }
  }
  if (id === 'fs') {
    return {
      existsSync: (path) => {
        // æ¨¡æ‹Ÿæ–‡ä»¶å­˜åœ¨çš„é€»è¾‘
        if (path.includes('ComfyUI_windows_portable')) return true
        if (path.includes('run_cpu.bat')) return true
        return false
      },
      mkdirSync: () => {},
      rmSync: () => {},
      createWriteStream: () => ({ close: () => {}, on: () => {} }),
      unlink: () => {},
      statSync: () => ({ size: 1000 }),
      unlinkSync: () => {},
    }
  }
  if (id === '7zip-min') {
    return { unpack: () => {} }
  }
  return originalRequire.call(this, id)
}

// Import the module
const comfyUIInstaller = await import('../../comfyUIInstaller.js')

console.log('ğŸ§ª å¼€å§‹è¿è¡Œ ComfyUI æ ¸å¿ƒåŠŸèƒ½æµ‹è¯•...\n')

// Test 1: GitHub API - æœ€é‡è¦çš„æµ‹è¯•
console.log('ğŸ“¡ æµ‹è¯• 1: GitHub API é›†æˆ')
try {
  const result = await comfyUIInstaller.getLatestComfyUIRelease()
  console.log('âœ… GitHub API æµ‹è¯•é€šè¿‡:')
  console.log(`   ç‰ˆæœ¬: ${result.version}`)
  console.log(`   æ–‡ä»¶å: ${result.fileName}`)
  console.log(`   å¤§å°: ${Math.round(result.size / 1024 / 1024)}MB`)
} catch (error) {
  console.log('âŒ GitHub API æµ‹è¯•å¤±è´¥:', error.message)
}

console.log()

// Test 2: å®‰è£…çŠ¶æ€ç®¡ç† - æ ¸å¿ƒçŠ¶æ€æ§åˆ¶
console.log('ğŸ”„ æµ‹è¯• 2: å®‰è£…çŠ¶æ€ç®¡ç†')
try {
  // åˆå§‹çŠ¶æ€åº”è¯¥æ˜¯æœªå–æ¶ˆ
  if (!comfyUIInstaller.isInstallationCancelled()) {
    console.log('âœ… åˆå§‹çŠ¶æ€æµ‹è¯•é€šè¿‡')
  } else {
    console.log('âŒ åˆå§‹çŠ¶æ€æµ‹è¯•å¤±è´¥')
  }

  // æµ‹è¯•å–æ¶ˆåŠŸèƒ½
  comfyUIInstaller.cancelInstallation()
  if (comfyUIInstaller.isInstallationCancelled()) {
    console.log('âœ… å–æ¶ˆå®‰è£…æµ‹è¯•é€šè¿‡')
  } else {
    console.log('âŒ å–æ¶ˆå®‰è£…æµ‹è¯•å¤±è´¥')
  }

  // æµ‹è¯•é‡ç½®çŠ¶æ€
  comfyUIInstaller.resetCancellationState()
  if (!comfyUIInstaller.isInstallationCancelled()) {
    console.log('âœ… é‡ç½®çŠ¶æ€æµ‹è¯•é€šè¿‡')
  } else {
    console.log('âŒ é‡ç½®çŠ¶æ€æµ‹è¯•å¤±è´¥')
  }
} catch (error) {
  console.log('âŒ å®‰è£…çŠ¶æ€ç®¡ç†æµ‹è¯•å¤±è´¥:', error.message)
}

console.log()

// Test 3: æ–‡ä»¶ç³»ç»Ÿæ“ä½œ - åŸºç¡€æ–‡ä»¶æŸ¥æ‰¾
console.log('ğŸ“ æµ‹è¯• 3: æ–‡ä»¶ç³»ç»Ÿæ“ä½œ')
try {
  const testDir = '/test/comfyui'

  // æµ‹è¯•æŸ¥æ‰¾ä¸»ç›®å½•
  const mainDir = comfyUIInstaller.findComfyUIMainDir(testDir)
  if (mainDir === path.join(testDir, 'ComfyUI_windows_portable')) {
    console.log('âœ… æŸ¥æ‰¾ä¸»ç›®å½•æµ‹è¯•é€šè¿‡')
  } else {
    console.log('âŒ æŸ¥æ‰¾ä¸»ç›®å½•æµ‹è¯•å¤±è´¥')
  }

  // æµ‹è¯•æŸ¥æ‰¾è¿è¡Œè„šæœ¬
  const runScript = comfyUIInstaller.findRunScript(testDir)
  if (runScript === path.join(testDir, 'run_cpu.bat')) {
    console.log('âœ… æŸ¥æ‰¾è¿è¡Œè„šæœ¬æµ‹è¯•é€šè¿‡')
  } else {
    console.log('âŒ æŸ¥æ‰¾è¿è¡Œè„šæœ¬æµ‹è¯•å¤±è´¥')
  }
} catch (error) {
  console.log('âŒ æ–‡ä»¶ç³»ç»Ÿæ“ä½œæµ‹è¯•å¤±è´¥:', error.message)
}

console.log()

// Test 4: é…ç½®ç®¡ç† - ç®€åŒ–ç‰ˆæœ¬
console.log('âš™ï¸ æµ‹è¯• 4: é…ç½®ç®¡ç†')
try {
  // Mock fetch
  global.fetch = async () => ({
    ok: true,
    json: async () => ({ message: 'Config updated successfully' }),
  })

  await comfyUIInstaller.updateConfigWithComfyUI()
  console.log('âœ… é…ç½®æ›´æ–°æµ‹è¯•é€šè¿‡')
} catch (error) {
  console.log('âŒ é…ç½®æ›´æ–°æµ‹è¯•å¤±è´¥:', error.message)
}

console.log('\nğŸ‰ æ ¸å¿ƒåŠŸèƒ½æµ‹è¯•å®Œæˆï¼')



================================================
FILE: electron/test/comfyUIInstaller/download-functions.test.js
================================================
// download-functions.test.js - ä¸‹è½½åŠŸèƒ½ä¸“é¡¹æµ‹è¯•
import { EventEmitter } from 'events'

// Set up test environment
process.env.IS_WORKER_PROCESS = 'false'

// Mock electron modules
const mockElectron = {
  app: {
    getPath: () => '/mock/user/data',
  },
  BrowserWindow: {
    getAllWindows: () => [],
  },
}

// Create a proper mock file stream using EventEmitter
class MockWriteStream extends EventEmitter {
  constructor() {
    super()
    this.writable = true
  }

  write(chunk) {
    return true
  }

  end() {
    // Simulate successful completion
    setTimeout(() => {
      this.emit('finish')
    }, 50)
  }

  close() {
    this.emit('close')
  }
}

// Mock modules
const Module = await import('module')
const originalRequire = Module.default.prototype.require

Module.default.prototype.require = function (id) {
  if (id === 'electron') {
    return mockElectron
  }
  if (id === 'child_process') {
    return { spawn: () => {} }
  }
  if (id === 'fs') {
    return {
      existsSync: () => false,
      mkdirSync: () => {},
      rmSync: () => {},
      createWriteStream: () => new MockWriteStream(),
      unlink: () => {},
      statSync: () => ({ size: 1000 }),
      unlinkSync: () => {},
    }
  }
  if (id === '7zip-min') {
    return { unpack: () => {} }
  }
  return originalRequire.call(this, id)
}

// Import the module
const comfyUIInstaller = await import('../../comfyUIInstaller.js')

console.log('ğŸ§ª å¼€å§‹è¿è¡Œä¸‹è½½åŠŸèƒ½ä¸“é¡¹æµ‹è¯•...\n')

// Test 1: å°æ–‡ä»¶ä¸‹è½½æµ‹è¯• - éªŒè¯ä¸‹è½½åŠŸèƒ½åŸºæœ¬å·¥ä½œ
console.log('ğŸ“¥ æµ‹è¯• 1: å°æ–‡ä»¶ä¸‹è½½åŠŸèƒ½')
try {
  const progressUpdates = []

  // ä½¿ç”¨ä¸€ä¸ªå°çš„æµ‹è¯•æ–‡ä»¶è¿›è¡ŒçœŸå®ä¸‹è½½æµ‹è¯•
  const testUrl = 'https://httpbin.org/bytes/1024' // 1KB æµ‹è¯•æ–‡ä»¶
  const testPath = '/tmp/test-download.bin'

  const progressCallback = (progress) => {
    progressUpdates.push(progress)
    console.log(`   ä¸‹è½½è¿›åº¦: ${Math.round(progress * 100)}%`)
  }

  await comfyUIInstaller.downloadFile(testUrl, testPath, progressCallback)

  if (progressUpdates.length > 0) {
    console.log('âœ… å°æ–‡ä»¶ä¸‹è½½æµ‹è¯•é€šè¿‡')
    console.log(`   æ”¶åˆ° ${progressUpdates.length} ä¸ªè¿›åº¦æ›´æ–°`)
  } else {
    console.log('âŒ å°æ–‡ä»¶ä¸‹è½½æµ‹è¯•å¤±è´¥: æ²¡æœ‰æ”¶åˆ°è¿›åº¦æ›´æ–°')
  }
} catch (error) {
  console.log('âŒ å°æ–‡ä»¶ä¸‹è½½æµ‹è¯•å¤±è´¥:', error.message)
}

console.log()

// Test 2: ä¸‹è½½å–æ¶ˆæµ‹è¯• - éªŒè¯å–æ¶ˆæœºåˆ¶
console.log('ğŸ›‘ æµ‹è¯• 2: ä¸‹è½½å–æ¶ˆåŠŸèƒ½')
try {
  // é‡ç½®å–æ¶ˆçŠ¶æ€
  comfyUIInstaller.resetCancellationState()

  // å¼€å§‹ä¸€ä¸ªä¸‹è½½ï¼Œç„¶åç«‹å³å–æ¶ˆ
  const downloadPromise = comfyUIInstaller.downloadFile(
    'https://httpbin.org/delay/3', // 3ç§’å»¶è¿Ÿçš„è¯·æ±‚
    '/tmp/test-cancel.bin',
    () => {}
  )

  // ç«‹å³å–æ¶ˆ
  setTimeout(() => {
    comfyUIInstaller.cancelInstallation()
  }, 100)

  try {
    await downloadPromise
    console.log('âŒ ä¸‹è½½å–æ¶ˆæµ‹è¯•å¤±è´¥: ä¸‹è½½åº”è¯¥è¢«å–æ¶ˆ')
  } catch (error) {
    if (error.message.includes('cancelled')) {
      console.log('âœ… ä¸‹è½½å–æ¶ˆæµ‹è¯•é€šè¿‡')
    } else {
      console.log('âŒ ä¸‹è½½å–æ¶ˆæµ‹è¯•å¤±è´¥:', error.message)
    }
  }
} catch (error) {
  console.log('âŒ ä¸‹è½½å–æ¶ˆæµ‹è¯•å¤±è´¥:', error.message)
}

console.log()

// Test 3: é”™è¯¯å¤„ç†æµ‹è¯• - éªŒè¯é”™è¯¯å¤„ç†æœºåˆ¶
console.log('âš ï¸ æµ‹è¯• 3: ä¸‹è½½é”™è¯¯å¤„ç†')
try {
  // é‡ç½®å–æ¶ˆçŠ¶æ€
  comfyUIInstaller.resetCancellationState()

  // å°è¯•ä¸‹è½½ä¸€ä¸ªä¸å­˜åœ¨çš„æ–‡ä»¶
  await comfyUIInstaller.downloadFile(
    'https://httpbin.org/status/404', // è¿”å› 404 é”™è¯¯
    '/tmp/test-error.bin',
    () => {}
  )

  console.log('âŒ é”™è¯¯å¤„ç†æµ‹è¯•å¤±è´¥: åº”è¯¥æŠ›å‡ºé”™è¯¯')
} catch (error) {
  if (
    error.message.includes('404') ||
    error.message.includes('Download failed')
  ) {
    console.log('âœ… é”™è¯¯å¤„ç†æµ‹è¯•é€šè¿‡')
  } else {
    console.log('âŒ é”™è¯¯å¤„ç†æµ‹è¯•å¤±è´¥:', error.message)
  }
}

console.log('\nğŸ‰ ä¸‹è½½åŠŸèƒ½æµ‹è¯•å®Œæˆï¼')



================================================
FILE: electron/test/comfyUIInstaller/process-management.test.js
================================================
// process-management.test.js - ComfyUI è¿›ç¨‹ç®¡ç†åŠŸèƒ½æµ‹è¯•
import path from 'path'
import { EventEmitter } from 'events'
import os from 'os'

// Set up test environment
process.env.IS_WORKER_PROCESS = 'false'

// Get real user data directory
function getRealUserDataDir() {
  // ç›´æ¥ä½¿ç”¨æŒ‡å®šçš„ComfyUIå®‰è£…è·¯å¾„
  return 'C:\\Users\\admin\\AppData\\Roaming\\Electron'
}

// Mock child process
class MockChildProcess extends EventEmitter {
  constructor(shouldFail = false, shouldExitImmediately = false) {
    super()
    this.killed = false
    this.pid = Math.floor(Math.random() * 10000) + 1000
    this.shouldFail = shouldFail
    this.shouldExitImmediately = shouldExitImmediately

    // Mock stdout and stderr
    this.stdout = new EventEmitter()
    this.stderr = new EventEmitter()

    // Simulate process startup
    setTimeout(() => {
      if (this.shouldFail) {
        this.emit('error', new Error('Process failed to start'))
      } else if (this.shouldExitImmediately) {
        this.killed = true
        this.emit('exit', 1, null)
      } else {
        // Simulate successful startup output
        this.stdout.emit('data', 'Starting server')
        this.stdout.emit('data', 'Server listening on 127.0.0.1:8188')
      }
    }, 100)
  }

  kill(signal) {
    console.log(`Mock process ${this.pid} received ${signal}`)
    this.killed = true

    // Simulate graceful shutdown
    setTimeout(() => {
      this.emit('exit', 0, signal)
    }, 100)
  }

  unref() {
    // Mock unref
  }
}

// Get real user data directory
const realUserDataDir = getRealUserDataDir()
console.log(`ğŸ” ä½¿ç”¨çœŸå®ç”¨æˆ·æ•°æ®ç›®å½•: ${realUserDataDir}`)

// Mock electron modules with real path
const mockElectron = {
  app: {
    getPath: () => realUserDataDir,
  },
  BrowserWindow: {
    getAllWindows: () => [],
  },
}

// Import real fs module for actual file checking
import fs from 'fs'

// Mock modules
const Module = await import('module')
const originalRequire = Module.default.prototype.require

Module.default.prototype.require = function (id) {
  if (id === 'electron') {
    return mockElectron
  }
  if (id === 'child_process') {
    return {
      spawn: (command, args, options) => {
        console.log(`Mock spawn: ${command} ${args.join(' ')}`)

        // Simulate different scenarios based on command
        if (command.includes('nonexistent')) {
          return new MockChildProcess(true) // Should fail
        }
        if (command.includes('exit-immediately')) {
          return new MockChildProcess(false, true) // Should exit immediately
        }

        return new MockChildProcess() // Normal process
      },
    }
  }
  if (id === 'fs') {
    // Use real fs module for actual file checking
    return fs
  }
  if (id === '7zip-min') {
    return { unpack: () => {} }
  }
  return originalRequire.call(this, id)
}

// Import the module
const comfyUIInstaller = await import('../../comfyUIInstaller.js')

console.log('ğŸ§ª å¼€å§‹è¿è¡Œ ComfyUI é™é»˜å¯åŠ¨å’Œè¿›ç¨‹ç®¡ç†æµ‹è¯•...\n')

// Test 0: æ£€æŸ¥çœŸå®æ–‡ä»¶ç»“æ„
console.log('ğŸ“ æµ‹è¯• 0: æ£€æŸ¥çœŸå®æ–‡ä»¶ç»“æ„')
try {
  const comfyUIDir = path.join(realUserDataDir, 'comfyui')
  console.log(`ComfyUIç›®å½•: ${comfyUIDir}`)

  if (fs.existsSync(comfyUIDir)) {
    console.log('âœ… ComfyUIç›®å½•å­˜åœ¨')

    // æŸ¥æ‰¾ä¸»ç›®å½•
    const mainDir = comfyUIInstaller.findComfyUIMainDir(comfyUIDir)
    if (mainDir) {
      console.log(`âœ… æ‰¾åˆ°ä¸»ç›®å½•: ${mainDir}`)

      // åˆ—å‡ºæ‰€æœ‰batæ–‡ä»¶
      const files = fs.readdirSync(mainDir)
      const batFiles = files.filter((file) => file.endsWith('.bat'))
      console.log(`âœ… æ‰¾åˆ°çš„å¯åŠ¨è„šæœ¬: ${batFiles.join(', ')}`)

      // æŸ¥æ‰¾è¿è¡Œè„šæœ¬
      const runScript = comfyUIInstaller.findRunScript(mainDir)
      if (runScript) {
        console.log(`âœ… æ‰¾åˆ°è¿è¡Œè„šæœ¬: ${runScript}`)
      } else {
        console.log('âŒ æœªæ‰¾åˆ°è¿è¡Œè„šæœ¬')
      }
    } else {
      console.log('âŒ æœªæ‰¾åˆ°ComfyUIä¸»ç›®å½•')
    }
  } else {
    console.log('âŒ ComfyUIç›®å½•ä¸å­˜åœ¨')
  }
} catch (error) {
  console.log('âŒ æ–‡ä»¶ç»“æ„æ£€æŸ¥å¤±è´¥:', error.message)
}

console.log()

// Test 1: GPUæ£€æµ‹æµ‹è¯•
console.log('ğŸ® æµ‹è¯• 1: GPUæ£€æµ‹åŠŸèƒ½')
try {
  console.log('æ­£åœ¨æ£€æµ‹NVIDIA GPU...')
  const hasGPU = await comfyUIInstaller.detectNvidiaGPU()
  console.log(
    `âœ… GPUæ£€æµ‹ç»“æœ: ${hasGPU ? 'æ£€æµ‹åˆ°NVIDIA GPU' : 'æœªæ£€æµ‹åˆ°NVIDIA GPU'}`
  )
} catch (error) {
  console.log('âŒ GPUæ£€æµ‹å¤±è´¥:', error.message)
}

console.log()

// Test 2: æ™ºèƒ½è„šæœ¬é€‰æ‹©æµ‹è¯•
console.log('ğŸ§  æµ‹è¯• 2: æ™ºèƒ½è„šæœ¬é€‰æ‹©')
try {
  const comfyUIDir = path.join(realUserDataDir, 'comfyui')
  const mainDir = comfyUIInstaller.findComfyUIMainDir(comfyUIDir)

  if (mainDir) {
    console.log('æ­£åœ¨é€‰æ‹©æœ€ä½³å¯åŠ¨è„šæœ¬...')
    const { script, mode } = await comfyUIInstaller.getPreferredStartupScript(
      mainDir
    )
    console.log(`âœ… è„šæœ¬é€‰æ‹©æˆåŠŸ:`)
    console.log(`   è„šæœ¬è·¯å¾„: ${script}`)
    console.log(`   è¿è¡Œæ¨¡å¼: ${mode}`)
    console.log(`   è„šæœ¬åç§°: ${path.basename(script)}`)
  } else {
    console.log('âŒ æ— æ³•æ‰¾åˆ°ComfyUIä¸»ç›®å½•')
  }
} catch (error) {
  console.log('âŒ è„šæœ¬é€‰æ‹©å¤±è´¥:', error.message)
}

console.log()

// Test 3: æ£€æŸ¥ComfyUIæ˜¯å¦å·²å®‰è£…
console.log('ğŸ“‹ æµ‹è¯• 3: æ£€æŸ¥ComfyUIå®‰è£…çŠ¶æ€')
try {
  const isInstalled = comfyUIInstaller.isComfyUIInstalled()
  if (isInstalled) {
    console.log('âœ… ComfyUIå®‰è£…çŠ¶æ€æ£€æŸ¥é€šè¿‡ - å·²å®‰è£…')
  } else {
    console.log('âŒ ComfyUIå®‰è£…çŠ¶æ€æ£€æŸ¥å¤±è´¥ - æœªå®‰è£…')
  }
} catch (error) {
  console.log('âŒ å®‰è£…çŠ¶æ€æ£€æŸ¥å¤±è´¥:', error.message)
}

console.log()

// Test 4: è·å–åˆå§‹è¿›ç¨‹çŠ¶æ€
console.log('ğŸ” æµ‹è¯• 4: è·å–è¿›ç¨‹çŠ¶æ€')
try {
  const initialStatus = comfyUIInstaller.getComfyUIProcessStatus()
  console.log('âœ… è·å–è¿›ç¨‹çŠ¶æ€æˆåŠŸ:')
  console.log(`   è¿è¡ŒçŠ¶æ€: ${initialStatus.running}`)
  console.log(`   è¿›ç¨‹ID: ${initialStatus.pid || 'N/A'}`)

  const isRunning = comfyUIInstaller.isComfyUIProcessRunning()
  console.log(`   è¿è¡Œæ£€æŸ¥: ${isRunning}`)
} catch (error) {
  console.log('âŒ è·å–è¿›ç¨‹çŠ¶æ€å¤±è´¥:', error.message)
}

console.log()

// Test 5: é™é»˜å¯åŠ¨ComfyUIè¿›ç¨‹
console.log('ğŸ”‡ æµ‹è¯• 5: é™é»˜å¯åŠ¨ComfyUIè¿›ç¨‹ (æ— CMDå¼¹çª—)')
try {
  console.log('æ­£åœ¨é™é»˜å¯åŠ¨ComfyUIè¿›ç¨‹...')
  console.log('âš ï¸  æ³¨æ„ï¼šåº”è¯¥ä¸ä¼šçœ‹åˆ°CMDçª—å£å¼¹å‡º')

  const startResult = await comfyUIInstaller.startComfyUIProcess()

  if (startResult.success) {
    console.log('âœ… ComfyUIé™é»˜å¯åŠ¨æˆåŠŸ:')
    console.log(`   æ¶ˆæ¯: ${startResult.message}`)
    console.log(`   æ¨¡å¼: ${startResult.mode}`)
    console.log('âœ… ç¡®è®¤ï¼šæ²¡æœ‰CMDçª—å£å¼¹å‡º')

    // æ£€æŸ¥å¯åŠ¨åçš„çŠ¶æ€
    const statusAfterStart = comfyUIInstaller.getComfyUIProcessStatus()
    console.log(
      `   å¯åŠ¨åçŠ¶æ€: è¿è¡Œ=${statusAfterStart.running}, PID=${statusAfterStart.pid}`
    )
  } else {
    console.log('âŒ ComfyUIå¯åŠ¨å¤±è´¥:')
    console.log(`   æ¶ˆæ¯: ${startResult.message}`)
  }
} catch (error) {
  console.log('âŒ å¯åŠ¨ComfyUIè¿›ç¨‹å¤±è´¥:', error.message)
}

console.log()

// Test 6: é‡å¤å¯åŠ¨æµ‹è¯•
console.log('ğŸ”„ æµ‹è¯• 6: é‡å¤å¯åŠ¨æ£€æŸ¥')
try {
  console.log('å°è¯•é‡å¤å¯åŠ¨ComfyUI...')
  const duplicateStartResult = await comfyUIInstaller.startComfyUIProcess()

  if (
    !duplicateStartResult.success &&
    duplicateStartResult.message.includes('already running')
  ) {
    console.log('âœ… é‡å¤å¯åŠ¨æ£€æŸ¥é€šè¿‡ - æ­£ç¡®é˜»æ­¢äº†é‡å¤å¯åŠ¨')
    console.log(`   æ¶ˆæ¯: ${duplicateStartResult.message}`)
  } else {
    console.log('âŒ é‡å¤å¯åŠ¨æ£€æŸ¥å¤±è´¥ - åº”è¯¥é˜»æ­¢é‡å¤å¯åŠ¨')
  }
} catch (error) {
  console.log('âŒ é‡å¤å¯åŠ¨æ£€æŸ¥å¤±è´¥:', error.message)
}

console.log()

// ç­‰å¾…ä¸€æ®µæ—¶é—´ç¡®ä¿è¿›ç¨‹ç¨³å®šè¿è¡Œ
console.log('â³ ç­‰å¾…è¿›ç¨‹ç¨³å®šè¿è¡Œ...')
await new Promise((resolve) => setTimeout(resolve, 2000))

// Test 7: æ”¹è¿›çš„è¿›ç¨‹åœæ­¢æµ‹è¯•
console.log('ğŸ›‘ æµ‹è¯• 7: æ”¹è¿›çš„è¿›ç¨‹åœæ­¢åŠŸèƒ½')
try {
  console.log('æ­£åœ¨ä½¿ç”¨æ”¹è¿›çš„åœæ­¢æ–¹æ³•åœæ­¢ComfyUIè¿›ç¨‹...')
  console.log('âš ï¸  Windowsç³»ç»Ÿå°†ä½¿ç”¨taskkillå‘½ä»¤è¿›è¡Œå¯é çš„è¿›ç¨‹ç»ˆæ­¢')

  const stopResult = await comfyUIInstaller.stopComfyUIProcess()

  if (stopResult.success) {
    console.log('âœ… ComfyUIåœæ­¢æˆåŠŸ:')
    console.log(`   æ¶ˆæ¯: ${stopResult.message}`)
    console.log('âœ… ç¡®è®¤ï¼šè¿›ç¨‹åº”è¯¥å·²ç»å®Œå…¨ç»ˆæ­¢')

    // æ£€æŸ¥åœæ­¢åçš„çŠ¶æ€
    const statusAfterStop = comfyUIInstaller.getComfyUIProcessStatus()
    console.log(
      `   åœæ­¢åçŠ¶æ€: è¿è¡Œ=${statusAfterStop.running}, PID=${statusAfterStop.pid}`
    )

    // éªŒè¯è¿›ç¨‹ç¡®å®å·²åœæ­¢
    if (!statusAfterStop.running) {
      console.log('âœ… è¿›ç¨‹ç»ˆæ­¢éªŒè¯æˆåŠŸ')
    } else {
      console.log('âŒ è­¦å‘Šï¼šè¿›ç¨‹å¯èƒ½ä»åœ¨è¿è¡Œ')
    }
  } else {
    console.log('âŒ ComfyUIåœæ­¢å¤±è´¥:')
    console.log(`   æ¶ˆæ¯: ${stopResult.message}`)
  }
} catch (error) {
  console.log('âŒ åœæ­¢ComfyUIè¿›ç¨‹å¤±è´¥:', error.message)
}

console.log()

// Test 8: åœæ­¢åé‡æ–°å¯åŠ¨æµ‹è¯•
console.log('ğŸ”„ æµ‹è¯• 8: åœæ­¢åé‡æ–°å¯åŠ¨æµ‹è¯•')
try {
  console.log('ç­‰å¾…2ç§’åå°è¯•é‡æ–°å¯åŠ¨...')
  await new Promise((resolve) => setTimeout(resolve, 2000))

  console.log('æ­£åœ¨é‡æ–°å¯åŠ¨ComfyUI...')
  const restartResult = await comfyUIInstaller.startComfyUIProcess()

  if (restartResult.success) {
    console.log('âœ… é‡æ–°å¯åŠ¨æˆåŠŸ:')
    console.log(`   æ¶ˆæ¯: ${restartResult.message}`)
    console.log(`   æ¨¡å¼: ${restartResult.mode}`)

    // ç«‹å³åœæ­¢ä»¥æ¸…ç†
    await new Promise((resolve) => setTimeout(resolve, 1000))
    const finalStop = await comfyUIInstaller.stopComfyUIProcess()
    console.log(`âœ… æœ€ç»ˆæ¸…ç†: ${finalStop.success ? 'æˆåŠŸ' : 'å¤±è´¥'}`)
  } else {
    console.log('âŒ é‡æ–°å¯åŠ¨å¤±è´¥:')
    console.log(`   æ¶ˆæ¯: ${restartResult.message}`)
  }
} catch (error) {
  console.log('âŒ é‡æ–°å¯åŠ¨æµ‹è¯•å¤±è´¥:', error.message)
}

console.log('\nğŸ‰ ComfyUI é™é»˜å¯åŠ¨å’Œè¿›ç¨‹ç®¡ç†æµ‹è¯•å®Œæˆï¼')

// Test Summary
console.log('\nğŸ“‹ æµ‹è¯•æ€»ç»“:')
console.log('- âœ… æ–‡ä»¶ç»“æ„æ£€æŸ¥')
console.log('- âœ… GPUæ£€æµ‹åŠŸèƒ½')
console.log('- âœ… æ™ºèƒ½è„šæœ¬é€‰æ‹©')
console.log('- âœ… å®‰è£…çŠ¶æ€æ£€æŸ¥')
console.log('- âœ… è¿›ç¨‹çŠ¶æ€ç®¡ç†')
console.log('- âœ… é™é»˜å¯åŠ¨åŠŸèƒ½ (æ— CMDå¼¹çª—)')
console.log('- âœ… é‡å¤å¯åŠ¨é˜²æŠ¤')
console.log('- âœ… æ”¹è¿›çš„è¿›ç¨‹åœæ­¢åŠŸèƒ½')
console.log('- âœ… åœæ­¢åé‡æ–°å¯åŠ¨æµ‹è¯•')

console.log('\nğŸ”§ ä¿®å¤çš„é—®é¢˜:')
console.log('1. ğŸ”‡ é™é»˜è¿è¡Œï¼šæ·»åŠ windowsHideé€‰é¡¹ï¼Œé¿å…CMDå¼¹çª—')
console.log('2. ğŸ›‘ å¯é åœæ­¢ï¼šä½¿ç”¨taskkillå‘½ä»¤ç¡®ä¿è¿›ç¨‹å®Œå…¨ç»ˆæ­¢')
console.log('3. ğŸ”„ çŠ¶æ€ç®¡ç†ï¼šæ”¹è¿›è¿›ç¨‹çŠ¶æ€æ£€æŸ¥å’Œæ¸…ç†é€»è¾‘')
console.log('4. ğŸ›¡ï¸ é”™è¯¯å¤„ç†ï¼šå¢å¼ºé”™è¯¯å¤„ç†å’Œå›é€€æœºåˆ¶')

console.log('\nğŸ’¡ æ–°åŠŸèƒ½ç‰¹ç‚¹:')
console.log('1. ğŸ® è‡ªåŠ¨æ£€æµ‹NVIDIA GPUæ”¯æŒ')
console.log('2. ğŸ§  æ™ºèƒ½é€‰æ‹©æœ€ä½³å¯åŠ¨è„šæœ¬')
console.log('3. ğŸ”‡ å®Œå…¨é™é»˜è¿è¡Œï¼Œæ— ä»»ä½•å¼¹çª—')
console.log('4. ğŸ›‘ å¯é çš„è¿›ç¨‹ç»ˆæ­¢æœºåˆ¶')
console.log('5. ğŸ“Š è¯¦ç»†çš„å¯åŠ¨æ¨¡å¼ä¿¡æ¯')

console.log('\nğŸš€ ä½¿ç”¨å»ºè®®:')
console.log('- é¦–æ¬¡å¯ç”¨ç°åœ¨åº”è¯¥èƒ½æ­£å¸¸å·¥ä½œ')
console.log('- è¿›ç¨‹å¯ä»¥å®Œå…¨ç»ˆæ­¢ï¼Œä¸ä¼šæ®‹ç•™')
console.log('- è¿è¡Œè¿‡ç¨‹ä¸­ä¸ä¼šæœ‰CMDçª—å£å¹²æ‰°')
console.log('- æ”¯æŒGPU/CPUæ¨¡å¼è‡ªåŠ¨é€‰æ‹©')



================================================
FILE: react/README.md
================================================
# React + TypeScript + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react/README.md) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## Expanding the ESLint configuration

If you are developing a production application, we recommend updating the configuration to enable type-aware lint rules:

```js
export default tseslint.config({
  extends: [
    // Remove ...tseslint.configs.recommended and replace with this
    ...tseslint.configs.recommendedTypeChecked,
    // Alternatively, use this for stricter rules
    ...tseslint.configs.strictTypeChecked,
    // Optionally, add this for stylistic rules
    ...tseslint.configs.stylisticTypeChecked,
  ],
  languageOptions: {
    // other options...
    parserOptions: {
      project: ['./tsconfig.node.json', './tsconfig.app.json'],
      tsconfigRootDir: import.meta.dirname,
    },
  },
})
```

You can also install [eslint-plugin-react-x](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x) and [eslint-plugin-react-dom](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-dom) for React-specific lint rules:

```js
// eslint.config.js
import reactX from 'eslint-plugin-react-x'
import reactDom from 'eslint-plugin-react-dom'

export default tseslint.config({
  plugins: {
    // Add the react-x and react-dom plugins
    'react-x': reactX,
    'react-dom': reactDom,
  },
  rules: {
    // other rules...
    // Enable its recommended typescript rules
    ...reactX.configs['recommended-typescript'].rules,
    ...reactDom.configs.recommended.rules,
  },
})
```



================================================
FILE: react/components.json
================================================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "src/index.css",
    "baseColor": "zinc",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}


================================================
FILE: react/eslint.config.js
================================================
import js from '@eslint/js'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import globals from 'globals'
import tseslint from 'typescript-eslint'

export default tseslint.config(
  { ignores: ['dist'] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      '@typescript-eslint/no-unused-vars': 'off',
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  }
)



================================================
FILE: react/index.html
================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/png" href="/jaaz.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script
      defer
      src="https://cloud.umami.is/script.js"
      data-website-id="5ab5a63b-de69-4714-8ba8-7bdf88c4aa94"
    ></script>
    <title>Jaaz</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>



================================================
FILE: react/package.json
================================================
{
  "name": "@jaaz/agent-ui",
  "version": "0.0.0",
  "type": "module",
  "main": "dist/index.es.js",
  "module": "dist/index.es.js",
  "types": "dist/index.d.ts",
  "exports": {
    ".": {
      "import": "./dist/index.es.js",
      "types": "./dist/index.d.ts"
    },
    "./styles": "./dist/agent-ui.css"
  },
  "files": [
    "dist"
  ],
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "build:lib": "vite build --mode lib && cp src/index.d.ts dist/index.d.ts",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@excalidraw/excalidraw": "^0.18.0",
    "@mdxeditor/editor": "^3.32.2",
    "@radix-ui/react-avatar": "^1.1.10",
    "@radix-ui/react-checkbox": "^1.3.1",
    "@radix-ui/react-context-menu": "^2.2.14",
    "@radix-ui/react-dialog": "^1.1.6",
    "@radix-ui/react-dropdown-menu": "^2.1.14",
    "@radix-ui/react-label": "^2.1.2",
    "@radix-ui/react-popover": "^1.1.14",
    "@radix-ui/react-scroll-area": "^1.2.3",
    "@radix-ui/react-select": "^2.1.6",
    "@radix-ui/react-separator": "^1.1.2",
    "@radix-ui/react-slot": "^1.1.2",
    "@radix-ui/react-switch": "^1.1.2",
    "@radix-ui/react-tooltip": "^1.1.8",
    "@tabler/icons-react": "^3.31.0",
    "@tailwindcss/vite": "^4.0.17",
    "@tanstack/query-async-storage-persister": "^5.81.5",
    "@tanstack/react-query": "^5.80.3",
    "@tanstack/react-query-persist-client": "^5.81.5",
    "@tanstack/react-router": "^1.120.15",
    "@tanstack/react-router-devtools": "^1.120.15",
    "@xyflow/react": "^12.7.0",
    "ahooks": "^3.8.5",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "file-saver": "^2.0.5",
    "i18next": "^25.2.1",
    "i18next-browser-languagedetector": "^8.1.0",
    "idb": "^8.0.3",
    "immer": "^10.1.1",
    "jszip": "^3.10.1",
    "lodash.debounce": "^4.0.8",
    "lucide-react": "^0.484.0",
    "mitt": "^3.0.1",
    "motion": "^12.16.0",
    "nanoid": "^5.1.5",
    "next-themes": "^0.4.6",
    "openai": "^4.98.0",
    "posthog-js": "^1.257.1",
    "rc-textarea": "^1.10.0",
    "react": "^19.1.0",
    "react-dom": "^19.1.0",
    "react-i18next": "^15.5.2",
    "react-markdown": "^10.1.0",
    "react-markdown-editor-lite": "^1.3.4",
    "react-photo-view": "^1.2.7",
    "react-resizable-panels": "^3.0.2",
    "remark-gfm": "^4.0.1",
    "socket.io-client": "^4.8.1",
    "sonner": "^2.0.3",
    "tailwind-merge": "^3.0.2",
    "tailwindcss": "^4.0.17",
    "tldraw": "^3.13.1",
    "tw-animate-css": "^1.2.4",
    "zustand": "^5.0.5"
  },
  "devDependencies": {
    "@eslint/js": "^9.21.0",
    "@tanstack/router-plugin": "^1.120.15",
    "@types/file-saver": "^2.0.7",
    "@types/lodash.debounce": "^4.0.9",
    "@types/node": "^22.13.13",
    "@types/react": "^19.0.10",
    "@types/react-dom": "^19.0.4",
    "@vitejs/plugin-react": "^4.3.4",
    "eslint": "^9.21.0",
    "eslint-plugin-react-hooks": "^5.1.0",
    "eslint-plugin-react-refresh": "^0.4.19",
    "globals": "^15.15.0",
    "prettier": "^3.3.2",
    "typescript": "~5.7.2",
    "typescript-eslint": "^8.24.1",
    "vite": "^6.2.0"
  }
}



================================================
FILE: react/tsconfig.app.json
================================================
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": ["ES2023", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    // "noUnusedLocals": true,
    // "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true,

    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["src"]
}



================================================
FILE: react/tsconfig.json
================================================
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ],
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}



================================================
FILE: react/tsconfig.lib.json
================================================
{
  "extends": "./tsconfig.app.json",
  "compilerOptions": {
    "noEmit": false,
    "declaration": true,
    "emitDeclarationOnly": true,
    "outDir": "./dist",
    "rootDir": "./src"
  },
  "include": ["src/index.ts", "src/**/*"],
  "exclude": [
    "src/**/*.test.ts",
    "src/**/*.test.tsx",
    "src/**/*.spec.ts",
    "src/**/*.spec.tsx",
    "src/route-tree.gen.ts"
  ]
}



================================================
FILE: react/tsconfig.node.json
================================================
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}



================================================
FILE: react/vite.config.ts
================================================
import tailwindcss from '@tailwindcss/vite'
import { TanStackRouterVite } from '@tanstack/router-plugin/vite'
import react from '@vitejs/plugin-react'
import path from 'path'
import { defineConfig, UserConfig } from 'vite'

const PORT = 57988

// https://vite.dev/config/
export default defineConfig(({ mode }) => {
  const isLibMode = mode === 'lib'

  // Base configuration that applies to all environments
  const config: UserConfig = {
    plugins: [
      !isLibMode &&
        TanStackRouterVite({
          target: 'react',
          autoCodeSplitting: true,
          generatedRouteTree: 'src/route-tree.gen.ts',
        }),
      react(),
      tailwindcss(),
    ].filter(Boolean),
    resolve: {
      alias: {
        '@': path.resolve(__dirname, './src'),
      },
    },
    server: {
      port: 5174,
      proxy: {},
    },
  }

  // Library build configuration
  if (isLibMode) {
    config.build = {
      lib: {
        entry: path.resolve(__dirname, 'src/index.ts'),
        name: '@jaaz/agent-ui',
        fileName: (format: string) => `index.${format}.js`,
        formats: ['es'],
      },
      rollupOptions: {
        external: [
          'react',
          'react-dom',
          'react/jsx-runtime',
          '@tanstack/react-router',
          '@tanstack/react-query',
          'i18next',
          'react-i18next',
          'framer-motion',
          'motion',
          'lucide-react',
          'sonner',
          'zustand',
          'immer',
          'nanoid',
          'ahooks',
          'socket.io-client',
          'openai',
          'clsx',
          'tailwind-merge',
          'class-variance-authority',
          /@radix-ui\/.*/,
          /@tanstack\/.*/,
          /@excalidraw\/.*/,
          /@mdxeditor\/.*/,
        ],
        output: {
          globals: {
            react: 'React',
            'react-dom': 'ReactDOM',
            'react/jsx-runtime': 'react/jsx-runtime',
          },
        },
      },
    }
  }

  // Configure server based on environment
  if (mode === 'development') {
    config.server = config.server || {}
    config.server.proxy = {
      '/api': {
        target: `http://127.0.0.1:${PORT}`,
        changeOrigin: true,
        // Uncomment the following if you want to remove the /api prefix when forwarding to Flask
        // rewrite: (path) => path.replace(/^\/api/, '')
      },
      // Also proxy WebSocket connections
      '/ws': {
        target: `ws://127.0.0.1:${PORT}`,
        ws: true,
      },
    }
  }

  return config
})



================================================
FILE: react/src/App.tsx
================================================
// import InstallComfyUIDialog from '@/components/comfyui/InstallComfyUIDialog'
import UpdateNotificationDialog from '@/components/common/UpdateNotificationDialog'
import SettingsDialog from '@/components/settings/dialog'
import { LoginDialog } from '@/components/auth/LoginDialog'
import { ThemeProvider } from '@/components/theme/ThemeProvider'
import { ConfigsProvider } from '@/contexts/configs'
import { AuthProvider } from '@/contexts/AuthContext'
import { useTheme } from '@/hooks/use-theme'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { PersistQueryClientProvider } from '@tanstack/react-query-persist-client'
import { createAsyncStoragePersister } from '@tanstack/query-async-storage-persister'
import { openDB } from 'idb'
import { createRouter, RouterProvider } from '@tanstack/react-router'
import { useEffect } from 'react'
import { Toaster } from 'sonner'
import { routeTree } from './route-tree.gen'

import '@/assets/style/App.css'
import '@/i18n'

const router = createRouter({ routeTree })

declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router
  }
}

// åˆ›å»º IndexedDB è¿æ¥
const getDB = () =>
  openDB('react-query-db', 1, {
    upgrade(db) {
      if (!db.objectStoreNames.contains('cache')) {
        db.createObjectStore('cache')
      }
    },
  })

// åˆ›å»º IndexedDB æŒä¹…åŒ–å™¨
const persister = createAsyncStoragePersister({
  storage: {
    getItem: async (key: string) => {
      const db = await getDB()
      return (await db.get('cache', key)) || null
    },
    setItem: async (key: string, value: unknown) => {
      const db = await getDB()
      await db.put('cache', value, key)
    },
    removeItem: async (key: string) => {
      const db = await getDB()
      await db.delete('cache', key)
    },
  },
  key: 'react-query-cache',
})

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000,
      gcTime: 10 * 60 * 1000,
    },
  },
})

function App() {
  const { theme } = useTheme()

  // Auto-start ComfyUI on app startup
  useEffect(() => {
    const autoStartComfyUI = async () => {
      try {
        // Check if ComfyUI is installed
        const isInstalled = await window.electronAPI?.checkComfyUIInstalled()
        if (!isInstalled) {
          console.log('ComfyUI is not installed, skipping auto-start')
          return
        }

        // Start ComfyUI process
        console.log('Auto-starting ComfyUI...')
        const result = await window.electronAPI?.startComfyUIProcess()

        if (result?.success) {
          console.log('ComfyUI auto-started successfully:', result.message)
        } else {
          console.log('Failed to auto-start ComfyUI:', result?.message)
        }
      } catch (error) {
        console.error('Error during ComfyUI auto-start:', error)
      }
    }

    // Only run if electronAPI is available (in Electron environment)
    if (window.electronAPI) {
      autoStartComfyUI()
    }
  }, [])

  return (
    <ThemeProvider defaultTheme={theme} storageKey="vite-ui-theme">
      <PersistQueryClientProvider
        client={queryClient}
        persistOptions={{ persister }}
      >
        <AuthProvider>
          <ConfigsProvider>
            <div className="app-container">
              <RouterProvider router={router} />

              {/* Install ComfyUI Dialog */}
              {/* <InstallComfyUIDialog /> */}

              {/* Update Notification Dialog */}
              <UpdateNotificationDialog />

              {/* Settings Dialog */}
              <SettingsDialog />

              {/* Login Dialog */}
              <LoginDialog />
            </div>
          </ConfigsProvider>
        </AuthProvider>
      </PersistQueryClientProvider>
      <Toaster position="bottom-center" richColors />
    </ThemeProvider>
  )
}

export default App



================================================
FILE: react/src/constants.ts
================================================
import type { LLMConfig, ToolCallFunctionName } from '@/types/types'

// API Configuration
export const BASE_API_URL =
  import.meta.env.VITE_JAAZ_BASE_API_URL || 'https://jaaz.app'

export const PROVIDER_NAME_MAPPING: {
  [key: string]: { name: string; icon: string }
} = {
  jaaz: {
    name: 'Jaaz',
    icon: 'https://raw.githubusercontent.com/11cafe/jaaz/refs/heads/main/assets/icons/jaaz.png',
  },
  anthropic: {
    name: 'Claude',
    icon: 'https://registry.npmmirror.com/@lobehub/icons-static-png/latest/files/dark/claude-color.png',
  },
  openai: { name: 'OpenAI', icon: 'https://openai.com/favicon.ico' },
  replicate: {
    name: 'Replicate',
    icon: 'https://images.seeklogo.com/logo-png/61/1/replicate-icon-logo-png_seeklogo-611690.png',
  },
  ollama: {
    name: 'Ollama',
    icon: 'https://images.seeklogo.com/logo-png/59/1/ollama-logo-png_seeklogo-593420.png',
  },
  huggingface: {
    name: 'Hugging Face',
    icon: 'https://huggingface.co/favicon.ico',
  },
  wavespeed: {
    name: 'WaveSpeedAi',
    icon: 'https://www.wavespeed.ai/favicon.ico',
  },
  volces: {
    name: 'Volces',
    icon: 'https://portal.volccdn.com/obj/volcfe/misc/favicon.png',
  },
  comfyui: {
    name: 'ComfyUI',
    icon: 'https://framerusercontent.com/images/3cNQMWKzIhIrQ5KErBm7dSmbd2w.png',
  },
}

// Tool call name mapping
export const TOOL_CALL_NAME_MAPPING: { [key in ToolCallFunctionName]: string } =
  {
    generate_image: 'Generate Image',
    prompt_user_multi_choice: 'Prompt Multi-Choice',
    prompt_user_single_choice: 'Prompt Single-Choice',
    write_plan: 'Write Plan',
    finish: 'Finish',
  }

export const LOGO_URL = 'https://jaaz.app/favicon.ico'

export const DEFAULT_SYSTEM_PROMPT = `You are a professional art design agent. You can write very professional image prompts to generate aesthetically pleasing images that best fulfilling and matching the user's request.
Step 1. write a design strategy plan. Write in the same language as the user's inital first prompt.

Example Design Strategy Doc:
Design Proposal for â€œMUSE MODULAR â€“ Future of Identityâ€ Cover
â€¢ Recommended resolution: 1024 Ã— 1536 px (portrait) â€“ optimal for a standard magazine trim while preserving detail for holographic accents.

â€¢ Style & Mood
â€“ High-contrast grayscale base evoking timeless editorial sophistication.
â€“ Holographic iridescence selectively applied (cyan â†’ violet â†’ lime) for mask edges, title glyphs and micro-glitches, signalling futurism and fluid identity.
â€“ Atmosphere: enigmatic, cerebral, slightly unsettling yet glamorous.

â€¢ Key Visual Element
â€“ Central androgynous model, shoulders-up, lit with soft frontal key and twin rim lights.
â€“ A translucent polygonal AR mask overlays the face; within it, three offset â€œghostâ€ facial layers (different eyes, nose, mouth) hint at multiple personas.
â€“ Subtle pixel sorting/glitch streaks emanate from mask edges, blending into background grid.

â€¢ Composition & Layout

Masthead â€œMUSE MODULARâ€ across the top, extra-condensed modular sans serif; characters constructed from repeating geometric units. Spot UV + holo foil.
Tagline â€œWho are you today?â€ centered beneath masthead in ultra-light italic.
Subjectâ€™s gaze directly engages reader; head breaks the baseline of the masthead for depth.
Bottom left kicker â€œFuture of Identity Issueâ€ in tiny monospaced capitals.
Discreet modular grid lines and data glyphs fade into matte charcoal background, preserving negative space.
â€¢ Color Palette
#000000, #1a1a1a, #4d4d4d, #d9d9d9 + holographic gradient (#00eaff, #c400ff, #38ffab).

â€¢ Typography
â€“ Masthead: custom variable sans with removable modules.
â€“ Tagline: thin italic grotesque.
â€“ Secondary copy: 10 pt monospaced to reference code.

â€¢ Print Finishing
â€“ Soft-touch matte laminate overall.
â€“ Spot UV + holographic foil on masthead, mask outline and glitch shards.

Step 2. Call generate_image tool to generate the image based on the plan immediately, use a detailed and professional image prompt according to your design strategy plan, no need to ask for user's approval.
`



================================================
FILE: react/src/index.d.ts
================================================
import { ReactNode, Dispatch, SetStateAction } from 'react'

// Types
export interface Session {
  id: string
  title: string
  created_at: string
  updated_at: string
  model: string
  provider: string
}

export interface Message {
  role: 'user' | 'assistant' | 'system' | 'tool'
  content: string | any[]
  tool_calls?: any[]
  tool_call_id?: string
}

export interface Model {
  provider: string
  model: string
}

export interface ChatInterfaceProps {
  canvasId: string
  sessionList: Session[]
  setSessionList: Dispatch<SetStateAction<Session[]>>
  sessionId: string
}

export interface ButtonProps {
  children: ReactNode
  variant?:
    | 'default'
    | 'destructive'
    | 'outline'
    | 'secondary'
    | 'ghost'
    | 'link'
  size?: 'default' | 'xs' | 'sm' | 'lg' | 'icon'
  className?: string
  onClick?: () => void
  disabled?: boolean
  asChild?: boolean
}

// Chat Components
export declare const ChatInterface: React.FC<ChatInterfaceProps>
export declare const ChatTextarea: React.FC<any>
export declare const ChatHistory: React.FC<any>
export declare const ChatMagicGenerator: React.FC<any>
export declare const ModelSelector: React.FC<any>
export declare const ModelSelectorV2: React.FC<any>
export declare const SessionSelector: React.FC<any>
export declare const ChatSpinner: React.FC<any>

// UI Components
export declare const Button: React.FC<ButtonProps>
export declare const Input: React.FC<any>
export declare const Avatar: React.FC<any>
export declare const AvatarImage: React.FC<any>
export declare const AvatarFallback: React.FC<any>
export declare const Badge: React.FC<any>
export declare const Card: React.FC<any>
export declare const CardHeader: React.FC<any>
export declare const CardFooter: React.FC<any>
export declare const CardTitle: React.FC<any>
export declare const CardAction: React.FC<any>
export declare const CardDescription: React.FC<any>
export declare const CardContent: React.FC<any>
export declare const Skeleton: React.FC<any>
export declare const ShinyText: React.FC<any>
export declare const ScrollArea: React.FC<any>
export declare const Separator: React.FC<any>
export declare const Switch: React.FC<any>
export declare const Tooltip: React.FC<any>
export declare const TooltipContent: React.FC<any>
export declare const TooltipProvider: React.FC<any>
export declare const TooltipTrigger: React.FC<any>

// Dialog Components
export declare const Dialog: React.FC<any>
export declare const DialogClose: React.FC<any>
export declare const DialogContent: React.FC<any>
export declare const DialogDescription: React.FC<any>
export declare const DialogFooter: React.FC<any>
export declare const DialogHeader: React.FC<any>
export declare const DialogOverlay: React.FC<any>
export declare const DialogPortal: React.FC<any>
export declare const DialogTitle: React.FC<any>
export declare const DialogTrigger: React.FC<any>

// Contexts & Hooks
export declare const AuthProvider: React.FC<{ children: ReactNode }>
export declare const useAuth: () => any
export declare const ConfigsProvider: React.FC<{ children: ReactNode }>
export declare const useConfigs: () => any
export declare const useDebounce: (callback: any, delay: number) => any
export declare const useTheme: () => any

// Utils
export declare const cn: (...classes: any[]) => string
export declare const eventBus: any
export declare const formatDate: (date: string | Date) => string



================================================
FILE: react/src/index.ts
================================================
// Chat Components
export { default as ChatInterface } from './components/chat/Chat'
export { default as ChatTextarea } from './components/chat/ChatTextarea'
export { default as ChatHistory } from './components/chat/ChatHistory'
export { default as ChatMagicGenerator } from './components/chat/ChatMagicGenerator'
export { default as ModelSelector } from './components/chat/ModelSelector'
export { default as ModelSelectorV2 } from './components/chat/ModelSelectorV2'
export { default as SessionSelector } from './components/chat/SessionSelector'
export { default as ChatSpinner } from './components/chat/Spinner'

// UI Components
export { Button, buttonVariants } from './components/ui/button'
export { Input } from './components/ui/input'
export { Avatar, AvatarImage, AvatarFallback } from './components/ui/avatar'
export { Badge } from './components/ui/badge'
export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
} from './components/ui/card'
export { Skeleton } from './components/ui/skeleton'
export { default as ShinyText } from './components/ui/shiny-text'
export { ScrollArea } from './components/ui/scroll-area'
export { Separator } from './components/ui/separator'
export { Switch } from './components/ui/switch'
export {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from './components/ui/tooltip'
export {
  ResizableHandle,
  ResizablePanel,
  ResizablePanelGroup,
} from './components/ui/resizable'

// Dialog Components
export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
} from './components/ui/dialog'

// Dropdown Components
export {
  DropdownMenu,
  DropdownMenuPortal,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuLabel,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubTrigger,
  DropdownMenuSubContent,
} from './components/ui/dropdown-menu'

// Select Components
export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
} from './components/ui/select'

// Context Menu Components
export {
  ContextMenu,
  ContextMenuTrigger,
  ContextMenuContent,
  ContextMenuItem,
  ContextMenuCheckboxItem,
  ContextMenuRadioItem,
  ContextMenuLabel,
  ContextMenuSeparator,
  ContextMenuShortcut,
  ContextMenuGroup,
  ContextMenuPortal,
  ContextMenuSub,
  ContextMenuSubContent,
  ContextMenuSubTrigger,
  ContextMenuRadioGroup,
} from './components/ui/context-menu'

// Sheet Components
export {
  Sheet,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
} from './components/ui/sheet'

// Sidebar Components
export {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarInput,
  SidebarInset,
  SidebarMenu,
  SidebarMenuAction,
  SidebarMenuBadge,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarMenuSkeleton,
  SidebarMenuSub,
  SidebarMenuSubButton,
  SidebarMenuSubItem,
  SidebarProvider,
  SidebarRail,
  SidebarSeparator,
  SidebarTrigger,
  useSidebar,
} from './components/ui/sidebar'

// Auth Components
export { LoginDialog } from './components/auth/LoginDialog'
export { UserMenu } from './components/auth/UserMenu'

// Common Components
export { default as Blur } from './components/common/Blur'
export { default as ErrorBoundary } from './components/common/ErrorBoundary'

// Theme Components
export { default as ThemeButton } from './components/theme/ThemeButton'
export { ThemeProvider } from './components/theme/ThemeProvider'

// Types
export type {
  Message,
  MessageContent,
  Model,
  Session,
  ChatSession,
  AssistantMessage,
  PendingType,
} from './types/types'

// Contexts
export { AuthProvider, useAuth } from './contexts/AuthContext'
export { ConfigsProvider, useConfigs } from './contexts/configs'
export { CanvasProvider, useCanvas } from './contexts/canvas'

// Hooks
export { useBalance } from './hooks/use-balance'
export { default as useDebounce } from './hooks/use-debounce'
export { useLanguage } from './hooks/use-language'
export { useTheme } from './hooks/use-theme'

// Utils
export { cn } from './lib/utils'
export { eventBus } from './lib/event'
export { formatDate } from './utils/formatDate'
export { compressImageFile, processImageFiles } from './utils/imageUtils'
export { readPNGMetadata, isPNGFile } from './utils/pngMetadata'

// API
export { sendMessages } from './api/chat'
export { uploadImage } from './api/upload'
export { listModels } from './api/model'
export type { ModelInfo, ToolInfo } from './api/model'
export { getCanvas, createCanvas, renameCanvas } from './api/canvas'



================================================
FILE: react/src/main.tsx
================================================
import { SocketProvider } from '@/contexts/socket'
import { StrictMode } from 'react'
import ReactDOM from 'react-dom/client'
import App from './App'
import { PostHogProvider } from 'posthog-js/react'
import '@/assets/style/index.css'

const options = {
  api_host: import.meta.env.VITE_PUBLIC_POSTHOG_HOST,
}

const rootElement = document.getElementById('root')!
if (!rootElement.innerHTML) {
  const root = ReactDOM.createRoot(rootElement)
  root.render(
    <StrictMode>
      <PostHogProvider apiKey={import.meta.env.VITE_PUBLIC_POSTHOG_KEY} options={options}>
        <SocketProvider>
          <App />
        </SocketProvider>
      </PostHogProvider>
    </StrictMode>
  )
}



================================================
FILE: react/src/route-tree.gen.ts
================================================
/* eslint-disable */

// @ts-nocheck

// noinspection JSUnusedGlobalSymbols

// This file was automatically generated by TanStack Router.
// You should NOT make any changes in this file as it will be overwritten.
// Additionally, you should also exclude this file from your linter and/or formatter to prevent it from being checked or modified.

import { Route as rootRouteImport } from './routes/__root'
import { Route as KnowledgeRouteImport } from './routes/knowledge'
import { Route as AssetsRouteImport } from './routes/assets'
import { Route as Agent_studioRouteImport } from './routes/agent_studio'
import { Route as IndexRouteImport } from './routes/index'
import { Route as CanvasIdRouteImport } from './routes/canvas.$id'

const KnowledgeRoute = KnowledgeRouteImport.update({
  id: '/knowledge',
  path: '/knowledge',
  getParentRoute: () => rootRouteImport,
} as any)
const AssetsRoute = AssetsRouteImport.update({
  id: '/assets',
  path: '/assets',
  getParentRoute: () => rootRouteImport,
} as any)
const Agent_studioRoute = Agent_studioRouteImport.update({
  id: '/agent_studio',
  path: '/agent_studio',
  getParentRoute: () => rootRouteImport,
} as any)
const IndexRoute = IndexRouteImport.update({
  id: '/',
  path: '/',
  getParentRoute: () => rootRouteImport,
} as any)
const CanvasIdRoute = CanvasIdRouteImport.update({
  id: '/canvas/$id',
  path: '/canvas/$id',
  getParentRoute: () => rootRouteImport,
} as any)

export interface FileRoutesByFullPath {
  '/': typeof IndexRoute
  '/agent_studio': typeof Agent_studioRoute
  '/assets': typeof AssetsRoute
  '/knowledge': typeof KnowledgeRoute
  '/canvas/$id': typeof CanvasIdRoute
}
export interface FileRoutesByTo {
  '/': typeof IndexRoute
  '/agent_studio': typeof Agent_studioRoute
  '/assets': typeof AssetsRoute
  '/knowledge': typeof KnowledgeRoute
  '/canvas/$id': typeof CanvasIdRoute
}
export interface FileRoutesById {
  __root__: typeof rootRouteImport
  '/': typeof IndexRoute
  '/agent_studio': typeof Agent_studioRoute
  '/assets': typeof AssetsRoute
  '/knowledge': typeof KnowledgeRoute
  '/canvas/$id': typeof CanvasIdRoute
}
export interface FileRouteTypes {
  fileRoutesByFullPath: FileRoutesByFullPath
  fullPaths: '/' | '/agent_studio' | '/assets' | '/knowledge' | '/canvas/$id'
  fileRoutesByTo: FileRoutesByTo
  to: '/' | '/agent_studio' | '/assets' | '/knowledge' | '/canvas/$id'
  id:
    | '__root__'
    | '/'
    | '/agent_studio'
    | '/assets'
    | '/knowledge'
    | '/canvas/$id'
  fileRoutesById: FileRoutesById
}
export interface RootRouteChildren {
  IndexRoute: typeof IndexRoute
  Agent_studioRoute: typeof Agent_studioRoute
  AssetsRoute: typeof AssetsRoute
  KnowledgeRoute: typeof KnowledgeRoute
  CanvasIdRoute: typeof CanvasIdRoute
}

declare module '@tanstack/react-router' {
  interface FileRoutesByPath {
    '/knowledge': {
      id: '/knowledge'
      path: '/knowledge'
      fullPath: '/knowledge'
      preLoaderRoute: typeof KnowledgeRouteImport
      parentRoute: typeof rootRouteImport
    }
    '/assets': {
      id: '/assets'
      path: '/assets'
      fullPath: '/assets'
      preLoaderRoute: typeof AssetsRouteImport
      parentRoute: typeof rootRouteImport
    }
    '/agent_studio': {
      id: '/agent_studio'
      path: '/agent_studio'
      fullPath: '/agent_studio'
      preLoaderRoute: typeof Agent_studioRouteImport
      parentRoute: typeof rootRouteImport
    }
    '/': {
      id: '/'
      path: '/'
      fullPath: '/'
      preLoaderRoute: typeof IndexRouteImport
      parentRoute: typeof rootRouteImport
    }
    '/canvas/$id': {
      id: '/canvas/$id'
      path: '/canvas/$id'
      fullPath: '/canvas/$id'
      preLoaderRoute: typeof CanvasIdRouteImport
      parentRoute: typeof rootRouteImport
    }
  }
}

const rootRouteChildren: RootRouteChildren = {
  IndexRoute: IndexRoute,
  Agent_studioRoute: Agent_studioRoute,
  AssetsRoute: AssetsRoute,
  KnowledgeRoute: KnowledgeRoute,
  CanvasIdRoute: CanvasIdRoute,
}
export const routeTree = rootRouteImport
  ._addFileChildren(rootRouteChildren)
  ._addFileTypes<FileRouteTypes>()



================================================
FILE: react/src/vite-env.d.ts
================================================
/// <reference types="vite/client" />



================================================
FILE: react/src/api/auth.ts
================================================
import { BASE_API_URL } from '../constants'
import i18n from '../i18n'
import { clearJaazApiKey } from './config'

export interface AuthStatus {
  status: 'logged_out' | 'pending' | 'logged_in'
  is_logged_in: boolean
  user_info?: UserInfo
  tokenExpired?: boolean
}

export interface UserInfo {
  id: string
  username: string
  email: string
  image_url?: string
  provider?: string
  created_at?: string
  updated_at?: string
}

export interface DeviceAuthResponse {
  status: string
  code: string
  expires_at: string
  message: string
}

export interface DeviceAuthPollResponse {
  status: 'pending' | 'authorized' | 'expired' | 'error'
  message?: string
  token?: string
  user_info?: UserInfo
}

export interface ApiResponse {
  status: string
  message: string
}

export async function startDeviceAuth(): Promise<DeviceAuthResponse> {
  const response = await fetch(`${BASE_API_URL}/api/device/auth`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
  })

  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`)
  }

  const data = await response.json()

  // Open browser for user authentication using Electron API
  const authUrl = `${BASE_API_URL}/auth/device?code=${data.code}`

  // Check if we're in Electron environment
  if (window.electronAPI?.openBrowserUrl) {
    try {
      await window.electronAPI.openBrowserUrl(authUrl)
    } catch (error) {
      console.error('Failed to open browser via Electron:', error)
      // Fallback to window.open if Electron API fails
      window.open(authUrl, '_blank')
    }
  } else {
    // Fallback for web environment
    window.open(authUrl, '_blank')
  }

  return {
    status: data.status,
    code: data.code,
    expires_at: data.expires_at,
    message: i18n.t('common:auth.browserLoginMessage'),
  }
}

export async function pollDeviceAuth(
  deviceCode: string
): Promise<DeviceAuthPollResponse> {
  const response = await fetch(
    `${BASE_API_URL}/api/device/poll?code=${deviceCode}`
  )

  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`)
  }

  return await response.json()
}

export async function getAuthStatus(): Promise<AuthStatus> {
  // Get auth status from local storage
  const token = localStorage.getItem('jaaz_access_token')
  const userInfo = localStorage.getItem('jaaz_user_info')

  console.log('Getting auth status:', {
    hasToken: !!token,
    hasUserInfo: !!userInfo,
    userInfo: userInfo ? JSON.parse(userInfo) : null,
  })

  if (token && userInfo) {
    try {
      // Always try to refresh token when we have one
      const newToken = await refreshToken(token)

      // Save the new token
      localStorage.setItem('jaaz_access_token', newToken)
      console.log('Token refreshed successfully')

      const authStatus = {
        status: 'logged_in' as const,
        is_logged_in: true,
        user_info: JSON.parse(userInfo),
      }
      return authStatus
    } catch (error) {
      console.log('Token refresh failed:', error)

      // Only clear auth data if token is truly expired (401), not for network errors
      if (error instanceof Error && error.message === 'TOKEN_EXPIRED') {
        console.log('Token expired, clearing auth data')
        localStorage.removeItem('jaaz_access_token')
        localStorage.removeItem('jaaz_user_info')

        // Clear jaaz provider api_key
        try {
          await clearJaazApiKey()
        } catch (clearError) {
          console.error('Failed to clear jaaz api key:', clearError)
        }

        const loggedOutStatus = {
          status: 'logged_out' as const,
          is_logged_in: false,
          tokenExpired: true,
        }

        return loggedOutStatus
      } else {
        // Network error or other issues, keep user logged in with old token
        console.log(
          'Network error during token refresh, keeping user logged in with existing token'
        )
        const authStatus = {
          status: 'logged_in' as const,
          is_logged_in: true,
          user_info: JSON.parse(userInfo),
        }
        return authStatus
      }
    }
  }

  const loggedOutStatus = {
    status: 'logged_out' as const,
    is_logged_in: false,
  }
  console.log('Returning logged out status:', loggedOutStatus)
  return loggedOutStatus
}

export async function logout(): Promise<{ status: string; message: string }> {
  // Clear local storage
  localStorage.removeItem('jaaz_access_token')
  localStorage.removeItem('jaaz_user_info')

  // Clear jaaz provider api_key
  await clearJaazApiKey()

  return {
    status: 'success',
    message: i18n.t('common:auth.logoutSuccessMessage'),
  }
}

export async function getUserProfile(): Promise<UserInfo> {
  const userInfo = localStorage.getItem('jaaz_user_info')
  if (!userInfo) {
    throw new Error(i18n.t('common:auth.notLoggedIn'))
  }

  return JSON.parse(userInfo)
}

// Helper function to save auth data to local storage
export function saveAuthData(token: string, userInfo: UserInfo) {
  localStorage.setItem('jaaz_access_token', token)
  localStorage.setItem('jaaz_user_info', JSON.stringify(userInfo))
}

// Helper function to get access token
export function getAccessToken(): string | null {
  return localStorage.getItem('jaaz_access_token')
}

// Helper function to make authenticated API calls
export async function authenticatedFetch(
  url: string,
  options: RequestInit = {}
): Promise<Response> {
  const token = getAccessToken()

  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
    ...((options.headers as Record<string, string>) || {}),
  }

  if (token) {
    headers['Authorization'] = `Bearer ${token}`
  }

  return fetch(url, {
    ...options,
    headers,
  })
}

// åˆ·æ–°token
export async function refreshToken(currentToken: string) {
  const response = await fetch(`${BASE_API_URL}/api/device/refresh-token`, {
    method: 'GET',
    headers: {
      Authorization: `Bearer ${currentToken}`,
    },
  })

  if (response.status === 200) {
    const data = await response.json()
    return data.new_token
  } else if (response.status === 401) {
    // Token çœŸæ­£è¿‡æœŸï¼Œéœ€è¦é‡æ–°ç™»å½•
    throw new Error('TOKEN_EXPIRED')
  } else {
    // å…¶ä»–é”™è¯¯ï¼ˆç½‘ç»œé”™è¯¯ã€æœåŠ¡å™¨é”™è¯¯ç­‰ï¼‰ï¼Œä¸å¼ºåˆ¶é‡æ–°ç™»å½•
    throw new Error(`NETWORK_ERROR: ${response.status}`)
  }
}



================================================
FILE: react/src/api/billing.ts
================================================
import { BASE_API_URL } from '../constants'
import { authenticatedFetch } from './auth'

export interface BalanceResponse {
  balance: string
}

export async function getBalance(): Promise<BalanceResponse> {
  const response = await authenticatedFetch(
    `${BASE_API_URL}/api/billing/getBalance`
  )

  if (!response.ok) {
    throw new Error(`Failed to fetch balance: ${response.status}`)
  }

  return await response.json()
}



================================================
FILE: react/src/api/canvas.ts
================================================
import { CanvasData, Message, Session } from '@/types/types'
import { ToolInfo } from '@/api/model'

export type ListCanvasesResponse = {
  id: string
  name: string
  description?: string
  thumbnail?: string
  created_at: string
}

export async function listCanvases(): Promise<ListCanvasesResponse[]> {
  const response = await fetch('/api/canvas/list')
  return await response.json()
}

export async function createCanvas(data: {
  name: string
  canvas_id: string
  messages: Message[]
  session_id: string
  text_model: {
    provider: string
    model: string
    url: string
  }
  tool_list: ToolInfo[]

  system_prompt: string
}): Promise<{ id: string }> {
  const response = await fetch('/api/canvas/create', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data),
  })
  return await response.json()
}

export async function getCanvas(
  id: string
): Promise<{ data: CanvasData; name: string; sessions: Session[] }> {
  const response = await fetch(`/api/canvas/${id}`)
  return await response.json()
}

export async function saveCanvas(
  id: string,
  payload: {
    data: CanvasData
    thumbnail: string
  }
): Promise<void> {
  const response = await fetch(`/api/canvas/${id}/save`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload),
  })
  return await response.json()
}

export async function renameCanvas(id: string, name: string): Promise<void> {
  const response = await fetch(`/api/canvas/${id}/rename`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ name }),
  })
  return await response.json()
}

export async function deleteCanvas(id: string): Promise<void> {
  const response = await fetch(`/api/canvas/${id}/delete`, {
    method: 'DELETE',
  })
  return await response.json()
}



================================================
FILE: react/src/api/chat.ts
================================================
import { Message, Model } from '@/types/types'
import { ModelInfo, ToolInfo } from './model'

export const getChatSession = async (sessionId: string) => {
  const response = await fetch(`/api/chat_session/${sessionId}`)
  const data = await response.json()
  return data as Message[]
}

export const sendMessages = async (payload: {
  sessionId: string
  canvasId: string
  newMessages: Message[]
  textModel: Model
  toolList: ToolInfo[]
  systemPrompt: string | null
}) => {
  const response = await fetch(`/api/chat`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      messages: payload.newMessages,
      canvas_id: payload.canvasId,
      session_id: payload.sessionId,
      text_model: payload.textModel,
      tool_list: payload.toolList,
      system_prompt: payload.systemPrompt,
    }),
  })
  const data = await response.json()
  return data as Message[]
}

export const cancelChat = async (sessionId: string) => {
  const response = await fetch(`/api/cancel/${sessionId}`, {
    method: 'POST',
  })
  return await response.json()
}



================================================
FILE: react/src/api/config.ts
================================================
import { LLMConfig } from '@/types/types'

export async function getConfigExists(): Promise<{ exists: boolean }> {
  const response = await fetch('/api/config/exists')
  return await response.json()
}

export async function getConfig(): Promise<{ [key: string]: LLMConfig }> {
  const response = await fetch('/api/config')
  return await response.json()
}

export async function updateConfig(config: {
  [key: string]: LLMConfig
}): Promise<{ status: string; message: string }> {
  const response = await fetch('/api/config', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(config),
  })
  return await response.json()
}

// Update jaaz provider api_key after login
export async function updateJaazApiKey(token: string): Promise<void> {
  try {
    const config = await getConfig()

    if (config.jaaz) {
      config.jaaz.api_key = token
    }

    await updateConfig(config)
    console.log('Successfully updated jaaz provider api_key')
  } catch (error) {
    console.error('Error updating jaaz provider api_key:', error)
  }
}

// Clear jaaz provider api_key after logout
export async function clearJaazApiKey(): Promise<void> {
  try {
    const config = await getConfig()

    if (config.jaaz) {
      config.jaaz.api_key = ''
      await updateConfig(config)
      console.log('Successfully cleared jaaz provider api_key')
    }
  } catch (error) {
    console.error('Error clearing jaaz provider api_key:', error)
  }
}



================================================
FILE: react/src/api/knowledge.ts
================================================
import { BASE_API_URL } from '../constants'
import { authenticatedFetch } from './auth'

// çŸ¥è¯†åº“åŸºæœ¬ä¿¡æ¯æ¥å£
export interface KnowledgeBase {
  id: string
  user_id: string
  name: string
  description: string | null
  cover: string | null
  is_public: boolean
  created_at: string
  updated_at: string
  content?: string // Optional, not always returned for performance
}

// åˆ†é¡µä¿¡æ¯æ¥å£
export interface Pagination {
  current_page: number
  page_size: number
  total_count: number
  total_pages: number
  has_next: boolean
  has_prev: boolean
}

// è·å–çŸ¥è¯†åº“åˆ—è¡¨çš„å“åº”æ¥å£
export interface KnowledgeListResponse {
  success: boolean
  data: {
    list: KnowledgeBase[]
    pagination: Pagination
    is_admin: boolean
  }
  message: string
}

// è·å–çŸ¥è¯†åº“åˆ—è¡¨çš„è¯·æ±‚å‚æ•°æ¥å£
export interface KnowledgeListParams {
  pageSize?: number
  pageNumber?: number
  search?: string
}

// APIå“åº”åŸºç¡€æ¥å£
export interface ApiResponse {
  success: boolean
  message: string
  error?: string
  details?: string
}

/**
 * è·å–çŸ¥è¯†åº“åˆ—è¡¨
 * @param params æŸ¥è¯¢å‚æ•°
 * @returns Promise<KnowledgeListResponse>
 */
export async function getKnowledgeList(
  params: KnowledgeListParams = {}
): Promise<KnowledgeListResponse> {
  const { pageSize = 10, pageNumber = 1, search } = params

  // æ„å»ºæŸ¥è¯¢å‚æ•°
  const queryParams = new URLSearchParams({
    pageSize: pageSize.toString(),
    pageNumber: pageNumber.toString(),
  })

  if (search && search.trim()) {
    queryParams.append('search', search.trim())
  }

  try {
    const response = await authenticatedFetch(
      `${BASE_API_URL}/api/knowledge/list?${queryParams.toString()}`
    )

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`)
    }

    const data = await response.json()
    return data
  } catch (error) {
    console.error('Failed to get knowledge list:', error)
    throw new Error(
      error instanceof Error ? error.message : 'Failed to get knowledge list'
    )
  }
}

/**
 * è·å–å•ä¸ªçŸ¥è¯†åº“è¯¦æƒ…
 * @param id çŸ¥è¯†åº“ID
 * @returns Promise<KnowledgeBase>
 */
export async function getKnowledgeById(id: string): Promise<KnowledgeBase> {
  try {
    const response = await authenticatedFetch(
      `${BASE_API_URL}/api/knowledge/${id}`
    )

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`)
    }

    const data = await response.json()
    return data.data
  } catch (error) {
    console.error('Failed to get knowledge by id:', error)
    throw new Error(
      error instanceof Error ? error.message : 'Failed to get knowledge base'
    )
  }
}

/**
 * åˆ›å»ºçŸ¥è¯†åº“
 * @param knowledgeData çŸ¥è¯†åº“æ•°æ®
 * @returns Promise<ApiResponse>
 */
export async function createKnowledge(knowledgeData: {
  name: string
  description?: string
  cover?: string
  is_public?: boolean
  content?: string
}): Promise<ApiResponse> {
  try {
    const response = await authenticatedFetch(
      `${BASE_API_URL}/api/knowledge/create`,
      {
        method: 'POST',
        body: JSON.stringify(knowledgeData),
      }
    )

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`)
    }

    return await response.json()
  } catch (error) {
    console.error('Failed to create knowledge:', error)
    throw new Error(
      error instanceof Error ? error.message : 'Failed to create knowledge base'
    )
  }
}

/**
 * æ›´æ–°çŸ¥è¯†åº“
 * @param id çŸ¥è¯†åº“ID
 * @param knowledgeData æ›´æ–°æ•°æ®
 * @returns Promise<ApiResponse>
 */
export async function updateKnowledge(
  id: string,
  knowledgeData: Partial<{
    name: string
    description: string
    cover: string
    is_public: boolean
    content: string
  }>
): Promise<ApiResponse> {
  try {
    const response = await authenticatedFetch(
      `${BASE_API_URL}/api/knowledge/${id}`,
      {
        method: 'PUT',
        body: JSON.stringify(knowledgeData),
      }
    )

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`)
    }

    return await response.json()
  } catch (error) {
    console.error('Failed to update knowledge:', error)
    throw new Error(
      error instanceof Error ? error.message : 'Failed to update knowledge base'
    )
  }
}

/**
 * åˆ é™¤çŸ¥è¯†åº“
 * @param id çŸ¥è¯†åº“ID
 * @returns Promise<ApiResponse>
 */
export async function deleteKnowledge(id: string): Promise<ApiResponse> {
  try {
    const response = await authenticatedFetch(
      `${BASE_API_URL}/api/knowledge/${id}`,
      {
        method: 'DELETE',
      }
    )

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`)
    }

    return await response.json()
  } catch (error) {
    console.error('Failed to delete knowledge:', error)
    throw new Error(
      error instanceof Error ? error.message : 'Failed to delete knowledge base'
    )
  }
}

/**
 * å°†å¯ç”¨çš„çŸ¥è¯†åº“å®Œæ•´æ•°æ®å­˜å‚¨åˆ°æœ¬åœ°è®¾ç½®
 * @param knowledgeData å®Œæ•´çš„çŸ¥è¯†åº“æ•°æ®æ•°ç»„
 * @returns Promise<ApiResponse>
 */
export async function saveEnabledKnowledgeDataToSettings(
  knowledgeData: KnowledgeBase[]
): Promise<ApiResponse> {
  try {
    // è°ƒç”¨æœ¬åœ°æœåŠ¡å™¨APIï¼Œä¸éœ€è¦BASE_API_URLå’Œè®¤è¯
    const response = await fetch('/api/settings', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        enabled_knowledge_data: knowledgeData,
      }),
    })

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`)
    }

    return await response.json()
  } catch (error) {
    console.error('Failed to save knowledge data to settings:', error)
    throw new Error(
      error instanceof Error ? error.message : 'Failed to save knowledge data'
    )
  }
}



================================================
FILE: react/src/api/magic.ts
================================================
import { Message, Model } from '@/types/types'
import { ToolInfo } from './model'

export const sendMagicGenerate = async (payload: {
  sessionId: string
  canvasId: string
  newMessages: Message[]
  systemPrompt: string | null
}) => {
  const response = await fetch(`/api/magic`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      messages: payload.newMessages,
      canvas_id: payload.canvasId,
      session_id: payload.sessionId,
      system_prompt: payload.systemPrompt,
    }),
  })
  const data = await response.json()
  return data as Message[]
}

export const cancelMagicGenerate = async (sessionId: string) => {
    const response = await fetch(`/api/magic/cancel/${sessionId}`, {
        method: 'POST',
    })
    return await response.json()
}



================================================
FILE: react/src/api/model.ts
================================================
export type ModelInfo = {
  provider: string
  model: string
  type: 'text' | 'image' | 'tool' | 'video'
  url: string
}

export type ToolInfo = {
  provider: string
  id: string
  display_name?: string | null
  type?: 'image' | 'tool' | 'video'
}

export async function listModels(): Promise<{
  llm: ModelInfo[]
  tools: ToolInfo[]
}> {
  const modelsResp = await fetch('/api/list_models')
    .then((res) => res.json())
    .catch((err) => {
      console.error(err)
      return []
    })
  const toolsResp = await fetch('/api/list_tools')
    .then((res) => res.json())
    .catch((err) => {
      console.error(err)
      return []
    })

  return {
    llm: modelsResp,
    tools: toolsResp,
  }
}



================================================
FILE: react/src/api/settings.ts
================================================
[Binary file]


================================================
FILE: react/src/api/upload.ts
================================================
import { compressImageFile } from '@/utils/imageUtils'

export async function uploadImage(
  file: File
): Promise<{ file_id: string; width: number; height: number; url: string }> {
  // Compress image before upload
  const compressedFile = await compressImageFile(file)

  const formData = new FormData()
  formData.append('file', compressedFile)
  const response = await fetch('/api/upload_image', {
    method: 'POST',
    body: formData,
  })
  return await response.json()
}



================================================
FILE: react/src/assets/style/animations.css
================================================
.brush-icon-animation {
  animation: brush-icon-animation 1s infinite;
  transform-origin: top center;
  animation-direction: alternate;
}

@keyframes brush-icon-animation {
  0% {
    transform: rotate(-8deg) translateY(-1px) translateX(-1px);
  }
  100% {
    transform: rotate(1deg) translateX(2px);
  }
}



================================================
FILE: react/src/assets/style/App.css
================================================
#root {
  margin: 0 auto;
}

h1 {
  font-size: 2rem;
  font-weight: 600;
  margin-bottom: 1rem;
}
h2 {
  font-size: 1.5rem;
  font-weight: 500;
  margin-bottom: 0.5rem;
}
h3 {
  font-size: 1.25rem;
  font-weight: 400;
  margin-bottom: 0.5rem;
}
h4 {
  font-size: 1rem;
  font-weight: 300;
  margin-bottom: 0.5rem;
}
.mdxeditor [role="textbox"] {
  height: calc(100vh - 200px);
}
.mdxeditor p {
  margin-bottom: 0.8rem;
}

.mdxeditor ul {
  list-style-type: disc; /* Use bullet points for unordered lists */
  margin-left: 1.5rem; /* Add some indentation */
}

/* Style ordered lists (numbered) */
.mdxeditor ol {
  list-style-type: decimal; /* Use numbers for ordered lists */
  margin-left: 1.5rem; /* Add some indentation */
}

/* Style for list items */
.mdxeditor li {
  margin-bottom: 0.5rem; /* Add spacing between list items */
}

/* Optional: Style for nested lists (nested ordered or unordered lists) */
.mdxeditor ul ul,
.mdxeditor ol ol {
  margin-left: 1.5rem; /* Indent nested lists */
}



================================================
FILE: react/src/assets/style/canvas.css
================================================
.excalidraw .shapes-section {
  display: none !important;
}

/* Conditionally hide left toolbar panel when embeddable is selected */
.excalidraw.hide-left-panel .App-menu__left {
  display: none !important;
}

/* Video overlay styles */
.video-overlay {
  position: absolute;
  top: 0;
  left: 0;
  z-index: 10;
  pointer-events: none;
  width: 100%;
  height: 100%;
}

.video-overlay video {
  object-fit: contain;
  pointer-events: auto;
}

.excalidraw .Stack.Stack_vertical.App-menu_top__left>div {
  display: none !important;
}

.ToolIcon__keybinding {
  display: none !important;
}

/* Enable embeddable tool for video integration */
/* .excalidraw .dropdown-menu .dropdown-menu-item[data-testid='toolbar-embeddable'] {
  display: none !important;
} */

.excalidraw .dropdown-menu .dropdown-menu-item[data-testid='toolbar-laser']+div {
  display: none !important;
}

.excalidraw .layer-ui__wrapper__top-right {
  display: none !important;
}

.excalidraw .FixedSideContainer.FixedSideContainer_side_top.App-top-bar {
  display: none !important;
}

.excalidraw .layer-ui__wrapper__footer.App-menu.App-menu_bottom {
  display: none !important;
}

.excalidraw .App-bottom-bar {
  display: none !important;
}

.scroll-back-to-content {
  bottom: 80px !important;
}

.excalidraw .popover {
  z-index: 60 !important;
}

.excalidraw .popover .context-menu {
  border-radius: 10px !important;
  border-color: color-mix(in oklab, var(--primary) 10%, transparent) !important;
  background-color: color-mix(in oklab,
      var(--background) 70%,
      transparent) !important;
  backdrop-filter: blur(60px) !important;
  box-shadow: 0 20px 30px -10px rgba(0, 0, 0, 0.1) !important;
  font-size: 14px !important;
}

.excalidraw .popover .context-menu .context-menu-item-separator {
  border-color: color-mix(in oklab, var(--primary) 8%, transparent) !important;
  margin: 4px 0 !important;
}

/* è‡ªå®šä¹‰æ·±è‰²æ¨¡å¼ä¿®å¤ç±» */
.excalidraw-custom.excalidraw-dark-fix-wm76394yjopk {
  /* ç§»é™¤æ‰€æœ‰æ»¤é•œæ•ˆæœ */
  filter: none !important;
}

.excalidraw-custom.excalidraw-dark-fix-wm76394yjopk * {
  /* ç¡®ä¿æ‰€æœ‰å­å…ƒç´ ä¹Ÿä¸å—æ»¤é•œå½±å“ */
  filter: none !important;
}

/* ä¸ºè‡ªå®šä¹‰æ·±è‰²æ¨¡å¼è®¾ç½®é€‚å½“çš„é¢œè‰² */
.excalidraw-custom.excalidraw-dark-fix-wm76394yjopk {
  --color-primary: #f5f5f5 !important;
  --color-primary-darker: #e0e0e0 !important;
  --color-primary-darkest: #cccccc !important;
  --color-primary-light: #ffffff !important;
  background-color: #121212 !important;
  color: #f5f5f5 !important;
}

/* ç›´æ¥è¦†ç›–Excalidrawçš„æ ¸å¿ƒCSSç±» */
.excalidraw-wrapper .excalidraw.theme--dark {
  filter: none !important;
}

.excalidraw-wrapper .excalidraw.theme--dark .App-menu_top,
.excalidraw-wrapper .excalidraw.theme--dark .App-menu_bottom,
.excalidraw-wrapper .excalidraw.theme--dark .App-menu_left,
.excalidraw-wrapper .excalidraw.theme--dark .App-menu_right {
  filter: none !important;
}

.excalidraw-wrapper .excalidraw.theme--dark .layer-ui__wrapper {
  filter: none !important;
}

/* è¦†ç›–Excalidrawçš„ç”»å¸ƒæ»¤é•œ */
.excalidraw-wrapper .excalidraw.theme--dark .FixedSideContainer {
  filter: none !important;
}

/* è¦†ç›–Excalidrawçš„å…ƒç´ æ»¤é•œ */
.excalidraw-wrapper .excalidraw.theme--dark .excalidraw-element {
  filter: none !important;
}

/* æœ€ç›´æ¥çš„è§£å†³æ–¹æ¡ˆï¼šè¦†ç›–æ‰€æœ‰Excalidrawå®¹å™¨å…ƒç´  */
.excalidraw.theme--dark,
.excalidraw.theme--dark *,
.excalidraw-wrapper,
.excalidraw-wrapper *,
.excalidraw-container,
.excalidraw-container * {
  filter: none !important;
}

/* è¦†ç›–Excalidrawçš„ä¸»è¦å®¹å™¨ */
.excalidraw-app {
  filter: none !important;
}

/* è¦†ç›–Excalidrawçš„ç”»å¸ƒå®¹å™¨ */
.excalidraw-canvas {
  filter: none !important;
}

/* è¦†ç›–Excalidrawçš„åœºæ™¯å®¹å™¨ */
.scene-container {
  filter: none !important;
}

/* ä¸ºæ·±è‰²æ¨¡å¼è®¾ç½®é€‚å½“çš„èƒŒæ™¯è‰²å’Œæ–‡æœ¬é¢œè‰² */
.excalidraw.theme--dark {
  --color-canvas-background: #121212 !important;
  background-color: #121212 !important;
  color: #f5f5f5 !important;
}

/* ç¡®ä¿æ·±è‰²æ¨¡å¼ä¸‹çš„æ–‡æœ¬å…ƒç´ é¢œè‰²æ­£ç¡® */
.excalidraw-wrapper .excalidraw.theme--dark .Layer_textarea {
  filter: none !important;
  color: #f5f5f5 !important;
}

/* ç¡®ä¿æ·±è‰²æ¨¡å¼ä¸‹çš„UIå…ƒç´ é¢œè‰²æ­£ç¡® */
.excalidraw-wrapper .excalidraw.theme--dark .ToolIcon__icon,
.excalidraw-wrapper .excalidraw.theme--dark .ToolIcon__label {
  filter: none !important;
  color: #f5f5f5 !important;
}

/* ç¡®ä¿æ·±è‰²æ¨¡å¼ä¸‹çš„æŒ‰é’®é¢œè‰²æ­£ç¡® */
.excalidraw-wrapper .excalidraw.theme--dark button {
  filter: none !important;
}

/* ç¡®ä¿æ·±è‰²æ¨¡å¼ä¸‹çš„è¾“å…¥æ¡†é¢œè‰²æ­£ç¡® */
.excalidraw-wrapper .excalidraw.theme--dark input,
.excalidraw-wrapper .excalidraw.theme--dark textarea {
  filter: none !important;
  color: #f5f5f5 !important;
  background-color: #333333 !important;
}


================================================
FILE: react/src/assets/style/index.css
================================================
@import 'tailwindcss';
@import 'tw-animate-css';
@import './animations.css';

@custom-variant dark (&:is(.dark *));

:root {
  --radius: 0.625rem;
  --background: oklch(1 0 0);
  --foreground: oklch(0.141 0.005 285.823);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.141 0.005 285.823);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.141 0.005 285.823);
  --primary: oklch(0.21 0.006 285.885);
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.967 0.001 286.375);
  --secondary-foreground: oklch(0.21 0.006 285.885);
  --muted: oklch(0.967 0.001 286.375);
  --muted-foreground: oklch(0.552 0.016 285.938);
  --accent: oklch(0.967 0.001 286.375);
  --accent-foreground: oklch(0.21 0.006 285.885);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.92 0.004 286.32);
  --input: oklch(0.92 0.004 286.32);
  --ring: oklch(0.705 0.015 286.067);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.141 0.005 285.823);
  --sidebar-primary: oklch(0.21 0.006 285.885);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.967 0.001 286.375);
  --sidebar-accent-foreground: oklch(0.21 0.006 285.885);
  --sidebar-border: oklch(0.92 0.004 286.32);
  --sidebar-ring: oklch(0.705 0.015 286.067);
}

.dark {
  --background: oklch(0.141 0.005 285.823);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.21 0.006 285.885);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.21 0.006 285.885);
  --popover-foreground: oklch(0.985 0 0);
  --primary: oklch(0.92 0.004 286.32);
  --primary-foreground: oklch(0.21 0.006 285.885);
  --secondary: oklch(0.274 0.006 286.033);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.274 0.006 286.033);
  --muted-foreground: oklch(0.705 0.015 286.067);
  --accent: oklch(0.274 0.006 286.033);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.552 0.016 285.938);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.21 0.006 285.885);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.274 0.006 286.033);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.552 0.016 285.938);
}

@theme inline {
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --color-card: var(--card);
  --color-card-foreground: var(--card-foreground);
  --color-popover: var(--popover);
  --color-popover-foreground: var(--popover-foreground);
  --color-primary: var(--primary);
  --color-primary-foreground: var(--primary-foreground);
  --color-secondary: var(--secondary);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-muted: var(--muted);
  --color-muted-foreground: var(--muted-foreground);
  --color-accent: var(--accent);
  --color-accent-foreground: var(--accent-foreground);
  --color-destructive: var(--destructive);
  --color-border: var(--border);
  --color-input: var(--input);
  --color-ring: var(--ring);
  --color-chart-1: var(--chart-1);
  --color-chart-2: var(--chart-2);
  --color-chart-3: var(--chart-3);
  --color-chart-4: var(--chart-4);
  --color-chart-5: var(--chart-5);
  --color-sidebar: var(--sidebar);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-ring: var(--sidebar-ring);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 224 71.4% 4.1%;
    --card: 0 0% 100%;
    --card-foreground: 224 71.4% 4.1%;
    --popover: 0 0% 100%;
    --popover-foreground: 224 71.4% 4.1%;
    --primary: 262.1 83.3% 57.8%;
    --primary-foreground: 210 20% 98%;
    --secondary: 220 14.3% 95.9%;
    --secondary-foreground: 220.9 39.3% 11%;
    --muted: 220 14.3% 95.9%;
    --muted-foreground: 220 8.9% 46.1%;
    --accent: 220 14.3% 95.9%;
    --accent-foreground: 220.9 39.3% 11%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 20% 98%;
    --border: 220 13% 91%;
    --input: 220 13% 91%;
    --ring: 262.1 83.3% 57.8%;
    --radius: 0.5rem;
    --chart-1: 12 76% 61%;
    --chart-2: 173 58% 39%;
    --chart-3: 197 37% 24%;
    --chart-4: 43 74% 66%;
    --chart-5: 27 87% 67%;
  }

  .dark {
    --background: 224 71.4% 4.1%;
    --foreground: 210 20% 98%;
    --card: 224 71.4% 4.1%;
    --card-foreground: 210 20% 98%;
    --popover: 224 71.4% 4.1%;
    --popover-foreground: 210 20% 98%;
    --primary: 263.4 70% 50.4%;
    --primary-foreground: 210 20% 98%;
    --secondary: 215 27.9% 16.9%;
    --secondary-foreground: 210 20% 98%;
    --muted: 215 27.9% 16.9%;
    --muted-foreground: 217.9 10.6% 64.9%;
    --accent: 215 27.9% 16.9%;
    --accent-foreground: 210 20% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 20% 98%;
    --border: 215 27.9% 16.9%;
    --input: 215 27.9% 16.9%;
    --ring: 263.4 70% 50.4%;
    --chart-1: 220 70% 50%;
    --chart-2: 160 60% 45%;
    --chart-3: 30 80% 55%;
    --chart-4: 280 65% 60%;
    --chart-5: 340 75% 55%;
  }
}



================================================
FILE: react/src/assets/style/shiny-text.css
================================================
.shiny-text {
  position: relative;
  color: #b5b5b5a4;
  display: inline-block;
  background: linear-gradient(
    120deg,
    rgba(255, 255, 255, 0) 40%,
    rgba(255, 255, 255, 0.8) 50%,
    rgba(255, 255, 255, 0) 60%
  );
  background-size: 200% 100%;
  -webkit-background-clip: text;
  background-clip: text;
  animation: shine 5s linear infinite;
  overflow: hidden;
}

.shiny-text .shine {
  position: absolute;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  color: transparent;
  background: linear-gradient(
    120deg,
    rgba(255, 255, 255, 0) 40%,
    rgba(255, 255, 255, 0.75) 50%,
    rgba(255, 255, 255, 0) 60%
  );
  background-size: 200% 100%;
  -webkit-background-clip: text;
  background-clip: text;
  pointer-events: none;
  animation: shine 2s linear infinite;
  white-space: pre;
}

@keyframes shine {
  0% {
    background-position: 100%;
  }
  100% {
    background-position: -100%;
  }
}

.shiny-text.disabled {
  animation: none;
}



================================================
FILE: react/src/components/TopMenu.tsx
================================================
import { useConfigs } from '@/contexts/configs'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { ChevronLeft, ImageIcon } from 'lucide-react'
import { motion } from 'motion/react'
import { useTranslation } from 'react-i18next'
import { useNavigate } from '@tanstack/react-router'
import { SettingsIcon } from 'lucide-react'
import ThemeButton from '@/components/theme/ThemeButton'
import { LOGO_URL } from '@/constants'
import LanguageSwitcher from './common/LanguageSwitcher'
import { cn } from '@/lib/utils'
import { UserMenu } from './auth/UserMenu'

export default function TopMenu({
  middle,
  right,
}: {
  middle?: React.ReactNode
  right?: React.ReactNode
}) {
  const { t } = useTranslation()

  const navigate = useNavigate()
  const { setShowSettingsDialog } = useConfigs()

  return (
    <motion.div
      className="sticky top-0 z-0 flex w-full h-8 bg-background px-4 justify-between items-center select-none border-b border-border"
      initial={{ opacity: 0, y: -10 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.3 }}
    >
      <div className="flex items-center gap-8">
        <motion.div
          className="flex items-center gap-2 cursor-pointer group"
          onClick={() => navigate({ to: '/' })}
        >
          {window.location.pathname !== '/' && (
            <ChevronLeft className="size-5 group-hover:-translate-x-0.5 transition-transform duration-300" />
          )}
          <img src={LOGO_URL} alt="logo" className="size-5" draggable={false} />
          <motion.div className="flex relative overflow-hidden items-start h-7 text-xl font-bold">
            <motion.span className="flex items-center" layout>
              {window.location.pathname === '/' ? 'Jaaz' : t('canvas:back')}
            </motion.span>
          </motion.div>
        </motion.div>
        <Button
          variant={window.location.pathname === '/assets' ? 'default' : 'ghost'}
          size="sm"
          className={cn('flex items-center font-bold rounded-none')}
          onClick={() => navigate({ to: '/assets' })}
        >
          <ImageIcon className="size-4" />
          {t('canvas:assets', 'Library')}
        </Button>
      </div>

      <div className="flex items-center gap-2">{middle}</div>

      <div className="flex items-center gap-2">
        {right}
        {/* <AgentSettings /> */}
        <Button
          size={'sm'}
          variant="ghost"
          onClick={() => setShowSettingsDialog(true)}
        >
          <SettingsIcon size={30} />
        </Button>
        <LanguageSwitcher />
        <ThemeButton />
        <UserMenu />
      </div>
    </motion.div>
  )
}



================================================
FILE: react/src/components/agent_studio/AgentNode.tsx
================================================
import { useCallback } from 'react'
import { Button } from '../ui/button'
import { BookOpenIcon, BotIcon, PlusIcon, WrenchIcon } from 'lucide-react'

export default function AgentNode() {
  return (
    <div className="p-4 bg-accent rounded-md flex flex-col gap-2">
      <div className="flex items-center gap-2">
        <BotIcon className="size-4" />
        <input
          type="text"
          placeholder="Enter Agent Name"
          className="border-none outline-none"
        />
      </div>
      <p className="text-sm text-muted-foreground">
        The description of the agent
      </p>
      <p className="font-bold flex items-center gap-2">
        <BookOpenIcon className="size-4" />
        <span>Knowledge</span>
      </p>
      <Button
        variant="outline"
        className="w-full
      "
      >
        <PlusIcon className="size-4" />
        Add Knowledge
      </Button>
      <p className="font-bold flex items-center gap-2">
        <WrenchIcon className="size-4" />
        <span>Tools</span>
      </p>
      <Button variant="outline" className="w-full">
        <PlusIcon className="size-4" />
        Add Tool
      </Button>
      <p className="font-bold flex items-center gap-2">
        <WrenchIcon className="size-4" />
        <span>Handoffs</span>
      </p>
      <Button variant="outline" className="w-full">
        <PlusIcon className="size-4" />
        Add Handoff
      </Button>
    </div>
  )
}



================================================
FILE: react/src/components/agent_studio/AgentSettings.tsx
================================================
import { BotIcon } from 'lucide-react'
import { Dialog, DialogContent, DialogTrigger } from '../ui/dialog'
import { Button } from '../ui/button'
import { Textarea } from '../ui/textarea'
import { useState } from 'react'
import { toast } from 'sonner'
import { DEFAULT_SYSTEM_PROMPT } from '@/constants'

export default function AgentSettings() {
  const [systemPrompt, setSystemPrompt] = useState(
    localStorage.getItem('system_prompt') || DEFAULT_SYSTEM_PROMPT
  )

  const handleSave = () => {
    localStorage.setItem('system_prompt', systemPrompt)
    toast.success('System prompt saved')
  }

  const handleReset = () => {
    localStorage.setItem('system_prompt', DEFAULT_SYSTEM_PROMPT)
    setSystemPrompt(DEFAULT_SYSTEM_PROMPT)
    toast.success('System prompt reset to default')
  }
  return (
    <Dialog>
      <DialogTrigger asChild>
        <Button size={'sm'} variant="ghost">
          <BotIcon size={30} />
        </Button>
      </DialogTrigger>
      <DialogContent className="max-w-2xl">
        <div className="flex items-center justify-between">
          <h3 className="text-2xl font-bold">Agent Settings</h3>
        </div>
        <div className="flex items-center justify-between">
          <p className="font-bold">System Prompt</p>
          <Button size={'sm'} variant={'outline'} onClick={handleReset}>
            Reset to Default
          </Button>
        </div>
        <div className="flex flex-col gap-2">
          <Textarea
            placeholder="Enter your system prompt here"
            className="h-[60vh]"
            value={systemPrompt}
            onChange={(e) => setSystemPrompt(e.target.value)}
          />
        </div>
        <Button className="w-full" onClick={handleSave}>
          Save
        </Button>
      </DialogContent>
    </Dialog>
  )
}



================================================
FILE: react/src/components/agent_studio/AgentStudio.tsx
================================================
import React, { useCallback, useEffect, useRef, useState } from 'react'
import {
  ReactFlow,
  useNodesState,
  useEdgesState,
  addEdge,
  Edge,
  Node,
  OnConnect,
  NodeMouseHandler,
} from '@xyflow/react'
import debounce from 'lodash.debounce'

import '@xyflow/react/dist/style.css'
import AgentNode from './AgentNode'
import { Textarea } from '../ui/textarea'
import TopMenu from '../TopMenu'

const LOCAL_STORAGE_KEY = 'agent-studio-graph'

const defaultNodes = [
  {
    id: '1',
    type: 'agent',
    position: { x: 0, y: 0 },
    data: { label: '1' },
  },
  {
    id: '2',
    type: 'agent',
    position: { x: 100, y: 100 },
    data: { label: '2' },
  },
]
// const defaultEdges = [{ id: 'e1-2', source: '1', target: '2' }]
const defaultEdges: Edge[] = []

const loadInitialGraph = () => {
  try {
    const saved = localStorage.getItem(LOCAL_STORAGE_KEY)
    if (saved) {
      const parsed = JSON.parse(saved)
      return [parsed.nodes || defaultNodes, parsed.edges || defaultEdges]
    }
  } catch (e) {
    console.warn('Failed to load saved graph', e)
  }
  return [defaultNodes, defaultEdges]
}

export default function AgentStudio() {
  const [initialNodes, initialEdges] = loadInitialGraph()
  const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes)
  const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges)
  const [selectedNode, setSelectedNode] = useState<Node | null>(null)

  const saveGraph = useRef(
    debounce((nodes, edges) => {
      console.log('Saving graph', nodes, edges)
      localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify({ nodes, edges }))
    }, 500)
  ).current

  useEffect(() => {
    saveGraph(nodes, edges)
  }, [nodes, edges, saveGraph])

  const onNodeClick: NodeMouseHandler<Node> = useCallback((_, node) => {
    console.log('onNodeClick', node)
    setSelectedNode(node)
  }, [])

  const onConnect: OnConnect = useCallback(
    (params) => setEdges((eds) => addEdge(params, eds)),
    [setEdges]
  )

  const nodeTypes = {
    agent: AgentNode,
  }

  return (
    <div>
      <TopMenu />
      <div style={{ width: '100vw', height: '100vh' }}>
        <ReactFlow
          nodes={nodes}
          edges={edges}
          onNodesChange={onNodesChange}
          onEdgesChange={onEdgesChange}
          onNodeClick={onNodeClick}
          onConnect={onConnect}
          nodeTypes={nodeTypes}
        />
      </div>
      {/* Sidebar */}
      {selectedNode && (
        <>
          <div
            className="absolute right-0 top-0 left-0 bottom-0"
            onClick={() => setSelectedNode(null)}
          />
          <div
            className="absolute right-0 top-0 h-[100vh] w-96 bg-sidebar"
            style={{
              width: '25%',
              padding: '16px',
              boxSizing: 'border-box',
              overflowY: 'auto',
            }}
          >
            <input
              type="text"
              placeholder="Enter Agent Name"
              className="w-full text-lg font-semibold outline-none border-none mb-2"
            />
            <textarea
              placeholder="Enter Agent Description"
              className="w-full text-sm outline-none border-none resize-none mb-2"
            />
            <div className="flex flex-col gap-2">
              <p>
                <strong>System Prompt</strong>
              </p>
              <Textarea
                className="w-full text-sm mb-2 h-48"
                placeholder="Enter System Prompt"
              />
            </div>
          </div>
        </>
      )}
    </div>
  )
}



================================================
FILE: react/src/components/auth/LoginDialog.tsx
================================================
import React, { useState, useEffect, useRef } from 'react'
import { useTranslation } from 'react-i18next'
import { Button } from '../ui/button'
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '../ui/dialog'
import { startDeviceAuth, pollDeviceAuth, saveAuthData } from '../../api/auth'
import { updateJaazApiKey } from '../../api/config'
import { useAuth } from '../../contexts/AuthContext'
import { useConfigs, useRefreshModels } from '../../contexts/configs'

export function LoginDialog() {
  const [authMessage, setAuthMessage] = useState('')
  const { refreshAuth } = useAuth()
  const { showLoginDialog: open, setShowLoginDialog } = useConfigs()
  const refreshModels = useRefreshModels()
  const { t } = useTranslation()
  const pollingIntervalRef = useRef<NodeJS.Timeout | null>(null)

  // Clean up polling when dialog closes
  useEffect(() => {
    setAuthMessage('')

    if (!open) {
      if (pollingIntervalRef.current) {
        clearInterval(pollingIntervalRef.current)
        pollingIntervalRef.current = null
      }
    }
  }, [open])

  // Clean up on unmount
  useEffect(() => {
    return () => {
      if (pollingIntervalRef.current) {
        clearInterval(pollingIntervalRef.current)
      }
    }
  }, [])

  const startPolling = (code: string) => {
    console.log('Starting polling for device code:', code)

    const poll = async () => {
      try {
        const result = await pollDeviceAuth(code)
        console.log('Poll result:', result)

        if (result.status === 'authorized') {
          // Login successful - save auth data to local storage
          if (result.token && result.user_info) {
            saveAuthData(result.token, result.user_info)

            // Update jaaz provider api_key with the access token
            await updateJaazApiKey(result.token)
          }

          setAuthMessage(t('common:auth.loginSuccessMessage'))
          if (pollingIntervalRef.current) {
            clearInterval(pollingIntervalRef.current)
            pollingIntervalRef.current = null
          }

          try {
            await refreshAuth()
            console.log('Auth status refreshed successfully')
            // Refresh models list after successful login and config update
            refreshModels()
          } catch (error) {
            console.error('Failed to refresh auth status:', error)
          }

          setTimeout(() => setShowLoginDialog(false), 1500)

        } else if (result.status === 'expired') {
          // Authorization expired
          setAuthMessage(t('common:auth.authExpiredMessage'))
          if (pollingIntervalRef.current) {
            clearInterval(pollingIntervalRef.current)
            pollingIntervalRef.current = null
          }

        } else if (result.status === 'error') {
          // Error occurred
          setAuthMessage(result.message || t('common:auth.authErrorMessage'))
          if (pollingIntervalRef.current) {
            clearInterval(pollingIntervalRef.current)
            pollingIntervalRef.current = null
          }

        } else {
          // Still pending, continue polling
          setAuthMessage(t('common:auth.waitingForBrowser'))
        }
      } catch (error) {
        console.error('Polling error:', error)
        setAuthMessage(t('common:auth.pollErrorMessage'))
        if (pollingIntervalRef.current) {
          clearInterval(pollingIntervalRef.current)
          pollingIntervalRef.current = null
        }
      }
    }

    // Start polling immediately, then every 1 seconds
    poll()
    pollingIntervalRef.current = setInterval(poll, 1000)
  }

  const handleLogin = async () => {
    try {
      setAuthMessage(t('common:auth.preparingLoginMessage'))

      const result = await startDeviceAuth()
      setAuthMessage(result.message)

      // Start polling for authorization status
      startPolling(result.code)

    } catch (error) {
      console.error('ç™»å½•è¯·æ±‚å¤±è´¥:', error)
      setAuthMessage(t('common:auth.loginRequestFailed'))
    }
  }

  const handleCancel = () => {
    if (pollingIntervalRef.current) {
      clearInterval(pollingIntervalRef.current)
      pollingIntervalRef.current = null
    }
    setAuthMessage('')
    setShowLoginDialog(false)
  }

  return (
    <Dialog open={open} onOpenChange={setShowLoginDialog}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>{t('common:auth.loginToJaaz')}</DialogTitle>
        </DialogHeader>

        <div className="space-y-4">
          <p className="text-sm text-muted-foreground">
            {t('common:auth.loginDescription')}
          </p>

          <div className="flex gap-2">
            <Button
              onClick={handleLogin}
              disabled={!!authMessage}
              className="flex-1"
            >
              {authMessage || t('common:auth.startLogin')}
            </Button>

          </div>
        </div>
      </DialogContent>
    </Dialog>
  )
}



================================================
FILE: react/src/components/auth/PointsDisplay.tsx
================================================
import React from 'react'
import { Zap } from 'lucide-react'
import { cn } from '@/lib/utils'
import { useBalance } from '@/hooks/use-balance'

interface PointsDisplayProps {
  className?: string
  children?: React.ReactNode
}

export function PointsDisplay({ className, children }: PointsDisplayProps) {
  const { balance } = useBalance()

  // å°†é‡‘é¢ä¹˜ä»¥ 100 è½¬æ¢ä¸ºç§¯åˆ†ï¼Œæ˜¾ç¤ºä¸ºæ•´æ•°ï¼Œå¦‚æœä¸ºè´Ÿæ•°åˆ™æ˜¾ç¤º 0
  const points = Math.max(0, Math.floor(parseFloat(balance) * 100))

  return (
    <div className={cn('flex items-center relative', className)}>
      {/* ç§¯åˆ†æ˜¾ç¤ºåŒºåŸŸ */}
      <div className="flex items-center bg-gray-100 dark:bg-gray-800 px-3 py-1 rounded-full border border-gray-200 dark:border-gray-700 pr-8">
        <Zap className="w-3.5 h-3.5 text-black dark:text-white mr-1.5" />
        <span className="text-xs font-semibold text-black dark:text-white">
          {points}
        </span>
      </div>

      {/* å¤´åƒåŒºåŸŸ - é‡å åœ¨ç§¯åˆ†æ˜¾ç¤ºä¸Š */}
      <div className="absolute -right-0.5">
        {children}
      </div>
    </div>
  )
}



================================================
FILE: react/src/components/auth/UserMenu.tsx
================================================
import React from 'react'
import { useTranslation } from 'react-i18next'
import { useAuth } from '@/contexts/AuthContext'
import { useConfigs, useRefreshModels } from '@/contexts/configs'
import { BASE_API_URL } from '@/constants'
import { Button } from '@/components/ui/button'
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu'
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar'
import { logout } from '@/api/auth'
import { PointsDisplay } from './PointsDisplay'

export function UserMenu() {
  const { authStatus, refreshAuth } = useAuth()
  const { setShowLoginDialog } = useConfigs()
  const refreshModels = useRefreshModels()
  const { t } = useTranslation()

  const handleLogout = async () => {
    await logout()
    await refreshAuth()
    // Refresh models list after logout and config update
    refreshModels()
  }

  // å¦‚æœç”¨æˆ·å·²ç™»å½•ï¼Œæ˜¾ç¤ºç”¨æˆ·èœå•
  if (authStatus.is_logged_in && authStatus.user_info) {
    const { username, image_url } = authStatus.user_info
    const initials = username ? username.substring(0, 2).toUpperCase() : 'U'

    return (
      <DropdownMenu>
        <DropdownMenuTrigger asChild>
          <Button variant="ghost" className="relative p-0 h-auto">
            <PointsDisplay>
              <Avatar className="h-6 w-6">
                <AvatarImage src={image_url} alt={username} />
                <AvatarFallback>{initials}</AvatarFallback>
              </Avatar>
            </PointsDisplay>
          </Button>
        </DropdownMenuTrigger>
        <DropdownMenuContent align="end">
          <DropdownMenuLabel>{t('common:auth.myAccount')}</DropdownMenuLabel>
          <DropdownMenuItem disabled>{username}</DropdownMenuItem>
          <DropdownMenuSeparator />
          <DropdownMenuItem
            onClick={() => {
              const billingUrl = `${BASE_API_URL}/billing`
              if (window.electronAPI?.openBrowserUrl) {
                window.electronAPI.openBrowserUrl(billingUrl)
              } else {
                window.open(billingUrl, '_blank')
              }
            }}
          >
            {t('common:auth.recharge')}
          </DropdownMenuItem>
          <DropdownMenuSeparator />
          <DropdownMenuItem onClick={handleLogout}>
            {t('common:auth.logout')}
          </DropdownMenuItem>
        </DropdownMenuContent>
      </DropdownMenu>
    )
  }

  // æœªç™»å½•çŠ¶æ€ï¼Œæ˜¾ç¤ºç™»å½•æŒ‰é’®
  return (
    <Button variant="outline" onClick={() => setShowLoginDialog(true)}>
      {t('common:auth.login')}
    </Button>
  )
}



================================================
FILE: react/src/components/canvas/CanvasExcali.tsx
================================================
import { saveCanvas } from '@/api/canvas'
import { useCanvas } from '@/contexts/canvas'
import useDebounce from '@/hooks/use-debounce'
import { useTheme } from '@/hooks/use-theme'
import { eventBus } from '@/lib/event'
import * as ISocket from '@/types/socket'
import { CanvasData } from '@/types/types'
import { Excalidraw, convertToExcalidrawElements } from '@excalidraw/excalidraw'
import {
  ExcalidrawImageElement,
  ExcalidrawEmbeddableElement,
  OrderedExcalidrawElement,
  Theme,
  NonDeleted,
} from '@excalidraw/excalidraw/element/types'
import '@excalidraw/excalidraw/index.css'
import {
  AppState,
  BinaryFileData,
  BinaryFiles,
  ExcalidrawInitialDataState,
} from '@excalidraw/excalidraw/types'
import { useCallback, useEffect, useRef } from 'react'
import { useTranslation } from 'react-i18next'
import { VideoElement } from './VideoElement'

import '@/assets/style/canvas.css'

type LastImagePosition = {
  x: number
  y: number
  width: number
  height: number
  col: number // col index
}

type CanvasExcaliProps = {
  canvasId: string
  initialData?: ExcalidrawInitialDataState
}

const CanvasExcali: React.FC<CanvasExcaliProps> = ({
  canvasId,
  initialData,
}) => {
  const { excalidrawAPI, setExcalidrawAPI } = useCanvas()

  const { i18n } = useTranslation()

  // Immediate handler for UI updates (no debounce)
  const handleSelectionChange = (
    elements: Readonly<OrderedExcalidrawElement[]>,
    appState: AppState
  ) => {
    if (!appState) return

    // Check if any selected element is embeddable type
    const selectedElements = elements.filter((element) => 
      appState.selectedElementIds[element.id]
    )
    const hasEmbeddableSelected = selectedElements.some(
      (element) => element.type === 'embeddable'
    )

    // Toggle CSS class to hide/show left panel immediately
    const excalidrawContainer = document.querySelector('.excalidraw')
    if (excalidrawContainer) {
      if (hasEmbeddableSelected) {
        excalidrawContainer.classList.add('hide-left-panel')
      } else {
        excalidrawContainer.classList.remove('hide-left-panel')
      }
    }
  }

  // Debounced handler for saving (performance optimization)
  const handleSave = useDebounce(
    (
      elements: Readonly<OrderedExcalidrawElement[]>,
      appState: AppState,
      files: BinaryFiles
    ) => {
      if (elements.length === 0 || !appState) {
        return
      }

      const data: CanvasData = {
        elements,
        appState: {
          ...appState,
          collaborators: undefined!,
        },
        files,
      }

      let thumbnail = ''
      const latestImage = elements
        .filter((element) => element.type === 'image')
        .sort((a, b) => b.updated - a.updated)[0]
      if (latestImage) {
        const file = files[latestImage.fileId!]
        if (file) {
          thumbnail = file.dataURL
        }
      }

      saveCanvas(canvasId, { data, thumbnail })
    },
    1000
  )

  // Combined handler that calls both immediate and debounced functions
  const handleChange = (
    elements: Readonly<OrderedExcalidrawElement[]>,
    appState: AppState,
    files: BinaryFiles
  ) => {
    // Immediate UI updates
    handleSelectionChange(elements, appState)
    // Debounced save operation
    handleSave(elements, appState, files)
  }

  const lastImagePosition = useRef<LastImagePosition | null>(
    localStorage.getItem('excalidraw-last-image-position')
      ? JSON.parse(localStorage.getItem('excalidraw-last-image-position')!)
      : null
  )
  const { theme } = useTheme()

  // æ·»åŠ è‡ªå®šä¹‰ç±»åä»¥ä¾¿åº”ç”¨æˆ‘ä»¬çš„CSSä¿®å¤
  const excalidrawClassName = `excalidraw-custom ${theme === 'dark' ? 'excalidraw-dark-fix-wm76394yjopk' : 'excalidraw-wm76394yjopk'}`
  
  // åœ¨æ·±è‰²æ¨¡å¼ä¸‹ä½¿ç”¨è‡ªå®šä¹‰ä¸»é¢˜è®¾ç½®ï¼Œé¿å…ä½¿ç”¨é»˜è®¤çš„æ»¤é•œ
  // è¿™æ ·å¯ä»¥ç¡®ä¿é¢œè‰²åœ¨æ·±è‰²æ¨¡å¼ä¸‹æ­£ç¡®æ˜¾ç¤º
  const customTheme = theme === 'dark' ? 'light' : theme
  
  // åœ¨ç»„ä»¶æŒ‚è½½å’Œä¸»é¢˜å˜åŒ–æ—¶è®¾ç½®æ·±è‰²æ¨¡å¼ä¸‹çš„èƒŒæ™¯è‰²
  useEffect(() => {
    if (excalidrawAPI && theme === 'dark') {
      // è®¾ç½®æ·±è‰²èƒŒæ™¯ï¼Œä½†ä¿æŒlightä¸»é¢˜ä»¥é¿å…é¢œè‰²åè½¬
      excalidrawAPI.updateScene({
        appState: {
          viewBackgroundColor: '#121212',
          gridColor: 'rgba(255, 255, 255, 0.1)',
        }
      })
    } else if (excalidrawAPI && theme === 'light') {
      // æ¢å¤æµ…è‰²èƒŒæ™¯
      excalidrawAPI.updateScene({
        appState: {
          viewBackgroundColor: '#ffffff',
          gridColor: 'rgba(0, 0, 0, 0.1)',
        }
      })
    }
  }, [excalidrawAPI, theme])

  const addImageToExcalidraw = useCallback(
    async (imageElement: ExcalidrawImageElement, file: BinaryFileData) => {
      if (!excalidrawAPI) return

      // è·å–å½“å‰ç”»å¸ƒå…ƒç´ ä»¥ä¾¿æ·»åŠ æ–°å…ƒç´ 
      const currentElements = excalidrawAPI.getSceneElements()

      excalidrawAPI.addFiles([file])

      console.log('ğŸ‘‡ Adding new image element to canvas:', imageElement.id)
      console.log('ğŸ‘‡ Image element properties:', {
        id: imageElement.id,
        type: imageElement.type,
        locked: imageElement.locked,
        groupIds: imageElement.groupIds,
        isDeleted: imageElement.isDeleted,
        x: imageElement.x,
        y: imageElement.y,
        width: imageElement.width,
        height: imageElement.height,
      })

      // Ensure image is not locked and can be manipulated
      const unlockedImageElement = {
        ...imageElement,
        locked: false,
        groupIds: [],
        isDeleted: false,
      }

      excalidrawAPI.updateScene({
        elements: [...(currentElements || []), unlockedImageElement],
      })

      localStorage.setItem(
        'excalidraw-last-image-position',
        JSON.stringify(lastImagePosition.current)
      )
    },
    [excalidrawAPI]
  )

  const addVideoEmbed = useCallback(
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async (elementData: any, videoSrc: string) => {
      if (!excalidrawAPI) return

      // Function to create video element with given dimensions
      const createVideoElement = (finalWidth: number, finalHeight: number) => {
        console.log('ğŸ‘‡ Video element properties:', {
          id: elementData.id,
          type: elementData.type,
          locked: elementData.locked,
          groupIds: elementData.groupIds,
          isDeleted: elementData.isDeleted,
          x: elementData.x,
          y: elementData.y,
          width: elementData.width,
          height: elementData.height,
        })

        const videoElements = convertToExcalidrawElements([
          {
            type: 'embeddable',
            id: elementData.id,
            x: elementData.x,
            y: elementData.y,
            width: elementData.width,
            height: elementData.height,
            link: videoSrc,
            // æ·»åŠ å¿…éœ€çš„åŸºæœ¬æ ·å¼å±æ€§
            strokeColor: '#000000',
            backgroundColor: 'transparent',
            fillStyle: 'solid',
            strokeWidth: 1,
            strokeStyle: 'solid',
            roundness: null,
            roughness: 1,
            opacity: 100,
            // æ·»åŠ å¿…éœ€çš„å˜æ¢å±æ€§
            angle: 0,
            seed: Math.random(),
            version: 1,
            versionNonce: Math.random(),
            // æ·»åŠ å¿…éœ€çš„çŠ¶æ€å±æ€§
            locked: false,
            isDeleted: false,
            groupIds: [],
            // æ·»åŠ ç»‘å®šæ¡†å±æ€§
            boundElements: [],
            updated: Date.now(),
            // æ·»åŠ å¿…éœ€çš„ç´¢å¼•å’Œå¸§IDå±æ€§
            frameId: null,
            index: null, // æ·»åŠ ç¼ºå¤±çš„indexå±æ€§
            // æ·»åŠ è‡ªå®šä¹‰æ•°æ®å±æ€§
            customData: {},
          },
        ])

        console.log('ğŸ‘‡ Converted video elements:', videoElements)

        const currentElements = excalidrawAPI.getSceneElements()
        const newElements = [...currentElements, ...videoElements]

        console.log(
          'ğŸ‘‡ Updating scene with elements count:',
          newElements.length
        )

        excalidrawAPI.updateScene({
          elements: newElements,
        })

        console.log(
          'ğŸ‘‡ Added video embed element:',
          videoSrc,
          `${elementData.width}x${elementData.height}`
        )
      }

      // If dimensions are provided, use them directly
      if (elementData.width && elementData.height) {
        createVideoElement(elementData.width, elementData.height)
        return
      }

      // Otherwise, try to get video's natural dimensions
      const video = document.createElement('video')
      video.crossOrigin = 'anonymous'

      video.onloadedmetadata = () => {
        const videoWidth = video.videoWidth
        const videoHeight = video.videoHeight

        if (videoWidth && videoHeight) {
          // Scale down if video is too large (max 800px width)
          const maxWidth = 800
          let finalWidth = videoWidth
          let finalHeight = videoHeight

          if (videoWidth > maxWidth) {
            const scale = maxWidth / videoWidth
            finalWidth = maxWidth
            finalHeight = videoHeight * scale
          }

          createVideoElement(finalWidth, finalHeight)
        } else {
          // Fallback to default dimensions
          createVideoElement(320, 180)
        }
      }

      video.onerror = () => {
        console.warn('Could not load video metadata, using default dimensions')
        createVideoElement(320, 180)
      }

      video.src = videoSrc
    },
    [excalidrawAPI]
  )

  const renderEmbeddable = useCallback(
    (element: NonDeleted<ExcalidrawEmbeddableElement>, appState: AppState) => {
      const { link } = element

      // Check if this is a video URL
      if (
        link &&
        (link.includes('.mp4') ||
          link.includes('.webm') ||
          link.includes('.ogg') ||
          link.startsWith('blob:') ||
          link.includes('video'))
      ) {
        // Return the VideoPlayer component
        return (
          <VideoElement
            src={link}
            width={element.width}
            height={element.height}
          />
        )
      }

      console.log('ğŸ‘‡ Not a video URL, returning null for:', link)
      // Return null for non-video embeds to use default rendering
      return null
    },
    []
  )

  const handleImageGenerated = useCallback(
    (imageData: ISocket.SessionImageGeneratedEvent) => {
      console.log('ğŸ‘‡ CanvasExcali received image_generated:', imageData)

      // Only handle if it's for this canvas
      if (imageData.canvas_id !== canvasId) {
        console.log('ğŸ‘‡ Image not for this canvas, ignoring')
        return
      }

      // Check if this is actually a video generation event that got mislabeled
      if (imageData.file?.mimeType?.startsWith('video/')) {
        console.log(
          'ğŸ‘‡ This appears to be a video, not an image. Ignoring in image handler.'
        )
        return
      }

      addImageToExcalidraw(imageData.element, imageData.file)
    },
    [addImageToExcalidraw, canvasId]
  )

  const handleVideoGenerated = useCallback(
    (videoData: ISocket.SessionVideoGeneratedEvent) => {
      console.log('ğŸ‘‡ CanvasExcali received video_generated:', videoData)

      // Only handle if it's for this canvas
      if (videoData.canvas_id !== canvasId) {
        console.log('ğŸ‘‡ Video not for this canvas, ignoring')
        return
      }

      // Create video embed element using the video URL
      addVideoEmbed(videoData.element, videoData.video_url)
    },
    [addVideoEmbed, canvasId]
  )

  useEffect(() => {
    eventBus.on('Socket::Session::ImageGenerated', handleImageGenerated)
    eventBus.on('Socket::Session::VideoGenerated', handleVideoGenerated)
    return () => {
      eventBus.off('Socket::Session::ImageGenerated', handleImageGenerated)
      eventBus.off('Socket::Session::VideoGenerated', handleVideoGenerated)
    }
  }, [handleImageGenerated, handleVideoGenerated])

  return (
    <Excalidraw
      theme={customTheme as Theme}
      langCode={i18n.language}
      className={excalidrawClassName}
      excalidrawAPI={(api) => {
        setExcalidrawAPI(api)
      }}
      onChange={handleChange}
      initialData={() => {
        const data = initialData
        console.log('ğŸ‘‡initialData', data)
        if (data?.appState) {
          data.appState = {
            ...data.appState,
            collaborators: undefined!,
          }
        }
        return data || null
      }}
      renderEmbeddable={renderEmbeddable}
      // Allow all URLs for embeddable content
      validateEmbeddable={(url: string) => {
        console.log('ğŸ‘‡ Validating embeddable URL:', url)
        // Allow all URLs - return true for everything
        return true
      }}
      // Ensure interactive mode is enabled
      viewModeEnabled={false}
      zenModeEnabled={false}
      // Allow element manipulation
      onPointerUpdate={(payload) => {
        // Minimal logging - only log significant pointer events
        if (payload.button === 'down' && Math.random() < 0.05) {
          // console.log('ğŸ‘‡ Pointer down on:', payload.pointer.x, payload.pointer.y)
        }
      }}
    />
  )
}

export { CanvasExcali }
export default CanvasExcali



================================================
FILE: react/src/components/canvas/CanvasExport.tsx
================================================
import { useCanvas } from '@/contexts/canvas'
import { saveAs } from 'file-saver'
import JSZip from 'jszip'
import { ImageDown } from 'lucide-react'
import { useTranslation } from 'react-i18next'
import { toast } from 'sonner'
import { Button } from '../ui/button'


const CanvasExport = () => {
  const { excalidrawAPI } = useCanvas()
  const { t } = useTranslation()

  const downloadImage = async (imageUrl: string): Promise<string> => {
    const image = new Image()
    image.src = imageUrl
    return new Promise((resolve, reject) => {
      image.onload = () => {
        const canvas = document.createElement('canvas')
        canvas.width = image.width
        canvas.height = image.height
        const ctx = canvas.getContext('2d')
        ctx?.drawImage(image, 0, 0)
        const dataURL = canvas.toDataURL('image/png')
        resolve(dataURL)
      }
      image.onerror = () => {
        reject(new Error('Failed to load image'))
      }
    })
  }

  const handleExportImages = async () => {
    if (!excalidrawAPI) return
    const toastId = toast.loading(t('canvas:messages.exportingAssets'))
    try {
      const appState = excalidrawAPI.getAppState()
      const elements = excalidrawAPI.getSceneElements()

      const selectedIds = Object.keys(appState.selectedElementIds).filter(
        (id) => appState.selectedElementIds[id]
      )

      const images = elements.filter(
        (element) =>
          selectedIds.includes(element.id) && 
          (element.type === 'image' || element.type === 'embeddable')
      )

      if (images.length === 0) {
        toast.error(t('canvas:messages.nothingSelected'))
        return
      }

      const files = excalidrawAPI.getFiles()

      // Separate embeddable elements (videos) and regular images
      const embeddableElements = images.filter(element => element.type === 'embeddable')
      const imageElements = images.filter(element => element.type === 'image')

      // Get video URLs from embeddable elements
      const videoUrls = embeddableElements
        .map((element) => {
          if ('link' in element && element.link) {
            return element.link
          }
          return null
        })
        .filter((url) => url !== null)

      // Get image URLs from regular image elements
      const imageUrls = imageElements
        .map((element) => {
          if ('fileId' in element && element.fileId) {
            const file = files[element.fileId]
            return file?.dataURL
          }
          return null
        })
        .filter((url) => url !== null)

      if (imageUrls.length === 0 && videoUrls.length === 0) {
        toast.error(t('canvas:messages.nothingSelected'))
        return
      }
      
      // Generate random ID for the asset package
      const randomId = Math.random().toString(36).substring(2, 15)
      const packageName = `Asset-${randomId}.zip`

      // If only one image and no videos, save directly
      if (imageUrls.length === 1 && videoUrls.length === 0) {
        const imageUrl = imageUrls[0]
        const dataURL = await downloadImage(imageUrl)
        saveAs(dataURL, `Asset-${randomId}.png`)
        return
      }

      // If only one video and no images, save directly
      if (videoUrls.length === 1 && imageUrls.length === 0) {
        const videoUrl = videoUrls[0]
        const response = await fetch(videoUrl)
        const blob = await response.blob()
        saveAs(blob, `Asset-${randomId}.mp4`)
        return
      }

      // Create a zip package for multiple assets or mixed types
      const zip = new JSZip()
      
      // Add videos to zip
      await Promise.all(
        videoUrls.map(async (videoUrl, index) => {
          const response = await fetch(videoUrl)
          const blob = await response.blob()
          zip.file(`video-${index + 1}.mp4`, blob)
        })
      )

      // Add images to zip
      await Promise.all(
        imageUrls.map(async (imageUrl, index) => {
          const dataURL = await downloadImage(imageUrl)
          if (dataURL) {
            zip.file(
              `image-${index + 1}.png`,
              dataURL.replace('data:image/png;base64,', ''),
              { base64: true }
            )
          }
        })
      )

      const content = await zip.generateAsync({ type: 'blob' })
      saveAs(content, packageName)
    } catch (error) {
      toast.error(t('canvas:messages.failedToExportImages'), {
        id: toastId,
      })
    } finally {
      toast.dismiss(toastId)
    }
  }

  return (
    <div className="inline-flex -space-x-px rounded-md shadow-xs rtl:space-x-reverse">
      <Button
        className="rounded-none shadow-none first:rounded-s-md last:rounded-e-md h-8"
        variant="outline"
        onClick={handleExportImages}
      >
        <ImageDown />
        {t('canvas:exportImages')}
      </Button>
    </div>
  )
}

export default CanvasExport



================================================
FILE: react/src/components/canvas/CanvasHeader.tsx
================================================
import { Input } from '@/components/ui/input'
import CanvasExport from './CanvasExport'
import TopMenu from '../TopMenu'

type CanvasHeaderProps = {
  canvasName: string
  canvasId: string
  onNameChange: (name: string) => void
  onNameSave: () => void
}

const CanvasHeader: React.FC<CanvasHeaderProps> = ({
  canvasName,
  canvasId,
  onNameChange,
  onNameSave,
}) => {
  return (
    <TopMenu
      middle={
        <Input
          className="text-sm text-muted-foreground text-center bg-transparent border-none shadow-none w-fit h-7 hover:bg-primary-foreground transition-all"
          value={canvasName}
          onChange={(e) => onNameChange(e.target.value)}
          onBlur={onNameSave}
        />
      }
      right={<CanvasExport />}
    />
  )
}

export default CanvasHeader



================================================
FILE: react/src/components/canvas/VideoElement.tsx
================================================
[Binary file]


================================================
FILE: react/src/components/canvas/menu/CanvasMenuButton.tsx
================================================
import { Button } from '@/components/ui/button'
import {
  Tooltip,
  TooltipContent,
  TooltipTrigger,
} from '@/components/ui/tooltip'
import { cn } from '@/lib/utils'
import React from 'react'
import { useTranslation } from 'react-i18next'
import icons, { toolShortcuts, ToolType } from './CanvasMenuIcon'

type CanvasMenuButtonProps = {
  type: ToolType
  active?: boolean
  activeTool?: ToolType
  onClick?: () => void
}

const CanvasMenuButton = ({
  type,
  active,
  activeTool,
  onClick,
}: CanvasMenuButtonProps) => {
  const { t } = useTranslation()
  const isActive = activeTool === type || active

  return (
    <Tooltip>
      <TooltipTrigger asChild>
        <Button
          variant="ghost"
          size="icon"
          className={cn(
            'p-2 rounded-md cursor-pointer hover:bg-primary/5',
            isActive && 'bg-primary/10'
          )}
          onMouseDown={(e) => {
            e.preventDefault()
            onClick?.()
          }}
        >
          {React.createElement(icons[type], {
            className: 'size-4',
          })}
        </Button>
      </TooltipTrigger>
      <TooltipContent>
        {t(`canvas:tool.${type}`)} ({toolShortcuts[type]})
      </TooltipContent>
    </Tooltip>
  )
}

export default CanvasMenuButton



================================================
FILE: react/src/components/canvas/menu/CanvasMenuIcon.tsx
================================================
import { ToolType as ExcalidrawToolType } from '@excalidraw/excalidraw/types'
import {
  ArrowUpRight,
  Circle,
  Hand,
  Image,
  Link,
  Minus,
  MousePointer2,
  Pencil,
  Square,
  Type,
} from 'lucide-react'

export type ToolType = Extract<
  ExcalidrawToolType,
  | 'hand'
  | 'selection'
  | 'rectangle'
  | 'ellipse'
  | 'arrow'
  | 'line'
  | 'freedraw'
  | 'text'
  | 'image'
  | 'embeddable'
  | 'lock'
>

const icons: Record<ToolType, React.ComponentType<{ className?: string }>> = {
  hand: Hand,
  selection: MousePointer2,
  rectangle: Square,
  ellipse: Circle,
  arrow: ArrowUpRight,
  line: Minus,
  freedraw: Pencil,
  text: Type,
  image: Image,
  embeddable: Link,
}

export const toolShortcuts: Record<ToolType, string> = {
  hand: 'H',
  selection: 'V',
  rectangle: 'R',
  ellipse: 'O',
  arrow: 'A',
  line: 'L',
  freedraw: 'P',
  text: 'T',
  image: '9',
  embeddable: '',
}

export default icons



================================================
FILE: react/src/components/canvas/menu/CanvasToolMenu.tsx
================================================
import { Separator } from '@/components/ui/separator'
import { useCanvas } from '@/contexts/canvas'
import { useState } from 'react'
import CanvasMenuButton from './CanvasMenuButton'
import { ToolType } from './CanvasMenuIcon'

const CanvasToolMenu = () => {
  const { excalidrawAPI } = useCanvas()

  const [activeTool, setActiveTool] = useState<ToolType | undefined>(undefined)

  const handleToolChange = (tool: ToolType) => {
    excalidrawAPI?.setActiveTool({ type: tool })
  }

  excalidrawAPI?.onChange((_elements, appState, _files) => {
    setActiveTool(appState.activeTool.type as ToolType)
  })

  const tools: (ToolType | null)[] = [
    'hand',
    'selection',
    null,
    'rectangle',
    'ellipse',
    'arrow',
    'line',
    'freedraw',
    null,
    'text',
    'image',
  ]

  return (
    <div className="absolute bottom-5 left-1/2 -translate-x-1/2 z-20 flex items-center gap-1 bg-primary-foreground/75 backdrop-blur-lg rounded-lg p-1 shadow-[0_5px_10px_rgba(0,0,0,0.08)] border border-primary/10">
      {tools.map((tool, index) =>
        tool ? (
          <CanvasMenuButton
            key={tool}
            type={tool}
            activeTool={activeTool}
            onClick={() => handleToolChange(tool)}
          />
        ) : (
          <Separator
            key={index}
            orientation="vertical"
            className="h-6! bg-primary/5"
          />
        )
      )}
    </div>
  )
}

export default CanvasToolMenu



================================================
FILE: react/src/components/canvas/menu/CanvasViewMenu.tsx
================================================
import { Button } from '@/components/ui/button'
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu'
import { useCanvas } from '@/contexts/canvas'
import { cn } from '@/lib/utils'
import { Minus, Plus } from 'lucide-react'
import { useState } from 'react'
import { useTranslation } from 'react-i18next'

const CanvasViewMenu = () => {
  const { t } = useTranslation()
  const { excalidrawAPI } = useCanvas()

  const [currentZoom, setCurrentZoom] = useState<number>(100)

  const handleZoomChange = (zoom: number) => {
    excalidrawAPI?.updateScene({
      appState: {
        zoom: {
          // @ts-ignore
          value: zoom / 100,
        },
      },
    })
  }

  const handleZoomFit = () => {
    excalidrawAPI?.scrollToContent(undefined, {
      fitToContent: true,
      animate: true,
    })
  }

  excalidrawAPI?.onChange((_elements, appState, _files) => {
    const zoom = (appState.zoom.value * 100).toFixed(0)
    setCurrentZoom(Number(zoom))
  })

  return (
    <div
      className={cn(
        'absolute top-2 right-2 flex items-center gap-1 rounded-lg p-1 z-20 transition-all duration-300 select-none text-primary/70',
        'hover:bg-primary-foreground/55 hover:backdrop-blur-lg hover:text-primary'
      )}
    >
      <Button
        className="size-8"
        variant="ghost"
        size="icon"
        onClick={() => handleZoomChange(currentZoom - 10)}
      >
        <Minus />
      </Button>
      <DropdownMenu>
        <DropdownMenuTrigger asChild>
          <span className="text-sm w-10 text-center">{currentZoom}%</span>
        </DropdownMenuTrigger>
        <DropdownMenuContent>
          {[10, 50, 100, 150, 200].map((zoom) => (
            <DropdownMenuItem key={zoom} onClick={() => handleZoomChange(zoom)}>
              {zoom}%
            </DropdownMenuItem>
          ))}
          <DropdownMenuSeparator />
          <DropdownMenuItem onClick={handleZoomFit}>
            {t('canvas:tool.zoomFit')}
          </DropdownMenuItem>
        </DropdownMenuContent>
      </DropdownMenu>
      <Button
        className="size-8"
        variant="ghost"
        size="icon"
        onClick={() => handleZoomChange(currentZoom + 10)}
      >
        <Plus />
      </Button>
    </div>
  )
}

export default CanvasViewMenu



================================================
FILE: react/src/components/canvas/menu/index.tsx
================================================
import CanvasToolMenu from './CanvasToolMenu'
import CanvasViewMenu from './CanvasViewMenu'

const CanvasMenu = () => {
  return (
    <>
      <CanvasToolMenu />
      <CanvasViewMenu />
    </>
  )
}

export default CanvasMenu



================================================
FILE: react/src/components/canvas/pop-bar/CanvasMagicGenerator.tsx
================================================
import { Button } from '@/components/ui/button'
import { Hotkey } from '@/components/ui/hotkey'
import { useCanvas } from '@/contexts/canvas'
import { eventBus, TCanvasAddImagesToChatEvent } from '@/lib/event'
import { useKeyPress } from 'ahooks'
import { motion } from 'motion/react'
import { memo } from 'react'
import { useTranslation } from 'react-i18next'
import { exportToCanvas } from "@excalidraw/excalidraw";
import { OrderedExcalidrawElement } from '@excalidraw/excalidraw/element/types'
import { toast } from 'sonner'

type CanvasMagicGeneratorProps = {
    selectedImages: TCanvasAddImagesToChatEvent
    selectedElements: OrderedExcalidrawElement[]
}

const CanvasMagicGenerator = ({ selectedImages, selectedElements }: CanvasMagicGeneratorProps) => {
    const { t } = useTranslation()
    const { excalidrawAPI } = useCanvas()

    const handleMagicGenerate = async () => {
        if (!excalidrawAPI) return;

        // è·å–é€‰ä¸­çš„å…ƒç´ 
        const appState = excalidrawAPI.getAppState();
        const selectedIds = appState.selectedElementIds;
        if (Object.keys(selectedIds).length === 0) {
            console.log('æ²¡æœ‰é€‰ä¸­ä»»ä½•å…ƒç´ ');
            return;
        }

        const files = excalidrawAPI.getFiles();

        // ä½¿ç”¨å®˜æ–¹SDKå¯¼å‡ºcanvas
        const canvas = await exportToCanvas({
            elements: selectedElements,
            appState: {
                ...appState,
                selectedElementIds: selectedIds,
            },
            files,
            mimeType: 'image/png',
            maxWidthOrHeight: 2048,
            quality: 1,
        });

        // è½¬base64
        const base64 = canvas.toDataURL('image/png', 0.8);

        // å‘é€é­”æ³•ç”Ÿæˆäº‹ä»¶
        eventBus.emit('Canvas::MagicGenerate', {
            fileId: `magic-${Date.now()}`,
            base64: base64,
            width: canvas.width,
            height: canvas.height,
            timestamp: new Date().toISOString(),
        });

        // æ¸…é™¤é€‰ä¸­çŠ¶æ€
        excalidrawAPI?.updateScene({
            appState: { selectedElementIds: {} },
        })
    }

    useKeyPress(['meta.b', 'ctrl.b'], handleMagicGenerate)

    return (
        <Button variant="ghost" size="sm" onClick={handleMagicGenerate}>
            {t('canvas:popbar.magicGenerate')} <Hotkey keys={['âŒ˜', 'B']} />
        </Button>
    )
}

export default memo(CanvasMagicGenerator)



================================================
FILE: react/src/components/canvas/pop-bar/CanvasPopbar.tsx
================================================
import { Button } from '@/components/ui/button'
import { Hotkey } from '@/components/ui/hotkey'
import { useCanvas } from '@/contexts/canvas'
import { eventBus, TCanvasAddImagesToChatEvent } from '@/lib/event'
import { useKeyPress } from 'ahooks'
import { motion } from 'motion/react'
import { memo } from 'react'
import { useTranslation } from 'react-i18next'

type CanvasPopbarProps = {
  selectedImages: TCanvasAddImagesToChatEvent
}

const CanvasPopbar = ({ selectedImages }: CanvasPopbarProps) => {
  const { t } = useTranslation()
  const { excalidrawAPI } = useCanvas()

  const handleAddToChat = () => {
    eventBus.emit('Canvas::AddImagesToChat', selectedImages)
    excalidrawAPI?.updateScene({
      appState: { selectedElementIds: {} },
    })
  }

  useKeyPress(['meta.enter', 'ctrl.enter'], handleAddToChat)

  return (
    <Button variant="ghost" size="sm" onClick={handleAddToChat}>
      {t('canvas:popbar.addToChat')} <Hotkey keys={['âŒ˜', 'â†©ï¸']} />
    </Button>
  )
}

export default memo(CanvasPopbar)



================================================
FILE: react/src/components/canvas/pop-bar/CanvasPopbarContainer.tsx
================================================
import { useCanvas } from '@/contexts/canvas'
import { TCanvasAddImagesToChatEvent } from '@/lib/event'
import { motion } from 'motion/react'
import { memo } from 'react'
import { OrderedExcalidrawElement } from '@excalidraw/excalidraw/element/types'
import CanvasMagicGenerator from './CanvasMagicGenerator'
import CanvasPopbar from './CanvasPopbar'

type CanvasPopbarContainerProps = {
    pos: { x: number; y: number }
    selectedImages: TCanvasAddImagesToChatEvent
    selectedElements: OrderedExcalidrawElement[]
    showAddToChat: boolean
    showMagicGenerate: boolean
}

const CanvasPopbarContainer = ({
    pos,
    selectedImages,
    selectedElements,
    showAddToChat,
    showMagicGenerate
}: CanvasPopbarContainerProps) => {

    return (
        <motion.div
            initial={{ opacity: 0, y: -3 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -3 }}
            transition={{ duration: 0.2, ease: 'easeInOut' }}
            className="absolute z-20 flex items-center gap-1 -translate-x-1/2 "
            style={{
                left: `${pos.x}px`,
                top: `${pos.y + 5}px`,
            }}
        >
            <div className="flex items-center gap-1 bg-primary-foreground/75 backdrop-blur-lg rounded-lg p-1 shadow-[0_5px_10px_rgba(0,0,0,0.08)] border border-primary/10 pointer-events-auto">
                {showAddToChat && (
                    <CanvasPopbar selectedImages={selectedImages} />
                )}
                {showMagicGenerate && (
                    <CanvasMagicGenerator selectedImages={selectedImages} selectedElements={selectedElements} />
                )}
            </div>
        </motion.div>
    )
}

export default memo(CanvasPopbarContainer) 


================================================
FILE: react/src/components/canvas/pop-bar/index.tsx
================================================
import { useCanvas } from '@/contexts/canvas'
import { TCanvasAddImagesToChatEvent } from '@/lib/event'
import {
  ExcalidrawImageElement,
  OrderedExcalidrawElement,
} from '@excalidraw/excalidraw/element/types'
import { AnimatePresence } from 'motion/react'
import { useRef, useState } from 'react'
import CanvasPopbarContainer from './CanvasPopbarContainer'

const CanvasPopbarWrapper = () => {
  const { excalidrawAPI } = useCanvas()

  const [pos, setPos] = useState<{ x: number; y: number } | null>(null)
  const [showAddToChat, setShowAddToChat] = useState(false)
  const [showMagicGenerate, setShowMagicGenerate] = useState(false)

  const selectedImagesRef = useRef<TCanvasAddImagesToChatEvent>([])
  const selectedElementsRef = useRef<OrderedExcalidrawElement[]>([])

  excalidrawAPI?.onChange((elements, appState, files) => {
    const selectedIds = appState.selectedElementIds
    if (Object.keys(selectedIds).length === 0) {
      setPos(null)
      setShowAddToChat(false)
      setShowMagicGenerate(false)
      return
    }

    const selectedImages = elements.filter(
      (element) => element.type === 'image' && selectedIds[element.id]
    ) as ExcalidrawImageElement[]

    // åˆ¤æ–­æ˜¯å¦æ˜¾ç¤ºæ·»åŠ åˆ°å¯¹è¯æŒ‰é’®ï¼šé€‰ä¸­å›¾ç‰‡å…ƒç´ 
    const hasSelectedImages = selectedImages.length > 0
    setShowAddToChat(hasSelectedImages)

    // åˆ¤æ–­æ˜¯å¦æ˜¾ç¤ºé­”æ³•ç”ŸæˆæŒ‰é’®ï¼šé€‰ä¸­2ä¸ªä»¥ä¸Šå…ƒç´ ï¼ˆåŒ…å«æ‰€æœ‰ç±»å‹ï¼‰
    const selectedCount = Object.keys(selectedIds).length
    setShowMagicGenerate(selectedCount >= 2)

    // å¦‚æœæ—¢æ²¡æœ‰é€‰ä¸­å›¾ç‰‡ï¼Œä¹Ÿæ²¡æœ‰æ»¡è¶³é­”æ³•ç”Ÿæˆæ¡ä»¶ï¼Œéšè—å¼¹çª—
    if (!hasSelectedImages && selectedCount < 2) {
      setPos(null)
      return
    }

    // å¤„ç†é€‰ä¸­çš„å›¾ç‰‡æ•°æ®
    selectedImagesRef.current = selectedImages
      .filter((image) => image.fileId)
      .map((image) => {
        const file = files[image.fileId!]
        const isBase64 = file.dataURL.startsWith('data:')
        const id = isBase64 ? file.id : file.dataURL.split('/').at(-1)!
        return {
          fileId: id,
          base64: isBase64 ? file.dataURL : undefined,
          width: image.width,
          height: image.height,
        }
      })

    // å¤„ç†é€‰ä¸­çš„å…ƒç´ æ•°æ®
    selectedElementsRef.current = elements.filter(
      (element) => selectedIds[element.id] && element.index !== null
    ) as OrderedExcalidrawElement[]

    // è®¡ç®—ä½ç½®ï¼šå¦‚æœæœ‰å›¾ç‰‡ï¼ŒåŸºäºå›¾ç‰‡ï¼›å¦åˆ™åŸºäºæ‰€æœ‰é€‰ä¸­çš„å…ƒç´ 
    let centerX: number
    let bottomY: number

    if (hasSelectedImages) {
      // åŸºäºé€‰ä¸­çš„å›¾ç‰‡è®¡ç®—ä½ç½®
      centerX =
        selectedImages.reduce((acc, image) => acc + image.x + image.width / 2, 0) /
        selectedImages.length

      bottomY = selectedImages.reduce(
        (acc, image) => Math.max(acc, image.y + image.height),
        Number.NEGATIVE_INFINITY
      )
    } else {
      // åŸºäºæ‰€æœ‰é€‰ä¸­çš„å…ƒç´ è®¡ç®—ä½ç½®
      const selectedElements = elements.filter((element) => selectedIds[element.id])

      centerX =
        selectedElements.reduce(
          (acc, element) => acc + element.x + (element.width || 0) / 2,
          0
        ) / selectedElements.length

      bottomY = selectedElements.reduce(
        (acc, element) => Math.max(acc, element.y + (element.height || 0)),
        Number.NEGATIVE_INFINITY
      )
    }

    const scrollX = appState.scrollX
    const scrollY = appState.scrollY
    const zoom = appState.zoom.value
    const offsetX = (scrollX + centerX) * zoom
    const offsetY = (scrollY + bottomY) * zoom
    setPos({ x: offsetX, y: offsetY })
    // console.log(offsetX, offsetY)
  })

  return (
    <div className='absolute left-0 bottom-0 w-full h-full z-20 pointer-events-none'>
      <AnimatePresence>
        {pos && (showAddToChat || showMagicGenerate) && (
          <CanvasPopbarContainer
            pos={pos}
            selectedImages={selectedImagesRef.current}
            selectedElements={selectedElementsRef.current}
            showAddToChat={showAddToChat}
            showMagicGenerate={showMagicGenerate}
          />
        )}
      </AnimatePresence>
    </div>
  )
}

export default CanvasPopbarWrapper



================================================
FILE: react/src/components/chat/Chat.tsx
================================================
import { sendMessages } from '@/api/chat'
import Blur from '@/components/common/Blur'
import { ScrollArea } from '@/components/ui/scroll-area'
import { eventBus, TEvents } from '@/lib/event'
import ChatMagicGenerator from './ChatMagicGenerator'
import {
  AssistantMessage,
  Message,
  Model,
  PendingType,
  Session,
} from '@/types/types'
import { useSearch } from '@tanstack/react-router'
import { produce } from 'immer'
import { motion } from 'motion/react'
import { nanoid } from 'nanoid'
import {
  Dispatch,
  SetStateAction,
  useCallback,
  useEffect,
  useRef,
  useState,
} from 'react'
import { useTranslation } from 'react-i18next'
import { PhotoProvider } from 'react-photo-view'
import { toast } from 'sonner'
import ShinyText from '../ui/shiny-text'
import ChatTextarea from './ChatTextarea'
import MessageRegular from './Message/Regular'
import { ToolCallContent } from './Message/ToolCallContent'
import ToolCallTag from './Message/ToolCallTag'
import SessionSelector from './SessionSelector'
import ChatSpinner from './Spinner'
import ToolcallProgressUpdate from './ToolcallProgressUpdate'
import ShareTemplateDialog from './ShareTemplateDialog'

import { useConfigs } from '@/contexts/configs'
import 'react-photo-view/dist/react-photo-view.css'
import { DEFAULT_SYSTEM_PROMPT } from '@/constants'
import { ModelInfo, ToolInfo } from '@/api/model'
import { Button } from '@/components/ui/button'
import { Share2 } from 'lucide-react'
import { useAuth } from '@/contexts/AuthContext'
import { useQueryClient } from '@tanstack/react-query'
import MixedContent, { MixedContentImages, MixedContentText } from './Message/MixedContent'


type ChatInterfaceProps = {
  canvasId: string
  sessionList: Session[]
  setSessionList: Dispatch<SetStateAction<Session[]>>
  sessionId: string
}

const ChatInterface: React.FC<ChatInterfaceProps> = ({
  canvasId,
  sessionList,
  setSessionList,
  sessionId: searchSessionId,
}) => {
  const { t } = useTranslation()
  const [session, setSession] = useState<Session | null>(null)
  const { initCanvas, setInitCanvas } = useConfigs()
  const { authStatus } = useAuth()
  const [showShareDialog, setShowShareDialog] = useState(false)
  const queryClient = useQueryClient()

  useEffect(() => {
    if (sessionList.length > 0) {
      let _session = null
      if (searchSessionId) {
        _session = sessionList.find((s) => s.id === searchSessionId) || null
      } else {
        _session = sessionList[0]
      }
      setSession(_session)
    } else {
      setSession(null)
    }
  }, [sessionList, searchSessionId])

  const [messages, setMessages] = useState<Message[]>([])
  const [pending, setPending] = useState<PendingType>(
    initCanvas ? 'text' : false
  )
  const mergedToolCallIds = useRef<string[]>([])

  const sessionId = session?.id ?? searchSessionId

  const sessionIdRef = useRef<string>(session?.id || nanoid())
  const [expandingToolCalls, setExpandingToolCalls] = useState<string[]>([])
  const [pendingToolConfirmations, setPendingToolConfirmations] = useState<
    string[]
  >([])

  const scrollRef = useRef<HTMLDivElement>(null)
  const isAtBottomRef = useRef(false)

  const scrollToBottom = useCallback(() => {
    if (!isAtBottomRef.current) {
      return
    }
    setTimeout(() => {
      scrollRef.current?.scrollTo({
        top: scrollRef.current!.scrollHeight,
        behavior: 'smooth',
      })
    }, 200)
  }, [])

  const mergeToolCallResult = (messages: Message[]) => {
    const messagesWithToolCallResult = messages.map((message, index) => {
      if (message.role === 'assistant' && message.tool_calls) {
        for (const toolCall of message.tool_calls) {
          // From the next message, find the tool call result
          for (let i = index + 1; i < messages.length; i++) {
            const nextMessage = messages[i]
            if (
              nextMessage.role === 'tool' &&
              nextMessage.tool_call_id === toolCall.id
            ) {
              toolCall.result = nextMessage.content
              mergedToolCallIds.current.push(toolCall.id)
            }
          }
        }
      }
      return message
    })

    return messagesWithToolCallResult
  }

  const handleDelta = useCallback(
    (data: TEvents['Socket::Session::Delta']) => {
      if (data.session_id && data.session_id !== sessionId) {
        return
      }

      setPending('text')
      setMessages(
        produce((prev) => {
          const last = prev.at(-1)
          if (
            last?.role === 'assistant' &&
            last.content != null &&
            last.tool_calls == null
          ) {
            if (typeof last.content === 'string') {
              last.content += data.text
            } else if (
              last.content &&
              last.content.at(-1) &&
              last.content.at(-1)!.type === 'text'
            ) {
              ;(last.content.at(-1) as { text: string }).text += data.text
            }
          } else {
            prev.push({
              role: 'assistant',
              content: data.text,
            })
          }
        })
      )
      scrollToBottom()
    },
    [sessionId, scrollToBottom]
  )

  const handleToolCall = useCallback(
    (data: TEvents['Socket::Session::ToolCall']) => {
      if (data.session_id && data.session_id !== sessionId) {
        return
      }

      const existToolCall = messages.find(
        (m) =>
          m.role === 'assistant' &&
          m.tool_calls &&
          m.tool_calls.find((t) => t.id == data.id)
      )

      if (existToolCall) {
        return
      }

      setMessages(
        produce((prev) => {
          console.log('ğŸ‘‡tool_call event get', data)
          setPending('tool')
          prev.push({
            role: 'assistant',
            content: '',
            tool_calls: [
              {
                type: 'function',
                function: {
                  name: data.name,
                  arguments: '',
                },
                id: data.id,
              },
            ],
          })
        })
      )

      setExpandingToolCalls(
        produce((prev) => {
          prev.push(data.id)
        })
      )
    },
    [sessionId]
  )

  const handleToolCallPendingConfirmation = useCallback(
    (data: TEvents['Socket::Session::ToolCallPendingConfirmation']) => {
      if (data.session_id && data.session_id !== sessionId) {
        return
      }

      const existToolCall = messages.find(
        (m) =>
          m.role === 'assistant' &&
          m.tool_calls &&
          m.tool_calls.find((t) => t.id == data.id)
      )

      if (existToolCall) {
        return
      }

      setMessages(
        produce((prev) => {
          console.log('ğŸ‘‡tool_call_pending_confirmation event get', data)
          setPending('tool')
          prev.push({
            role: 'assistant',
            content: '',
            tool_calls: [
              {
                type: 'function',
                function: {
                  name: data.name,
                  arguments: data.arguments,
                },
                id: data.id,
              },
            ],
          })
        })
      )

      setPendingToolConfirmations(
        produce((prev) => {
          prev.push(data.id)
        })
      )

      // è‡ªåŠ¨å±•å¼€éœ€è¦ç¡®è®¤çš„å·¥å…·è°ƒç”¨
      setExpandingToolCalls(
        produce((prev) => {
          if (!prev.includes(data.id)) {
            prev.push(data.id)
          }
        })
      )
    },
    [sessionId]
  )

  const handleToolCallConfirmed = useCallback(
    (data: TEvents['Socket::Session::ToolCallConfirmed']) => {
      if (data.session_id && data.session_id !== sessionId) {
        return
      }

      setPendingToolConfirmations(
        produce((prev) => {
          return prev.filter((id) => id !== data.id)
        })
      )

      setExpandingToolCalls(
        produce((prev) => {
          if (!prev.includes(data.id)) {
            prev.push(data.id)
          }
        })
      )
    },
    [sessionId]
  )

  const handleToolCallCancelled = useCallback(
    (data: TEvents['Socket::Session::ToolCallCancelled']) => {
      if (data.session_id && data.session_id !== sessionId) {
        return
      }

      setPendingToolConfirmations(
        produce((prev) => {
          return prev.filter((id) => id !== data.id)
        })
      )

      // æ›´æ–°å·¥å…·è°ƒç”¨çš„çŠ¶æ€
      setMessages(
        produce((prev) => {
          prev.forEach((msg) => {
            if (msg.role === 'assistant' && msg.tool_calls) {
              msg.tool_calls.forEach((tc) => {
                if (tc.id === data.id) {
                  // æ·»åŠ å–æ¶ˆçŠ¶æ€æ ‡è®°
                  tc.result = 'å·¥å…·è°ƒç”¨å·²å–æ¶ˆ'
                }
              })
            }
          })
        })
      )
    },
    [sessionId]
  )

  const handleToolCallArguments = useCallback(
    (data: TEvents['Socket::Session::ToolCallArguments']) => {
      if (data.session_id && data.session_id !== sessionId) {
        return
      }

      setMessages(
        produce((prev) => {
          setPending('tool')
          const lastMessage = prev.find(
            (m) =>
              m.role === 'assistant' &&
              m.tool_calls &&
              m.tool_calls.find((t) => t.id == data.id)
          ) as AssistantMessage

          if (lastMessage) {
            const toolCall = lastMessage.tool_calls!.find(
              (t) => t.id == data.id
            )
            if (toolCall) {
              // æ£€æŸ¥æ˜¯å¦æ˜¯å¾…ç¡®è®¤çš„å·¥å…·è°ƒç”¨ï¼Œå¦‚æœæ˜¯åˆ™è·³è¿‡å‚æ•°è¿½åŠ 
              if (pendingToolConfirmations.includes(data.id)) {
                return
              }
              toolCall.function.arguments += data.text
            }
          }
        })
      )
      scrollToBottom()
    },
    [sessionId, scrollToBottom, pendingToolConfirmations]
  )

  const handleToolCallResult = useCallback(
    (data: TEvents['Socket::Session::ToolCallResult']) => {
      console.log('ğŸ˜˜ğŸ–¼ï¸tool_call_result event get', data)
      if (data.session_id && data.session_id !== sessionId) {
        return
      }
      // TODO: support other non string types of returning content like image_url
      if (data.message.content) {
        setMessages(
          produce((prev) => {
            prev.forEach((m) => {
              if (m.role === 'assistant' && m.tool_calls) {
                m.tool_calls.forEach((t) => {
                  if (t.id === data.id) {
                    t.result = data.message.content
                  }
                })
              }
            })
          })
        )
      }
    },
    [canvasId, sessionId]
  )

  const handleImageGenerated = useCallback(
    (data: TEvents['Socket::Session::ImageGenerated']) => {
      if (
        data.canvas_id &&
        data.canvas_id !== canvasId &&
        data.session_id !== sessionId
      ) {
        return
      }

      console.log('â­ï¸dispatching image_generated', data)
      setPending('image')
    },
    [canvasId, sessionId]
  )

  const handleAllMessages = useCallback(
    (data: TEvents['Socket::Session::AllMessages']) => {
      if (data.session_id && data.session_id !== sessionId) {
        return
      }

      setMessages(() => {
        console.log('ğŸ‘‡all_messages', data.messages)
        return data.messages
      })
      setMessages(mergeToolCallResult(data.messages))
      scrollToBottom()
    },
    [sessionId, scrollToBottom]
  )

  const handleDone = useCallback(
    (data: TEvents['Socket::Session::Done']) => {
      if (data.session_id && data.session_id !== sessionId) {
        return
      }

      setPending(false)
      scrollToBottom()

      // èŠå¤©è¾“å‡ºå®Œæ¯•åæ›´æ–°ä½™é¢
      if (authStatus.is_logged_in) {
        queryClient.invalidateQueries({ queryKey: ['balance'] })
      }
    },
    [sessionId, scrollToBottom, authStatus.is_logged_in, queryClient]
  )

  const handleError = useCallback((data: TEvents['Socket::Session::Error']) => {
    setPending(false)
    toast.error('Error: ' + data.error, {
      closeButton: true,
      duration: 3600 * 1000,
      style: { color: 'red' },
    })
  }, [])

  const handleInfo = useCallback((data: TEvents['Socket::Session::Info']) => {
    toast.info(data.info, {
      closeButton: true,
      duration: 10 * 1000,
    })
  }, [])

  useEffect(() => {
    const handleScroll = () => {
      if (scrollRef.current) {
        isAtBottomRef.current =
          scrollRef.current.scrollHeight - scrollRef.current.scrollTop <=
          scrollRef.current.clientHeight + 1
      }
    }
    const scrollEl = scrollRef.current
    scrollEl?.addEventListener('scroll', handleScroll)

    eventBus.on('Socket::Session::Delta', handleDelta)
    eventBus.on('Socket::Session::ToolCall', handleToolCall)
    eventBus.on(
      'Socket::Session::ToolCallPendingConfirmation',
      handleToolCallPendingConfirmation
    )
    eventBus.on('Socket::Session::ToolCallConfirmed', handleToolCallConfirmed)
    eventBus.on('Socket::Session::ToolCallCancelled', handleToolCallCancelled)
    eventBus.on('Socket::Session::ToolCallArguments', handleToolCallArguments)
    eventBus.on('Socket::Session::ToolCallResult', handleToolCallResult)
    eventBus.on('Socket::Session::ImageGenerated', handleImageGenerated)
    eventBus.on('Socket::Session::AllMessages', handleAllMessages)
    eventBus.on('Socket::Session::Done', handleDone)
    eventBus.on('Socket::Session::Error', handleError)
    eventBus.on('Socket::Session::Info', handleInfo)
    return () => {
      scrollEl?.removeEventListener('scroll', handleScroll)

      eventBus.off('Socket::Session::Delta', handleDelta)
      eventBus.off('Socket::Session::ToolCall', handleToolCall)
      eventBus.off(
        'Socket::Session::ToolCallPendingConfirmation',
        handleToolCallPendingConfirmation
      )
      eventBus.off(
        'Socket::Session::ToolCallConfirmed',
        handleToolCallConfirmed
      )
      eventBus.off(
        'Socket::Session::ToolCallCancelled',
        handleToolCallCancelled
      )
      eventBus.off(
        'Socket::Session::ToolCallArguments',
        handleToolCallArguments
      )
      eventBus.off('Socket::Session::ToolCallResult', handleToolCallResult)
      eventBus.off('Socket::Session::ImageGenerated', handleImageGenerated)
      eventBus.off('Socket::Session::AllMessages', handleAllMessages)
      eventBus.off('Socket::Session::Done', handleDone)
      eventBus.off('Socket::Session::Error', handleError)
      eventBus.off('Socket::Session::Info', handleInfo)
    }
  })

  const initChat = useCallback(async () => {
    if (!sessionId) {
      return
    }

    sessionIdRef.current = sessionId

    const resp = await fetch('/api/chat_session/' + sessionId)
    const data = await resp.json()
    const msgs = data?.length ? data : []

    setMessages(mergeToolCallResult(msgs))
    if (msgs.length > 0) {
      setInitCanvas(false)
    }

    scrollToBottom()
  }, [sessionId, scrollToBottom, setInitCanvas])

  useEffect(() => {
    initChat()
  }, [sessionId, initChat])

  const onSelectSession = (sessionId: string) => {
    setSession(sessionList.find((s) => s.id === sessionId) || null)
    window.history.pushState(
      {},
      '',
      `/canvas/${canvasId}?sessionId=${sessionId}`
    )
  }

  const onClickNewChat = () => {
    const newSession: Session = {
      id: nanoid(),
      title: t('chat:newChat'),
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
      model: session?.model || 'gpt-4o',
      provider: session?.provider || 'openai',
    }

    setSessionList((prev) => [...prev, newSession])
    onSelectSession(newSession.id)
  }

  const onSendMessages = useCallback(
    (data: Message[], configs: { textModel: Model; toolList: ToolInfo[] }) => {
      setPending('text')
      setMessages(data)

      sendMessages({
        sessionId: sessionId!,
        canvasId: canvasId,
        newMessages: data,
        textModel: configs.textModel,
        toolList: configs.toolList,
        systemPrompt:
          localStorage.getItem('system_prompt') || DEFAULT_SYSTEM_PROMPT,
      })

      if (searchSessionId !== sessionId) {
        window.history.pushState(
          {},
          '',
          `/canvas/${canvasId}?sessionId=${sessionId}`
        )
      }

      scrollToBottom()
    },
    [canvasId, sessionId, searchSessionId, scrollToBottom]
  )

  const handleCancelChat = useCallback(() => {
    setPending(false)
  }, [])

  return (
    <PhotoProvider>
      <div className='flex flex-col h-screen relative'>
        {/* Chat messages */}

        <header className='flex items-center px-2 py-2 absolute top-0 z-1 w-full'>
          <div className='flex-1 min-w-0'>
            <SessionSelector
              session={session}
              sessionList={sessionList}
              onClickNewChat={onClickNewChat}
              onSelectSession={onSelectSession}
            />
          </div>

          {/* Share Template Button */}
          {/* {authStatus.is_logged_in && (
            <Button
              variant="outline"
              size="sm"
              className="ml-2 shrink-0"
              onClick={() => setShowShareDialog(true)}
            >
              <Share2 className="h-4 w-4 mr-1" />
            </Button>
          )} */}

          <Blur className='absolute top-0 left-0 right-0 h-full -z-1' />
        </header>

        <ScrollArea className='h-[calc(100vh-45px)]' viewportRef={scrollRef}>
          {messages.length > 0 ? (
            <div className='flex flex-col flex-1 px-4 pb-50 pt-15'>
              {/* Messages */}
              {messages.map((message, idx) => (
                <div key={`${idx}`} className='flex flex-col gap-4 mb-2'>
                  {/* Regular message content */}
                  {typeof message.content == 'string' &&
                    (message.role !== 'tool' ? (
                      <MessageRegular
                        message={message}
                        content={message.content}
                      />
                    ) : message.tool_call_id &&
                      mergedToolCallIds.current.includes(
                        message.tool_call_id
                      ) ? (
                      <></>
                    ) : (
                      <ToolCallContent
                        expandingToolCalls={expandingToolCalls}
                        message={message}
                      />
                    ))}

                  {/* æ··åˆå†…å®¹æ¶ˆæ¯çš„æ–‡æœ¬éƒ¨åˆ† - æ˜¾ç¤ºåœ¨èŠå¤©æ¡†å†… */}
                  {Array.isArray(message.content) && (
                    <>
                      <MixedContentImages
                        contents={message.content}
                      />
                      <MixedContentText
                        message={message}
                        contents={message.content}
                      />
                    </>
                  )}

                  {message.role === 'assistant' &&
                    message.tool_calls &&
                    message.tool_calls.at(-1)?.function.name != 'finish' &&
                    message.tool_calls.map((toolCall, i) => {
                      return (
                        <ToolCallTag
                          key={toolCall.id}
                          toolCall={toolCall}
                          isExpanded={expandingToolCalls.includes(toolCall.id)}
                          onToggleExpand={() => {
                            if (expandingToolCalls.includes(toolCall.id)) {
                              setExpandingToolCalls((prev) =>
                                prev.filter((id) => id !== toolCall.id)
                              )
                            } else {
                              setExpandingToolCalls((prev) => [
                                ...prev,
                                toolCall.id,
                              ])
                            }
                          }}
                          requiresConfirmation={pendingToolConfirmations.includes(
                            toolCall.id
                          )}
                          onConfirm={() => {
                            // å‘é€ç¡®è®¤äº‹ä»¶åˆ°åç«¯
                            fetch('/api/tool_confirmation', {
                              method: 'POST',
                              headers: {
                                'Content-Type': 'application/json',
                              },
                              body: JSON.stringify({
                                session_id: sessionId,
                                tool_call_id: toolCall.id,
                                confirmed: true,
                              }),
                            })
                          }}
                          onCancel={() => {
                            // å‘é€å–æ¶ˆäº‹ä»¶åˆ°åç«¯
                            fetch('/api/tool_confirmation', {
                              method: 'POST',
                              headers: {
                                'Content-Type': 'application/json',
                              },
                              body: JSON.stringify({
                                session_id: sessionId,
                                tool_call_id: toolCall.id,
                                confirmed: false,
                              }),
                            })
                          }}
                        />
                      )
                    })}
                </div>
              ))}
              {pending && <ChatSpinner pending={pending} />}
              {pending && sessionId && (
                <ToolcallProgressUpdate sessionId={sessionId} />
              )}
            </div>
          ) : (
            <motion.div className='flex flex-col h-full p-4 items-start justify-start pt-16 select-none'>
              <motion.span
                initial={{ opacity: 0, y: 10 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ duration: 0.5 }}
                className='text-muted-foreground text-3xl'
              >
                <ShinyText text='Hello, Jaaz!' />
              </motion.span>
              <motion.span
                initial={{ opacity: 0, y: 10 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ duration: 0.6 }}
                className='text-muted-foreground text-2xl'
              >
                <ShinyText text='How can I help you today?' />
              </motion.span>
            </motion.div>
          )}
        </ScrollArea>

        <div className='p-2 gap-2 sticky bottom-0'>
          <ChatTextarea
            sessionId={sessionId!}
            pending={!!pending}
            messages={messages}
            onSendMessages={onSendMessages}
            onCancelChat={handleCancelChat}
          />

          {/* é­”æ³•ç”Ÿæˆç»„ä»¶ */}
          <ChatMagicGenerator
            sessionId={sessionId || ''}
            canvasId={canvasId}
            messages={messages}
            setMessages={setMessages}
            setPending={setPending}
            scrollToBottom={scrollToBottom}
          />
        </div>
      </div>

      {/* Share Template Dialog */}
      <ShareTemplateDialog
        open={showShareDialog}
        onOpenChange={setShowShareDialog}
        canvasId={canvasId}
        sessionId={sessionId || ''}
        messages={messages}
      />
    </PhotoProvider>
  )
}

export default ChatInterface



================================================
FILE: react/src/components/chat/ChatHistory.tsx
================================================
import { Button } from '@/components/ui/button'
import { ChatSession } from '@/types/types'
import { XIcon } from 'lucide-react'
import { useEffect, useState } from 'react'

export default function ChatHistory({
  sessionId,
  setSessionId,
  onClose,
}: {
  sessionId: string
  setSessionId: (sessionId: string) => void
  onClose: () => void
}) {
  const [chatSessions, setChatSessions] = useState<ChatSession[]>([])
  useEffect(() => {
    const fetchChatSessions = async () => {
      const sessions = await fetch('/api/list_chat_sessions', {
        headers: {
          'Content-Type': 'application/json',
        },
      })
      const data = await sessions.json()
      setChatSessions(data)
    }

    fetchChatSessions()
  }, [])
  return (
    <div className="flex flex-col bg-sidebar text-foreground w-[300px]">
      <div className="flex flex-col gap-4 p-3 sticky top-0 right-0 items-end">
        <Button variant={'ghost'} onClick={onClose} className="w-fit">
          <XIcon />
        </Button>
      </div>

      <div className="flex-1 overflow-y-auto px-3">
        <div className="flex flex-col text-left justify-start">
          {chatSessions.map((session) => (
            <Button
              key={session.id}
              variant={session.id === sessionId ? 'default' : 'ghost'}
              className="justify-start text-left px-2 w-full"
              onClick={() => {
                setSessionId(session.id)
              }}
            >
              <span className="truncate">{session.title || 'Untitled'}</span>
            </Button>
          ))}
        </div>
      </div>
    </div>
  )
}



================================================
FILE: react/src/components/chat/ChatMagicGenerator.tsx
================================================
import { sendMagicGenerate } from '@/api/magic'
import { useConfigs } from '@/contexts/configs'
import { eventBus, TCanvasMagicGenerateEvent } from '@/lib/event'
import { Message, PendingType } from '@/types/types'
import { useCallback, useEffect } from 'react'
import { DEFAULT_SYSTEM_PROMPT } from '@/constants'
import { useAuth } from '@/contexts/AuthContext'

type ChatMagicGeneratorProps = {
    sessionId: string
    canvasId: string
    messages: Message[]
    setMessages: (messages: Message[]) => void
    setPending: (pending: PendingType) => void
    scrollToBottom: () => void
}

const ChatMagicGenerator: React.FC<ChatMagicGeneratorProps> = ({
    sessionId,
    canvasId,
    messages,
    setMessages,
    setPending,
    scrollToBottom
}) => {
    const { setShowLoginDialog } = useConfigs()
    const { authStatus } = useAuth()

    const handleMagicGenerate = useCallback(
        async (data: TCanvasMagicGenerateEvent) => {
            if (!authStatus.is_logged_in) {
                setShowLoginDialog(true)
                return
            }

            // è®¾ç½®pendingçŠ¶æ€ä¸ºtextï¼Œè¡¨ç¤ºæ­£åœ¨å¤„ç†
            setPending('text')

            // åˆ›å»ºåŒ…å«å›¾ç‰‡çš„æ¶ˆæ¯
            const magicMessage: Message = {
                role: 'user',
                content: [
                    {
                        type: 'text',
                        text: 'âœ¨ Magic Magic! Wait about 1~2 minutes please...'
                    },
                    {
                        type: 'image_url',
                        image_url: {
                            url: data.base64
                        }
                    },
                ]
            }

            // æ›´æ–°æ¶ˆæ¯åˆ—è¡¨
            const newMessages = [...messages, magicMessage]
            setMessages(newMessages)
            scrollToBottom()

            // å‘é€åˆ°åå°
            try {
                await sendMagicGenerate({
                    sessionId: sessionId,
                    canvasId: canvasId,
                    newMessages: newMessages,
                    systemPrompt: localStorage.getItem('system_prompt') || DEFAULT_SYSTEM_PROMPT,
                })

                scrollToBottom()
                console.log('é­”æ³•ç”Ÿæˆæ¶ˆæ¯å·²å‘é€åˆ°åå°')
            } catch (error) {
                console.error('å‘é€é­”æ³•ç”Ÿæˆæ¶ˆæ¯å¤±è´¥:', error)
                // å‘ç”Ÿé”™è¯¯æ—¶é‡ç½®pendingçŠ¶æ€
                setPending(false)
            }
        },
        [sessionId, canvasId, messages, setMessages, setPending, scrollToBottom, authStatus.is_logged_in, setShowLoginDialog]
    )

    useEffect(() => {
        // ç›‘å¬é­”æ³•ç”Ÿæˆäº‹ä»¶
        eventBus.on('Canvas::MagicGenerate', handleMagicGenerate)

        return () => {
            eventBus.off('Canvas::MagicGenerate', handleMagicGenerate)
        }
    }, [handleMagicGenerate])

    return null // è¿™æ˜¯ä¸€ä¸ªçº¯é€»è¾‘ç»„ä»¶ï¼Œä¸æ¸²æŸ“UI
}

export default ChatMagicGenerator



================================================
FILE: react/src/components/chat/ChatTextarea.tsx
================================================
import { cancelChat } from '@/api/chat'
import { cancelMagicGenerate } from '@/api/magic'
import { uploadImage } from '@/api/upload'
import { Button } from '@/components/ui/button'
import { useConfigs } from '@/contexts/configs'
import {
  eventBus,
  TCanvasAddImagesToChatEvent,
  TMaterialAddImagesToChatEvent,
} from '@/lib/event'
import { cn, dataURLToFile } from '@/lib/utils'
import { Message, MessageContent, Model } from '@/types/types'
import { ModelInfo, ToolInfo } from '@/api/model'
import { useMutation } from '@tanstack/react-query'
import { useDrop } from 'ahooks'
import { produce } from 'immer'
import {
  ArrowUp,
  Loader2,
  PlusIcon,
  Square,
  XIcon,
  RectangleVertical,
  ChevronDown,
  Hash,
} from 'lucide-react'
import { AnimatePresence, motion } from 'motion/react'
import Textarea, { TextAreaRef } from 'rc-textarea'
import { useCallback, useEffect, useRef, useState } from 'react'
import { useTranslation } from 'react-i18next'
import { toast } from 'sonner'
import ModelSelectorV2 from './ModelSelectorV2'
import ModelSelectorV3 from './ModelSelectorV3'
import { useAuth } from '@/contexts/AuthContext'
import { useBalance } from '@/hooks/use-balance'
import { BASE_API_URL } from '@/constants'
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu'

type ChatTextareaProps = {
  pending: boolean
  className?: string
  messages: Message[]
  sessionId?: string
  onSendMessages: (
    data: Message[],
    configs: {
      textModel: Model
      toolList: ToolInfo[]
    }
  ) => void
  onCancelChat?: () => void
}

const ChatTextarea: React.FC<ChatTextareaProps> = ({
  pending,
  className,
  messages,
  sessionId,
  onSendMessages,
  onCancelChat,
}) => {
  const { t } = useTranslation()
  const { authStatus } = useAuth()
  const { textModel, selectedTools, setShowLoginDialog } = useConfigs()
  const { balance } = useBalance()
  const [prompt, setPrompt] = useState('')
  const textareaRef = useRef<TextAreaRef>(null)
  const [images, setImages] = useState<
    {
      file_id: string
      width: number
      height: number
    }[]
  >([])
  const [isFocused, setIsFocused] = useState(false)
  const [selectedAspectRatio, setSelectedAspectRatio] = useState<string>('auto')
  const [quantity, setQuantity] = useState<number>(1)
  const [showQuantitySlider, setShowQuantitySlider] = useState(false)
  const quantitySliderRef = useRef<HTMLDivElement>(null)
  const MAX_QUANTITY = 30

  const imageInputRef = useRef<HTMLInputElement>(null)

  // å……å€¼æŒ‰é’®ç»„ä»¶
  const RechargeContent = useCallback(() => (
    <div className="flex items-center justify-between gap-3">
      <span className="text-sm text-muted-foreground flex-1">
        {t('chat:insufficientBalanceDescription')}
      </span>
      <Button
        size="sm"
        variant="outline"
        className="shrink-0"
        onClick={() => {
          const billingUrl = `${BASE_API_URL}/billing`
          if (window.electronAPI?.openBrowserUrl) {
            window.electronAPI.openBrowserUrl(billingUrl)
          } else {
            window.open(billingUrl, '_blank')
          }
        }}
      >
        {t('common:auth.recharge')}
      </Button>
    </div>
  ), [t])

  const { mutate: uploadImageMutation } = useMutation({
    mutationFn: (file: File) => uploadImage(file),
    onSuccess: (data) => {
      console.log('ğŸ¦„uploadImageMutation onSuccess', data)
      setImages((prev) => [
        ...prev,
        {
          file_id: data.file_id,
          width: data.width,
          height: data.height,
        },
      ])
    },
    onError: (error) => {
      console.error('ğŸ¦„uploadImageMutation onError', error)
      toast.error('Failed to upload image', {
        description: <div>{error.toString()}</div>,
      })
    },
  })

  const handleImagesUpload = useCallback(
    (e: React.ChangeEvent<HTMLInputElement>) => {
      const files = e.target.files
      if (files) {
        for (const file of files) {
          uploadImageMutation(file)
        }
      }
    },
    [uploadImageMutation]
  )

  const handleCancelChat = useCallback(async () => {
    if (sessionId) {
      // åŒæ—¶å–æ¶ˆæ™®é€šèŠå¤©å’Œé­”æ³•ç”Ÿæˆä»»åŠ¡
      await Promise.all([cancelChat(sessionId), cancelMagicGenerate(sessionId)])
    }
    onCancelChat?.()
  }, [sessionId, onCancelChat])

  // Send Prompt
  const handleSendPrompt = useCallback(async () => {
    if (pending) return

    // æ£€æŸ¥æ˜¯å¦ä½¿ç”¨ Jaaz æœåŠ¡
    const isUsingJaaz =
      textModel?.provider === 'jaaz' ||
      selectedTools?.some((tool) => tool.provider === 'jaaz')
    // console.log('ğŸ‘€isUsingJaaz', textModel, selectedTools, isUsingJaaz)

    // åªæœ‰å½“ä½¿ç”¨ Jaaz æœåŠ¡ä¸”ä½™é¢ä¸º 0 æ—¶æ‰æé†’å……å€¼
    if (authStatus.is_logged_in && isUsingJaaz && parseFloat(balance) <= 0) {
      toast.error(t('chat:insufficientBalance'), {
        description: <RechargeContent />,
        duration: 10000, // 10sï¼Œç»™ç”¨æˆ·æ›´å¤šæ—¶é—´æ“ä½œ
      })
      return
    }

    if (!textModel) {
      toast.error(t('chat:textarea.selectModel'))
      if (!authStatus.is_logged_in) {
        setShowLoginDialog(true)
      }
      return
    }

    if (!selectedTools || selectedTools.length === 0) {
      toast.warning(t('chat:textarea.selectTool'))
    }

    let text_content: MessageContent[] | string = prompt
    if (prompt.length === 0 || prompt.trim() === '') {
      toast.error(t('chat:textarea.enterPrompt'))
      return
    }

    // Add aspect ratio and quantity information if not default values
    let additionalInfo = ''
    if (selectedAspectRatio !== 'auto') {
      additionalInfo += `<aspect_ratio>${selectedAspectRatio}</aspect_ratio>\n`
    }
    if (quantity !== 1) {
      additionalInfo += `<quantity>${quantity}</quantity>\n`
    }

    if (additionalInfo) {
      text_content = text_content + '\n\n' + additionalInfo
    }

    if (images.length > 0) {
      text_content += `\n\n<input_images count="${images.length}">`
      images.forEach((image, index) => {
        text_content += `\n<image index="${index + 1}" file_id="${image.file_id}" width="${image.width}" height="${image.height}" />`
      })
      text_content += `\n</input_images>`
    }

    // Fetch images as base64
    const imagePromises = images.map(async (image) => {
      const response = await fetch(`/api/file/${image.file_id}`)
      const blob = await response.blob()
      return new Promise<string>((resolve) => {
        const reader = new FileReader()
        reader.onloadend = () => resolve(reader.result as string)
        reader.readAsDataURL(blob)
      })
    })

    const base64Images = await Promise.all(imagePromises)

    const final_content = [
      {
        type: 'text',
        text: text_content as string,
      },
      ...images.map((image, index) => ({
        type: 'image_url',
        image_url: {
          url: base64Images[index],
        },
      })),
    ] as MessageContent[]

    const newMessage = messages.concat([
      {
        role: 'user',
        content: final_content,
      },
    ])

    setImages([])
    setPrompt('')

    onSendMessages(newMessage, {
      textModel: textModel,
      toolList: selectedTools && selectedTools.length > 0 ? selectedTools : [],
    })
  }, [
    pending,
    textModel,
    selectedTools,
    prompt,
    onSendMessages,
    images,
    messages,
    t,
    selectedAspectRatio,
    quantity,
    authStatus.is_logged_in,
    setShowLoginDialog,
    balance,
    RechargeContent,
  ])

  // Drop Area
  const dropAreaRef = useRef<HTMLDivElement>(null)
  const [isDragOver, setIsDragOver] = useState(false)

  const handleFilesDrop = useCallback(
    (files: File[]) => {
      for (const file of files) {
        uploadImageMutation(file)
      }
    },
    [uploadImageMutation]
  )

  useDrop(dropAreaRef, {
    onDragOver() {
      setIsDragOver(true)
    },
    onDragLeave() {
      setIsDragOver(false)
    },
    onDrop() {
      setIsDragOver(false)
    },
    onFiles: handleFilesDrop,
  })

  useEffect(() => {
    const handleAddImagesToChat = (data: TCanvasAddImagesToChatEvent) => {
      data.forEach(async (image) => {
        if (image.base64) {
          const file = dataURLToFile(image.base64, image.fileId)
          uploadImageMutation(file)
        } else {
          setImages(
            produce((prev) => {
              prev.push({
                file_id: image.fileId,
                width: image.width,
                height: image.height,
              })
            })
          )
        }
      })

      textareaRef.current?.focus()
    }

    const handleMaterialAddImagesToChat = async (
      data: TMaterialAddImagesToChatEvent
    ) => {
      data.forEach(async (image: TMaterialAddImagesToChatEvent[0]) => {
        // Convert file path to blob and upload
        try {
          const fileUrl = `/api/serve_file?file_path=${encodeURIComponent(image.filePath)}`
          const response = await fetch(fileUrl)
          const blob = await response.blob()
          const file = new File([blob], image.fileName, {
            type: `image/${image.fileType}`,
          })
          uploadImageMutation(file)
        } catch (error) {
          console.error('Failed to load image from material:', error)
          toast.error('Failed to load image from material', {
            description: `${error}`,
          })
        }
      })

      textareaRef.current?.focus()
    }

    eventBus.on('Canvas::AddImagesToChat', handleAddImagesToChat)
    eventBus.on('Material::AddImagesToChat', handleMaterialAddImagesToChat)
    return () => {
      eventBus.off('Canvas::AddImagesToChat', handleAddImagesToChat)
      eventBus.off('Material::AddImagesToChat', handleMaterialAddImagesToChat)
    }
  }, [uploadImageMutation])

  // Close quantity slider when clicking outside
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        quantitySliderRef.current &&
        !quantitySliderRef.current.contains(event.target as Node)
      ) {
        setShowQuantitySlider(false)
      }
    }

    if (showQuantitySlider) {
      document.addEventListener('mousedown', handleClickOutside)
    }

    return () => {
      document.removeEventListener('mousedown', handleClickOutside)
    }
  }, [showQuantitySlider])

  return (
    <motion.div
      ref={dropAreaRef}
      className={cn(
        'w-full flex flex-col items-center border border-primary/20 rounded-2xl p-3 hover:border-primary/40 transition-all duration-300 cursor-text gap-5 bg-background/80 backdrop-blur-xl relative',
        isFocused && 'border-primary/40',
        className
      )}
      style={{
        boxShadow: isFocused
          ? '0 0 0 4px color-mix(in oklab, var(--primary) 10%, transparent)'
          : 'none',
      }}
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      transition={{ duration: 0.3, ease: 'linear' }}
      onClick={() => textareaRef.current?.focus()}
    >
      <AnimatePresence>
        {isDragOver && (
          <motion.div
            className="absolute top-0 left-0 right-0 bottom-0 bg-background/50 backdrop-blur-xl rounded-2xl z-10"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            transition={{ duration: 0.2, ease: 'easeInOut' }}
          >
            <div className="flex items-center justify-center h-full">
              <p className="text-sm text-muted-foreground">
                Drop images here to upload
              </p>
            </div>
          </motion.div>
        )}
      </AnimatePresence>

      <AnimatePresence>
        {images.length > 0 && (
          <motion.div
            className="flex items-center gap-2 w-full"
            initial={{ opacity: 0, height: 0 }}
            animate={{ opacity: 1, height: 'auto' }}
            exit={{ opacity: 0, height: 0 }}
            transition={{ duration: 0.2, ease: 'easeInOut' }}
          >
            {images.map((image) => (
              <motion.div
                key={image.file_id}
                className="relative size-10"
                initial={{ opacity: 0, scale: 0.95 }}
                animate={{ opacity: 1, scale: 1 }}
                exit={{ opacity: 0, scale: 0.95 }}
                transition={{ duration: 0.2, ease: 'easeInOut' }}
              >
                <img
                  key={image.file_id}
                  src={`/api/file/${image.file_id}`}
                  alt="Uploaded image"
                  className="w-full h-full object-cover rounded-md"
                  draggable={false}
                />
                <Button
                  variant="secondary"
                  size="icon"
                  className="absolute -top-1 -right-1 size-4"
                  onClick={() =>
                    setImages((prev) =>
                      prev.filter((i) => i.file_id !== image.file_id)
                    )
                  }
                >
                  <XIcon className="size-3" />
                </Button>
              </motion.div>
            ))}
          </motion.div>
        )}
      </AnimatePresence>

      <Textarea
        ref={textareaRef}
        className="w-full h-full border-none outline-none resize-none"
        placeholder={t('chat:textarea.placeholder')}
        value={prompt}
        autoSize
        onChange={(e) => setPrompt(e.target.value)}
        onFocus={() => setIsFocused(true)}
        onBlur={() => setIsFocused(false)}
        onKeyDown={(e) => {
          if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault()
            handleSendPrompt()
          }
        }}
      />

      <div className="flex items-center justify-between gap-2 w-full">
        <div className="flex items-center gap-2 max-w-[calc(100%-50px)] flex-wrap">
          <input
            ref={imageInputRef}
            type="file"
            accept="image/*"
            multiple
            onChange={handleImagesUpload}
            hidden
          />
          <Button
            variant="outline"
            size="sm"
            onClick={() => imageInputRef.current?.click()}
          >
            <PlusIcon className="size-4" />
          </Button>

          <ModelSelectorV3 />

          {/* Aspect Ratio Selector */}
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button
                variant="outline"
                className="flex items-center gap-1"
                size={'sm'}
              >
                <RectangleVertical className="size-4" />
                <span className="text-sm">{selectedAspectRatio}</span>
                <ChevronDown className="size-3 opacity-50" />
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="start" className="w-32">
              {['auto', '1:1', '4:3', '3:4', '16:9', '9:16'].map((ratio) => (
                <DropdownMenuItem
                  key={ratio}
                  onClick={() => setSelectedAspectRatio(ratio)}
                  className="flex items-center justify-between"
                >
                  <span>{ratio}</span>
                  {selectedAspectRatio === ratio && (
                    <div className="size-2 rounded-full bg-primary" />
                  )}
                </DropdownMenuItem>
              ))}
            </DropdownMenuContent>
          </DropdownMenu>

          {/* Quantity Selector */}
          <div className="relative" ref={quantitySliderRef}>
            <Button
              variant="outline"
              className="flex items-center gap-1"
              onClick={() => setShowQuantitySlider(!showQuantitySlider)}
              size={'sm'}
            >
              <Hash className="size-4" />
              <span className="text-sm">{quantity}</span>
              <ChevronDown className="size-3 opacity-50" />
            </Button>

            {/* Quantity Slider */}
            <AnimatePresence>
              {showQuantitySlider && (
                <motion.div
                  className="absolute bottom-full mb-2 left-0  bg-background border border-border rounded-lg p-4 shadow-lg min-w-48"
                  initial={{ opacity: 0, y: 10, scale: 0.95 }}
                  animate={{ opacity: 1, y: 0, scale: 1 }}
                  exit={{ opacity: 0, y: 10, scale: 0.95 }}
                  transition={{ duration: 0.15, ease: 'easeOut' }}
                >
                  <div className="flex flex-col gap-3">
                    <div className="flex items-center justify-between">
                      <span className="text-sm font-medium">
                        {t('chat:textarea.quantity', 'Image Quantity')}
                      </span>
                      <span className="text-sm text-muted-foreground">
                        {quantity}
                      </span>
                    </div>
                    <div className="flex items-center gap-3">
                      <span className="text-xs text-muted-foreground">1</span>
                      <input
                        type="range"
                        min="1"
                        max={MAX_QUANTITY}
                        value={quantity}
                        onChange={(e) => setQuantity(Number(e.target.value))}
                        className="flex-1 h-2 bg-muted rounded-lg appearance-none cursor-pointer
                                  [&::-webkit-slider-thumb]:appearance-none [&::-webkit-slider-thumb]:w-4 [&::-webkit-slider-thumb]:h-4
                                  [&::-webkit-slider-thumb]:rounded-full [&::-webkit-slider-thumb]:bg-primary
                                  [&::-webkit-slider-thumb]:cursor-pointer [&::-webkit-slider-thumb]:shadow-sm
                                  [&::-moz-range-thumb]:w-4 [&::-moz-range-thumb]:h-4 [&::-moz-range-thumb]:rounded-full
                                  [&::-moz-range-thumb]:bg-primary [&::-moz-range-thumb]:cursor-pointer [&::-moz-range-thumb]:border-0"
                      />
                      <span className="text-xs text-muted-foreground">
                        {MAX_QUANTITY}
                      </span>
                    </div>
                  </div>
                  {/* Arrow pointing down */}
                  <div className="absolute top-full left-1/2 -translate-x-1/2 w-0 h-0 border-l-4 border-r-4 border-t-4 border-transparent border-t-border"></div>
                  <div className="absolute top-full left-1/2 -translate-x-1/2 w-0 h-0 border-l-4 border-r-4 border-t-4 border-transparent border-t-background translate-y-[-1px]"></div>
                </motion.div>
              )}
            </AnimatePresence>
          </div>
        </div>

        {pending ? (
          <Button
            className="shrink-0 relative"
            variant="default"
            size="icon"
            onClick={handleCancelChat}
          >
            <Loader2 className="size-5.5 animate-spin absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2" />
            <Square className="size-2 absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2" />
          </Button>
        ) : (
          <Button
            className="shrink-0"
            variant="default"
            size="icon"
            onClick={handleSendPrompt}
            disabled={!textModel || !selectedTools || prompt.length === 0}
          >
            <ArrowUp className="size-4" />
          </Button>
        )}
      </div>
    </motion.div>
  )
}

export default ChatTextarea



================================================
FILE: react/src/components/chat/IconCarousel.tsx
================================================
import { cn } from '@/lib/utils'
import { AnimatePresence, motion } from 'motion/react'
import React, { useEffect, useState } from 'react'

type IconCarouselProps = {
  icons: React.ReactNode[]
  className?: string
  iconClassName?: string
  time?: number
}

const IconCarousel: React.FC<IconCarouselProps> = ({
  icons,
  className,
  time = 2000,
  iconClassName,
}) => {
  const [index, setIndex] = useState(0)

  useEffect(() => {
    const timer = setInterval(() => {
      setIndex((prev) => (prev + 1) % icons.length)
    }, time)
    return () => clearInterval(timer)
  }, [icons.length, time])

  return (
    <div
      className={cn('flex items-center justify-start gap-2', className)}
      style={{ minHeight: 40 }}
    >
      <AnimatePresence mode="wait">
        <motion.div
          key={index}
          initial={{ opacity: 0, scale: 0.85 }}
          animate={{ opacity: 1, scale: 1 }}
          exit={{ opacity: 0, scale: 0.85 }}
          transition={{ duration: 0.2, ease: 'easeInOut' }}
          style={{ display: 'flex', alignItems: 'center' }}
          className={iconClassName}
        >
          {icons[index]}
        </motion.div>
      </AnimatePresence>
    </div>
  )
}

export default IconCarousel



================================================
FILE: react/src/components/chat/Markdown.tsx
================================================
import { Button } from '@/components/ui/button'
import { useCanvas } from '@/contexts/canvas'
import { memo, useState, useEffect } from 'react'
import { useTranslation } from 'react-i18next'
import ReactMarkdown, { Components } from 'react-markdown'
import { PhotoView } from 'react-photo-view'
import remarkGfm from 'remark-gfm'
import TextFoldTag from './Message/TextFoldTag'

type MarkdownProps = {
  children: string
}

const NonMemoizedMarkdown: React.FC<MarkdownProps> = ({ children }) => {
  const { excalidrawAPI } = useCanvas()
  const files = excalidrawAPI?.getFiles()
  const filesArray = Object.keys(files || {}).map((key) => ({
    id: key,
    url: files![key].dataURL,
  }))

  const { t } = useTranslation()
  const [isThinkExpanded, setIsThinkExpanded] = useState(false)

  // Main function to process think tags
  const processThinkTags = (content: string) => {
    // Remove empty think tags and fix unclosed tags
    const cleanedContent = content.replace(/<think>\s*<\/think>/g, '')
    const openTags = (cleanedContent.match(/<think>/g) || []).length
    const closeTags = (cleanedContent.match(/<\/think>/g) || []).length
    const fixedContent =
      openTags > closeTags
        ? cleanedContent + '</think>'.repeat(openTags - closeTags)
        : cleanedContent

    const thinkRegex = /<think>([\s\S]*?)<\/think>/g
    const parts = []
    let lastIndex = 0
    let match

    while ((match = thinkRegex.exec(fixedContent)) !== null) {
      if (match.index > lastIndex) {
        const beforeContent = fixedContent.slice(lastIndex, match.index).trim()
        if (beforeContent) {
          parts.push({ type: 'normal', content: beforeContent })
        }
      }

      const thinkContent = match[1]?.trim()
      if (thinkContent) {
        parts.push({ type: 'think', content: thinkContent })
      }
      lastIndex = match.index + match[0].length
    }

    if (lastIndex < fixedContent.length) {
      const remainingContent = fixedContent.slice(lastIndex).trim()
      if (remainingContent) {
        parts.push({ type: 'normal', content: remainingContent })
      }
    }

    if (parts.length === 0 && fixedContent.trim()) {
      parts.push({ type: 'normal', content: fixedContent.trim() })
    }

    console.log('Think tags processing:', {
      parts,
      originalContent: children.substring(0, 100),
    })

    return { parts, hasUnclosed: openTags > closeTags }
  }

  // Check if it should auto-expand
  const { parts, hasUnclosed } = children.includes('<think>')
    ? processThinkTags(children)
    : { parts: [], hasUnclosed: false }

  useEffect(() => {
    setIsThinkExpanded(hasUnclosed)
  }, [hasUnclosed])

  const handleImagePositioning = (id: string) => {
    excalidrawAPI?.scrollToContent(id, { animate: true })
  }

  const components: Components = {
    code: ({ node, className, children, ref, ...props }) => {
      const match = /language-(\w+)/.exec(className || '')
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      return !(props as any).inline && match ? (
        <pre
          {...props}
          className={`${className} text-sm w-full max-w-full overflow-x-auto p-3 rounded-lg mt-2 bg-zinc-800 text-white dark:bg-zinc-300 dark:text-black whitespace-pre-wrap break-all`}
        >
          <code
            className={match[1]}
            style={{
              wordBreak: 'break-all',
              whiteSpace: 'pre-wrap',
              wordWrap: 'break-word'
            }}
          >
            {children}
          </code>
        </pre>
      ) : (
        <code
          className={`${className} text-sm py-0.5 px-1 overflow-x-auto whitespace-pre-wrap rounded-md bg-zinc-800 text-white dark:bg-zinc-300 dark:text-black break-all`}
          {...props}
        >
          {children}
        </code>
      )
    },

    ol: ({ node, children, ...props }) => {
      return (
        <ol className="list-decimal list-inside ml-1" {...props}>
          {children}
        </ol>
      )
    },
    li: ({ node, children, ...props }) => {
      return (
        <li className="py-1 [&>p]:inline [&>p]:m-0" {...props}>
          {children}
        </li>
      )
    },
    ul: ({ node, children, ...props }) => {
      return (
        <ul className="list-disc list-inside ml-1" {...props}>
          {children}
        </ul>
      )
    },
    strong: ({ node, children, ...props }) => {
      return (
        <span className="font-bold" {...props}>
          {children}
        </span>
      )
    },
    a: ({ node, children, ...props }) => {
      return (
        <a
          className="text-blue-500 hover:underline break-all"
          target="_blank"
          rel="noreferrer"
          {...props}
        >
          {children}
        </a>
      )
    },
    h1: ({ node, children, ...props }) => {
      return (
        <h1 className="text-3xl font-semibold mt-6 mb-2" {...props}>
          {children}
        </h1>
      )
    },
    h2: ({ node, children, ...props }) => {
      return (
        <h2 className="text-2xl font-semibold mt-6 mb-2" {...props}>
          {children}
        </h2>
      )
    },
    h3: ({ node, children, ...props }) => {
      return (
        <h3 className="text-xl font-semibold mt-6 mb-2" {...props}>
          {children}
        </h3>
      )
    },
    h4: ({ node, children, ...props }) => {
      return (
        <h4 className="text-lg font-semibold mt-6 mb-2" {...props}>
          {children}
        </h4>
      )
    },
    h5: ({ node, children, ...props }) => {
      return (
        <h5 className="text-base font-semibold mt-6 mb-2" {...props}>
          {children}
        </h5>
      )
    },
    h6: ({ node, children, ...props }) => {
      return (
        <h6 className="text-sm font-semibold mt-6 mb-2" {...props}>
          {children}
        </h6>
      )
    },
    blockquote: ({ node, children, ...props }) => {
      return (
        <blockquote
          className="border-l-3 border-b-accent-foreground pl-4 py-2"
          {...props}
        >
          {children}
        </blockquote>
      )
    },
    img: ({ node, children, ...props }) => {
      const id = filesArray.find((file) => props.src?.includes(file.url))?.id

      // æ£€æŸ¥altæ–‡æœ¬æ˜¯å¦åŒ…å«video_idæ ‡è¯†ï¼Œè¿™è¡¨ç¤ºè¿™æ˜¯ä¸€ä¸ªè§†é¢‘æ–‡ä»¶
      const isVideo = props.alt && props.alt.includes('video_id:')

      if (isVideo) {
        return (
          <span className="group block relative overflow-hidden rounded-md my-2 last:mb-4">
            <video
              className="w-full max-w-full h-auto rounded-md cursor-pointer group-hover:scale-105 transition-transform duration-300"
              controls
              preload="metadata"
              src={props.src}
              {...(props.alt && { title: props.alt })}
            >
              Your browser does not support the video tag.
            </video>

            {id && (
              <Button
                variant="secondary"
                className="group-hover:opacity-100 opacity-0 absolute top-2 right-2 z-10"
                onClick={(e) => {
                  e.stopPropagation()
                  handleImagePositioning(id)
                }}
              >
                {t('chat:messages:imagePositioning')}
              </Button>
            )}
          </span>
        )
      }

      return (
        <PhotoView src={props.src}>
          <span className="group block relative overflow-hidden rounded-md my-2 last:mb-4">
            <img
              className="cursor-pointer group-hover:scale-105 transition-transform duration-300"
              {...props}
            />

            {id && (
              <Button
                variant="secondary"
                className="group-hover:opacity-100 opacity-0 absolute top-2 right-2 z-10"
                onClick={(e) => {
                  e.stopPropagation()
                  handleImagePositioning(id)
                }}
              >
                {t('chat:messages:imagePositioning')}
              </Button>
            )}
          </span>
        </PhotoView>
      )
    },
    video: ({ node, children, ...props }) => {
      const id = filesArray.find((file) => props.src?.includes(file.url))?.id
      return (
        <span className="group block relative overflow-hidden rounded-md my-2 last:mb-4">
          <video
            className="w-full max-w-full h-auto rounded-md"
            controls
            preload="metadata"
            {...props}
          >
            Your browser does not support the video tag.
          </video>

          {id && (
            <Button
              variant="secondary"
              className="group-hover:opacity-100 opacity-0 absolute top-2 right-2 z-10"
              onClick={(e) => {
                e.stopPropagation()
                handleImagePositioning(id)
              }}
            >
              {t('chat:messages:imagePositioning')}
            </Button>
          )}
        </span>
      )
    },
  }
  // Special handling if content contains think tags
  if (children.includes('<think>')) {
    return (
      <div className="space-y-3 flex flex-col w-full max-w-full">
        {parts.map((part, index) =>
          part.type === 'think' ? (
            <TextFoldTag
              key={index}
              isExpanded={isThinkExpanded}
              onToggleExpand={() => setIsThinkExpanded(!isThinkExpanded)}
            >
              <div className="prose prose-sm dark:prose-invert max-w-none">
                <ReactMarkdown
                  remarkPlugins={[remarkGfm]}
                  components={components}
                >
                  {part.content}
                </ReactMarkdown>
              </div>
            </TextFoldTag>
          ) : (
            <div key={index} className="w-full max-w-full">
              <ReactMarkdown
                remarkPlugins={[remarkGfm]}
                components={components}
              >
                {part.content}
              </ReactMarkdown>
            </div>
          )
        )}
      </div>
    )
  }

  return (
    <ReactMarkdown remarkPlugins={[remarkGfm]} components={components}>
      {children}
    </ReactMarkdown>
  )
}

export const Markdown = memo(
  NonMemoizedMarkdown,
  (prevProps, nextProps) => prevProps.children === nextProps.children
)



================================================
FILE: react/src/components/chat/ModelSelectorV2.tsx
================================================
import {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select'
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuCheckboxItem,
  DropdownMenuTrigger,
  DropdownMenuSeparator,
  DropdownMenuLabel,
  DropdownMenuGroup,
} from '@/components/ui/dropdown-menu'
import { Button } from '@/components/ui/button'
import { useConfigs } from '@/contexts/configs'
import { ChevronDown } from 'lucide-react'
import { PROVIDER_NAME_MAPPING } from '@/constants'
import { ModelInfo, ToolInfo } from '@/api/model'
import { useState } from 'react'
import { Switch } from '../ui/switch'
import { useTranslation } from 'react-i18next'

const ModelSelector: React.FC = () => {
  const {
    textModel,
    setTextModel,
    textModels,
    selectedTools,
    setSelectedTools,
    allTools,
  } = useConfigs()
  const selectedToolKeys = selectedTools.map(
    (tool) => tool.provider + ':' + tool.id
  )
  // single select mode
  const [singleMode, setSingleMode] = useState(false)
  // Add state to control dropdown open state
  const [dropdownOpen, setDropdownOpen] = useState(false)
  const { t } = useTranslation()

  // handle model selection click
  const handleImageModelToggle = (modelKey: string, checked: boolean) => {
    let newSelected: ToolInfo[] = []
    const tool = allTools.find((m) => m.provider + ':' + m.id === modelKey)
    // single select mode
    if (singleMode) {
      tool && setSelectedTools([tool])
      // Close dropdown after selection in single mode
      setDropdownOpen(false)
      return
    }
    // multi select mode
    if (checked) {
      if (tool) {
        newSelected = [...selectedTools, tool]
      }
    } else {
      newSelected = selectedTools.filter(
        (t) => t.provider + ':' + t.id !== modelKey
      )
    }

    setSelectedTools(newSelected)
    localStorage.setItem(
      'disabled_tool_ids',
      JSON.stringify(
        allTools.filter((t) => !newSelected.includes(t)).map((t) => t.id)
      )
    )
  }

  // è·å–æ˜¾ç¤ºæ–‡æœ¬
  const getSelectedImageModelsText = () => {
    if (selectedTools.length === 0) return 'â€¼ï¸'
    return `${selectedTools.length}`
  }

  // Group models by provider
  const groupModelsByProvider = (models: typeof allTools) => {
    const grouped: { [provider: string]: typeof allTools } = {}
    models?.forEach((model) => {
      if (!grouped[model.provider]) {
        grouped[model.provider] = []
      }
      grouped[model.provider].push(model)
    })
    return grouped
  }

  const groupLLMsByProvider = (models: typeof textModels) => {
    const grouped: { [provider: string]: typeof textModels } = {}
    models?.forEach((model) => {
      if (!grouped[model.provider]) {
        grouped[model.provider] = []
      }
      grouped[model.provider].push(model)
    })
    return grouped
  }
  const groupedLLMs = groupLLMsByProvider(textModels)
  const groupedTools = groupModelsByProvider(allTools)

  return (
    <>
      <Select
        value={textModel?.provider + ':' + textModel?.model}
        onValueChange={(value) => {
          localStorage.setItem('text_model', value)
          setTextModel(
            textModels?.find((m) => m.provider + ':' + m.model == value)
          )
        }}
      >
        <SelectTrigger className="w-fit max-w-[100px] bg-background" size="sm">
          <SelectValue placeholder="Theme" />
        </SelectTrigger>
        <SelectContent>
          {Object.entries(groupedLLMs).map(([provider, models]) => {
            return (
              <SelectGroup key={provider}>
                <SelectLabel>{provider}</SelectLabel>
                {models.map((model) => (
                  <SelectItem
                    key={model.provider + ':' + model.model}
                    value={model.provider + ':' + model.model}
                  >
                    {model.model}
                  </SelectItem>
                ))}
              </SelectGroup>
            )
          })}
        </SelectContent>
      </Select>

      {/* å¤šé€‰å›¾åƒæ¨¡å‹ä¸‹æ‹‰èœå• */}
      <DropdownMenu open={dropdownOpen} onOpenChange={setDropdownOpen}>
        <DropdownMenuTrigger asChild>
          <Button
            size={'sm'}
            variant="outline"
            className="w-fit max-w-[40%] bg-background justify-between overflow-hidden"
          >
            <span>ğŸ¨</span>
            <span className="bg-primary text-primary-foreground rounded-full text-[0.7rem] w-[1.5rem]">
              {getSelectedImageModelsText()}
            </span>
            <ChevronDown className="h-4 w-4" />
          </Button>
        </DropdownMenuTrigger>
        <DropdownMenuContent className="w-100">
          <div className="flex items-center gap-1 px-2 mt-1 justify-end text-sm text-muted-foreground">
            <span>{t('chat:single_select_mode', 'Single Mode')}</span>
            <Switch
              checked={singleMode}
              size="sm"
              onCheckedChange={setSingleMode}
            />
          </div>
          {Object.entries(groupedTools).map(([provider, models]) => {
            const getProviderDisplayName = (provider: string) => {
              const providerInfo = PROVIDER_NAME_MAPPING[provider]
              return {
                name: providerInfo?.name || provider,
                icon: providerInfo?.icon,
              }
            }
            return (
              <DropdownMenuGroup key={provider}>
                <DropdownMenuLabel>
                  <div className="flex items-center gap-2 text-muted-foreground">
                    <img
                      src={getProviderDisplayName(provider).icon}
                      alt={getProviderDisplayName(provider).name}
                      className="w-4 h-4 rounded-full"
                    />
                    {getProviderDisplayName(provider).name}
                  </div>
                </DropdownMenuLabel>
                {models.map((model) => {
                  const modelKey = model.provider + ':' + model.id
                  return (
                    <DropdownMenuCheckboxItem
                      key={modelKey}
                      checked={selectedToolKeys.includes(modelKey)}
                      onCheckedChange={(checked) =>
                        handleImageModelToggle(modelKey, checked)
                      }
                      onSelect={(e) => {
                        // Only prevent default in multi-select mode
                        if (!singleMode) {
                          e.preventDefault()
                        }
                      }}
                    >
                      {model.type === 'video' ? 'ğŸ¬ ' : ''}
                      {model.display_name || model.id}
                    </DropdownMenuCheckboxItem>
                  )
                })}
                <DropdownMenuSeparator />
              </DropdownMenuGroup>
            )
          })}
        </DropdownMenuContent>
      </DropdownMenu>
    </>
  )
}

export default ModelSelector



================================================
FILE: react/src/components/chat/ModelSelectorV3.tsx
================================================
import React, { useState } from 'react'
import { Button } from '@/components/ui/button'
import { ChevronDown, Component } from 'lucide-react'
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuCheckboxItem,
  DropdownMenuTrigger,
  DropdownMenuSeparator,
  DropdownMenuLabel,
  DropdownMenuGroup,
} from '@/components/ui/dropdown-menu'
import { Switch } from '@/components/ui/switch'
import { Checkbox } from '@/components/ui/checkbox'
import { useTranslation } from 'react-i18next'
import { useConfigs } from '@/contexts/configs'
import { ModelInfo, ToolInfo } from '@/api/model'
import { PROVIDER_NAME_MAPPING } from '@/constants'
import { ScrollArea } from '@/components/ui/scroll-area'

interface ModelSelectorV3Props {
  onModelToggle?: (modelId: string, checked: boolean) => void
  onAutoToggle?: (enabled: boolean) => void
}

const ModelSelectorV3: React.FC<ModelSelectorV3Props> = ({
  onModelToggle,
  onAutoToggle
}) => {
  const {
    textModel,
    setTextModel,
    textModels,
    selectedTools,
    setSelectedTools,
    allTools,
  } = useConfigs()

  const [activeTab, setActiveTab] = useState<'image' | 'video' | 'text'>('image')
  const [dropdownOpen, setDropdownOpen] = useState(false)
  const { t } = useTranslation()

  // åˆå§‹åŒ–æ—¶åˆ¤æ–­autoæ¨¡å¼ï¼šå¦‚æœæ‰€æœ‰å·¥å…·éƒ½è¢«é€‰ä¸­ï¼Œåˆ™ä¸ºautoæ¨¡å¼
  const initialAutoMode = allTools.length > 0 && selectedTools.length === allTools.length
  const [autoMode, setAutoMode] = useState(initialAutoMode)

  // Group models by provider
  const groupModelsByProvider = (models: typeof allTools) => {
    const grouped: { [provider: string]: typeof allTools } = {}
    models?.forEach((model) => {
      if (!grouped[model.provider]) {
        grouped[model.provider] = []
      }
      grouped[model.provider].push(model)
    })
    return grouped
  }

  const groupLLMsByProvider = (models: typeof textModels) => {
    const grouped: { [provider: string]: typeof textModels } = {}
    models?.forEach((model) => {
      if (!grouped[model.provider]) {
        grouped[model.provider] = []
      }
      grouped[model.provider].push(model)
    })
    return grouped
  }

  // Sort providers to put Jaaz first
  const sortProviders = <T,>(grouped: { [provider: string]: T[] }) => {
    const sortedEntries = Object.entries(grouped).sort(([a], [b]) => {
      if (a === 'jaaz') return -1
      if (b === 'jaaz') return 1
      return a.localeCompare(b)
    })
    return Object.fromEntries(sortedEntries)
  }

  const groupedLLMs = sortProviders(groupLLMsByProvider(textModels))
  const groupedTools = groupModelsByProvider(allTools)

  // Filter tools by type
  const getToolsByType = (type: 'image' | 'video') => {
    const filteredTools = allTools.filter(tool => tool.type === type)
    return groupModelsByProvider(filteredTools)
  }

  const handleModelToggle = (modelKey: string, checked: boolean) => {
    if (activeTab === 'text') {
      // Text models are single select
      const model = textModels?.find((m) => m.provider + ':' + m.model === modelKey)
      if (model) {
        setTextModel(model)
        localStorage.setItem('text_model', modelKey)
      }
    } else {
      // Image and video models are multi select
      let newSelected: ToolInfo[] = []
      const tool = allTools.find((m) => m.provider + ':' + m.id === modelKey)

      if (checked) {
        if (tool) {
          newSelected = [...selectedTools, tool]
        }
      } else {
        newSelected = selectedTools.filter(
          (t) => t.provider + ':' + t.id !== modelKey
        )
      }

      setSelectedTools(newSelected)
      localStorage.setItem(
        'disabled_tool_ids',
        JSON.stringify(
          allTools.filter((t) => !newSelected.includes(t)).map((t) => t.id)
        )
      )

      // æ›´æ–°autoæ¨¡å¼çŠ¶æ€
      const isAuto = newSelected.length === allTools.length
      setAutoMode(isAuto)
    }
    onModelToggle?.(modelKey, checked)
  }

  const handleModelClick = (modelKey: string) => {
    if (activeTab === 'text') {
      // Text models: always single select, no auto mode
      const model = textModels?.find((m) => m.provider + ':' + m.model === modelKey)
      if (model) {
        setTextModel(model)
        localStorage.setItem('text_model', modelKey)
        onModelToggle?.(modelKey, true)
      }
    } else {
      // Image and video models
      if (autoMode) {
        // å¦‚æœå½“å‰æ˜¯autoæ¨¡å¼ï¼Œåˆ‡æ¢åˆ°éautoæ¨¡å¼å¹¶åªé€‰ä¸­ç‚¹å‡»çš„æ¨¡å‹
        setAutoMode(false)
        const tool = allTools.find((m) => m.provider + ':' + m.id === modelKey)
        if (tool) {
          setSelectedTools([tool])
          localStorage.setItem(
            'disabled_tool_ids',
            JSON.stringify(
              allTools.filter((t) => t.id !== tool.id).map((t) => t.id)
            )
          )
          onModelToggle?.(modelKey, true)
        }
      } else {
        // éautoæ¨¡å¼ï¼Œåˆ‡æ¢å½“å‰æ¨¡å‹çš„é€‰ä¸­çŠ¶æ€
        const isSelected = selectedTools.some(t => t.provider + ':' + t.id === modelKey)
        handleModelToggle(modelKey, !isSelected)
      }
    }
  }

  const handleAutoToggle = (enabled: boolean) => {
    if (activeTab === 'text') {
      // Text models don't support auto mode
      return
    }

    if (enabled) {
      // å¼€å¯autoæ¨¡å¼æ—¶ï¼Œé€‰ä¸­æ‰€æœ‰å·¥å…·æ¨¡å‹
      setSelectedTools(allTools)
      localStorage.setItem('disabled_tool_ids', JSON.stringify([]))
    } else {
      // å…³é—­autoæ¨¡å¼æ—¶ï¼Œé»˜è®¤é€‰ä¸­imageå’Œvideoçš„ç¬¬ä¸€ä¸ªå·¥å…·
      const imageTools = allTools.filter(tool => tool.type === 'image')
      const videoTools = allTools.filter(tool => tool.type === 'video')

      const firstImageTool = imageTools.length > 0 ? imageTools[0] : null
      const firstVideoTool = videoTools.length > 0 ? videoTools[0] : null

      const selectedToolsList: ToolInfo[] = []
      if (firstImageTool) selectedToolsList.push(firstImageTool)
      if (firstVideoTool) selectedToolsList.push(firstVideoTool)

      if (selectedToolsList.length > 0) {
        setSelectedTools(selectedToolsList)
        localStorage.setItem(
          'disabled_tool_ids',
          JSON.stringify(
            allTools.filter((t) => !selectedToolsList.includes(t)).map((t) => t.id)
          )
        )
      }
    }
    setAutoMode(enabled)
    onAutoToggle?.(enabled)
  }

  // Get selected models count
  const getSelectedModelsCount = () => {
    if (activeTab === 'text') {
      return textModel ? 1 : 0
    } else {
      return selectedTools.length
    }
  }

  // Get current models based on active tab
  const getCurrentModels = () => {
    if (activeTab === 'text') {
      return groupedLLMs
    } else {
      return getToolsByType(activeTab)
    }
  }

  // Check if a model is selected
  const isModelSelected = (modelKey: string) => {
    if (activeTab === 'text') {
      return textModel?.provider + ':' + textModel?.model === modelKey
    } else {
      return selectedTools.some(t => t.provider + ':' + t.id === modelKey)
    }
  }

  // Get provider display info
  const getProviderDisplayInfo = (provider: string) => {
    const providerInfo = PROVIDER_NAME_MAPPING[provider]
    return {
      name: providerInfo?.name || provider,
      icon: providerInfo?.icon,
    }
  }

  const tabs = [
    { id: 'image', label: t('chat:modelSelector.tabs.image') },
    { id: 'video', label: t('chat:modelSelector.tabs.video') },
    { id: 'text', label: t('chat:modelSelector.tabs.text') }
  ] as const

  return (
    <DropdownMenu open={dropdownOpen} onOpenChange={setDropdownOpen}>
      <DropdownMenuTrigger asChild>
        <Button
          size={'sm'}
          variant="outline"
          className={`w-fit max-w-[40%] justify-between overflow-hidden ${autoMode
            ? 'bg-background border-border text-muted-foreground'
            : 'text-primary border-green-200 bg-green-50'
            }`}
        >
          {autoMode ? (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none" /><path d="M4 4m0 1a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v4a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1z" /><path d="M4 14m0 1a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v4a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1z" /><path d="M14 14m0 1a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v4a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1z" /><path d="M14 7l6 0" /><path d="M17 4l0 6" /></svg>
          ) : (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" className="icon icon-tabler icons-tabler-filled icon-tabler-apps"><path stroke="none" d="M0 0h24v24H0z" fill="none" /><path d="M9 3h-4a2 2 0 0 0 -2 2v4a2 2 0 0 0 2 2h4a2 2 0 0 0 2 -2v-4a2 2 0 0 0 -2 -2z" /><path d="M9 13h-4a2 2 0 0 0 -2 2v4a2 2 0 0 0 2 2h4a2 2 0 0 0 2 -2v-4a2 2 0 0 0 -2 -2z" /><path d="M19 13h-4a2 2 0 0 0 -2 2v4a2 2 0 0 0 2 2h4a2 2 0 0 0 2 -2v-4a2 2 0 0 0 -2 -2z" /><path d="M17 3a1 1 0 0 1 .993 .883l.007 .117v2h2a1 1 0 0 1 .117 1.993l-.117 .007h-2v2a1 1 0 0 1 -1.993 .117l-.007 -.117v-2h-2a1 1 0 0 1 -.117 -1.993l.117 -.007h2v-2a1 1 0 0 1 1 -1z" /></svg>
          )}
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent className="w-96 select-none">
        {/* Header */}
        <div className="flex items-center justify-between px-4 py-2 border-b">
          <div>{t('chat:modelSelector.title')}</div>
          <div className="flex items-center gap-2">
            <span className="text-sm text-muted-foreground">{t('chat:modelSelector.auto')}</span>
            <Switch
              checked={autoMode}
              onCheckedChange={handleAutoToggle}
            // disabled={activeTab === 'text'}
            />
          </div>
        </div>

        {/* Tabs */}
        <div className="flex p-1 bg-muted rounded-lg mx-4 my-2">
          {tabs.map((tab) => (
            <button
              key={tab.id}
              onClick={() => setActiveTab(tab.id)}
              className={`flex-1 px-3 py-1 rounded-md text-sm font-medium transition-colors cursor-pointer ${activeTab === tab.id
                ? 'bg-background text-foreground shadow-sm'
                : 'text-muted-foreground hover:text-foreground'
                }`}
            >
              {tab.label}
            </button>
          ))}
        </div>

        {/* Models List */}
        <ScrollArea>
          <div className="max-h-80 h-80 px-4 pb-4 select-none">
            {Object.entries(getCurrentModels()).map(([provider, providerModels], index, array) => {
              const providerInfo = getProviderDisplayInfo(provider)
              const isLastGroup = index === array.length - 1
              return (
                <DropdownMenuGroup key={provider}>
                  <DropdownMenuLabel className="text-xs font-medium text-muted-foreground px-0 py-2">
                    <div className="flex items-center gap-2">
                      <img
                        src={providerInfo.icon}
                        alt={providerInfo.name}
                        className="w-4 h-4 rounded-full"
                      />
                      {providerInfo.name}
                    </div>
                  </DropdownMenuLabel>
                  {providerModels.map((model: ModelInfo | ToolInfo) => {
                    const modelKey = activeTab === 'text'
                      ? model.provider + ':' + (model as ModelInfo).model
                      : model.provider + ':' + (model as ToolInfo).id
                    const modelName = activeTab === 'text'
                      ? (model as ModelInfo).model
                      : (model as ToolInfo).display_name || (model as ToolInfo).id

                    return (
                      <div
                        key={modelKey}
                        className="flex items-center justify-between p-3 hover:bg-muted/50 transition-colors mb-2 cursor-pointer"
                        onClick={() => handleModelClick(modelKey)}
                      >
                        <div className="flex-1">
                          <div className="font-medium text-sm">{modelName}</div>
                        </div>
                        <Checkbox
                          checked={isModelSelected(modelKey)}
                          className={`ml-4 ${autoMode && activeTab !== 'text' ? 'opacity-50' : ''}`}
                          disabled={autoMode && activeTab !== 'text'}
                        />
                      </div>
                    )
                  })}
                  {!isLastGroup && <DropdownMenuSeparator className="my-2" />}
                </DropdownMenuGroup>
              )
            })}
          </div>
        </ScrollArea>
      </DropdownMenuContent>
    </DropdownMenu>
  )
}

export default ModelSelectorV3



================================================
FILE: react/src/components/chat/MultiChoicePrompt.tsx
================================================
import { Button } from '@/components/ui/button'
import { Card } from '@/components/ui/card'
import { Checkbox } from '@/components/ui/checkbox'
import { SparkleIcon } from 'lucide-react'
import { Markdown } from './Markdown'

export default function MultiChoicePrompt() {
  const data = [
    '[Best under the radar AI tools for marketers?](https://www.reddit.com/r/digital_marketing/comments/1btayyg/best_under_the_radar_ai_tools_for_marketers/) - Posted 1 year ago on r/digital_marketing. This thread could be a good place to discuss innovative AI tools including yours.',

    '[How Do You Find AI Tools for Marketing?](https://www.reddit.com/r/marketing/comments/1gdgfyt/how_do_you_find_ai_tools_for_marketing/) - Posted 6 months ago on r/marketing. Relevant to share your tool as a solution to their query.',

    '[What AI tools are you using to help with performance marketing?](https://www.reddit.com/r/DigitalMarketing/comments/1k65uxz/what_ai_tools_are_you_using_to_help_with/) - Posted 17 days ago on r/DigitalMarketing. Your tool fits into this discussion on performance marketing tools.',

    '[What AI marketing tool do you WISH existed?](https://www.reddit.com/r/smallbusiness/comments/1k65uxz/what_ai_marketing_tool_do_you_wish_existed/) - Posted 10 months ago on r/smallbusiness. Presenting your tool here could answer the question of the requester.',

    '[Recommended AI Tools for Marketing](https://www.reddit.com/r/DigitalMarketing/comments/1k65uxz/recommended_ai_tools_for_marketing/) - Posted 4 months ago on r/DigitalMarketing. This thread discussing recommended tools is ideal for mentioning your product.',

    "[What's the most impressive AI tool you have ever tried for marketing?](https://www.reddit.com/r/marketing/comments/1gdgfyt/whats_the_most_impressive_ai_tool_you_have_ever/) - Posted 1 year ago on r/marketing. A good opportunity to introduce an impressive aspect of your tool.",

    'AI Tools for Content Creation - Older post on r/digital_marketing. Your toolâ€™s features in content creation can be mentioned here.',

    'How effective have AI tools been in your marketing strategies? - Older thread on r/marketing where effectiveness of AI tools is discussed.',

    'AI Tools to Boost Your Marketing Efficiency - Posted some time ago in r/smallbusiness, a good space to show how your tool could be effective.',

    'Future of AI in Digital Marketing - Discussion of AIâ€™s role in the future of digital marketing where your product could be highlighted.',
  ]

  return (
    <div className="flex flex-col gap-2">
      <div className="flex items-center gap-2 justify-between">
        <div className="flex items-center gap-2">
          <Checkbox />
          <label>Select all</label>
        </div>
        <Button size={'sm'} variant={'outline'}>
          <SparkleIcon className="w-4 h-4" />
          Generate Reply ğŸ¤– (10)
        </Button>
      </div>
      {data.map((item) => (
        <div key={item} className="flex items-center gap-2">
          <Checkbox />
          <Card className="w-full px-3 py-3">
            <Markdown>{item}</Markdown>
          </Card>
        </div>
      ))}
    </div>
  )
}



================================================
FILE: react/src/components/chat/SessionSelector.tsx
================================================
import { Session } from '@/types/types'
import { PlusIcon } from 'lucide-react'
import { useTranslation } from 'react-i18next'
import { Button } from '../ui/button'
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '../ui/select'

type SessionSelectorProps = {
  session: Session | null
  sessionList: Session[]
  onSelectSession: (sessionId: string) => void
  onClickNewChat: () => void
}

const SessionSelector: React.FC<SessionSelectorProps> = ({
  session,
  sessionList,
  onSelectSession,
  onClickNewChat,
}) => {
  const { t } = useTranslation()

  return (
    <div className="flex items-center gap-2 w-full">
      <Select
        value={session?.id}
        onValueChange={(value) => {
          onSelectSession(value)
        }}
      >
        <SelectTrigger className="flex-1 min-w-0 bg-background">
          <SelectValue placeholder="Theme" />
        </SelectTrigger>
        <SelectContent>
          {sessionList
            ?.filter((session) => session.id && session.id.trim() !== '') // Fix error of A â€¹Select.Item /> must have a value prop that is not an empty string.
            ?.map((session) => (
              <SelectItem key={session.id} value={session.id}>
                {session.title}
              </SelectItem>
            ))}
        </SelectContent>
      </Select>

      <Button
        variant={'outline'}
        onClick={onClickNewChat}
        className="shrink-0 gap-1"
      >
        <PlusIcon />
        <span className="text-sm">{t('chat:newChat')}</span>
      </Button>
    </div>
  )
}

export default SessionSelector



================================================
FILE: react/src/components/chat/ShareTemplateDialog.tsx
================================================
import { useState, useEffect } from "react"
import { useTranslation } from "react-i18next"
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { useCanvas } from "@/contexts/canvas"
import { ExcalidrawImageElement } from "@excalidraw/excalidraw/element/types"
import { toast } from "sonner"
import { Share2 } from "lucide-react"
import { Message } from "@/types/types"
import { BASE_API_URL } from "@/constants"

interface ShareTemplateDialogProps {
  open: boolean
  onOpenChange: (open: boolean) => void
  canvasId: string
  sessionId: string
  messages: Message[]
}

interface CanvasImage {
  id: string
  fileId: string
  dataURL: string
  width: number
  height: number
}

export default function ShareTemplateDialog({
  open,
  onOpenChange,
  canvasId,
  sessionId,
  messages,
}: ShareTemplateDialogProps) {
  const { t } = useTranslation()
  const { excalidrawAPI } = useCanvas()
  const [templateName, setTemplateName] = useState("")
  const [images, setImages] = useState<CanvasImage[]>([])
  const [selectedCoverImage, setSelectedCoverImage] = useState<string>("")
  const [isSubmitting, setIsSubmitting] = useState(false)

  // Get canvas images when dialog opens
  useEffect(() => {
    if (open && excalidrawAPI) {
      const elements = excalidrawAPI.getSceneElements()
      const files = excalidrawAPI.getFiles()

      // Filter image elements and get their file data
      const imageElements = elements.filter(
        (element) => element.type === "image" && element.fileId
      ) as ExcalidrawImageElement[]

      const canvasImages: CanvasImage[] = imageElements
        .map((element) => {
          const file = files[element.fileId!]
          if (file) {
            return {
              id: element.id,
              fileId: element.fileId! as string,
              dataURL: file.dataURL as string,
              width: element.width,
              height: element.height,
            }
          }
          return null
        })
        .filter((img): img is CanvasImage => img !== null)

      setImages(canvasImages)
      // Set first image as default cover
      if (canvasImages.length > 0) {
        setSelectedCoverImage(canvasImages[0].fileId)
      }
    }
  }, [open, excalidrawAPI])

  const handleSubmit = async () => {
    if (!templateName.trim()) {
      toast.error(t("chat:shareTemplate.nameRequired"))
      return
    }

    if (!selectedCoverImage) {
      toast.error(t("chat:shareTemplate.coverImageRequired"))
      return
    }

    setIsSubmitting(true)

    try {
      // Get the selected cover image
      const coverImage = images.find((img) => img.fileId === selectedCoverImage)
      if (!coverImage) {
        throw new Error("Cover image not found")
      }

      // Get canvas data
      const elements = excalidrawAPI?.getSceneElements()
      const appState = excalidrawAPI?.getAppState()
      const files = excalidrawAPI?.getFiles()

      if (!elements || !appState || !files) {
        throw new Error("Failed to get canvas data")
      }

      // Prepare template data
      const templateData = {
        name: templateName,
        canvas_id: canvasId,
        session_id: sessionId,
        cover_image: coverImage.dataURL,
        message: messages,
        canvas_data: {
          elements,
          appState: {
            ...appState,
            collaborators: undefined,
          },
          files,
        },
      }

      // Call jaaz-cloud API to create template
      const response = await fetch(`${BASE_API_URL}/api/template/create`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${localStorage.getItem("jaaz_access_token")}`,
        },
        body: JSON.stringify(templateData),
      })

      if (!response.ok) {
        console.error("Failed to create template", response)
        throw new Error(`Failed to create template ${response}`)
      }

      const result = await response.json()

      toast.success(t("chat:shareTemplate.success"))
      onOpenChange(false)

      // Reset form
      setTemplateName("")
      setSelectedCoverImage("")
    } catch (error) {
      console.error("Error creating template:", error)
      toast.error(t("chat:shareTemplate.error"))
    } finally {
      setIsSubmitting(false)
    }
  }

  const handleCancel = () => {
    setTemplateName("")
    setSelectedCoverImage("")
    onOpenChange(false)
  }

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className='sm:max-w-[500px]'>
        <DialogHeader>
          <DialogTitle className='flex items-center gap-2'>
            <Share2 className='h-5 w-5' />
            {t("chat:shareTemplate.title")}
          </DialogTitle>
        </DialogHeader>

        <div className='space-y-4'>
          {/* Template Name Input */}
          <div className='space-y-2'>
            <Label htmlFor='templateName'>
              {t("chat:shareTemplate.templateName")}
            </Label>
            <Input
              id='templateName'
              value={templateName}
              onChange={(e) => setTemplateName(e.target.value)}
              placeholder={t("chat:shareTemplate.templateNamePlaceholder")}
            />
          </div>

          {/* Cover Photo Selection */}
          <div className='space-y-2'>
            <Label>{t("chat:shareTemplate.coverPhoto")}</Label>

            {images.length === 0 ? (
              <p className='text-sm text-muted-foreground'>
                {t("chat:shareTemplate.noImagesFound")}
              </p>
            ) : (
              <div className='grid grid-cols-3 gap-2 max-h-64 overflow-y-auto'>
                {images.map((image) => (
                  <div
                    key={image.fileId}
                    className={`relative cursor-pointer rounded-lg border-3 transition-colors ${
                      selectedCoverImage === image.fileId
                        ? "border-blue-500"
                        : "border-gray-200 hover:border-gray-300"
                    }`}
                    onClick={() => setSelectedCoverImage(image.fileId)}
                  >
                    <img
                      src={image.dataURL}
                      alt='Canvas image'
                      className='w-full h-20 object-cover rounded-lg'
                    />
                  </div>
                ))}
              </div>
            )}
          </div>

          {/* Action Buttons */}
          <div className='flex justify-end space-x-2 pt-4'>
            <Button
              variant='outline'
              onClick={handleCancel}
              disabled={isSubmitting}
            >
              {t("common:buttons.cancel")}
            </Button>
            <Button
              onClick={handleSubmit}
              disabled={
                isSubmitting || !templateName.trim() || !selectedCoverImage
              }
            >
              {isSubmitting
                ? t("chat:shareTemplate.creating")
                : t("chat:shareTemplate.create")}
            </Button>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  )
}



================================================
FILE: react/src/components/chat/SingleChoicePrompt.tsx
================================================
import { Button } from '@/components/ui/button'
import { Card } from '@/components/ui/card'
import { InfoIcon } from 'lucide-react'
import { Markdown } from './Markdown'

export default function SingleChoicePrompt() {
  return (
    <div className="flex flex-col gap-2">
      <Card className="p-3">
        <div className="flex gap-2">
          <InfoIcon className="w-8 h-8" />
          <Markdown>
            {`**âœ¨Post draft done!** I have made a post draft for you. Please review it. If you want to make any edits, please [open browser](https://www.medium.com) to **edit the post**. If you are happy with the post, please click the button below to submit the post.`}
          </Markdown>
        </div>
        <div className="flex gap-2">
          <Button
            size={'sm'}
            className="flex-1 bg-purple-600 dark:bg-purple-600 text-white"
          >
            Post
          </Button>
          <Button size={'sm'} variant={'secondary'} className="flex-1">
            Cancel
          </Button>
        </div>
        <Markdown>{`![My cat](https://i.imgur.com/gufUD2J.png) \n`}</Markdown>
      </Card>
    </div>
  )
}



================================================
FILE: react/src/components/chat/Spinner.tsx
================================================
import { PendingType } from '@/types/types'
import {
  Brush,
  Hammer,
  Loader2,
  Paintbrush,
  PenTool,
  ScanSearch,
  Telescope,
} from 'lucide-react'
import ShinyText from '../ui/shiny-text'
import IconCarousel from './IconCarousel'

const ChatSpinner: React.FC<{ pending: PendingType }> = ({ pending }) => {
  return (
    <div className="flex items-center justify-start select-none gap-1">
      {pending === 'image' ? (
        <>
          <Paintbrush className="animate-caret-blink size-4 text-primary/60 brush-icon-animation" />
          <ShinyText
            text="Generating image..."
            className="text-sm text-primary/60!"
            speed={2.5}
          />
        </>
      ) : pending === 'tool' ? (
        <>
          <IconCarousel
            icons={[
              <PenTool />,
              <Telescope />,
              <Brush />,
              <Hammer />,
              <ScanSearch />,
            ]}
            className="text-primary/60"
            iconClassName="size-4"
            time={1500}
          />
          <ShinyText
            text="Using tools..."
            className="text-sm text-primary/60!"
            speed={2.5}
          />
        </>
      ) : (
        <>
          <Loader2 className="animate-spin size-4 text-primary/60" />
          <ShinyText
            text="Thinking..."
            className="text-sm text-primary/60!"
            speed={2.5}
          />
        </>
      )}
    </div>
  )
}

export default ChatSpinner



================================================
FILE: react/src/components/chat/ToolcallProgressUpdate.tsx
================================================
import { eventBus } from '@/lib/event'

import { TEvents } from '@/lib/event'
import { useEffect } from 'react'

import Spinner from '@/components/ui/Spinner'
import { useState } from 'react'

export default function ToolcallProgressUpdate({
  sessionId,
}: {
  sessionId: string
}) {
  const [progress, setProgress] = useState('')

  useEffect(() => {
    const handleToolCallProgress = (
      data: TEvents['Socket::Session::ToolCallProgress']
    ) => {
      if (data.session_id === sessionId) {
        setProgress(data.update)
      }
    }

    eventBus.on('Socket::Session::ToolCallProgress', handleToolCallProgress)
    return () => {
      eventBus.off('Socket::Session::ToolCallProgress', handleToolCallProgress)
    }
  }, [sessionId])
  if (!progress) return null
  return (
    <div className="flex items-center gap-2 bg-purple-200 dark:bg-purple-500 rounded-full p-2">
      <Spinner size={4} />
      {progress}
    </div>
  )
}



================================================
FILE: react/src/components/chat/Message/Image.tsx
================================================
import { Button } from '@/components/ui/button'
import { useCanvas } from '@/contexts/canvas'
import { useTranslation } from 'react-i18next'
import { PhotoView } from 'react-photo-view'

type MessageImageProps = {
  content: {
    image_url: {
      url: string
    }
    type: 'image_url'
  }
}

const MessageImage = ({ content }: MessageImageProps) => {
  const { excalidrawAPI } = useCanvas()
  const files = excalidrawAPI?.getFiles()
  const filesArray = Object.keys(files || {}).map((key) => ({
    id: key,
    url: files![key].dataURL,
  }))

  const { t } = useTranslation()

  const handleImagePositioning = (id: string) => {
    excalidrawAPI?.scrollToContent(id, { animate: true })
  }
  const id = filesArray.find((file) =>
    content.image_url.url?.includes(file.url)
  )?.id

  return (
    <div className="w-full max-w-[140px]">
      <PhotoView src={content.image_url.url}>
        <div className="relative group cursor-pointer">
          <img
            className="w-full h-auto max-h-[140px] object-cover rounded-md border border-border hover:scale-105 transition-transform duration-300"
            src={content.image_url.url}
            alt="Image"
          />

          {id && (
            <Button
              variant="secondary"
              size="sm"
              className="group-hover:opacity-100 opacity-0 absolute top-2 right-2 z-10 text-xs"
              onClick={(e) => {
                e.stopPropagation()
                handleImagePositioning(id)
              }}
            >
              {t('chat:messages:imagePositioning')}
            </Button>
          )}
        </div>
      </PhotoView>
    </div>
  )
}

export default MessageImage



================================================
FILE: react/src/components/chat/Message/MixedContent.tsx
================================================
import { Message, MessageContent } from '@/types/types'
import { Markdown } from '../Markdown'
import MessageImage from './Image'

type MixedContentProps = {
  message: Message
  contents: MessageContent[]
}

type MixedContentImagesProps = {
  contents: MessageContent[]
}

type MixedContentTextProps = {
  message: Message
  contents: MessageContent[]
}

// å›¾ç‰‡ç»„ä»¶ - ç‹¬ç«‹æ˜¾ç¤ºåœ¨èŠå¤©æ¡†å¤–
export const MixedContentImages: React.FC<MixedContentImagesProps> = ({ contents }) => {
  const images = contents.filter((content) => content.type === 'image_url')
  
  if (images.length === 0) return null

  return (
    <div className="px-4">
      {images.length === 1 ? (
        // å•å¼ å›¾ç‰‡ï¼šä¿æŒé•¿å®½æ¯”ï¼Œæœ€å¤§å®½åº¦é™åˆ¶
        <div className="max-h-[512px] flex justify-end">
          <MessageImage content={images[0]} />
        </div>
      ) : (
        // å¤šå¼ å›¾ç‰‡ï¼šæ¨ªå‘æ’å¸ƒï¼Œç¬¬ä¸€å¼ å›¾é å³
        <div className="flex gap-2 max-h-[512px] justify-end flex-row-reverse">
          {images.map((image, index) => (
            <div key={index} className="max-h-[512px]">
              <MessageImage content={image} />
            </div>
          ))}
        </div>
      )}
    </div>
  )
}

// æ–‡æœ¬ç»„ä»¶ - æ˜¾ç¤ºåœ¨èŠå¤©æ¡†å†…
export const MixedContentText: React.FC<MixedContentTextProps> = ({ message, contents }) => {
  const textContents = contents.filter((content) => content.type === 'text')

  // è¿‡æ»¤æ‰æ–‡æœ¬ä¸­çš„å›¾ç‰‡å¼•ç”¨ï¼Œåªä¿ç•™çº¯æ–‡æœ¬
  const combinedText = textContents
    .map((content) => content.text)
    .join('\n')
    .replace(/!\[.*?\]\(.*?\)/g, '') // ç§»é™¤markdownå›¾ç‰‡è¯­æ³•
    .replace(/!\[.*?\]\[.*?\]/g, '') // ç§»é™¤å¼•ç”¨å¼å›¾ç‰‡è¯­æ³•
    .replace(/^\s*$/gm, '') // ç§»é™¤ç©ºè¡Œ
    .trim()

  if (!combinedText) return null

  return (
    <>
      {message.role === 'user' ? (
        <div className="flex justify-end mb-4">
          <div className="bg-primary text-primary-foreground rounded-xl rounded-br-md px-4 py-3 text-left max-w-[300px] w-fit">
            <div className="w-full">
              <Markdown>{combinedText}</Markdown>
            </div>
          </div>
        </div>
      ) : (
        <div className="text-gray-800 dark:text-gray-200 text-left items-start mb-4">
          <div className="w-full">
            <Markdown>{combinedText}</Markdown>
          </div>
        </div>
      )}
    </>
  )
}

// ä¿æŒåŸæœ‰çš„MixedContentç»„ä»¶ä½œä¸ºå‘åå…¼å®¹ï¼ˆå¦‚æœéœ€è¦çš„è¯ï¼‰
const MixedContent: React.FC<MixedContentProps> = ({ message, contents }) => {
  return (
    <>
      <MixedContentImages contents={contents} />
      <MixedContentText message={message} contents={contents} />
    </>
  )
}

export default MixedContent



================================================
FILE: react/src/components/chat/Message/Regular.tsx
================================================
import { Message, MessageContent } from '@/types/types'
import { Markdown } from '../Markdown'
import MessageImage from './Image'

type MessageRegularProps = {
  message: Message
  content: MessageContent | string
}

const MessageRegular: React.FC<MessageRegularProps> = ({
  message,
  content,
}) => {
  const isStrContent = typeof content === 'string'
  const isText = isStrContent || (!isStrContent && content.type == 'text')

  const markdownText = isStrContent
    ? content
    : content.type === 'text'
      ? content.text
      : ''
  if (!isText) return <MessageImage content={content} />

  return (
    <>
      {message.role === 'user' ? (
        <div className="flex justify-end mb-4">
          <div className="bg-primary text-primary-foreground rounded-xl rounded-br-md px-4 py-3 text-left max-w-[300px] w-fit flex flex-col">
            <Markdown>{markdownText}</Markdown>
          </div>
        </div>
      ) : (
        <div className="text-gray-800 dark:text-gray-200 text-left items-start mb-4 flex flex-col">
          <Markdown>{markdownText}</Markdown>
        </div>
      )}
    </>
  )
}

export default MessageRegular



================================================
FILE: react/src/components/chat/Message/TextFoldTag.tsx
================================================
import { Button } from '@/components/ui/button'
import { cn } from '@/lib/utils'
import { ChevronDown, ChevronRight } from 'lucide-react'
import { AnimatePresence, motion } from 'motion/react'
import { ReactNode } from 'react'
import { useTranslation } from 'react-i18next'

type TextFoldTagProps = {
  children: ReactNode
  isExpanded: boolean
  onToggleExpand: () => void
  buttonText?: string
}

const TextFoldTag: React.FC<TextFoldTagProps> = ({
  children,
  isExpanded,
  onToggleExpand,
  buttonText,
}) => {
  const { t } = useTranslation()
  return (
    <div className="bg-[rgb(254,252,232)] dark:bg-[rgb(50,40,16)] border border-[rgb(254,249,195)] dark:border-[rgb(81,66,27)] rounded-md shadow-sm overflow-hidden max-w-full mb-4">
      <div
        className="flex items-center justify-between p-3 cursor-pointer hover:bg-[rgb(254,249,195)] dark:hover:bg-[rgb(81,66,27)] transition-colors"
        onClick={onToggleExpand}
      >
        <div className="flex items-center gap-2">
          <div className="bg-[rgb(254,249,195)] dark:bg-[rgb(81,66,27)] p-1 rounded">
            <svg className="w-4 h-4 text-[rgb(161,98,7)] dark:text-[rgb(253,224,71)]" fill="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
              <path clipRule="evenodd" fillRule="evenodd" d="M4.804 21.644A6.707 6.707 0 0 0 6 21.75a6.721 6.721 0 0 0 3.583-1.029c.774.182 1.584.279 2.417.279 5.322 0 9.75-3.97 9.75-9 0-5.03-4.428-9-9.75-9s-9.75 3.97-9.75 9c0 2.409 1.025 4.587 2.674 6.192.232.226.277.428.254.543a3.73 3.73 0 0 1-.814 1.686.75.75 0 0 0 .44 1.223ZM8.25 10.875a1.125 1.125 0 1 0 0 2.25 1.125 1.125 0 0 0 0-2.25ZM10.875 12a1.125 1.125 0 1 1 2.25 0 1.125 1.125 0 0 1-2.25 0Zm4.875-1.125a1.125 1.125 0 1 0 0 2.25 1.125 1.125 0 0 0 0-2.25Z"></path>
            </svg>
          </div>
          <p className="font-bold text-[rgb(161,98,7)] dark:text-[rgb(253,224,71)]">
            {buttonText || t('chat:thinking.title')}
          </p>
        </div>
        {isExpanded ? (
          <ChevronDown className="h-4 w-4 text-[rgb(161,98,7)] dark:text-[rgb(253,224,71)]" />
        ) : (
          <ChevronRight className="h-4 w-4 text-[rgb(161,98,7)] dark:text-[rgb(253,224,71)]" />
        )}
      </div>

      <AnimatePresence>
        {isExpanded && (
          <motion.div
            initial={{ opacity: 0, height: 0 }}
            animate={{ opacity: 1, height: 'auto' }}
            exit={{ opacity: 0, height: 0 }}
            transition={{ duration: 0.3, ease: 'easeOut' }}
            className="overflow-hidden"
          >
            <div className="border-t border-[rgb(254,249,195)] dark:border-[rgb(81,66,27)]">
              <div className="p-3 max-w-full overflow-hidden">
                {children}
              </div>
            </div>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  )
}

export default TextFoldTag


================================================
FILE: react/src/components/chat/Message/ToolCallContent.tsx
================================================
import { ToolResultMessage } from '@/types/types'
import { AnimatePresence, motion } from 'motion/react'
import { Markdown } from '../Markdown'

type ToolCallContentProps = {
  expandingToolCalls: string[]
  message: ToolResultMessage
}

export const ToolCallContent: React.FC<ToolCallContentProps> = ({
  expandingToolCalls,
  message,
}) => {
  const isExpanded = expandingToolCalls.includes(message.tool_call_id)

  if (message.content.includes('<hide_in_user_ui>')) {
    return null
  }

  return (
    <AnimatePresence>
      {isExpanded && (
        <motion.div
          initial={{ opacity: 0, y: -5, height: 0 }}
          animate={{ opacity: 1, y: 0, height: 'auto' }}
          exit={{ opacity: 0, y: -5, height: 0 }}
          layout
          transition={{ duration: 0.2, ease: 'easeOut' }}
          className="p-3 bg-muted rounded-lg"
        >
          <Markdown>{message.content}</Markdown>
        </motion.div>
      )}
    </AnimatePresence>
  )
}

const ToolCallContentV2: React.FC<{ content: string }> = ({ content }) => {
  if (content.includes('<hide_in_user_ui>')) {
    return null
  }

  return (
    <div className="p-2 bg-muted rounded-lg">
      <Markdown>{content}</Markdown>
    </div>
  )
}

export default ToolCallContentV2



================================================
FILE: react/src/components/chat/Message/ToolCallTag.tsx
================================================
import { Button } from '@/components/ui/button'
import { TOOL_CALL_NAME_MAPPING } from '@/constants'
import { ToolCall } from '@/types/types'
import {
  ChevronDown,
  ChevronRight,
  AlertTriangle,
  Check,
  X,
} from 'lucide-react'
import MultiChoicePrompt from '../MultiChoicePrompt'
import SingleChoicePrompt from '../SingleChoicePrompt'
import WritePlanToolCall from './WritePlanToolcall'
import ToolCallContentV2 from './ToolCallContent'
import { useTranslation } from 'react-i18next'

type ToolCallTagProps = {
  toolCall: ToolCall
  isExpanded: boolean
  onToggleExpand: () => void
  requiresConfirmation?: boolean
  onConfirm?: () => void
  onCancel?: () => void
}

const ToolCallTag: React.FC<ToolCallTagProps> = ({
  toolCall,
  isExpanded,
  onToggleExpand,
  requiresConfirmation = false,
  onConfirm,
  onCancel,
}) => {
  const { name, arguments: inputs } = toolCall.function
  const { t } = useTranslation()

  if (name == 'prompt_user_multi_choice') {
    return <MultiChoicePrompt />
  }
  if (name == 'prompt_user_single_choice') {
    return <SingleChoicePrompt />
  }
  if (name == 'write_plan') {
    return <WritePlanToolCall args={inputs} />
  }
  if (name.startsWith('transfer_to')) {
    return null
  }

  const needsConfirmation = requiresConfirmation

  let parsedArgs = null
  try {
    parsedArgs = JSON.parse(inputs)
  } catch (error) {
    console.error('Error parsing args:', error, 'Raw input:', inputs)
    // å°è¯•æ¸…ç†è¾“å…¥å­—ç¬¦ä¸²ï¼Œç§»é™¤å¯èƒ½çš„é¢å¤–å†…å®¹
    try {
      const cleanedInput = inputs.trim()
      const jsonEndIndex = cleanedInput.lastIndexOf('}')
      if (jsonEndIndex > 0) {
        const jsonPart = cleanedInput.substring(0, jsonEndIndex + 1)
        parsedArgs = JSON.parse(jsonPart)
        console.log('Successfully parsed cleaned JSON:', jsonPart)
      }
    } catch (cleanError) {
      console.error('Failed to parse even after cleaning:', cleanError)
    }
  }

  // æ™®é€šæ¨¡å¼çš„æ ·å¼
  return (
    <div className="bg-green-50 dark:bg-green-950/50 border border-green-200 dark:border-green-800 rounded-md shadow-sm overflow-hidden">
      {/* Header */}
      <div
        className="flex items-center justify-between p-3 cursor-pointer hover:bg-green-100/50 dark:hover:bg-green-900/30 transition-colors"
        onClick={onToggleExpand}
      >
        <div className="flex items-center gap-2">
          <div className="bg-green-200/70 dark:bg-green-800 p-1 rounded">
            <svg
              className="w-4 h-4 text-green-700 dark:text-green-300"
              fill="currentColor"
              viewBox="0 0 24 24"
              xmlns="http://www.w3.org/2000/svg"
              aria-hidden="true"
            >
              <path
                clipRule="evenodd"
                fillRule="evenodd"
                d="M20.599 1.5c-.376 0-.743.111-1.055.32l-5.08 3.385a18.747 18.747 0 0 0-3.471 2.987 10.04 10.04 0 0 1 4.815 4.815 18.748 18.748 0 0 0 2.987-3.472l3.386-5.079A1.902 1.902 0 0 0 20.599 1.5Zm-8.3 14.025a18.76 18.76 0 0 0 1.896-1.207 8.026 8.026 0 0 0-4.513-4.513A18.75 18.75 0 0 0 8.475 11.7l-.278.5a5.26 5.26 0 0 1 3.601 3.602l.502-.278ZM6.75 13.5A3.75 3.75 0 0 0 3 17.25a1.5 1.5 0 0 1-1.601 1.497.75.75 0 0 0-.7 1.123 5.25 5.25 0 0 0 9.8-2.62 3.75 3.75 0 0 0-3.75-3.75Z"
              ></path>
            </svg>
          </div>

          <div className="font-bold text-green-900 dark:text-green-100 leading-relaxed break-all">
            {TOOL_CALL_NAME_MAPPING[name] ?? name}
          </div>
        </div>
        <div className="flex items-center gap-2">
          {needsConfirmation && (
            <div className="bg-yellow-200 dark:bg-yellow-800 text-yellow-800 dark:text-yellow-200 text-xs px-2 py-0.5 rounded-full flex items-center gap-1">
              <AlertTriangle className="h-3 w-3" />
              {t('chat.toolCall.requiresConfirmation', 'Needs Confirmation')}
            </div>
          )}
          {!needsConfirmation && toolCall.result === 'å·¥å…·è°ƒç”¨å·²å–æ¶ˆ' && (
            <div className="bg-gray-200 dark:bg-gray-800 text-gray-800 dark:text-gray-200 text-xs px-2 py-0.5 rounded-full flex items-center gap-1">
              <X className="h-3 w-3" />
              {t('chat.toolCall.cancelled', 'Cancelled')}
            </div>
          )}
          {parsedArgs && Object.keys(parsedArgs).length > 0 && (
            <div className="bg-green-200 dark:bg-green-800 text-green-800 dark:text-green-200 text-xs px-2 py-0.5 rounded-full">
              {Object.keys(parsedArgs).length}
            </div>
          )}
          {isExpanded ? (
            <ChevronDown className="h-4 w-4 text-green-600 dark:text-green-400" />
          ) : (
            <ChevronRight className="h-4 w-4 text-green-600 dark:text-green-400" />
          )}
        </div>
      </div>

      {/* Collapsible Content */}
      {isExpanded && (
        <div className="border-t border-green-200 dark:border-green-950">
          <div className="p-3">
            {parsedArgs && Object.keys(parsedArgs).length > 0 ? (
              <div className="space-y-2">
                {Object.entries(parsedArgs).map(([key, value]) => (
                  <div
                    key={key}
                    className="bg-white dark:bg-gray-950 border border-green-200 dark:border-green-950 rounded-md p-3 hover:shadow-sm transition-shadow"
                  >
                    <div className="flex flex-col gap-1">
                      <span className="font-bold text-green-900 dark:text-green-100">
                        {key}:
                      </span>
                      <div className="text-gray-600 dark:text-gray-400 leading-relaxed break-all">
                        {typeof value == 'object'
                          ? JSON.stringify(value, null, 2)
                          : String(value)}
                      </div>
                    </div>
                  </div>
                ))}
              </div>
            ) : (
              <div className="bg-white dark:bg-gray-950 border border-green-200 dark:border-green-950 rounded-md p-3 hover:shadow-sm transition-shadow">
                <div className="text-gray-600 dark:text-gray-400 leading-relaxed break-all">
                  {inputs}
                </div>
              </div>
            )}
            {toolCall.result && <ToolCallContentV2 content={toolCall.result} />}

            {/* ç¡®è®¤æŒ‰é’® - ä»…åœ¨éœ€è¦ç¡®è®¤æ—¶æ˜¾ç¤º */}
            {needsConfirmation && (
              <div className="mt-4 pt-4 border-t border-green-200 dark:border-green-800">
                <div className="flex gap-2">
                  <Button
                    onClick={onConfirm}
                    className="flex-1 bg-green-600 hover:bg-green-700 text-white"
                  >
                    <Check className="h-4 w-4 mr-2" />
                    {t('chat.toolCall.confirm', 'Confirm')}
                  </Button>
                  <Button
                    onClick={onCancel}
                    variant="outline"
                    className="flex-1 border-green-300 text-green-700 hover:bg-green-100"
                  >
                    <X className="h-4 w-4 mr-2" />
                    {t('chat.toolCall.cancel', 'Cancel')}
                  </Button>
                </div>
              </div>
            )}

            {/* å–æ¶ˆçŠ¶æ€æ˜¾ç¤º */}
            {!needsConfirmation && toolCall.result === 'å·¥å…·è°ƒç”¨å·²å–æ¶ˆ' && (
              <div className="mt-4 pt-4 border-t border-gray-200 dark:border-gray-800">
                <div className="flex items-center gap-2 text-gray-500 dark:text-gray-400">
                  <X className="h-4 w-4" />
                  <span className="text-sm">å·¥å…·è°ƒç”¨å·²å–æ¶ˆ</span>
                </div>
              </div>
            )}
          </div>
        </div>
      )}
    </div>
  )
}

export default ToolCallTag



================================================
FILE: react/src/components/chat/Message/WritePlanToolcall.tsx
================================================
import React, { useState } from 'react'
import { ChevronDown, ChevronRight, FileText, CheckCircle2 } from 'lucide-react'
import { useTranslation } from 'react-i18next'
export default function WritePlanToolCall({ args }: { args: string }) {
  const [isExpanded, setIsExpanded] = useState(true)
  const { t } = useTranslation()

  let parsedArgs: {
    steps: {
      title: string
      description: string
    }[]
  } | null = null

  try {
    parsedArgs = JSON.parse(args)
  } catch (error) {}

  return (
    <div className="bg-purple-50 dark:bg-purple-950/50 border border-purple-200 dark:border-purple-800 rounded-md shadow-sm overflow-hidden">
      {/* Header */}
      <div
        className="flex items-center justify-between p-3 cursor-pointer hover:bg-purple-100/50 dark:hover:bg-purple-900/30 transition-colors"
        onClick={() => setIsExpanded(!isExpanded)}
      >
        <div className="flex items-center gap-2">
          <div className="bg-purple-200/70 dark:bg-purple-800 p-1 rounded">
            <FileText className="h-4 w-4 text-purple-700 dark:text-purple-300" />
          </div>

          <p className="font-bold text-purple-900 dark:text-purple-100">
            {t('chat:plan.title')}
          </p>
        </div>
        <div className="flex items-center gap-2">
          {parsedArgs && (
            <div className="bg-purple-200 dark:bg-purple-800 text-purple-800 dark:text-purple-200 text-xs px-2 py-0.5 rounded-full">
              {parsedArgs.steps.length}
            </div>
          )}
          {isExpanded ? (
            <ChevronDown className="h-4 w-4 text-purple-600 dark:text-purple-400" />
          ) : (
            <ChevronRight className="h-4 w-4 text-purple-600 dark:text-purple-400" />
          )}
        </div>
      </div>

      {/* Collapsible Content */}
      {isExpanded && (
        <div className="border-t border-purple-200 dark:border-purple-950">
          <div className="p-3 space-y-2">
            {parsedArgs?.steps.map((step, index) => (
              <div
                key={`${step.title}-${index}`}
                className="bg-white dark:bg-gray-950 border border-purple-200 dark:border-purple-950 rounded-md p-3 hover:shadow-sm transition-shadow"
              >
                <div className="flex items-start gap-2">
                  <div className="bg-purple-100 dark:bg-purple-900 border border-purple-300 dark:border-purple-950 rounded-full p-0.5 mt-0.5 flex-shrink-0">
                    <CheckCircle2 className="h-3 w-3 text-purple-600 dark:text-purple-400" />
                  </div>
                  <div className="flex-1 min-w-0">
                    <h4 className="text-md font-bold text-gray-900 dark:text-gray-100 mb-1">
                      {index + 1}. {step.title}
                    </h4>
                    {step.description && (
                      <p className="text-gray-600 dark:text-gray-400 leading-relaxed">
                        {step.description}
                      </p>
                    )}
                  </div>
                </div>
              </div>
            ))}
          </div>
        </div>
      )}
    </div>
  )
}



================================================
FILE: react/src/components/comfyui/InstallComfyUIDialog.tsx
================================================
import CommonDialogContent from '@/components/common/DialogContent'
import { Button } from '@/components/ui/button'
import {
  Dialog,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog'
import Spinner from '@/components/ui/Spinner'
import { useConfigs } from '@/contexts/configs'
import { useCallback, useState } from 'react'
import { toast } from 'sonner'
import InstallProgressDialog from './InstallProgressDialog'

interface InstallComfyUIDialogProps {
  onOpenChange?: (open: boolean) => void
  onInstallSuccess?: () => void
}

const InstallComfyUIDialog = ({
  onOpenChange,
  onInstallSuccess,
}: InstallComfyUIDialogProps) => {
  const [isInstalling, setIsInstalling] = useState(false)
  const [showProgressDialog, setShowProgressDialog] = useState(false)

  const { showInstallDialog: open, setShowInstallDialog } = useConfigs()

  const handleInstallComfyUI = async () => {
    setIsInstalling(true)
    setShowProgressDialog(true)
    handleOpenChange(false) // Close the initial dialog

    try {
      const result = await window.electronAPI?.installComfyUI()
      if (result?.success) {
        toast.success('ComfyUI installation successful!')
      } else {
        toast.error(`Installation failed: ${result?.error}`)
        setShowProgressDialog(false)
      }
    } catch (error: unknown) {
      const errorMessage =
        error instanceof Error ? error.message : String(error)
      toast.error(`Installation failed: ${errorMessage}`)
      setShowProgressDialog(false)
    } finally {
      setIsInstalling(false)
    }
  }

  const handleInstallComplete = () => {
    setShowProgressDialog(false)
    setIsInstalling(false)
    onInstallSuccess?.()

    window.location.reload()
  }

  const handleOpenChange = useCallback(
    (open: boolean) => {
      setShowInstallDialog(open)
      onOpenChange?.(open)
    },
    [onOpenChange, setShowInstallDialog]
  )

  return (
    <>
      <Dialog open={open} onOpenChange={handleOpenChange}>
        <CommonDialogContent open={open}>
          <DialogHeader>
            <DialogTitle>ğŸ¨ Install Flux Image Generation Model</DialogTitle>
            <DialogDescription>
              No image generation models detected.
              <br />
              To use AI image generation features, you can install ComfyUI and
              Flux models.
            </DialogDescription>
            <div className="text-sm text-muted-foreground mt-2">
              This will:
              <ul className="list-disc list-inside mt-2 space-y-1">
                <li>Download and install ComfyUI (~2000MB)</li>
                <li>Configure Flux image generation models</li>
                <li>Start local image generation service</li>
              </ul>
            </div>
          </DialogHeader>
          <DialogFooter>
            <Button
              variant="outline"
              onClick={() => handleOpenChange(false)}
              disabled={isInstalling}
            >
              Cancel
            </Button>
            <Button onClick={handleInstallComfyUI} disabled={isInstalling}>
              {isInstalling ? (
                <>
                  <Spinner />
                  Installing...
                </>
              ) : (
                'Install Flux Image Model'
              )}
            </Button>
          </DialogFooter>
        </CommonDialogContent>
      </Dialog>

      <InstallProgressDialog
        open={showProgressDialog}
        onOpenChange={setShowProgressDialog}
        onInstallComplete={handleInstallComplete}
      />
    </>
  )
}

export default InstallComfyUIDialog



================================================
FILE: react/src/components/comfyui/InstallProgressDialog.tsx
================================================
import { Button } from '@/components/ui/button'
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Progress } from "@/components/ui/progress";
import { ScrollArea } from "@/components/ui/scroll-area";
import { useEffect, useState, useRef } from 'react';

interface InstallProgressDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onInstallComplete?: () => void;
}

interface ProgressData {
  percent: number;
  status: string;
}

interface LogData {
  message: string;
}

const InstallProgressDialog = ({ open, onOpenChange, onInstallComplete }: InstallProgressDialogProps) => {
  const [progress, setProgress] = useState(0);
  const [status, setStatus] = useState("Preparing to start download...");
  const [logs, setLogs] = useState<string[]>(["Waiting to start..."]);
  const [isCompleted, setIsCompleted] = useState(false);
  const [hasError, setHasError] = useState(false);
  const [isCancelling, setIsCancelling] = useState(false);
  const [isCancelled, setIsCancelled] = useState(false);
  const logContainerRef = useRef<HTMLDivElement>(null);

  // Auto-scroll to bottom when logs change
  useEffect(() => {
    if (logContainerRef.current) {
      // Find the scrollable viewport within ScrollArea
      const scrollableElement = logContainerRef.current.closest('[data-radix-scroll-area-viewport]') as HTMLElement;
      if (scrollableElement) {
        scrollableElement.scrollTop = scrollableElement.scrollHeight;
      } else {
        // Fallback: try to scroll the parent element
        const parent = logContainerRef.current.parentElement;
        if (parent) {
          parent.scrollTop = parent.scrollHeight;
        }
      }
    }
  }, [logs]);

  useEffect(() => {
    if (!open) {
      // Reset state when dialog closes
      setProgress(0);
      setStatus("Preparing to start download...");
      setLogs(["Waiting to start..."]);
      setIsCompleted(false);
      setHasError(false);
      setIsCancelling(false);
      setIsCancelled(false);
      return;
    }

    // Listen for installation progress events
    const handleProgress = (event: CustomEvent<ProgressData>) => {
      const { percent, status } = event.detail;
      setProgress(percent);
      setStatus(status);

      if (percent >= 100) {
        setIsCompleted(true);
        setTimeout(() => {
          onInstallComplete?.();
          onOpenChange(false);
        }, 3000);
      }
    };

    const handleLog = (event: CustomEvent<LogData>) => {
      const { message } = event.detail;
      setLogs(prev => [...prev, message]);

      // Check for error messages
      if (message.toLowerCase().includes('error') || message.toLowerCase().includes('failed')) {
        setHasError(true);
      }
    };

    const handleError = (event: CustomEvent<{ error: string }>) => {
      const { error } = event.detail;
      setHasError(true);
      setStatus(`Installation failed: ${error}`);
      setLogs(prev => [...prev, `Error: ${error}`]);
    };

    const handleCancelled = (event: CustomEvent<{ message: string }>) => {
      const { message } = event.detail;
      setIsCancelled(true);
      setIsCancelling(false);
      setStatus('Installation cancelled');
      setLogs(prev => [...prev, `Cancelled: ${message}`]);
    };

    // Add event listeners
    window.addEventListener('comfyui-install-progress', handleProgress as EventListener);
    window.addEventListener('comfyui-install-log', handleLog as EventListener);
    window.addEventListener('comfyui-install-error', handleError as EventListener);
    window.addEventListener('comfyui-install-cancelled', handleCancelled as EventListener);

    return () => {
      // Remove event listeners
      window.removeEventListener('comfyui-install-progress', handleProgress as EventListener);
      window.removeEventListener('comfyui-install-log', handleLog as EventListener);
      window.removeEventListener('comfyui-install-error', handleError as EventListener);
      window.removeEventListener('comfyui-install-cancelled', handleCancelled as EventListener);
    };
  }, [open, onInstallComplete, onOpenChange]);

  const handleClose = () => {
    if (!isCompleted && !hasError && !isCancelled) {
      // Don't allow closing during installation unless there's an error or it's cancelled
      return;
    }
    onOpenChange(false);
  };

  const handleCancel = async () => {
    if (isCompleted || hasError || isCancelling || isCancelled) {
      return;
    }

    setIsCancelling(true);
    setStatus('Cancelling installation...');
    setLogs(prev => [...prev, 'User requested cancellation...']);

    try {
      // Call electron API to cancel installation
      if (window.electronAPI?.cancelComfyUIInstall) {
        await window.electronAPI.cancelComfyUIInstall();
      }
    } catch (error) {
      console.error('Failed to cancel installation:', error);
      setLogs(prev => [...prev, `Failed to cancel: ${error}`]);
    }
  };

  const canCancel = !isCompleted && !hasError && !isCancelling && !isCancelled;
  const canClose = isCompleted || hasError || isCancelled;

  return (
    <Dialog open={open} onOpenChange={handleClose}>
      <DialogContent className="max-w-2xl">
        <DialogHeader>
          <DialogTitle>ğŸ¨ Installing Flux Image Generation Model</DialogTitle>
          <DialogDescription>
            {status}
          </DialogDescription>
        </DialogHeader>

        <div className="space-y-4">
          {/* Progress Bar */}
          <div className="space-y-2">
            <Progress value={progress} className="w-full" />
            <div className="text-sm text-muted-foreground text-center">
              {Math.round(progress)}%
            </div>
          </div>

          {/* Log Area */}
          <div className="space-y-2">
            <div className="text-sm font-medium">Installation Log:</div>
            <ScrollArea className="h-48 w-full border rounded-md p-3">
              <div className="space-y-1 font-mono text-xs" ref={logContainerRef}>
                {logs.map((log, index) => (
                  <div
                    key={index}
                    className={`break-all whitespace-pre-wrap ${log.toLowerCase().includes('error') || log.toLowerCase().includes('failed')
                      ? 'text-red-600 dark:text-red-400'
                      : log.toLowerCase().includes('success') || log.toLowerCase().includes('completed')
                        ? 'text-green-600 dark:text-green-400'
                        : log.toLowerCase().includes('cancel')
                          ? 'text-yellow-600 dark:text-yellow-400'
                          : 'text-foreground'
                      }`}
                  >
                    {log}
                  </div>
                ))}
              </div>
            </ScrollArea>
          </div>
        </div>

        <DialogFooter className="flex justify-between">
          <div className="flex gap-2">
            {canCancel && (
              <Button
                variant="outline"
                onClick={handleCancel}
                disabled={isCancelling}
              >
                {isCancelling ? "Cancelling..." : "Cancel Installation"}
              </Button>
            )}
          </div>

          <div className="flex gap-2">
            {canClose && (
              <Button onClick={handleClose}>
                Close
              </Button>
            )}
            {!canClose && !canCancel && (
              <div className="text-sm text-muted-foreground">
                Installation in progress... Please wait.
              </div>
            )}
          </div>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};

export default InstallProgressDialog;



================================================
FILE: react/src/components/comfyui/UninstallProgressDialog.tsx
================================================
import { Button } from '@/components/ui/button'
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Progress } from "@/components/ui/progress";
import { ScrollArea } from "@/components/ui/scroll-area";
import { useEffect, useState, useRef } from 'react';
import { useTranslation } from 'react-i18next';

interface UninstallProgressDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onUninstallComplete?: () => void;
  onConfirmUninstall?: () => void;
}

interface ProgressData {
  percent: number;
  status: string;
}

interface LogData {
  message: string;
}

const UninstallProgressDialog = ({ open, onOpenChange, onUninstallComplete, onConfirmUninstall }: UninstallProgressDialogProps) => {
  const { t } = useTranslation();
  const [progress, setProgress] = useState(0);
  const [logs, setLogs] = useState<string[]>([t('settings:comfyui.uninstallProgress.preparing')]);
  const [isCompleted, setIsCompleted] = useState(false);
  const [hasError, setHasError] = useState(false);
  const [isConfirming, setIsConfirming] = useState(true);
  const logContainerRef = useRef<HTMLDivElement>(null);

  // Auto-scroll to bottom when logs change
  useEffect(() => {
    if (logContainerRef.current) {
      // Find the scrollable viewport within ScrollArea
      const scrollableElement = logContainerRef.current.closest('[data-radix-scroll-area-viewport]') as HTMLElement;
      if (scrollableElement) {
        scrollableElement.scrollTop = scrollableElement.scrollHeight;
      } else {
        // Fallback: try to scroll the parent element
        const parent = logContainerRef.current.parentElement;
        if (parent) {
          parent.scrollTop = parent.scrollHeight;
        }
      }
    }
  }, [logs]);

  useEffect(() => {
    if (!open) {
      // Reset state when dialog closes
      setProgress(0);
      setLogs([t('settings:comfyui.uninstallProgress.preparing')]);
      setIsCompleted(false);
      setHasError(false);
      setIsConfirming(true);
      return;
    }

    // Skip event listeners if still confirming
    if (isConfirming) {
      return;
    }

    // Listen for uninstallation progress events
    const handleProgress = (event: CustomEvent<ProgressData>) => {
      const { percent } = event.detail;
      setProgress(percent);

      if (percent >= 100) {
        setIsCompleted(true);
        setTimeout(() => {
          onUninstallComplete?.();
          onOpenChange(false);
        }, 2000);
      }
    };

    const handleLog = (event: CustomEvent<LogData>) => {
      const { message } = event.detail;
      setLogs(prev => [...prev, message]);

      // Check for error messages
      if (message.toLowerCase().includes('error') || message.toLowerCase().includes('failed')) {
        setHasError(true);
      }

      // Check for completion message
      if (message.includes('completed successfully')) {
        setIsCompleted(true);
        setTimeout(() => {
          onUninstallComplete?.();
          onOpenChange(false);
        }, 2000);
      }
    };

    const handleError = (event: CustomEvent<{ error: string }>) => {
      const { error } = event.detail;
      setHasError(true);
      setLogs(prev => [...prev, `Error: ${error}`]);
    };

    // Add event listeners
    window.addEventListener('comfyui-uninstall-progress', handleProgress as EventListener);
    window.addEventListener('comfyui-uninstall-log', handleLog as EventListener);
    window.addEventListener('comfyui-uninstall-error', handleError as EventListener);

    return () => {
      // Remove event listeners
      window.removeEventListener('comfyui-uninstall-progress', handleProgress as EventListener);
      window.removeEventListener('comfyui-uninstall-log', handleLog as EventListener);
      window.removeEventListener('comfyui-uninstall-error', handleError as EventListener);
    };
  }, [open, onUninstallComplete, onOpenChange, isConfirming, t]);

  const handleConfirm = () => {
    setIsConfirming(false);
    onConfirmUninstall?.();
  };

  const handleCancel = () => {
    onOpenChange(false);
  };

  const handleClose = () => {
    if (!isCompleted && !hasError && !isConfirming) {
      // Don't allow closing during uninstallation unless there's an error
      return;
    }
    onOpenChange(false);
  };

  const canClose = isCompleted || hasError || isConfirming;

  return (
    <Dialog open={open} onOpenChange={handleClose}>
      <DialogContent className="max-w-2xl">
        <DialogHeader>
          <DialogTitle>ğŸ—‘ï¸ {t('settings:comfyui.uninstallButton')}</DialogTitle>
        </DialogHeader>

        {isConfirming ? (
          // Confirmation view
          <div className="py-4">
            <p className="text-sm text-muted-foreground">
              {t('settings:comfyui.confirmUninstall')}
            </p>
          </div>
        ) : (
          // Progress view
          <div className="space-y-4">
            {/* Progress Bar */}
            <div className="space-y-2">
              <Progress value={progress} className="w-full" />
              <div className="text-sm text-muted-foreground text-center">
                {Math.round(progress)}%
              </div>
            </div>

            {/* Log Area */}
            <div className="space-y-2">
              <div className="text-sm font-medium">{t('settings:comfyui.uninstallProgress.logTitle')}</div>
              <ScrollArea className="h-48 w-full border rounded-md p-3">
                <div className="space-y-1 font-mono text-xs" ref={logContainerRef}>
                  {logs.map((log, index) => (
                    <div
                      key={index}
                      className={`break-all whitespace-pre-wrap ${log.toLowerCase().includes('error') || log.toLowerCase().includes('failed')
                        ? 'text-red-600 dark:text-red-400'
                        : log.toLowerCase().includes('success') || log.toLowerCase().includes('completed')
                          ? 'text-green-600 dark:text-green-400'
                          : 'text-foreground'
                        }`}
                    >
                      {log}
                    </div>
                  ))}
                </div>
              </ScrollArea>
            </div>
          </div>
        )}

        <DialogFooter className="flex justify-end">
          {isConfirming ? (
            <div className="flex gap-2">
              <Button variant="outline" onClick={handleCancel}>
                {t('settings:cancel')}
              </Button>
              <Button variant="destructive" onClick={handleConfirm}>
                {t('settings:comfyui.confirmUninstallButton')}
              </Button>
            </div>
          ) : canClose ? (
            <Button onClick={handleClose}>
              {t('settings:close')}
            </Button>
          ) : (
            <div className="text-sm text-muted-foreground">
              {t('settings:comfyui.uninstallProgress.inProgress')}
            </div>
          )}
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};

export default UninstallProgressDialog;



================================================
FILE: react/src/components/common/Blur.tsx
================================================
type BlurProps = {
  direction?: 't-b' | 'l-r' | 'r-l' | 'b-t'
  bgOpacity?: number
  className?: string
}
const Blur: React.FC<BlurProps> = ({
  className,
  direction = 't-b',
  bgOpacity = 10,
}) => {
  const deg =
    direction === 't-b'
      ? 0
      : direction === 'l-r'
        ? -90
        : direction === 'r-l'
          ? 90
          : 180

  const bgColor = `color-mix(in oklab, var(--background) ${bgOpacity}%, transparent)`

  return (
    <div className={`grid -z-1 ${className}`}>
      <span
        style={{
          gridArea: '1 / 1',
          WebkitBackdropFilter: 'blur(1px)',
          backdropFilter: 'blur(1px)',
          WebkitMask: `linear-gradient(${deg}deg, transparent, #fff 8%)`,
          mask: `linear-gradient(${deg}deg, transparent, #fff 8%)`,
          backgroundColor: bgColor,
        }}
      />
      <span
        style={{
          gridArea: '1 / 1',
          WebkitBackdropFilter: 'blur(4px)',
          backdropFilter: 'blur(4px)',
          WebkitMask: `linear-gradient(${deg}deg, transparent 8%, #fff 16%)`,
          mask: `linear-gradient(${deg}deg, transparent 8%, #fff 16%)`,
          backgroundColor: bgColor,
        }}
      />
      <span
        style={{
          gridArea: '1 / 1',
          WebkitBackdropFilter: 'blur(8px)',
          backdropFilter: 'blur(8px)',
          WebkitMask: `linear-gradient(${deg}deg, transparent 16%, #fff 24%)`,
          mask: `linear-gradient(${deg}deg, transparent 16%, #fff 24%)`,
          backgroundColor: bgColor,
        }}
      />
      <span
        style={{
          gridArea: '1 / 1',
          WebkitBackdropFilter: 'blur(16px)',
          backdropFilter: 'blur(16px)',
          WebkitMask: `linear-gradient(${deg}deg, transparent 24%, #fff 36%)`,
          mask: `linear-gradient(${deg}deg, transparent 24%, #fff 36%)`,
          backgroundColor: bgColor,
        }}
      />
      <span
        style={{
          gridArea: '1 / 1',
          WebkitBackdropFilter: 'blur(24px)',
          backdropFilter: 'blur(24px)',
          WebkitMask: `linear-gradient(${deg}deg, transparent 36%, #fff 48%)`,
          mask: `linear-gradient(${deg}deg, transparent 36%, #fff 48%)`,
          backgroundColor: bgColor,
        }}
      />
      <span
        style={{
          gridArea: '1 / 1',
          WebkitBackdropFilter: 'blur(32px)',
          backdropFilter: 'blur(32px)',
          WebkitMask: `linear-gradient(${deg}deg, transparent 48%, #fff 64%)`,
          mask: `linear-gradient(${deg}deg, transparent 48%, #fff 64%)`,
          backgroundColor: bgColor,
        }}
      />
    </div>
  )
}

export default Blur



================================================
FILE: react/src/components/common/DialogContent.tsx
================================================
import { cn } from '@/lib/utils'
import * as Dialog from '@radix-ui/react-dialog'
import { AnimatePresence, motion } from 'motion/react'

type CommonDialogProps = {
  open: boolean
  children: React.ReactNode
  className?: string
  transformPerspective?: number
}

const CommonDialogContent: React.FC<CommonDialogProps> = ({
  open,
  children,
  className,
  transformPerspective = 500,
}) => {
  const openState = {
    opacity: 1,
    filter: 'blur(0px)',
    rotateX: 0,
    rotateY: 0,
    z: 0,
    transition: {
      duration: 0.5,
      ease: [0.17, 0.67, 0.51, 1],
      opacity: {
        delay: 0.2,
        duration: 0.4,
        ease: 'easeOut',
      },
    },
  }

  const initialState = {
    opacity: 0,
    filter: 'blur(12px)',
    z: -100,
    rotateY: 5,
    rotateX: 25,
    transition: {
      duration: 0.3,
      ease: [0.67, 0.17, 0.62, 0.64],
    },
  }

  return (
    <AnimatePresence>
      {open ? (
        <Dialog.Portal forceMount>
          <Dialog.Overlay asChild>
            <motion.div
              className="fixed inset-0 z-45 bg-black/50 backdrop-blur-lg"
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              exit={{ opacity: 0 }}
            />
          </Dialog.Overlay>
          <Dialog.Content asChild>
            <div className="fixed inset-0 flex items-center justify-center z-50">
              <motion.div
                className={cn(
                  'grid rounded-lg p-4 min-w-[300px] w-full max-w-lg gap-4 border bg-background shadow-lg sm:rounded-lg',
                  className
                )}
                initial={initialState}
                animate={openState}
                exit={initialState}
                style={{ transformPerspective }}
              >
                {children}
              </motion.div>
            </div>
          </Dialog.Content>
        </Dialog.Portal>
      ) : null}
    </AnimatePresence>
  )
}

export default CommonDialogContent



================================================
FILE: react/src/components/common/ErrorBoundary.tsx
================================================
import { Button } from '@/components/ui/button'
import { Separator } from '@/components/ui/separator'
import { ErrorComponentProps, useNavigate } from '@tanstack/react-router'

const ErrorBoundary: React.FC<ErrorComponentProps> = ({ error, reset }) => {
  const navigate = useNavigate()
  const handleBackToHome = () => {
    navigate({ to: '/' })
  }
  return (
    <div className="flex flex-col items-center justify-center h-screen">
      <h1 className="text-2xl font-bold">Error</h1>
      <div className="flex items-center gap-2 border bg-accent rounded-md px-2 py-1">
        <p>Error Name: {error?.name}</p>
        <Separator orientation="vertical" />
        <p>Error Message: {error?.message}</p>
      </div>
      <div className="flex flex-col gap-2 mt-4 bg-orange-50 rounded-md p-3 border border-orange-100">
        <pre className="text-sm">{error?.stack}</pre>

        <div className="flex gap-2 w-full justify-center items-center mt-4">
          <Button variant="ghost" onClick={handleBackToHome}>
            Back to Home
          </Button>
          <Button onClick={() => reset()}>Reset</Button>
        </div>
      </div>
    </div>
  )
}

export default ErrorBoundary



================================================
FILE: react/src/components/common/LanguageSwitcher.tsx
================================================
import { useLanguage } from '@/hooks/use-language'
import { useTranslation } from 'react-i18next'
import { Button } from '@/components/ui/button'
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu'
import { Languages } from 'lucide-react'

const LanguageSwitcher = () => {
  const { changeLanguage, currentLanguage } = useLanguage()
  const { t } = useTranslation()

  const languages = [
    { code: 'en', name: t('common:languages.en') },
    { code: 'zh-CN', name: t('common:languages.zh-CN') },
  ]

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button size={'sm'}
          variant={'ghost'}>
          <Languages size={30} />
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end">
        {languages.map((language) => (
          <DropdownMenuItem
            key={language.code}
            onClick={() => changeLanguage(language.code)}
            className={currentLanguage === language.code ? 'bg-accent' : ''}
          >
            {language.name}
          </DropdownMenuItem>
        ))}
      </DropdownMenuContent>
    </DropdownMenu>
  )
}

export default LanguageSwitcher



================================================
FILE: react/src/components/common/NotificationPanel.tsx
================================================
import { Button } from '@/components/ui/button'
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from '@/components/ui/popover'
import { ScrollArea } from '@/components/ui/scroll-area'
import { useNotifications } from '@/hooks/use-notifications'
import { eventBus, TEvents } from '@/lib/event'
import { cn } from '@/lib/utils'
import { useLocation, useNavigate } from '@tanstack/react-router'
import {
  Bell,
  CheckCheck,
  CircleX,
  ImageIcon,
  InfoIcon,
  MessageSquare,
  X,
} from 'lucide-react'
import { useEffect } from 'react'
import { useTranslation } from 'react-i18next'
import { toast } from 'sonner'

export const NotificationPanel: React.FC = () => {
  const {
    notifications,
    unreadCount,
    markAsRead,
    markAllAsRead,
    clearNotifications,
  } = useNotifications()
  const { t } = useTranslation()
  const location = useLocation()
  const sessionId = (location.search as { sessionId?: string }).sessionId

  const getNotificationIcon = (type: string) => {
    switch (type) {
      case 'canvas_update':
        return <ImageIcon className="w-4 h-4" />
      case 'session_done':
        return <MessageSquare className="w-4 h-4" />
      case 'error':
        return <CircleX className="w-4 h-4" />
      case 'info':
        return <InfoIcon className="w-4 h-4" />
      default:
        return <InfoIcon className="w-4 h-4" />
    }
  }

  const getNotificationColor = (type: string) => {
    switch (type) {
      case 'canvas_update':
        return 'border-l-blue-500'
      case 'session_done':
        return 'border-l-green-500'
      case 'error':
        return 'border-l-red-500'
      case 'info':
        return 'border-l-yellow-500'
      default:
        return 'border-l-gray-500'
    }
  }

  const navigate = useNavigate()

  const handleError = (data: TEvents['Socket::Session::Error']) => {
    // Only show error if it's not the current session
    if (data.session_id === sessionId) {
      return
    }

    toast.error('Error: ' + data.error, {
      closeButton: true,
      duration: 3600 * 1000,
      style: { color: 'red' },
    })
  }

  useEffect(() => {
    eventBus.on('Socket::Session::Error', handleError)

    return () => {
      eventBus.off('Socket::Session::Error', handleError)
    }
  })

  return (
    <Popover>
      <PopoverTrigger asChild>
        <Button variant="ghost" size="sm" className="relative">
          <Bell className="w-5 h-5" />
          {unreadCount > 0 && (
            <span className="absolute -top-1 -right-1 bg-red-500 text-white text-xs rounded-full w-5 h-5 flex items-center justify-center">
              {unreadCount > 99 ? '99+' : unreadCount}
            </span>
          )}
        </Button>
      </PopoverTrigger>
      <PopoverContent className="w-80 p-0 select-none" align="end">
        <div className="flex items-center justify-between pl-3.5 pr-2 py-2 border-b">
          <span className="font-semibold">{t('notifications.title')}</span>
          <div className="flex items-center gap-2">
            {unreadCount > 0 && (
              <Button
                variant="ghost"
                size="sm"
                onClick={markAllAsRead}
                className="text-xs"
              >
                <CheckCheck className="w-4 h-4 mr-1" />
                {t('notifications.markAllAsRead')}
              </Button>
            )}
            {notifications.length > 0 && (
              <Button
                variant="ghost"
                size="sm"
                onClick={clearNotifications}
                className="text-xs"
              >
                {t('notifications.clear')}
                <X className="w-4 h-4" />
              </Button>
            )}
          </div>
        </div>

        <ScrollArea className="h-96 w-full">
          {notifications.length === 0 ? (
            <div className="flex flex-col text-center text-primary justify-center items-center h-96">
              <Bell className="w-8 h-8 mx-auto mb-2 opacity-50" />
            </div>
          ) : (
            <div>
              {notifications.map((notification) => (
                <div
                  key={notification.id}
                  className={cn(
                    'p-3 border-l-4 mb-2 cursor-pointer rounded-r transition-colors hover:bg-gray-50',
                    getNotificationColor(notification.type),
                    !notification.read && 'bg-blue-50/50'
                  )}
                  onClick={() => {
                    markAsRead(notification.id)
                    if (notification.canvasId) {
                      navigate({
                        to: '/canvas/$id',
                        params: { id: notification.canvasId },
                        search: { sessionId: notification.sessionId },
                      })
                    }
                  }}
                >
                  <div className="flex items-center justify-between w-full">
                    <div className="flex items-center gap-3">
                      {notification.imageUrl ? (
                        <img
                          src={notification.imageUrl}
                          alt="notification"
                          className="w-10 h-10 rounded-md"
                        />
                      ) : (
                        <span className="text-lg flex-shrink-0">
                          {getNotificationIcon(notification.type)}
                        </span>
                      )}

                      <div className="flex flex-col items-start">
                        <span
                          className={cn(
                            'font-medium text-sm',
                            !notification.read && 'text-blue-900'
                          )}
                        >
                          {notification.title}
                        </span>

                        <div className="flex-1 min-w-0 flex items-center gap-1 mt-1">
                          {!notification.read && (
                            <div className="size-2 bg-blue-500 rounded-full flex-shrink-0" />
                          )}

                          <p className="text-xs text-gray-600">
                            {notification.message}
                          </p>
                        </div>
                      </div>
                    </div>

                    <p className="text-xs text-gray-400">
                      {notification.timestamp.toLocaleString().split(' ')[1]}
                    </p>
                  </div>
                </div>
              ))}
            </div>
          )}
        </ScrollArea>
      </PopoverContent>
    </Popover>
  )
}



================================================
FILE: react/src/components/common/UpdateNotificationDialog.tsx
================================================
import { Button } from '@/components/ui/button'
import {
  Dialog,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog'
import { useConfigs } from '@/contexts/configs'
import { useCallback, useEffect, useState } from 'react'
import { useTranslation } from 'react-i18next'
import CommonDialogContent from './DialogContent'

interface UpdateInfo {
  version: string
  files: unknown[]
  path: string
  sha512: string
  releaseDate: string
}

// show the update notification dialog when there is a new version available
const UpdateNotificationDialog = () => {
  const { t } = useTranslation()
  const { showUpdateDialog, setShowUpdateDialog } = useConfigs()
  const [updateInfo, setUpdateInfo] = useState<UpdateInfo | null>(null)
  const [isInstalling, setIsInstalling] = useState(false)

  useEffect(() => {
    // Listen for update downloaded event
    const handleUpdateDownloaded = (info: UpdateInfo) => {
      console.log('Update downloaded:', info)
      setUpdateInfo(info)
      setShowUpdateDialog(true)
    }

    window.electronAPI?.onUpdateDownloaded(handleUpdateDownloaded)

    return () => {
      window.electronAPI?.removeUpdateDownloadedListener()
    }
  }, [])

  // Add test function for local development
  const handleTestUpdateDialog = () => {
    const mockUpdateInfo: UpdateInfo = {
      version: '2.1.0',
      files: [],
      path: '/mock/path',
      sha512: 'mock-sha512',
      releaseDate: new Date().toISOString(),
    }
    setUpdateInfo(mockUpdateInfo)
    setShowUpdateDialog(true)
  }

  // Add global function for testing in browser console
  useEffect(() => {
    if (process.env.NODE_ENV === 'development') {
      // @ts-expect-error - Adding test function to window for development
      window.testUpdateDialog = handleTestUpdateDialog
      console.log(
        'ğŸ”§ Development mode: Use window.testUpdateDialog() to test update dialog'
      )
    }
  }, [])

  const handleInstallUpdate = async () => {
    setIsInstalling(true)
    try {
      await window.electronAPI?.restartAndInstall()
    } catch (error) {
      console.error('Failed to install update:', error)
      setIsInstalling(false)
    }
  }

  const handleClose = useCallback(() => {
    setShowUpdateDialog(false)
  }, [setShowUpdateDialog])

  const handleOpenChange = useCallback(
    (open: boolean) => {
      setShowUpdateDialog(open)
    },
    [setShowUpdateDialog]
  )

  if (!updateInfo) return null

  return (
    <Dialog open={showUpdateDialog} onOpenChange={handleOpenChange}>
      <CommonDialogContent open={showUpdateDialog}>
        <DialogHeader>
          <DialogTitle>{t('common:update.title')}</DialogTitle>
        </DialogHeader>

        <div className="text-sm text-muted-foreground">
          <p>
            {t('common:update.description', { version: updateInfo.version })}
          </p>
          <p className="mt-2">{t('common:update.installNote')}</p>
        </div>

        <DialogFooter>
          <Button
            variant="outline"
            onClick={handleClose}
            disabled={isInstalling}
          >
            {t('common:update.laterButton')}
          </Button>
          <Button onClick={handleInstallUpdate} disabled={isInstalling}>
            {isInstalling
              ? t('common:update.installing')
              : t('common:update.installButton')}
          </Button>
        </DialogFooter>
      </CommonDialogContent>
    </Dialog>
  )
}

export default UpdateNotificationDialog



================================================
FILE: react/src/components/home/CanvasCard.tsx
================================================
import { deleteCanvas, ListCanvasesResponse } from '@/api/canvas'
import { ImageIcon, Trash2 } from 'lucide-react'
import { motion } from 'motion/react'
import { useState } from 'react'
import { useTranslation } from 'react-i18next'
import { toast } from 'sonner'
import { Button } from '../ui/button'
import { formatDate } from '@/utils/formatDate'
import CanvasDeleteDialog from './CanvasDeleteDialog'

type CanvasCardProps = {
  index: number
  canvas: ListCanvasesResponse
  handleCanvasClick: (id: string) => void
  handleDeleteCanvas: () => void
}

const CanvasCard: React.FC<CanvasCardProps> = ({
  index,
  canvas,
  handleCanvasClick,
  handleDeleteCanvas,
}) => {
  const { t } = useTranslation()
  const [showDeleteDialog, setShowDeleteDialog] = useState(false)

  const handleDelete = async () => {
    try {
      await deleteCanvas(canvas.id)
      handleDeleteCanvas()
      toast.success(t('canvas:messages.canvasDeleted'))
    } catch (error) {
      toast.error(t('canvas:messages.failedToDelete'))
    }
    setShowDeleteDialog(false)
  }

  return (
    <motion.div
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      transition={{ duration: 0.5, delay: index * 0.1 }}
      className="border border-primary/20 rounded-xl cursor-pointer hover:border-primary/40 transition-all duration-300 hover:shadow-md hover:bg-primary/5 active:scale-99 relative group"
    >
      <CanvasDeleteDialog
        show={showDeleteDialog}
        setShow={setShowDeleteDialog}
        handleDeleteCanvas={handleDelete}
      >
        <Button
          variant="secondary"
          size="icon"
          className="absolute top-4 right-4 opacity-0 group-hover:opacity-100 transition-opacity duration-300"
        >
          <Trash2 className="w-4 h-4" />
        </Button>
      </CanvasDeleteDialog>

      <div
        className="p-3 flex flex-col gap-2"
        onClick={() => handleCanvasClick(canvas.id)}
      >
        {canvas.thumbnail ? (
          <img
            src={canvas.thumbnail}
            alt={canvas.name}
            className="w-full h-40 object-cover rounded-lg"
          />
        ) : (
          <div className="w-full h-40 bg-primary/10 rounded-lg flex items-center justify-center">
            <ImageIcon className="w-10 h-10 opacity-10" />
          </div>
        )}
        <div className="flex flex-col">
          <h3 className="text-lg font-bold">{canvas.name}</h3>
          <p className="text-sm text-gray-500">{formatDate(canvas.created_at)}</p>
        </div>
      </div>
    </motion.div>
  )
}

export default CanvasCard



================================================
FILE: react/src/components/home/CanvasDeleteDialog.tsx
================================================
import CommonDialogContent from '@/components/common/DialogContent'
import { Button } from '@/components/ui/button'
import {
  Dialog,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from '@/components/ui/dialog'
import { Trash2 } from 'lucide-react'
import { useTranslation } from 'react-i18next'

type CanvasDeleteDialogProps = {
  show: boolean
  className?: string
  children?: React.ReactNode
  setShow: (show: boolean) => void
  handleDeleteCanvas: () => void
}

const CanvasDeleteDialog: React.FC<CanvasDeleteDialogProps> = ({
  show,
  className,
  children,
  setShow,
  handleDeleteCanvas,
}) => {
  const { t } = useTranslation()

  return (
    <Dialog open={show} onOpenChange={setShow}>
      <DialogTrigger asChild>
        {children ? (
          children
        ) : (
          <Button variant="destructive" size="icon" className={className}>
            <Trash2 className="w-4 h-4" />
          </Button>
        )}
      </DialogTrigger>

      <CommonDialogContent open={show}>
        <DialogHeader>
          <DialogTitle>{t('canvas:deleteDialog.title')}</DialogTitle>
        </DialogHeader>

        <DialogDescription>
          {t('canvas:deleteDialog.description')}
        </DialogDescription>

        <DialogFooter>
          <Button variant="outline" onClick={() => setShow(false)}>
            {t('canvas:deleteDialog.cancel')}
          </Button>
          <Button variant="destructive" onClick={() => handleDeleteCanvas()}>
            {t('canvas:deleteDialog.delete')}
          </Button>
        </DialogFooter>
      </CommonDialogContent>
    </Dialog>
  )
}

export default CanvasDeleteDialog



================================================
FILE: react/src/components/home/CanvasList.tsx
================================================
import { listCanvases } from '@/api/canvas'
import CanvasCard from '@/components/home/CanvasCard'
import { useQuery } from '@tanstack/react-query'
import { useNavigate, useLocation } from '@tanstack/react-router'
import { AnimatePresence, motion } from 'motion/react'
import { memo } from 'react'
import { useTranslation } from 'react-i18next'

const CanvasList: React.FC = () => {
  const { t } = useTranslation()
  const location = useLocation()
  const isHomePage = location.pathname === '/'

  const { data: canvases, refetch } = useQuery({
    queryKey: ['canvases'],
    queryFn: listCanvases,
    enabled: isHomePage, // æ¯æ¬¡è¿›å…¥é¦–é¡µæ—¶éƒ½é‡æ–°æŸ¥è¯¢
    refetchOnMount: 'always',
  })

  const navigate = useNavigate()
  const handleCanvasClick = (id: string) => {
    navigate({ to: '/canvas/$id', params: { id } })
  }

  return (
    <div className="flex flex-col px-10 mt-10 gap-4 select-none max-w-[1200px] mx-auto">
      {canvases && canvases.length > 0 && (
        <motion.span
          className="text-2xl font-bold"
          initial={{ opacity: 0, y: 10 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.5 }}
        >
          {t('home:allProjects')}
        </motion.span>
      )}

      <AnimatePresence>
        <div className="grid grid-cols-4 gap-4 w-full pb-10">
          {canvases?.map((canvas, index) => (
            <CanvasCard
              key={canvas.id}
              index={index}
              canvas={canvas}
              handleCanvasClick={handleCanvasClick}
              handleDeleteCanvas={() => refetch()}
            />
          ))}
        </div>
      </AnimatePresence>
    </div>
  )
}

export default memo(CanvasList)



================================================
FILE: react/src/components/knowledge/Editor.tsx
================================================
import { useEffect, useRef, useState, useCallback } from 'react'
import '@mdxeditor/editor/style.css'
import {
  headingsPlugin,
  listsPlugin,
  quotePlugin,
  thematicBreakPlugin,
  markdownShortcutPlugin,
  MDXEditor,
  type MDXEditorMethods,
  type MDXEditorProps,
  BoldItalicUnderlineToggles,
  UndoRedo,
  toolbarPlugin,
  InsertTable,
  InsertImage,
  Separator,
  CodeToggle,
  ListsToggle,
  CreateLink,
  BlockTypeSelect,
  linkPlugin,
  imagePlugin,
} from '@mdxeditor/editor'

import { toast } from 'sonner'
import { useTheme } from '@/hooks/use-theme'
import { Textarea } from '../ui/textarea'
import { Switch } from '../ui/switch'
import { ImagePlusIcon, SaveIcon } from 'lucide-react'
import { Button } from '../ui/button'
import MarkdownIt from 'markdown-it'
import MdEditor from 'react-markdown-editor-lite'
import 'react-markdown-editor-lite/lib/index.css'
import { uploadImage } from '@/api/upload'
const mdParser = new MarkdownIt()

type MediaFile = {
  path: string
  type: 'image' | 'video'
  name: string
}

function useDebounce<T extends (...args: any[]) => any>(
  callback: T,
  delay: number
): (...args: Parameters<T>) => void {
  const timeoutRef = useRef<NodeJS.Timeout | undefined>(undefined)

  return useCallback(
    (...args: Parameters<T>) => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current)
      }

      timeoutRef.current = setTimeout(() => {
        callback(...args)
      }, delay)
    },
    [callback, delay]
  )
}

export default function Editor({ knowledgeID }: { knowledgeID: string }) {
  const HEADER_HEIGHT = 50
  const { theme } = useTheme()
  const [isTextSelected, setIsTextSelected] = useState(false)
  const [selectionPosition, setSelectionPosition] = useState<{
    top: number
    left: number
  } | null>(null)
  const [isPreviewMode, setIsPreviewMode] = useState(false)
  const mdxEditorRef = useRef<MDXEditorMethods>(null)
  const [editorTitle, setEditorTitle] = useState('')
  const [editorContent, setEditorContent] = useState('')
  const [isLoading, setIsLoading] = useState(false)

  useEffect(() => {
    setIsLoading(true)
    const draft = localStorage.getItem('knowledge_draft')
    if (draft) {
      setEditorContent(draft)
      mdxEditorRef.current?.setMarkdown(draft)
      setIsLoading(false)
    }
    fetch('/api/read_file', {
      method: 'POST',
      body: JSON.stringify({ knowledge_id: knowledgeID }),
    })
      .then((res) => res.json())
      .then((data) => {
        if (typeof data.content == 'string') {
          const { title, content } = getTitleAndContent(data.content)
          setEditorTitle(title)
          setEditorContent(content)
          mdxEditorRef.current?.setMarkdown(content)
          setIsLoading(false)
        } else {
          toast.error('Failed to read file ' + curPath)
        }
      })
  }, [])

  const updateFile = useCallback((content: string) => {
    localStorage.setItem('knowledge_draft', content)
  }, [])

  // Create debounced versions of the functions
  const debouncedUpdateFile = useDebounce(updateFile, 500)

  const setEditorContentWrapper = (content: string) => {
    setEditorContent(content)
    debouncedUpdateFile(content)
  }

  useEffect(() => {
    const toolbar = document.querySelector('.my-classname')
    if (toolbar) {
      ;(toolbar as HTMLElement).style.padding = '0px'
    }

    const handleSelectionChange = () => {
      const selection = window.getSelection()
      if (selection && selection.rangeCount > 0) {
        const range = selection.getRangeAt(0)

        // Ensure that there's a non-empty selection
        if (!range.collapsed) {
          const rect = range.getBoundingClientRect()
          setSelectionPosition({ top: rect.top - 50, left: rect.left })
          setIsTextSelected(true)
        } else {
          setIsTextSelected(false) // No selection or collapsed selection
        }
      } else {
        setIsTextSelected(false) // No selection
      }
    }

    document.addEventListener('selectionchange', handleSelectionChange)

    return () => {
      document.removeEventListener('selectionchange', handleSelectionChange)
    }
  }, [])

  const handleImageUpload = async (file: File) => {
    const res = await uploadImage(file)
    console.log('res', res)
    return res.url
  }
  return (
    <div className="mb-5 p-5">
      <div
        className="flex py-2 items-center gap-2 justify-between"
        style={{ height: `${HEADER_HEIGHT}px` }}
      >
        <div className="flex items-center gap-2">
          <Switch checked={isPreviewMode} onCheckedChange={setIsPreviewMode} />
          <span className="text-sm">Preview</span>
        </div>
        <Button className="w-[200px]">
          <SaveIcon />
          Save
        </Button>
      </div>
      <div className="overflow-y-auto">
        <div className="mb-5 border rounded-md overflow-hidden">
          <MdEditor
            value={editorContent}
            style={{ height: '80vh' }}
            renderHTML={(text) => mdParser.render(text)}
            onChange={({ text }) => setEditorContentWrapper(text)}
            onImageUpload={handleImageUpload}
          />
        </div>
      </div>
    </div>
  )
}

function getTitleAndContent(value: string) {
  const firstNewlineIndex = value.indexOf('\n')
  if (firstNewlineIndex !== -1 && value.startsWith('# ')) {
    const title = value.substring(2, firstNewlineIndex).trim() // Extract title without '# '
    const content = value.substring(firstNewlineIndex + 1).trim() // Extract content after the first newline
    console.log('content', content)
    return { title, content }
  }
  return { title: '', content: value }
}



================================================
FILE: react/src/components/knowledge/Knowledge.tsx
================================================
import React, { useState, useEffect } from 'react'
import { useTranslation } from 'react-i18next'
import { toast } from 'sonner'
import { Card, CardContent, CardHeader } from '../ui/card'
import { Switch } from '../ui/switch'
import { Input } from '../ui/input'
import { Button } from '../ui/button'
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '../ui/dialog'
import { ScrollArea } from '../ui/scroll-area'
import { Search, ChevronLeft, ChevronRight, Eye } from 'lucide-react'
import {
  getKnowledgeList,
  saveEnabledKnowledgeDataToSettings,
  type KnowledgeBase,
  type KnowledgeListParams,
  getKnowledgeById,
} from '@/api/knowledge'
import TopMenu from '../TopMenu'

// è·å–æœ¬åœ°è®¾ç½®çš„API
async function getSettings(): Promise<{
  enabled_knowledge_data?: KnowledgeBase[]
}> {
  try {
    const response = await fetch('/api/settings')
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`)
    }
    return await response.json()
  } catch (error) {
    console.error('Failed to get settings:', error)
    return {}
  }
}

export default function Knowledge() {
  const { t } = useTranslation()
  const [knowledgeList, setKnowledgeList] = useState<KnowledgeBase[]>([])
  const [loading, setLoading] = useState(true)
  const [searchTerm, setSearchTerm] = useState('')
  const [currentPage, setCurrentPage] = useState(1)
  const [totalPages, setTotalPages] = useState(1)
  const [enabledKnowledge, setEnabledKnowledge] = useState<Set<string>>(
    new Set()
  )

  // è¯¦æƒ…å¼¹çª—çŠ¶æ€
  const [selectedKnowledge, setSelectedKnowledge] =
    useState<KnowledgeBase | null>(null)
  const [showDetailDialog, setShowDetailDialog] = useState(false)

  const pageSize = 12

  // Load enabled knowledge from settings
  useEffect(() => {
    const loadEnabledKnowledge = async () => {
      try {
        const settings = await getSettings()
        const enabledData = settings.enabled_knowledge_data || []
        const enabledIds = enabledData.map((kb) => kb.id)
        setEnabledKnowledge(new Set(enabledIds))
      } catch (error) {
        console.error('Failed to load enabled knowledge from settings:', error)
      }
    }

    loadEnabledKnowledge()
  }, [])

  // Fetch knowledge list
  const fetchKnowledgeList = async (params: KnowledgeListParams = {}) => {
    try {
      setLoading(true)
      const response = await getKnowledgeList({
        pageSize,
        pageNumber: currentPage,
        search: searchTerm.trim() || undefined,
        ...params,
      })

      setKnowledgeList(response.data.list)
      setTotalPages(response.data.pagination.total_pages)
    } catch (error) {
      console.error('Failed to fetch knowledge list:', error)
      toast.error('è·å–çŸ¥è¯†åº“åˆ—è¡¨å¤±è´¥')
      setKnowledgeList([])
    } finally {
      setLoading(false)
    }
  }

  // Initial load
  useEffect(() => {
    fetchKnowledgeList({ pageNumber: currentPage })
  }, [currentPage])

  // Search handler
  const handleSearch = () => {
    setCurrentPage(1)
    fetchKnowledgeList({ pageNumber: 1, search: searchTerm })
  }

  // Enter key search
  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter') {
      handleSearch()
    }
  }

  // Toggle knowledge enable/disable
  const toggleKnowledge = async (knowledgeId: string, enabled: boolean) => {
    const newEnabled = new Set(enabledKnowledge)
    if (enabled) {
      newEnabled.add(knowledgeId)
    } else {
      newEnabled.delete(knowledgeId)
    }

    // Update local state immediately for UI responsiveness
    setEnabledKnowledge(newEnabled)

    // Get full knowledge data for enabled items and save to settings
    try {
      const enabledKnowledgeData: KnowledgeBase[] = []

      for (const id of newEnabled) {
        // Find in current list first
        let kb = knowledgeList.find((k) => k.id === id)

        // If not found or missing content, fetch full data
        if (!kb || !kb.content) {
          try {
            console.log(`Fetching full data for knowledge: ${id}`)
            kb = await getKnowledgeById(id)
          } catch (error) {
            console.error(`Failed to fetch knowledge ${id}:`, error)
            // Use partial data if available
            kb = knowledgeList.find((k) => k.id === id)
          }
        }

        if (kb) {
          enabledKnowledgeData.push(kb)
        }
      }

      // Save complete data to settings
      await saveEnabledKnowledgeDataToSettings(enabledKnowledgeData)
      console.log(
        `Saved ${enabledKnowledgeData.length} enabled knowledge items to settings`
      )
      toast.success('çŸ¥è¯†åº“è®¾ç½®å·²ä¿å­˜')
    } catch (error) {
      console.error('Failed to save knowledge data to settings:', error)
      toast.error('ä¿å­˜çŸ¥è¯†åº“è®¾ç½®å¤±è´¥')
      // Revert UI state on error
      const revertedEnabled = new Set(enabledKnowledge)
      if (enabled) {
        revertedEnabled.delete(knowledgeId)
      } else {
        revertedEnabled.add(knowledgeId)
      }
      setEnabledKnowledge(revertedEnabled)
    }
  }

  // Show knowledge detail
  const showKnowledgeDetail = (knowledge: KnowledgeBase) => {
    setSelectedKnowledge(knowledge)
    setShowDetailDialog(true)
  }

  // Close detail dialog
  const closeDetailDialog = () => {
    setShowDetailDialog(false)
    setSelectedKnowledge(null)
  }

  // Pagination handlers
  const goToPreviousPage = () => {
    if (currentPage > 1) {
      setCurrentPage(currentPage - 1)
    }
  }

  const goToNextPage = () => {
    if (currentPage < totalPages) {
      setCurrentPage(currentPage + 1)
    }
  }

  return (
    <div>
      <TopMenu />
      <div className="flex flex-col px-6">
        <h1 className="text-2xl font-bold mb-4">çŸ¥è¯†åº“</h1>

        {/* Search Bar */}
        {/* <div className="flex gap-2 mb-4 max-w-md">
          <Input
            placeholder="æœç´¢çŸ¥è¯†åº“..."
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            onKeyPress={handleKeyPress}
          />
          <Button onClick={handleSearch} size="icon" variant="outline">
            <Search className="h-4 w-4" />
          </Button>
        </div> */}

        {/* Loading State */}
        {loading && (
          <div className="text-center py-8 text-muted-foreground">
            åŠ è½½ä¸­...
          </div>
        )}

        {/* Empty State */}
        {!loading && knowledgeList.length === 0 && (
          <div className="text-center py-8 text-muted-foreground">
            {searchTerm ? 'æ²¡æœ‰æ‰¾åˆ°ç›¸å…³çŸ¥è¯†åº“' : 'æš‚æ— çŸ¥è¯†åº“'}
          </div>
        )}

        {/* Knowledge Grid */}
        {!loading && knowledgeList.length > 0 && (
          <>
            <div
              style={{
                display: 'grid',
                gridTemplateColumns: 'repeat(auto-fill, minmax(280px, 1fr))',
                gap: '16px',
                marginBottom: '24px',
              }}
            >
              {knowledgeList.map((knowledge) => {
                const isEnabled = enabledKnowledge.has(knowledge.id)
                return (
                  <Card
                    key={knowledge.id}
                    className="relative cursor-pointer hover:shadow-md transition-shadow overflow-hidden"
                  >
                    {/* Cover Image */}
                    {knowledge.cover && (
                      <div
                        className="w-full h-32 bg-cover bg-center bg-no-repeat"
                        style={{ backgroundImage: `url(${knowledge.cover})` }}
                        onClick={() => showKnowledgeDetail(knowledge)}
                      />
                    )}

                    <CardHeader className={knowledge.cover ? 'pb-2' : 'pb-2'}>
                      <div className="flex items-start justify-between">
                        <h3
                          className="text-lg font-semibold truncate flex-1 mr-2"
                          onClick={() => showKnowledgeDetail(knowledge)}
                        >
                          {knowledge.name}
                        </h3>
                        <Switch
                          checked={isEnabled}
                          onCheckedChange={(checked) =>
                            toggleKnowledge(knowledge.id, checked)
                          }
                          className="flex-shrink-0"
                          onClick={(e) => e.stopPropagation()}
                        />
                      </div>
                    </CardHeader>
                    <CardContent
                      className="pt-0"
                      onClick={() => showKnowledgeDetail(knowledge)}
                    >
                      {knowledge.description && (
                        <p className="text-sm text-muted-foreground text-ellipsis overflow-hidden">
                          <span className="block max-h-[3.6em] overflow-hidden leading-6">
                            {knowledge.description}
                          </span>
                        </p>
                      )}
                      <div className="flex items-center justify-between mt-2 text-xs text-muted-foreground">
                        <span>{knowledge.is_public ? 'å…¬å¼€' : 'ç§æœ‰'}</span>
                        <div className="flex items-center gap-2">
                          <span>{isEnabled ? 'å·²å¯ç”¨' : 'æœªå¯ç”¨'}</span>
                          <Eye className="h-3 w-3 opacity-60" />
                        </div>
                      </div>
                    </CardContent>
                  </Card>
                )
              })}
            </div>

            {/* Pagination */}
            {totalPages > 1 && (
              <div className="flex items-center justify-center gap-2 pb-4">
                <Button
                  variant="outline"
                  size="sm"
                  onClick={goToPreviousPage}
                  disabled={currentPage === 1}
                >
                  <ChevronLeft className="h-4 w-4" />
                  ä¸Šä¸€é¡µ
                </Button>

                <span className="text-sm text-muted-foreground px-2">
                  {currentPage} / {totalPages}
                </span>

                <Button
                  variant="outline"
                  size="sm"
                  onClick={goToNextPage}
                  disabled={currentPage === totalPages}
                >
                  ä¸‹ä¸€é¡µ
                  <ChevronRight className="h-4 w-4" />
                </Button>
              </div>
            )}
          </>
        )}
      </div>

      {/* çŸ¥è¯†åº“è¯¦æƒ…å¼¹çª— */}
      <Dialog open={showDetailDialog} onOpenChange={setShowDetailDialog}>
        <DialogContent className="max-w-4xl max-h-[80vh] flex flex-col">
          <DialogHeader>
            <DialogTitle className="flex items-center gap-2">
              <span>{selectedKnowledge?.name}</span>
              <span className="text-sm font-normal text-muted-foreground">
                ({selectedKnowledge?.is_public ? 'å…¬å¼€' : 'ç§æœ‰'})
              </span>
            </DialogTitle>
          </DialogHeader>

          {selectedKnowledge && (
            <div className="flex-1 space-y-4">
              {/* Cover Image in Dialog */}
              {selectedKnowledge.cover && (
                <div className="w-full h-48 rounded-lg overflow-hidden">
                  <img
                    src={selectedKnowledge.cover}
                    alt={selectedKnowledge.name}
                    className="w-full h-full object-cover"
                    onError={(e) => {
                      // Hide image if it fails to load
                      e.currentTarget.style.display = 'none'
                    }}
                  />
                </div>
              )}

              {/* åŸºæœ¬ä¿¡æ¯ */}
              <div className="grid grid-cols-2 gap-4 text-sm">
                <div>
                  <span className="font-medium text-muted-foreground">
                    åˆ›å»ºæ—¶é—´ï¼š
                  </span>
                  <span>
                    {new Date(selectedKnowledge.created_at).toLocaleString(
                      'zh-CN'
                    )}
                  </span>
                </div>
                <div>
                  <span className="font-medium text-muted-foreground">
                    æ›´æ–°æ—¶é—´ï¼š
                  </span>
                  <span>
                    {new Date(selectedKnowledge.updated_at).toLocaleString(
                      'zh-CN'
                    )}
                  </span>
                </div>
              </div>

              {/* æè¿° */}
              {selectedKnowledge.description && (
                <div>
                  <h4 className="font-medium mb-2">æè¿°</h4>
                  <p className="text-sm text-muted-foreground leading-relaxed">
                    {selectedKnowledge.description}
                  </p>
                </div>
              )}

              {/* å†…å®¹ */}
              {selectedKnowledge.content && (
                <div className="flex-1">
                  <h4 className="font-medium mb-2">å†…å®¹</h4>
                  <ScrollArea className="h-[400px] w-full rounded-md border p-4">
                    <pre className="text-sm whitespace-pre-wrap break-words">
                      {selectedKnowledge.content}
                    </pre>
                  </ScrollArea>
                </div>
              )}

              {/* å¦‚æœæ²¡æœ‰å†…å®¹ */}
              {!selectedKnowledge.content && (
                <div className="flex-1 flex items-center justify-center py-12">
                  <p className="text-muted-foreground">æš‚æ— å†…å®¹</p>
                </div>
              )}
            </div>
          )}
        </DialogContent>
      </Dialog>
    </div>
  )
}



================================================
FILE: react/src/components/material/FilePreviewModal.tsx
================================================
import {
  X,
  Download,
  Heart,
  Star,
  Info,
  Copy,
  ExternalLink,
  ZoomIn,
  ZoomOut,
} from 'lucide-react'
import { useState, useEffect } from 'react'
import { getFileServiceUrl, getFileInfoApi } from '@/api/settings'

interface FileInfo {
  name: string
  path: string
  type: string
  size: number
  mtime: number
  ctime: number
  is_directory: boolean
  is_media: boolean
  mime_type: string
}

interface FilePreviewModalProps {
  isOpen: boolean
  onClose: () => void
  filePath: string
  fileName: string
  fileType: string
}

export default function FilePreviewModal({
  isOpen,
  onClose,
  filePath,
  fileName,
  fileType,
}: FilePreviewModalProps) {
  const [fileInfo, setFileInfo] = useState<FileInfo | null>(null)
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [zoom, setZoom] = useState(1)
  const [showInfo, setShowInfo] = useState(false)

  useEffect(() => {
    if (isOpen && filePath) {
      loadFileInfo()
    }
  }, [isOpen, filePath])

  const loadFileInfo = async () => {
    setLoading(true)
    setError(null)

    try {
      const info = await getFileInfoApi(filePath)
      setFileInfo(info)
    } catch (err) {
      setError('Failed to load file info')
      console.error('Error loading file info:', err)
    } finally {
      setLoading(false)
    }
  }

  const formatFileSize = (bytes: number) => {
    if (bytes === 0) return '0 Bytes'
    const k = 1024
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB']
    const i = Math.floor(Math.log(bytes) / Math.log(k))
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i]
  }

  const formatDate = (timestamp: number) => {
    return new Date(timestamp * 1000).toLocaleString()
  }

  const handleDownload = () => {
    const link = document.createElement('a')
    link.href = getFileServiceUrl(filePath)
    link.download = fileName
    document.body.appendChild(link)
    link.click()
    document.body.removeChild(link)
  }

  const handleCopyPath = () => {
    navigator.clipboard.writeText(filePath)
    // å¯ä»¥æ·»åŠ æç¤ºæ¶ˆæ¯
  }

  const handleZoomIn = () => {
    setZoom((prev) => Math.min(prev + 0.25, 5))
  }

  const handleZoomOut = () => {
    setZoom((prev) => Math.max(prev - 0.25, 0.25))
  }

  const resetZoom = () => {
    setZoom(1)
  }

  if (!isOpen) return null

  return (
    <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50">
      <div className="bg-white dark:bg-gray-800 rounded-xl shadow-2xl max-w-7xl max-h-[95vh] w-full mx-4 flex flex-col">
        {/* Header */}
        <div className="flex items-center justify-between p-4 border-b border-gray-200 dark:border-gray-700">
          <div className="flex items-center gap-3">
            <h2 className="text-xl font-bold text-gray-900 dark:text-white truncate">
              {fileName}
            </h2>
            {fileInfo && (
              <span className="text-sm text-gray-500 bg-gray-100 dark:bg-gray-700 px-2 py-1 rounded">
                {formatFileSize(fileInfo.size)}
              </span>
            )}
          </div>

          <div className="flex items-center gap-2">
            {fileType === 'image' && (
              <>
                <button
                  onClick={handleZoomOut}
                  className="p-2 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg transition-colors"
                  title="ç¼©å°"
                >
                  <ZoomOut className="w-4 h-4" />
                </button>
                <button
                  onClick={resetZoom}
                  className="px-3 py-1 text-sm hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg transition-colors"
                  title="é‡ç½®ç¼©æ”¾"
                >
                  {Math.round(zoom * 100)}%
                </button>
                <button
                  onClick={handleZoomIn}
                  className="p-2 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg transition-colors"
                  title="æ”¾å¤§"
                >
                  <ZoomIn className="w-4 h-4" />
                </button>
              </>
            )}

            <button
              onClick={() => setShowInfo(!showInfo)}
              className={`p-2 rounded-lg transition-colors ${
                showInfo
                  ? 'bg-blue-100 dark:bg-blue-900 text-blue-600'
                  : 'hover:bg-gray-100 dark:hover:bg-gray-700'
              }`}
              title="æ–‡ä»¶ä¿¡æ¯"
            >
              <Info className="w-4 h-4" />
            </button>

            <button
              onClick={handleCopyPath}
              className="p-2 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg transition-colors"
              title="å¤åˆ¶è·¯å¾„"
            >
              <Copy className="w-4 h-4" />
            </button>

            <button
              onClick={handleDownload}
              className="p-2 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg transition-colors"
              title="ä¸‹è½½"
            >
              <Download className="w-4 h-4" />
            </button>

            <button
              className="p-2 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg transition-colors"
              title="æ·»åŠ åˆ°æ”¶è—"
            >
              <Heart className="w-4 h-4" />
            </button>

            <button
              onClick={onClose}
              className="p-2 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg transition-colors"
            >
              <X className="w-4 h-4" />
            </button>
          </div>
        </div>

        <div className="flex-1 flex overflow-hidden">
          {/* Main content */}
          <div className="flex-1 flex items-center justify-center p-4 overflow-auto">
            {loading && (
              <div className="text-center">
                <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto mb-4"></div>
                <p className="text-gray-500">åŠ è½½ä¸­...</p>
              </div>
            )}

            {error && (
              <div className="text-center text-red-500">
                <p>åŠ è½½å¤±è´¥: {error}</p>
              </div>
            )}

            {!loading && !error && fileType === 'image' && (
              <img
                src={getFileServiceUrl(filePath)}
                alt={fileName}
                className="max-w-full max-h-full object-contain transition-transform duration-200"
                style={{ transform: `scale(${zoom})` }}
                onError={(e) => {
                  console.error('Failed to load image:', e)
                  setError('å›¾ç‰‡åŠ è½½å¤±è´¥')
                }}
              />
            )}

            {!loading && !error && fileType === 'video' && (
              <video
                src={getFileServiceUrl(filePath)}
                controls
                className="max-w-full max-h-full"
                style={{ transform: `scale(${zoom})` }}
                onError={(e) => {
                  console.error('Failed to load video:', e)
                  setError('è§†é¢‘åŠ è½½å¤±è´¥')
                }}
              />
            )}
          </div>

          {/* Info panel */}
          {showInfo && fileInfo && (
            <div className="w-80 border-l border-gray-200 dark:border-gray-700 p-4 bg-gray-50 dark:bg-gray-900 overflow-y-auto">
              <h3 className="font-bold text-lg mb-4">æ–‡ä»¶ä¿¡æ¯</h3>

              <div className="space-y-3">
                <div>
                  <label className="text-sm font-medium text-gray-600 dark:text-gray-400">
                    æ–‡ä»¶å
                  </label>
                  <p className="text-sm text-gray-900 dark:text-white break-all">
                    {fileInfo.name}
                  </p>
                </div>

                <div>
                  <label className="text-sm font-medium text-gray-600 dark:text-gray-400">
                    è·¯å¾„
                  </label>
                  <p className="text-sm text-gray-900 dark:text-white break-all">
                    {fileInfo.path}
                  </p>
                </div>

                <div>
                  <label className="text-sm font-medium text-gray-600 dark:text-gray-400">
                    ç±»å‹
                  </label>
                  <p className="text-sm text-gray-900 dark:text-white">
                    {fileInfo.mime_type}
                  </p>
                </div>

                <div>
                  <label className="text-sm font-medium text-gray-600 dark:text-gray-400">
                    å¤§å°
                  </label>
                  <p className="text-sm text-gray-900 dark:text-white">
                    {formatFileSize(fileInfo.size)}
                  </p>
                </div>

                <div>
                  <label className="text-sm font-medium text-gray-600 dark:text-gray-400">
                    ä¿®æ”¹æ—¶é—´
                  </label>
                  <p className="text-sm text-gray-900 dark:text-white">
                    {formatDate(fileInfo.mtime)}
                  </p>
                </div>

                <div>
                  <label className="text-sm font-medium text-gray-600 dark:text-gray-400">
                    åˆ›å»ºæ—¶é—´
                  </label>
                  <p className="text-sm text-gray-900 dark:text-white">
                    {formatDate(fileInfo.ctime)}
                  </p>
                </div>
              </div>
            </div>
          )}
        </div>
      </div>
    </div>
  )
}



================================================
FILE: react/src/components/material/MaterialManager.tsx
================================================
import {
  ChevronDown,
  ChevronRight,
  Folder,
  FolderOpen,
  Image,
  Play,
  File,
  Grid,
  List,
  RefreshCw,
  FileText,
  Music,
  Archive,
  Code,
  Eye,
  Star,
  Heart,
  MoreHorizontal,
  ExternalLink,
  Info,
  X,
  MessageCirclePlus,
} from 'lucide-react'
import { useState, useEffect, useCallback, useRef } from 'react'
import {
  browseFolderApi,
  getMediaFilesApi,
  getFileServiceUrl,
  openFolderInExplorer,
  getMyAssetsDirPath,
} from '@/api/settings'
import { readPNGMetadata } from '@/utils/pngMetadata'
import FilePreviewModal from './FilePreviewModal'
import { Button } from '../ui/button'
import { eventBus } from '@/lib/event'
import { toast } from 'sonner'
import { useTranslation } from 'react-i18next'

interface FileSystemItem {
  name: string
  path: string
  type: string
  size?: number
  mtime: number
  is_directory: boolean
  is_media: boolean
  has_thumbnail: boolean
}

interface BrowseResult {
  current_path: string
  parent_path: string | null
  items: FileSystemItem[]
}

interface FileDetails extends FileSystemItem {
  dimensions?: {
    width: number
    height: number
  }
  pngMetadata?: {
    success: boolean
    metadata: Record<string, any>
    has_metadata: boolean
    error?: string
  }
}

// ImageModelBadgeç»„ä»¶ï¼šå¼‚æ­¥æ˜¾ç¤ºPNGå›¾ç‰‡çš„æ¨¡å‹ä¿¡æ¯
function ImageModelBadge({
  filePath,
  fileName,
  variant = 'grid',
}: {
  filePath: string
  fileName: string
  variant?: 'grid' | 'list'
}) {
  const [modelInfo, setModelInfo] = useState<string | null>(null)
  const [isLoading, setIsLoading] = useState(false)

  useEffect(() => {
    // åªå¤„ç†PNGæ–‡ä»¶
    if (!fileName.toLowerCase().endsWith('.png')) {
      return
    }

    const loadModelInfo = async () => {
      setIsLoading(true)
      try {
        const result = await readPNGMetadata(getFileServiceUrl(filePath))
        if (result.success && result.has_metadata) {
          // å°è¯•æå–æ¨¡å‹ä¿¡æ¯ï¼Œä¼˜å…ˆçº§é¡ºåº
          const metadata = result.metadata
          const modelKeys = [
            'model',
            'Model',
            'checkpoint',
            'Checkpoint',
            'model_name',
            'Model Name',
            'sd_model_name',
            'Model used',
            'model_used',
          ]

          let extractedModel = null
          for (const key of modelKeys) {
            if (metadata[key]) {
              extractedModel = metadata[key]
              break
            }
          }

          // å¦‚æœæ²¡æœ‰æ‰¾åˆ°æ ‡å‡†çš„æ¨¡å‹å­—æ®µï¼Œå°è¯•ä»å…¶ä»–å­—æ®µæ¨æ–­
          if (!extractedModel) {
            // æ£€æŸ¥æ˜¯å¦æœ‰å‚æ•°å­—æ®µåŒ…å«æ¨¡å‹ä¿¡æ¯
            const paramKeys = [
              'parameters',
              'Parameters',
              'params',
              'generation_params',
            ]
            for (const key of paramKeys) {
              if (metadata[key] && typeof metadata[key] === 'string') {
                const paramStr = metadata[key]
                // å°è¯•ä»å‚æ•°å­—ç¬¦ä¸²ä¸­æå–æ¨¡å‹å
                const modelMatch = paramStr.match(
                  /(?:model|Model):\s*([^,\n]+)/i
                )
                if (modelMatch) {
                  extractedModel = modelMatch[1].trim()
                  break
                }
              }
            }
          }

          if (extractedModel) {
            // æ¸…ç†æ¨¡å‹åç§°ï¼Œå»æ‰è·¯å¾„å’Œæ‰©å±•å
            let cleanModel = String(extractedModel)
            if (cleanModel.includes('/')) {
              cleanModel = cleanModel.split('/').pop() || cleanModel
            }
            if (cleanModel.includes('\\')) {
              cleanModel = cleanModel.split('\\').pop() || cleanModel
            }
            // ç§»é™¤å¸¸è§çš„æ–‡ä»¶æ‰©å±•å
            cleanModel = cleanModel.replace(/\.(ckpt|safetensors|pt|pth)$/i, '')

            setModelInfo(cleanModel)
          }
        }
      } catch (error) {
        console.error('Error loading model info for', fileName, error)
      } finally {
        setIsLoading(false)
      }
    }

    loadModelInfo()
  }, [filePath, fileName])

  if (!fileName.toLowerCase().endsWith('.png')) {
    return null
  }

  const gridStyles =
    'absolute top-2 left-2 bg-blue-600/90 backdrop-blur-sm text-white text-xs px-2 py-1 rounded-full max-w-[calc(100%-1rem)] truncate shadow-lg'
  const listStyles =
    'bg-blue-600/90 backdrop-blur-sm text-white text-[10px] px-1.5 py-0.5 rounded-full max-w-16 truncate shadow-lg'

  if (isLoading) {
    return (
      <div
        className={
          variant === 'grid'
            ? 'absolute top-2 left-2 bg-gray-500/80 backdrop-blur-sm text-white text-xs px-2 py-1 rounded-full'
            : 'bg-gray-500/80 backdrop-blur-sm text-white text-[10px] px-1.5 py-0.5 rounded-full'
        }
      >
        <div className="flex items-center gap-1">
          <div
            className={`border border-white border-t-transparent rounded-full animate-spin ${variant === 'grid' ? 'w-3 h-3' : 'w-2 h-2'}`}
          ></div>
          {variant === 'grid' && <span>Loading...</span>}
        </div>
      </div>
    )
  }

  if (!modelInfo) {
    return null
  }

  return (
    <div className={variant === 'grid' ? gridStyles : listStyles}>
      <span title={modelInfo}>{modelInfo}</span>
    </div>
  )
}

export default function MaterialManager() {
  const [currentPath, setCurrentPath] = useState<string>('')
  const [pathHistory, setPathHistory] = useState<string[]>([])
  const [items, setItems] = useState<FileSystemItem[]>([])
  const [mediaFiles, setMediaFiles] = useState<FileSystemItem[]>([])
  const [selectedFolder, setSelectedFolder] = useState<FileSystemItem | null>(
    null
  )
  const [selectedFile, setSelectedFile] = useState<FileDetails | null>(null)
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [viewMode, setViewMode] = useState<'grid' | 'list'>('grid')
  const [searchTerm, setSearchTerm] = useState('')
  const [expandedFolders, setExpandedFolders] = useState<Set<string>>(new Set())
  const [folderContents, setFolderContents] = useState<
    Map<string, FileSystemItem[]>
  >(new Map())
  const [previewModal, setPreviewModal] = useState<{
    isOpen: boolean
    filePath: string
    fileName: string
    fileType: string
  }>({
    isOpen: false,
    filePath: '',
    fileName: '',
    fileType: '',
  })
  const myAssetsPath = useRef<string>('')
  const { t } = useTranslation()

  // åˆå§‹åŒ–æ—¶åŠ è½½ç”¨æˆ·ç›®å½•
  useEffect(() => {
    loadFolder('')
  }, [])

  // è·å–å›¾ç‰‡å°ºå¯¸çš„å‡½æ•°
  const getImageDimensions = useCallback(
    (imagePath: string): Promise<{ width: number; height: number }> => {
      return new Promise((resolve, reject) => {
        const img = new window.Image()
        img.onload = () => {
          resolve({ width: img.naturalWidth, height: img.naturalHeight })
        }
        img.onerror = reject
        img.src = getFileServiceUrl(imagePath)
      })
    },
    []
  )

  const loadFolder = useCallback(
    async (path: string = '') => {
      setLoading(true)
      setError(null)

      try {
        const result: BrowseResult = await browseFolderApi(path)
        setCurrentPath(result.current_path)
        setItems(result.items)

        // å°†å½“å‰è·¯å¾„çš„å†…å®¹æ·»åŠ åˆ°folderContentsä¸­
        setFolderContents((prev) =>
          new Map(prev).set(result.current_path, result.items)
        )

        // å¦‚æœé€‰æ‹©äº†æ–‡ä»¶å¤¹ï¼ŒåŠ è½½åª’ä½“æ–‡ä»¶
        if (selectedFolder && selectedFolder.is_directory) {
          try {
            const mediaResult = await getMediaFilesApi(selectedFolder.path)
            setMediaFiles(mediaResult)
          } catch (err) {
            console.error('Failed to load media files:', err)
          }
        }
      } catch (err) {
        setError('Failed to load folder')
        console.error('Error loading folder:', err)
      } finally {
        setLoading(false)
      }
    },
    [selectedFolder]
  )

  const loadFolderContents = useCallback(async (folderPath: string) => {
    try {
      const result: BrowseResult = await browseFolderApi(folderPath)
      setFolderContents((prev) => new Map(prev).set(folderPath, result.items))
      return result.items
    } catch (err) {
      console.error('Failed to load folder contents:', err)
      return []
    }
  }, [])

  const handleFolderClick = useCallback(
    async (folder: FileSystemItem) => {
      if (folder.is_directory) {
        setSelectedFolder(folder)

        // Toggle expansion state
        setExpandedFolders((prev) => {
          const newSet = new Set(prev)
          if (newSet.has(folder.path)) {
            newSet.delete(folder.path)
          } else {
            newSet.add(folder.path)
          }
          return newSet
        })

        // Load folder contents if not already loaded
        if (!folderContents.has(folder.path)) {
          await loadFolderContents(folder.path)
        }

        try {
          const mediaResult = await getMediaFilesApi(folder.path)
          setMediaFiles(mediaResult)
        } catch (err) {
          console.error('Failed to load media files:', err)
          setMediaFiles([])
        }
      }
    },
    [folderContents, loadFolderContents]
  )

  const handlePreviewFile = useCallback((file: FileSystemItem) => {
    if (file.is_media) {
      setPreviewModal({
        isOpen: true,
        filePath: file.path,
        fileName: file.name,
        fileType: file.type,
      })
    }
  }, [])

  const closePreviewModal = useCallback(() => {
    setPreviewModal({
      isOpen: false,
      filePath: '',
      fileName: '',
      fileType: '',
    })
  }, [])

  const handleFileClick = useCallback(
    async (file: FileSystemItem) => {
      // if (!file.is_media) return

      const fileDetails: FileDetails = { ...file }

      // å¦‚æœæ˜¯å›¾ç‰‡ï¼Œè·å–å°ºå¯¸ä¿¡æ¯
      if (file.type === 'image') {
        try {
          const dimensions = await getImageDimensions(file.path)
          fileDetails.dimensions = dimensions
        } catch (error) {
          console.error('Failed to get image dimensions:', error)
        }

        // å¦‚æœæ˜¯PNGæ–‡ä»¶ï¼Œè·å–metadataä¿¡æ¯
        if (file.path.toLowerCase().endsWith('.png')) {
          try {
            const pngMetadata = await readPNGMetadata(
              getFileServiceUrl(file.path)
            )
            fileDetails.pngMetadata = pngMetadata
          } catch (error) {
            console.error('Failed to get PNG metadata:', error)
          }
        }
      }

      setSelectedFile(fileDetails)
    },
    [getImageDimensions]
  )

  const handleAddToChat = useCallback(
    (file: FileSystemItem, event?: React.MouseEvent) => {
      if (event) {
        event.stopPropagation()
      }
      eventBus.emit('Material::AddImagesToChat', [
        {
          filePath: file.path,
          fileName: file.name,
          fileType: file.type,
          width: undefined,
          height: undefined,
        },
      ])
    },
    []
  )

  const handleOpenInExplorer = useCallback(async () => {
    if (selectedFolder) {
      try {
        await openFolderInExplorer(selectedFolder.path)
      } catch (error) {
        console.error('Failed to open folder in explorer:', error)
      }
    }
  }, [selectedFolder])

  useEffect(() => {
    // by default, load my assets folder when open page
    handleMyAssets()
  }, [])

  const handleMyAssets = useCallback(async () => {
    try {
      const result = await getMyAssetsDirPath()
      if (result.success) {
        myAssetsPath.current = result.path
        const myAssetsFolder: FileSystemItem = {
          name: t('canvas:myAssets', 'My Assets'),
          path: result.path,
          type: 'folder',
          mtime: Date.now() / 1000,
          is_directory: true,
          is_media: false,
          has_thumbnail: false,
        }
        await handleFolderClick(myAssetsFolder)
      } else {
        console.error('Failed to get My Assets directory path:', result.error)
      }
    } catch (error) {
      console.error('Failed to load My Assets folder:', error)
    }
  }, [handleFolderClick])

  const getFileIcon = useCallback(
    (type: string, className: string = 'w-4 h-4') => {
      switch (type) {
        case 'folder':
          return <Folder className={className} />
        case 'image':
          return <Image className={`${className} text-blue-500`} />
        case 'video':
          return <Play className={`${className} text-red-500`} />
        case 'audio':
          return <Music className={`${className} text-green-500`} />
        case 'document':
          return <FileText className={`${className} text-orange-500`} />
        case 'archive':
          return <Archive className={`${className} text-purple-500`} />
        case 'code':
          return <Code className={`${className} text-yellow-500`} />
        default:
          return <File className={className} />
      }
    },
    []
  )

  const formatFileSize = useCallback((bytes: number) => {
    if (bytes === 0) return '0 Bytes'
    const k = 1024
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB']
    const i = Math.floor(Math.log(bytes) / Math.log(k))
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i]
  }, [])

  const formatDate = useCallback((timestamp: number) => {
    return new Date(timestamp * 1000).toLocaleString()
  }, [])

  const filteredItems = items.filter((item) =>
    item.name.toLowerCase().includes(searchTerm.toLowerCase())
  )

  const filteredMediaFiles = mediaFiles.filter((file) =>
    file.name.toLowerCase().includes(searchTerm.toLowerCase())
  )

  // é€’å½’æœç´¢æ‰€æœ‰æ–‡ä»¶å¤¹å†…å®¹
  const searchInFolderContents = useCallback(
    (items: FileSystemItem[], term: string): FileSystemItem[] => {
      if (!term) return items

      return items.filter((item) => {
        const nameMatches = item.name.toLowerCase().includes(term.toLowerCase())
        if (nameMatches) return true

        // å¦‚æœæ˜¯æ–‡ä»¶å¤¹ä¸”å·²å±•å¼€ï¼Œæœç´¢å­å†…å®¹
        if (item.is_directory && expandedFolders.has(item.path)) {
          const childItems = folderContents.get(item.path) || []
          return searchInFolderContents(childItems, term).length > 0
        }

        return false
      })
    },
    [expandedFolders, folderContents]
  )

  const getFilteredFolderContents = useCallback(
    (path: string): FileSystemItem[] => {
      const contents = folderContents.get(path) || []
      return searchTerm
        ? searchInFolderContents(contents, searchTerm)
        : contents
    },
    [folderContents, searchTerm, searchInFolderContents]
  )

  const renderFileTree = useCallback(
    (items: FileSystemItem[], depth = 0) => {
      return items.map((item) => (
        <div key={item.path} className={`select-none`}>
          <div
            className={`flex items-center gap-2 px-3 py-1 rounded-lg cursor-pointer transition-all duration-200 hover:bg-gray-100 dark:hover:bg-gray-800 ${
              selectedFolder?.path === item.path && item.is_directory
                ? 'bg-blue-50 dark:bg-blue-950 border-l-4 border-blue-500'
                : item.is_media && !item.is_directory
                  ? 'hover:bg-green-50 dark:hover:bg-green-950'
                  : ''
            }`}
            style={{ paddingLeft: `${12 + depth * 16}px` }}
            onClick={() =>
              item.is_directory
                ? handleFolderClick(item)
                : handlePreviewFile(item)
            }
          >
            {item.is_directory && (
              <button className="p-1 hover:bg-gray-200 dark:hover:bg-gray-700 rounded transition-colors">
                {expandedFolders.has(item.path) ? (
                  <ChevronDown className="w-3 h-3" />
                ) : (
                  <ChevronRight className="w-3 h-3" />
                )}
              </button>
            )}

            {!item.is_directory && (
              <div className="w-5 h-5 flex items-center justify-center">
                <div className="w-3 h-3"></div>
              </div>
            )}

            <div className="flex items-center gap-2 flex-1">
              {item.is_directory ? (
                expandedFolders.has(item.path) ? (
                  <FolderOpen className="w-4 h-4 text-blue-600" />
                ) : (
                  <Folder className="w-4 h-4 text-gray-600" />
                )
              ) : (
                getFileIcon(item.type)
              )}
              <span className="text-sm font-medium truncate" title={item.name}>
                {item.name}
              </span>
            </div>

            {/* æ–‡ä»¶å¤§å°æ˜¾ç¤º */}
            {!item.is_directory && item.size && (
              <span className="text-xs text-gray-400 ml-2">
                {formatFileSize(item.size)}
              </span>
            )}
          </div>

          {/* é€’å½’æ¸²æŸ“å­æ–‡ä»¶å¤¹å’Œæ–‡ä»¶ */}
          {item.is_directory && expandedFolders.has(item.path) && (
            <div className="ml-2">
              {getFilteredFolderContents(item.path).length > 0 &&
                renderFileTree(getFilteredFolderContents(item.path), depth + 1)}
            </div>
          )}
        </div>
      ))
    },
    [
      selectedFolder,
      expandedFolders,
      folderContents,
      handleFolderClick,
      handlePreviewFile,
      getFileIcon,
      formatFileSize,
      getFilteredFolderContents,
    ]
  )

  const renderMediaGrid = useCallback(() => {
    return (
      <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-4">
        {filteredMediaFiles.map((file) => (
          <div
            key={file.path}
            className={`group relative bg-white dark:bg-gray-800 rounded-xl shadow-sm hover:shadow-lg transition-all duration-300 overflow-hidden border cursor-pointer ${
              selectedFile?.path === file.path
                ? 'border-blue-500 ring-2 ring-blue-200 dark:ring-blue-800'
                : 'border-gray-200 dark:border-gray-700'
            }`}
            onClick={() => handleFileClick(file)}
          >
            <div className="aspect-square bg-gradient-to-br from-gray-50 to-gray-100 dark:from-gray-800 dark:to-gray-900 flex items-center justify-center overflow-hidden relative">
              {/* Model Badge for PNG images */}
              <ImageModelBadge filePath={file.path} fileName={file.name} />

              {file.type === 'image' ? (
                <img
                  src={getFileServiceUrl(file.path)}
                  alt={file.name}
                  className="w-full h-full object-cover transition-transform duration-300 group-hover:scale-105"
                  onError={(e) => {
                    e.currentTarget.style.display = 'none'
                    e.currentTarget.nextElementSibling?.classList.remove(
                      'hidden'
                    )
                  }}
                />
              ) : (
                <div className="flex flex-col items-center justify-center text-gray-400">
                  {getFileIcon(file.type, 'w-8 h-8')}
                  <span className="text-xs mt-1">
                    {file.type.toUpperCase()}
                  </span>
                </div>
              )}
              <div className="hidden flex flex-col items-center justify-center text-gray-400">
                {getFileIcon(file.type, 'w-8 h-8')}
                <span className="text-xs mt-1">{file.type.toUpperCase()}</span>
              </div>
            </div>

            <div className="p-3">
              <div className="text-sm font-medium truncate" title={file.name}>
                {file.name}
              </div>
              <div className="flex justify-between items-center mt-2 text-xs text-gray-500">
                <span>{formatFileSize(file.size || 0)}</span>
                <span>{formatDate(file.mtime)}</span>
              </div>
            </div>
          </div>
        ))}
      </div>
    )
  }, [
    filteredMediaFiles,
    selectedFile,
    getFileIcon,
    formatFileSize,
    formatDate,
    handlePreviewFile,
    handleFileClick,
    handleAddToChat,
  ])

  const renderMediaList = useCallback(() => {
    return (
      <div className="space-y-2 w-full overflow-hidden">
        {filteredMediaFiles.map((file) => (
          <div
            key={file.path}
            className={`flex items-center gap-4 p-3 bg-white dark:bg-gray-800 rounded-lg border hover:shadow-md transition-shadow min-w-0 cursor-pointer ${
              selectedFile?.path === file.path
                ? 'border-blue-500 ring-2 ring-blue-200 dark:ring-blue-800'
                : 'border-gray-200 dark:border-gray-700'
            }`}
            onClick={() => handleFileClick(file)}
          >
            <div className="w-12 h-12 bg-gray-100 dark:bg-gray-700 rounded-lg flex items-center justify-center overflow-hidden flex-shrink-0 relative">
              {/* Model Badge for PNG images in list view */}
              {file.type === 'image' &&
                file.name.toLowerCase().endsWith('.png') && (
                  <div className="absolute -top-1 -right-1 z-10">
                    <ImageModelBadge
                      filePath={file.path}
                      fileName={file.name}
                      variant="list"
                    />
                  </div>
                )}

              {file.type === 'image' ? (
                <img
                  src={getFileServiceUrl(file.path)}
                  alt={file.name}
                  className="w-full h-full object-cover"
                  onError={(e) => {
                    e.currentTarget.style.display = 'none'
                    e.currentTarget.nextElementSibling?.classList.remove(
                      'hidden'
                    )
                  }}
                />
              ) : (
                getFileIcon(file.type)
              )}
              <div className="hidden">{getFileIcon(file.type)}</div>
            </div>
            <div className="flex-1 min-w-0 overflow-hidden">
              <div className="font-medium truncate">{file.name}</div>
              <div className="text-sm text-gray-500 flex items-center gap-4 overflow-hidden">
                <span className="whitespace-nowrap">
                  {formatFileSize(file.size || 0)}
                </span>
                <span className="whitespace-nowrap">
                  {formatDate(file.mtime)}
                </span>
              </div>
            </div>
            <div className="flex items-center gap-2 flex-shrink-0">
              <button
                onClick={(e) => {
                  e.stopPropagation()
                  handlePreviewFile(file)
                }}
                className="p-2 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg transition-colors"
                title="é¢„è§ˆ"
              >
                <Eye className="w-4 h-4" />
              </button>
              <button
                onClick={(e) => handleAddToChat(file, e)}
                className="p-2 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg transition-colors"
                title="æ·»åŠ åˆ°èŠå¤©"
              >
                <Heart className="w-4 h-4" />
              </button>
              <button className="p-2 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg transition-colors">
                <MoreHorizontal className="w-4 h-4" />
              </button>
            </div>
          </div>
        ))}
      </div>
    )
  }, [
    filteredMediaFiles,
    selectedFile,
    getFileIcon,
    formatFileSize,
    formatDate,
    handlePreviewFile,
    handleFileClick,
    handleAddToChat,
  ])

  const renderFileDetailsPanel = useCallback(() => {
    if (!selectedFile) return null

    return (
      <div className="absolute bottom-0 left-0 right-0 mt-6 bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 p-4">
        <div className="absolute top-0 right-0 flex items-center justify-between mb-4">
          <button
            onClick={() => setSelectedFile(null)}
            className="p-1 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg transition-colors"
          >
            <X className="w-4 h-4" />
          </button>
        </div>

        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          {/* æ–‡ä»¶é¢„è§ˆ */}
          <div className="space-y-4">
            <div className="aspect-video bg-gray-100 dark:bg-gray-700 rounded-lg overflow-hidden flex items-center justify-center">
              {selectedFile.type === 'image' ? (
                <img
                  src={getFileServiceUrl(selectedFile.path)}
                  alt={selectedFile.name}
                  className="max-w-full max-h-full object-contain"
                />
              ) : (
                <div className="flex flex-col items-center justify-center text-gray-400">
                  {getFileIcon(selectedFile.type, 'w-12 h-12')}
                  <span className="text-sm mt-2">
                    {selectedFile.type.toUpperCase()}
                  </span>
                </div>
              )}
            </div>

            <div className="flex gap-2">
              {/* <Button
                onClick={(e) => handleAddToChat(selectedFile, e)}
                variant="default"
                size="sm"
                className="flex-1"
              >
                <MessageCirclePlus className="w-4 h-4 mr-2" />
                æ·»åŠ åˆ°èŠå¤©
              </Button> */}
            </div>
          </div>

          {/* æ–‡ä»¶ä¿¡æ¯ */}
          <div className="space-y-4">
            <div>
              <h4 className="font-medium mb-2">
                {t('canvas:basicInfo', 'Basic info')}
              </h4>
              <div className="space-y-2 text-sm">
                <div className="flex justify-between">
                  <span className="text-gray-600 dark:text-gray-400">
                    {t('canvas:fileName', 'File name')}
                  </span>
                  <span className="font-medium break-all">
                    {selectedFile.name}
                  </span>
                </div>
                <div className="flex justify-between">
                  <span className="text-gray-600 dark:text-gray-400">
                    {t('canvas:fileSize', 'File size')}
                  </span>
                  <span className="font-medium">
                    {formatFileSize(selectedFile.size || 0)}
                  </span>
                </div>
                <div className="flex justify-between">
                  <span className="text-gray-600 dark:text-gray-400">
                    {t('canvas:modifiedTime', 'Modified time')}
                  </span>
                  <span className="font-medium">
                    {formatDate(selectedFile.mtime)}
                  </span>
                </div>
                {selectedFile.dimensions && (
                  <div className="flex justify-between">
                    <span className="text-gray-600 dark:text-gray-400">
                      {t('canvas:dimensions', 'Dimensions')}
                    </span>
                    <span className="font-medium">
                      {selectedFile.dimensions.width} Ã—{' '}
                      {selectedFile.dimensions.height}
                    </span>
                  </div>
                )}
              </div>
            </div>

            <div>
              <h4 className="font-medium mb-2">
                {t('canvas:filePath', 'File path')}
              </h4>
              <div className="text-sm text-gray-600 dark:text-gray-400 break-all bg-gray-50 dark:bg-gray-700 p-2 rounded">
                {selectedFile.path}
              </div>
            </div>

            {/* PNG Metadata Section */}
            {selectedFile.pngMetadata &&
              selectedFile.pngMetadata.success &&
              selectedFile.pngMetadata.has_metadata && (
                <div>
                  <h4 className="font-medium mb-2">
                    {t('canvas:pngMetadata', 'PNG Metadata')}
                  </h4>
                  <div className="space-y-2 text-sm max-h-64 overflow-y-auto bg-gray-50 dark:bg-gray-700 p-3 rounded">
                    {Object.entries(selectedFile.pngMetadata.metadata)
                      .filter(
                        ([key]) => !['width', 'height', 'mode'].includes(key)
                      ) // è¿‡æ»¤æ‰åŸºæœ¬ä¿¡æ¯
                      .map(([key, value]) => (
                        <div
                          key={key}
                          className="border-b border-gray-200 dark:border-gray-600 pb-2"
                        >
                          <div className="flex justify-between items-start gap-2">
                            <span className="text-gray-600 dark:text-gray-400 font-medium min-w-0 flex-shrink-0">
                              {key}:
                            </span>
                            <div className="text-right min-w-0 flex-1">
                              {typeof value === 'object' ? (
                                <pre className="text-xs bg-white dark:bg-gray-800 p-2 rounded border overflow-x-auto">
                                  {JSON.stringify(value, null, 2)}
                                </pre>
                              ) : (
                                <span className="break-all">
                                  {String(value)}
                                </span>
                              )}
                            </div>
                          </div>
                        </div>
                      ))}
                  </div>
                </div>
              )}
          </div>
        </div>
      </div>
    )
  }, [
    selectedFile,
    getFileIcon,
    formatFileSize,
    formatDate,
    handleAddToChat,
    handlePreviewFile,
  ])

  return (
    <div className="flex h-full bg-gray-50 dark:bg-gray-900 w-full overflow-hidden">
      {/* Left Sidebar */}
      <div className="w-80 bg-white dark:bg-gray-800 border-r border-gray-200 dark:border-gray-700 flex flex-col flex-shrink-0">
        {/* Header */}
        <div className="p-4 border-b border-gray-200 dark:border-gray-700">
          {/* My Assets Button */}
          <Button
            variant={
              selectedFolder?.path === myAssetsPath.current
                ? 'default'
                : 'ghost'
            }
            onClick={handleMyAssets}
            className="w-full justify-start text-left mb-3"
            style={{ padding: '4px', margin: '0px' }}
          >
            <Star className="w-4 h-4" />
            <span>{t('canvas:myAssets', 'My Assets')}</span>
          </Button>
          {/* Navigation */}
          <div className="flex items-center gap-2 mb-3 px-[4px]">
            <button className="rounded-lg hover:bg-gray-100 dark:hover:bg-gray-700 disabled:opacity-50 disabled:cursor-not-allowed transition-colors">
              <FolderOpen className="w-4 h-4" />
            </button>
            <div className="flex-1 text-sm text-gray-600 dark:text-gray-400 truncate">
              {currentPath || '~'}
            </div>
            <button
              onClick={() => loadFolder(currentPath)}
              className="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors"
            >
              <RefreshCw
                className={`w-4 h-4 ${loading ? 'animate-spin' : ''}`}
              />
            </button>
          </div>

          {/* Search */}
          {/* <div className="relative">
            <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 w-4 h-4" />
            <input
              type="text"
              placeholder="æœç´¢æ–‡ä»¶..."
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              className="w-full pl-10 pr-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
            />
          </div> */}
        </div>

        {/* File Tree */}
        <div className="flex-1 overflow-y-auto p-2">
          {loading && (
            <div className="flex items-center justify-center py-8">
              <RefreshCw className="w-6 h-6 animate-spin text-blue-600" />
            </div>
          )}

          {error && (
            <div className="p-4 bg-red-50 dark:bg-red-900 border border-red-200 dark:border-red-800 rounded-lg">
              <p className="text-red-600 dark:text-red-400 text-sm">{error}</p>
            </div>
          )}

          {!loading && !error && (
            <div className="space-y-1">{renderFileTree(filteredItems)}</div>
          )}
        </div>
      </div>

      {/* Right Panel */}
      <div
        className="flex-1 flex flex-col min-w-0 overflow-hidden relative"
        onClick={() => setSelectedFile(null)}
      >
        {/* Header */}
        <div className="p-6 bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700">
          <div className="flex items-center justify-between">
            <div>
              <div className="flex items-center gap-2">
                <h2 className="text-2xl font-bold text-gray-900 dark:text-white">
                  {selectedFolder
                    ? selectedFolder.name
                    : t('canvas:selectAFolder', 'Select a folder')}
                </h2>
                {selectedFolder && (
                  <button
                    onClick={handleOpenInExplorer}
                    className="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors"
                    title={t(
                      'canvas:openInExplorer',
                      'Open in system file browser'
                    )}
                  >
                    <ExternalLink className="w-5 h-5 text-gray-600 dark:text-gray-400" />
                  </button>
                )}
              </div>
              {selectedFolder && (
                <p className="text-sm text-gray-600 dark:text-gray-400 mt-1">
                  {filteredMediaFiles.length}{' '}
                  {t('canvas:mediaFiles', 'media files')}
                </p>
              )}
            </div>

            {selectedFolder && (
              <div className="flex items-center gap-2">
                <button
                  onClick={() => setViewMode('grid')}
                  className={`p-2 rounded-lg transition-colors ${
                    viewMode === 'grid'
                      ? 'bg-blue-100 dark:bg-blue-900 text-blue-600'
                      : 'hover:bg-gray-100 dark:hover:bg-gray-700'
                  }`}
                >
                  <Grid className="w-4 h-4" />
                </button>
                <button
                  onClick={() => setViewMode('list')}
                  className={`p-2 rounded-lg transition-colors ${
                    viewMode === 'list'
                      ? 'bg-blue-100 dark:bg-blue-900 text-blue-600'
                      : 'hover:bg-gray-100 dark:hover:bg-gray-700'
                  }`}
                >
                  <List className="w-4 h-4" />
                </button>
              </div>
            )}
          </div>
        </div>

        {/* Content */}
        <div className="flex-1 overflow-y-auto p-6 w-full min-w-0">
          {selectedFolder ? (
            <div className="w-full overflow-hidden">
              {filteredMediaFiles.length > 0 ? (
                <div>
                  {viewMode === 'grid' ? renderMediaGrid() : renderMediaList()}
                  {/* File Details Panel */}
                  {renderFileDetailsPanel()}
                </div>
              ) : (
                <div className="flex items-center justify-center h-64 text-gray-500">
                  <div className="text-center">
                    <Image className="w-16 h-16 mx-auto mb-4 opacity-30" />
                    <p className="text-lg font-medium">
                      {t('canvas:noMediaFiles', 'No media files')}
                    </p>
                    <p className="text-sm mt-2">
                      {t(
                        'canvas:noMediaFilesDescription',
                        'No images or videos in this folder'
                      )}
                    </p>
                  </div>
                </div>
              )}
            </div>
          ) : (
            <div className="flex items-center justify-center h-full text-gray-500">
              <div className="text-center">
                <Folder className="w-20 h-20 mx-auto mb-6 opacity-30" />
                <p className="text-xl font-medium">
                  {t('canvas:selectAFolder', 'Select a folder')}
                </p>
                <p className="text-sm mt-2">
                  {t(
                    'canvas:selectAFolderDescription',
                    'Select a folder to view its images and videos'
                  )}
                </p>
              </div>
            </div>
          )}
        </div>
      </div>

      {/* File Preview Modal */}
      <FilePreviewModal
        isOpen={previewModal.isOpen}
        onClose={closePreviewModal}
        filePath={previewModal.filePath}
        fileName={previewModal.fileName}
        fileType={previewModal.fileType}
      />
    </div>
  )
}



================================================
FILE: react/src/components/settings/AddModelsList.tsx
================================================
import { useState, useEffect, useCallback } from 'react'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Plus, Trash2 } from 'lucide-react'
import { Dialog, DialogContent, DialogTrigger } from '../ui/dialog'

export type ModelItem = {
  name: string
  type: 'text' | 'image' | 'video'
}

interface ModelsListProps {
  models: Record<string, { type?: 'text' | 'image' | 'video' }>
  onChange: (
    models: Record<string, { type?: 'text' | 'image' | 'video' }>
  ) => void
  label?: string
}

export default function AddModelsList({
  models,
  onChange,
  label = 'Models',
}: ModelsListProps) {
  const [modelItems, setModelItems] = useState<ModelItem[]>([])
  const [newModelName, setNewModelName] = useState('')
  const [openAddModelDialog, setOpenAddModelDialog] = useState(false)

  useEffect(() => {
    const modelItems = Object.entries(models).map(([name, config]) => ({
      name,
      type: (config.type || 'text') as 'text' | 'image' | 'video',
    }))
    setModelItems(modelItems.length > 0 ? modelItems : [])
  }, [models])

  const notifyChange = useCallback(
    (items: ModelItem[]) => {
      // Filter out empty model names and convert back to object format
      const validModels = items.filter((model) => model.name.trim())
      const modelsConfig: Record<
        string,
        { type?: 'text' | 'image' | 'video' }
      > = {}

      validModels.forEach((model) => {
        modelsConfig[model.name] = { type: model.type }
      })

      onChange(modelsConfig)
    },
    [onChange]
  )

  const handleAddModel = () => {
    if (newModelName) {
      const newItems = [
        ...modelItems,
        { name: newModelName, type: 'text' as const },
      ]
      setModelItems(newItems)
      notifyChange(newItems)
      setNewModelName('')
      setOpenAddModelDialog(false)
    }
  }

  const handleRemoveModel = (index: number) => {
    if (modelItems.length > 1) {
      const newItems = modelItems.filter((_, i) => i !== index)
      setModelItems(newItems)
      notifyChange(newItems)
    }
  }
  return (
    <div className="space-y-2">
      <div className="flex items-center justify-between">
        <Label>{label}</Label>
        <Dialog open={openAddModelDialog} onOpenChange={setOpenAddModelDialog}>
          <DialogTrigger asChild>
            <Button variant="secondary" size="sm">
              <Plus className="h-4 w-4 mr-1" />
              Add Model
            </Button>
          </DialogTrigger>
          <DialogContent>
            <div className="space-y-5">
              <Label>Model Name</Label>
              <Input
                type="text"
                placeholder="openai/gpt-4o"
                value={newModelName}
                onKeyDown={(e) => {
                  if (e.key === 'Enter') {
                    handleAddModel()
                  }
                }}
                onChange={(e) => setNewModelName(e.target.value)}
              />
              <Button type="button" onClick={handleAddModel} className="w-full">
                Add Model
              </Button>
            </div>
          </DialogContent>
        </Dialog>
      </div>

      <div className="space-y-2">
        {modelItems.map((model, index) => (
          <div key={index} className="flex items-center justify-between">
            <p className="w-[50%]">{model.name}</p>
            <div className="flex items-center gap-6">
              <p>{model.type}</p>
              {modelItems.length > 1 && (
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => handleRemoveModel(index)}
                  className="h-10 w-10 p-0"
                >
                  <Trash2 className="h-4 w-4" />
                </Button>
              )}
            </div>
          </div>
        ))}
      </div>
    </div>
  )
}



================================================
FILE: react/src/components/settings/AddProviderDialog.tsx
================================================
import CommonDialogContent from '@/components/common/DialogContent'
import { Button } from '@/components/ui/button'
import {
  Dialog,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Combobox } from '@/components/ui/combobox'
import { LLMConfig } from '@/types/types'
import { useState } from 'react'
import { useTranslation } from 'react-i18next'
import AddModelsList from './AddModelsList'
import { toast } from 'sonner'

interface AddProviderDialogProps {
  open: boolean
  onOpenChange: (open: boolean) => void
  onSave: (providerKey: string, config: LLMConfig) => void
}

// Predefined provider options with their API URLs
const PROVIDER_OPTIONS = [
  {
    value: 'anthropic',
    label: 'Claude',
    data: {
      apiUrl: 'https://api.anthropic.com/v1/',
      models: {
        'claude-3-7-sonnet-latest': { type: 'text' },
      },
    },
  },
  {
    value: 'OpenRouter',
    label: 'OpenRouter',
    data: {
      apiUrl: 'https://openrouter.ai/api/v1/',
      models: {
        'openai/gpt-4o': { type: 'text' },
        'deepseek/deepseek-chat-v3-0324': { type: 'text' },
        'deepseek/deepseek-chat-v3-0324:free': { type: 'text' },
      },
    },
  },
  {
    value: 'wavespeed',
    label: 'Wavespeed',
    mediaOnly: true,
    data: {
      apiUrl: 'https://api.wavespeed.ai/api/v3/',
      models: {},
      api_key: '',
    },
  },
  {
    value: 'replicate',
    label: 'Replicate',
    mediaOnly: true,
    data: {
      apiUrl: 'https://api.replicate.com/v1/',
      models: {},
      api_key: '',
      max_tokens: 8192,
    },
  },
  {
    value: 'æ·±åº¦æ±‚ç´¢',
    label: 'æ·±åº¦æ±‚ç´¢ (DeepSeek)',
    data: {
      apiUrl: 'https://api.deepseek.com/v1/',
      models: {
        'deepseek-chat': { type: 'text' },
      },
    },
  },
  {
    value: 'volces',
    label: 'ç«å±±å¼•æ“ (Volces)',
    data: {
      apiUrl: 'https://ark.cn-beijing.volces.com/api/v3/',
      models: {
        'doubao-seed-1-6-250615': { type: 'text' },
        'doubao-seed-1-6-thinking-250615': { type: 'text' },
        'doubao-seed-1-6-flash-250615': { type: 'text' },
        'doubao-seedream-3-0-t2i-250415': { type: 'image' },
        'doubao-seedance-1-0-pro-250528': { type: 'video' },
        'doubao-seedance-1-0-lite-i2v-250428': { type: 'video' },
        'doubao-seedance-1-0-lite-t2v-250428': { type: 'video' },
      },
    },
  },
  {
    value: 'GoogleVertex',
    label: 'GoogleVertex',
    data: {
      apiUrl: '',
      models: {
        'gemini-2.5-flash': { type: 'text' },
        'gemini-2.5-pro': { type: 'text' },
        'gemini-2.5-flash-lite-preview-06-17': { type: 'text' },
        'gemini-2.0-flash': { type: 'text' },
        'gemini-2.0-flash-lite': { type: 'text' },
        // not supported yet!
        // 'gemini-2.0-flash-preview-image-generation': { type: 'image' },
        // 'imagen-4.0-generate-preview-06-06': { type: 'image' },
        // 'imagen-4.0-fast-generate-preview-06-06': { type: 'image' },
        // 'imagen-4.0-ultra-generate-preview-06-06': { type: 'image' },
        // 'imagen-3.0-generate-002': { type: 'image' },
        // 'imagen-3.0-fast-generate-001': { type: 'image' },
        // 'veo-3.0-generate-preview': { type: 'video' },
        // 'veo-2.0-generate-001': { type: 'video' },
      },
    },
  },
  {
    value: 'ç¡…åŸºæµåŠ¨',
    label: 'ç¡…åŸºæµåŠ¨ (SiliconFlow)',
    data: { apiUrl: 'https://api.siliconflow.cn/v1/' },
  },
  {
    value: 'æ™ºè°± AI',
    label: 'æ™ºè°± AI (GLM)',
    data: { apiUrl: 'https://open.bigmodel.cn/api/paas/v4/' },
  },
  {
    value: 'æœˆä¹‹æš—é¢',
    label: 'æœˆä¹‹æš—é¢ (Kimi)',
    data: { apiUrl: 'https://api.moonshot.cn/v1/' },
  },
]

export default function AddProviderDialog({
  open,
  onOpenChange,
  onSave,
}: AddProviderDialogProps) {
  const { t } = useTranslation()
  const [providerName, setProviderName] = useState('')
  const [apiUrl, setApiUrl] = useState('')
  const [apiKey, setApiKey] = useState('')
  const [models, setModels] = useState<
    Record<string, { type?: 'text' | 'image' | 'video' }>
  >({})

  const isMediaOnlyProvider =
    PROVIDER_OPTIONS.find((p) => p.value === providerName)?.mediaOnly ?? false

  // Handle data change when provider is selected
  const handleProviderDataChange = (data: any) => {
    if (data && typeof data === 'object' && 'apiUrl' in data) {
      setApiUrl((data as { apiUrl: string }).apiUrl)
      setModels(data.models ?? {})
    }
  }

  const handleSave = () => {
    if (!providerName.trim() || !apiUrl.trim()) {
      return
    }
    if (
      !PROVIDER_OPTIONS.find((p) => p.value === providerName)?.mediaOnly &&
      Object.keys(models).length === 0
    ) {
      toast.error(t('settings:provider.noModelsSelected'))
      return
    }

    const config: LLMConfig = {
      models,
      url: apiUrl,
      api_key: apiKey,
      max_tokens: 8192,
      is_custom: true,
    }

    // Use provider name as key (convert to lowercase and replace spaces with underscores)
    const providerKey = providerName.toLowerCase().replace(/\s+/g, '_')

    onSave(providerKey, config)

    // Reset form
    setProviderName('')
    setApiUrl('')
    setApiKey('')
    setModels({})
    onOpenChange(false)
  }

  const handleCancel = () => {
    // Reset form
    setProviderName('')
    setApiUrl('')
    setApiKey('')
    setModels({})
    onOpenChange(false)
  }

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <CommonDialogContent open={open}>
        <DialogHeader>
          <DialogTitle>
            {t('settings:provider.addProvider')}
            {isMediaOnlyProvider && <span className="ml-3">ğŸ¨ ğŸ¥</span>}
          </DialogTitle>
        </DialogHeader>

        <div className="space-y-4 py-4">
          {/* Provider Name */}
          <div className="space-y-2">
            <Label htmlFor="provider-name">
              {t('settings:provider.providerName')}
            </Label>
            <Combobox
              id="provider-name"
              value={providerName}
              onChange={setProviderName}
              onDataChange={handleProviderDataChange}
              options={PROVIDER_OPTIONS}
              placeholder={t('settings:provider.providerNamePlaceholder')}
            />
          </div>

          {/* API URL */}
          <div className="space-y-2">
            <Label htmlFor="api-url">{t('settings:provider.apiUrl')}</Label>
            <Input
              id="api-url"
              placeholder={t('settings:provider.apiUrlPlaceholder')}
              value={apiUrl}
              onChange={(e) => setApiUrl(e.target.value)}
            />
          </div>

          {/* API Key */}
          <div className="space-y-2">
            <Label htmlFor="api-key">{t('settings:provider.apiKey')}</Label>
            <Input
              id="api-key"
              type="password"
              placeholder={t('settings:provider.apiKeyPlaceholder')}
              value={apiKey}
              onChange={(e) => setApiKey(e.target.value)}
            />
          </div>

          {/* Models */}
          {!isMediaOnlyProvider && (
            <AddModelsList
              models={models}
              onChange={setModels}
              label={t('settings:models.title')}
            />
          )}
        </div>

        <DialogFooter>
          <Button variant="outline" onClick={handleCancel}>
            {t('settings:provider.cancel')}
          </Button>
          <Button
            onClick={handleSave}
            disabled={!providerName.trim() || !apiUrl.trim()}
          >
            {t('settings:provider.save')}
          </Button>
        </DialogFooter>
      </CommonDialogContent>
    </Dialog>
  )
}



================================================
FILE: react/src/components/settings/ComfyuiSetting.tsx
================================================
// import InstallComfyUIDialog from '@/components/comfyui/InstallComfyUIDialog'
import UninstallProgressDialog from '@/components/comfyui/UninstallProgressDialog'
import { Button } from '@/components/ui/button'
import { Checkbox } from '@/components/ui/checkbox'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { PROVIDER_NAME_MAPPING } from '@/constants'
import { LLMConfig } from '@/types/types'
import {
  AlertCircle,
  CheckCircle,
  Play,
  SquareSquareIcon,
  Trash2,
} from 'lucide-react'
import { useCallback, useEffect, useRef, useState } from 'react'
import { useTranslation } from 'react-i18next'
import { useConfigs } from '@/contexts/configs'
import ComfuiWorkflowSetting from './ComfyuiWorkflowSetting'

interface ComfyuiSettingProps {
  config: LLMConfig
  onConfigChange: (key: string, newConfig: LLMConfig) => void
}

export default function ComfyuiSetting({
  config,
  onConfigChange,
}: ComfyuiSettingProps) {
  const { t } = useTranslation()
  const { setShowInstallDialog } = useConfigs()
  const [comfyUIStatus, setComfyUIStatus] = useState<
    'unknown' | 'running' | 'not-running'
  >('unknown')
  const [isComfyUIInstalled, setIsComfyUIInstalled] = useState<boolean>(false)
  const [showUninstallDialog, setShowUninstallDialog] = useState<boolean>(false)
  const provider = PROVIDER_NAME_MAPPING.comfyui
  const comfyUrl = config.url || ''
  const [comfyuiModels, setComfyuiModels] = useState<string[]>([])

  // Validate URL format
  const isValidUrl = (url: string): boolean => {
    try {
      const urlObj = new URL(url)
      return urlObj.protocol === 'http:' || urlObj.protocol === 'https:'
    } catch {
      return false
    }
  }

  // Check if ComfyUI is installed
  useEffect(() => {
    const checkInstallation = async () => {
      try {
        const installed = await window.electronAPI?.checkComfyUIInstalled()
        console.log('ComfyUI installation status:', installed)
        setIsComfyUIInstalled(!!installed)
      } catch (error) {
        console.error('Error checking ComfyUI installation:', error)
        setIsComfyUIInstalled(false)
      }
    }

    checkInstallation()
  }, [])

  // Fetch ComfyUI models when URL is available
  useEffect(() => {
    if (!comfyUrl || !isValidUrl(comfyUrl)) {
      console.log('Invalid ComfyUI URL format for models fetch:', comfyUrl)
      setComfyuiModels([])
      return
    }

    fetch(`/api/comfyui/object_info`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ url: comfyUrl }),
    })
      .then((res) => res.json())
      .then((data) => {
        if (data?.CheckpointLoaderSimple?.input?.required?.ckpt_name?.[0]) {
          const modelList =
            data?.CheckpointLoaderSimple?.input?.required?.ckpt_name?.[0]
          console.log('ComfyUI models:', modelList)
          setComfyuiModels(modelList)

          // if models are fetched, then ComfyUI is installed and running
          //TODO: Needs to delete this line, because user may self installed ComfyUI, but we cannot show Start ComfyUI button if user self installed ComfyUI
          setIsComfyUIInstalled(true)
        }
      })
      .catch((error) => {
        console.error('Failed to fetch ComfyUI models:', error)
        setComfyuiModels([])
      })
  }, [comfyUrl])

  // Check ComfyUI status when URL is provided
  const checkComfyUIStatus = useCallback(async () => {
    if (!comfyUrl) {
      setComfyUIStatus('unknown')
      return
    }

    if (!isValidUrl(comfyUrl)) {
      console.log('Invalid ComfyUI URL format:', comfyUrl)
      setComfyUIStatus('not-running')
      return
    }

    try {
      console.log('Checking ComfyUI status via proxy...')
      // é€šè¿‡æœåŠ¡ç«¯ä»£ç†æ¥å£è½¬å‘è¯·æ±‚
      const response = await fetch(`/api/settings/comfyui/proxy`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          url: comfyUrl, // ä¼ é€’ç”¨æˆ·é…ç½®çš„ComfyUIåœ°å€
          path: '/system_stats', // ç›®æ ‡è·¯å¾„
        }),
      })

      if (response.ok) {
        console.log('ComfyUI is running')
        setComfyUIStatus('running')
      } else {
        console.log('ComfyUI is not responding')
        setComfyUIStatus('not-running')
      }
    } catch (error) {
      console.log(
        'ComfyUI connection failed:',
        error instanceof Error ? error.message : String(error)
      )
      setComfyUIStatus('not-running')
    }
  }, [comfyUrl])

  // Check status when URL changes
  useEffect(() => {
    checkComfyUIStatus()
  }, [comfyUrl, checkComfyUIStatus])

  const handleUrlChange = (url: string) => {
    onConfigChange('comfyui', {
      ...config,
      url: url,
    })
  }

  // const handleInstallClick = () => {
  //   setShowInstallDialog(true)
  // }

  // start ComfyUI
  const startComfyUI = async () => {
    try {
      console.log('Starting ComfyUI...')
      const result = await window.electronAPI?.startComfyUIProcess()

      if (result?.success) {
        console.log('ComfyUI started successfully:', result.message)
        // Recheck status after starting
        setTimeout(() => {
          checkComfyUIStatus()
        }, 3000)
      } else {
        console.error('Failed to start ComfyUI:', result?.message)
      }
    } catch (error) {
      console.error('Error starting ComfyUI:', error)
    }
  }

  const handleStartClick = async () => {
    await startComfyUI()
  }

  // Uninstall ComfyUI
  const handleUninstallClick = async () => {
    // Show uninstall dialog (confirmation will be handled in the dialog)
    setShowUninstallDialog(true)
  }

  // Handle actual uninstall after confirmation
  const handleConfirmUninstall = async () => {
    // Stop ComfyUI process first if it's running
    if (comfyUIStatus === 'running') {
      console.log('Stopping ComfyUI process before uninstallation...')
      try {
        const stopResult = await window.electronAPI?.stopComfyUIProcess()
        if (stopResult?.success) {
          console.log('ComfyUI process stopped successfully')
          // Wait for process to fully terminate
          await new Promise((resolve) => setTimeout(resolve, 2000))
        }
      } catch (stopError) {
        console.log('Error stopping ComfyUI process:', stopError)
      }
    }

    try {
      await window.electronAPI?.uninstallComfyUI()
    } catch (error) {
      console.error('Error starting uninstallation:', error)
    }
  }

  // Handle uninstall completion
  const handleUninstallComplete = () => {
    console.log('ComfyUI uninstalled successfully')
    setIsComfyUIInstalled(false)
    setComfyUIStatus('unknown')
    setComfyuiModels([])

    // Clear ComfyUI configuration
    onConfigChange('comfyui', {
      ...config,
      url: '',
      models: {},
    })
  }

  const getComfyUIStatusIcon = () => {
    if (!isComfyUIInstalled) return null

    if (!comfyUrl) {
      return <AlertCircle className="w-5 h-5 text-yellow-500" />
    }

    switch (comfyUIStatus) {
      case 'running':
        return <CheckCircle className="w-5 h-5 text-green-500" />
      case 'not-running':
        return <AlertCircle className="w-5 h-5 text-red-500" />
      default:
        return <AlertCircle className="w-5 h-5 text-gray-500" />
    }
  }

  const getComfyUIStatusText = () => {
    if (!isComfyUIInstalled) return ''

    if (!comfyUrl) {
      return t('settings:comfyui.status.installed')
    }

    switch (comfyUIStatus) {
      case 'running':
        return t('settings:comfyui.status.running')
      case 'not-running':
        return t('settings:comfyui.status.notRunning')
      default:
        return t('settings:comfyui.status.checking')
    }
  }

  return (
    <div className="space-y-4">
      {/* Provider Header */}
      <div className="flex items-center gap-2">
        <img
          src={provider.icon}
          alt={provider.name}
          className="w-10 h-10 rounded-full"
        />
        <p className="font-bold text-2xl w-fit">{provider.name}</p>
        <span>{t('settings:comfyui.localImageGeneration')}</span>

        {/* Status or Start/Uninstall Button */}
        <div className="ml-auto">
          {isComfyUIInstalled ? (
            // Show status, start and uninstall buttons if ComfyUI is installed
            <div className="flex items-center gap-2">
              {getComfyUIStatusIcon()}
              <span className="text-sm text-muted-foreground">
                {getComfyUIStatusText()}
              </span>
              {(comfyUIStatus === 'not-running' ||
                (!comfyUrl && isComfyUIInstalled)) && (
                <Button
                  onClick={handleStartClick}
                  variant="outline"
                  size="sm"
                  className="border-green-300 text-green-700 hover:bg-green-50"
                >
                  <Play className="w-4 h-4 mr-2" />
                  {t('settings:comfyui.startButton')}
                </Button>
              )}
              <Button
                onClick={handleUninstallClick}
                variant="outline"
                size="sm"
                className="border-red-300 text-red-700 hover:bg-red-50"
                disabled={showUninstallDialog}
              >
                <Trash2 className="w-4 h-4 mr-2" />
                {t('settings:comfyui.uninstallButton')}
              </Button>
            </div>
          ) : (
            // Show install button if ComfyUI is not installed
            <></>
            // <Button
            //   onClick={handleInstallClick}
            //   variant="outline"
            //   size="sm"
            //   className="border-blue-300 text-blue-700 hover:bg-blue-50"
            // >
            //   <Download className="w-4 h-4 mr-2" />
            //   {t('settings:comfyui.installButton')}
            // </Button>
          )}
        </div>
      </div>

      {/* API URL Input */}
      <div className="space-y-2">
        <Label htmlFor="comfyui-url">{t('settings:provider.apiUrl')}</Label>
        <Input
          id="comfyui-url"
          placeholder="http://127.0.0.1:8188"
          value={comfyUrl}
          onChange={(e) => handleUrlChange(e.target.value)}
          className={`w-full ${
            comfyUrl && !isValidUrl(comfyUrl)
              ? 'border-red-300 focus:border-red-500'
              : ''
          }`}
        />
        <p className="text-xs text-gray-500">
          {t('settings:comfyui.urlDescription')}
        </p>
        {comfyUrl && !isValidUrl(comfyUrl) && (
          <p className="text-xs text-red-500 mt-1">
            {t('settings:comfyui.invalidUrl')}
          </p>
        )}
      </div>
      <ComfuiWorkflowSetting />
      {/* Temporarily disable ComfyUI Models, until it is fixed */}
      {/* {comfyuiModels.length > 0 && (
        <div className="space-y-4">
          <div className="flex items-center gap-2">
            <SquareSquareIcon className="w-5 h-5" />
            <p className="text-sm font-bold">{t('settings:models.title')}</p>
          </div>
          <div className="grid grid-cols-2 gap-2">
            {comfyuiModels.map((model) => (
              <div key={model} className="flex items-center gap-2">
                <Checkbox
                  id={model}
                  checked={!!config.models?.[model]}
                  onCheckedChange={(checked) => {
                    if (checked) {
                      onConfigChange('comfyui', {
                        ...config,
                        models: {
                          ...config.models,
                          [model]: {
                            type: 'image',
                          },
                        },
                      })
                    } else {
                      const newModels = { ...config.models }
                      delete newModels[model]
                      onConfigChange('comfyui', {
                        ...config,
                        models: newModels,
                      })
                    }
                  }}
                />
                <Label htmlFor={model}>{model}</Label>
              </div>
            ))}
          </div>
        </div>
      )} */}

      {/* Install Dialog */}
      {/* <InstallComfyUIDialog onInstallSuccess={handleInstallSuccess} /> */}

      {/* Uninstall Dialog */}
      <UninstallProgressDialog
        open={showUninstallDialog}
        onOpenChange={setShowUninstallDialog}
        onUninstallComplete={handleUninstallComplete}
        onConfirmUninstall={handleConfirmUninstall}
      />
    </div>
  )
}



================================================
FILE: react/src/components/settings/ComfyuiWorkflowSetting.tsx
================================================
import { Button } from '@/components/ui/button'
import {
  PaletteIcon,
  PencilIcon,
  PlusIcon,
  TrashIcon,
  UploadIcon,
} from 'lucide-react'
import { useEffect, useState } from 'react'
import { useRef } from 'react'
import { Input } from '../ui/input'
import { Textarea } from '../ui/textarea'
import { Checkbox } from '../ui/checkbox'
import {
  DialogContent,
  DialogHeader,
  DialogTitle,
  Dialog,
  DialogDescription,
} from '../ui/dialog'
import { toast } from 'sonner'
import { useTranslation } from 'react-i18next'
import { Card, CardHeader, CardTitle, CardContent } from '../ui/card'
import { Badge } from '../ui/badge'
import { Label } from '../ui/label'
import { Separator } from '../ui/separator'

export type ComfyWorkflowInput = {
  name: string
  type: 'string' | 'number' | 'boolean'
  description: string
  node_id: string
  node_input_name: string
  default_value: string | number | boolean
  required: boolean
}

type ComfyWorkflowFromAPI = {
  id: number
  name: string
  description: string
  api_json: string
  inputs: string
  outputs: string
}

export type ComfyWorkflow = {
  id: number
  name: string
  description: string
  api_json: Record<string, ComfyUIAPINode> | null
  inputs: ComfyWorkflowInput[] | null
  // outputs: ComfyWorkflowOutput[]
}

export default function ComfuiWorkflowSetting() {
  const { t } = useTranslation()
  const [showAddWorkflowDialog, setShowAddWorkflowDialog] = useState(false)
  const [deleteWorkflowId, setDeleteWorkflowId] = useState<number | null>(null)
  const [editingWorkflow, setEditingWorkflow] = useState<ComfyWorkflow | null>(
    null
  )

  const [workflows, setWorkflows] = useState<ComfyWorkflow[]>([])
  const loadWorkflows = async () => {
    fetch('/api/settings/comfyui/list_workflows')
      .then((res) => res.json())
      .then((data: ComfyWorkflowFromAPI[]) => {
        console.log('ComfyUI workflows:', data)
        const workflows: ComfyWorkflow[] = data.map(
          (workflow: ComfyWorkflowFromAPI) => {
            const inputs = JSON.parse(workflow.inputs ?? '[]')
            const outputs = JSON.parse(workflow.outputs ?? '[]')
            const api_json = JSON.parse(workflow.api_json)
            return {
              ...workflow,
              inputs: inputs,
              outputs: outputs,
              api_json: api_json,
            }
          }
        )
        setWorkflows(workflows)
      })
  }
  useEffect(() => {
    loadWorkflows()
  }, [])
  const handleDeleteWorkflow = (id: number) => {
    fetch(`/api/settings/comfyui/delete_workflow/${id}`, {
      method: 'DELETE',
    })
      .then(() => {
        loadWorkflows()
      })
      .catch((err) => {
        toast.error(`Failed to delete workflow: ${err}`)
        console.error(err)
      })
      .finally(() => {
        setDeleteWorkflowId(null)
      })
  }
  return (
    <div className="space-y-4">
      {deleteWorkflowId && (
        <Dialog
          open={!!deleteWorkflowId}
          onOpenChange={() => setDeleteWorkflowId(null)}
        >
          <DialogContent>
            <p>{t('settings:comfyui.deleteWorkflowConfirmation')}</p>

            <Button onClick={() => handleDeleteWorkflow(deleteWorkflowId)}>
              Delete
            </Button>
          </DialogContent>
        </Dialog>
      )}
      {
        <div className="flex items-center gap-2">
          <PaletteIcon className="w-5 h-5" />
          <p className="text-sm font-bold">{t('settings:comfyui.workflows')}</p>
          <Button
            variant="outline"
            size="sm"
            onClick={() => setShowAddWorkflowDialog(true)}
          >
            <PlusIcon className="w-4 h-4" />
            {t('settings:comfyui.addWorkflow')}
          </Button>
          {(showAddWorkflowDialog || editingWorkflow) && (
            <AddWorkflowDialog
              workflow={editingWorkflow}
              onClose={() => {
                setShowAddWorkflowDialog(false)
                setEditingWorkflow(null)
                loadWorkflows()
              }}
            />
          )}
        </div>
      }
      {/* Workflows */}
      {workflows.length > 0 && (
        <div className="space-y-2">
          <div className="grid grid-cols-2 gap-2">
            {workflows.map((workflow) => (
              <div
                key={workflow.id}
                className="flex items-center gap-2 border p-2 rounded-md justify-between"
              >
                <div className="flex flex-col gap-1">
                  <p>{workflow.name}</p>
                  <p className="text-muted-foreground">
                    {workflow.description}
                  </p>
                </div>
                <div className="flex items-center gap-1">
                  <Button
                    variant="ghost"
                    size="icon"
                    onClick={() => {
                      setEditingWorkflow(workflow)
                    }}
                  >
                    <PencilIcon className="w-4 h-4" />
                  </Button>
                  <Button
                    variant="ghost"
                    size="icon"
                    onClick={() => {
                      setDeleteWorkflowId(workflow.id)
                    }}
                  >
                    <TrashIcon />
                  </Button>
                </div>
              </div>
            ))}
          </div>
        </div>
      )}
    </div>
  )
}

type ComfyUIAPINode = {
  class_type: string
  inputs: Record<string, string | number | boolean | string[] | number[]>
}
function AddWorkflowDialog({
  onClose,
  workflow,
}: {
  onClose: () => void
  workflow: ComfyWorkflow | null
}) {
  const { t } = useTranslation()
  const inputRef = useRef<HTMLInputElement>(null)
  const [workflowName, setWorkflowName] = useState(workflow?.name ?? '')
  const [workflowJson, setWorkflowJson] = useState<Record<
    string,
    ComfyUIAPINode
  > | null>(workflow?.api_json ?? null)
  const [inputs, setInputs] = useState<ComfyWorkflowInput[]>(
    workflow?.inputs ?? []
  )
  const [error, setError] = useState('')
  const [workflowDescription, setWorkflowDescription] = useState(
    workflow?.description ?? ''
  )
  const [outputs, setOutputs] = useState<
    {
      name: string
      type: 'string' | 'number' | 'boolean'
      description: string
    }[]
  >([])
  const handleFileChange = async (e: React.ChangeEvent<HTMLInputElement>) => {
    setInputs([])
    const file = e.target.files?.[0]
    if (file) {
      try {
        const fileContent = await file.text()
        // Parse the JSON content
        const jsonContent = JSON.parse(fileContent)
        console.log('Parsed workflow JSON:', jsonContent)
        for (const key in jsonContent) {
          const node: ComfyUIAPINode = jsonContent[key]
          if (!node.class_type) {
            toast.error(
              t(
                'settings:comfyui.invalidApiJsonFormat',
                'Invalid API JSON format. You need to export API JSON, not workflow JSON in ComfyUI. Please go to ComfyUI Menu -> Workflow -> Export (API) JSON and try again.'
              )
            )
            return
          }
        }
        setWorkflowJson(jsonContent)
        setWorkflowName(file.name.replace('.json', ''))
      } catch (error) {
        console.error(error)
        toast.error(
          t(
            'settings:comfyui.invalidWorkflowJsonFormat',
            'Invalid workflow JSON, make sure you exprted API JSON in ComfyUI!' +
              error
          )
        )
      }
    }
  }
  const handleSubmit = async () => {
    if (!workflowJson) {
      setError(
        t(
          'settings:comfyui.pleaseUploadWorkflowApiJsonFile',
          'Please upload a workflow API JSON file'
        )
      )
      return
    }
    if (inputs.length === 0) {
      setError(
        t(
          'settings:comfyui.pleaseAddAtLeastOneInput',
          'Please add at least one input'
        )
      )
      return
    }
    if (workflowName === '') {
      setError(
        t(
          'settings:comfyui.pleaseEnterWorkflowName',
          'Please enter a workflow name'
        )
      )
      return
    }
    if (workflowDescription === '') {
      setError(
        t(
          'settings:comfyui.pleaseEnterWorkflowDescription',
          'Please enter a workflow description'
        )
      )
      return
    }
    const matched = workflowName.match(/^[a-zA-Z0-9_]+$/)
    if (!matched) {
      setError(
        t(
          'settings:comfyui.workflowNameInvalid',
          'Workflow Name only allow a-Z, 0-9, _'
        )
      )
      return
    }
    const payload = {
      name: workflowName,
      api_json: workflowJson,
      description: workflowDescription,
      inputs: inputs,
    }
    console.log('å‘é€åˆ°åç«¯çš„æ•°æ®ï¼š', payload)

    if (workflow) {
      // å…ˆåˆ é™¤
      const deleteRes = await fetch(
        `/api/settings/comfyui/delete_workflow/${workflow.id}`,
        {
          method: 'DELETE',
        }
      )
      if (!deleteRes.ok) {
        const data = await deleteRes.json()
        toast.error(`Failed to delete old workflow: ${data.message}`)
        return
      }
    }

    // å†åˆ›å»º
    const createRes = await fetch('/api/settings/comfyui/create_workflow', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(payload),
    })

    if (createRes.ok) {
      toast.success(
        t(
          'settings:comfyui.workflowUpdatedSuccessfully',
          `Workflow ${workflow ? 'updated' : 'created'} successfully`
        )
      )
      onClose()
    } else {
      const data = await createRes.json()
      toast.error(
        `Failed to ${workflow ? 'update' : 'create'} workflow: ${data.message}`
      )
    }
  }
  return (
    <Dialog
      open={true}
      onOpenChange={(open) => {
        if (!open) {
          onClose()
        }
      }}
    >
      <DialogContent
        // open={true}
        className="max-w-4xl h-[90vh] flex flex-col p-4"
      >
        <DialogHeader className="flex-shrink-0 pb-2">
          <DialogTitle>
            {workflow
              ? t('settings:comfyui.editWorkflow', 'Edit Workflow')
              : t('settings:comfyui.addWorkflow', 'Add Workflow')}
          </DialogTitle>
          {error && <p className="text-red-500">{error}</p>}
        </DialogHeader>
        
        {/* Scrollable content area */}
        <div className="flex-1 overflow-y-auto space-y-3 pr-2">
        <Input
          type="text"
          style={{ flexShrink: 0 }}
          placeholder={t(
            'settings:comfyui.workflowName',
            'Workflow Name, only a-Z, 0-9, _ are allowed'
          )}
          value={workflowName}
          onChange={(e) => setWorkflowName(e.target.value)}
        />
        <Textarea
          placeholder={t(
            'settings:comfyui.workflowDescription',
            'Workflow Description'
          )}
          value={workflowDescription}
          onChange={(e) => setWorkflowDescription(e.target.value)}
        />
        <Button onClick={() => inputRef.current?.click()} variant={'outline'}>
          <UploadIcon className="w-4 h-4 mr-2" />
          {t(
            'settings:comfyui.uploadWorkflowApiJson',
            'Upload Workflow API JSON'
          )}
        </Button>
        <input
          type="file"
          accept=".json"
          ref={inputRef}
          onChange={handleFileChange}
          className="hidden"
        />
        {workflowJson && (
          <Card className="border-2 border-dashed border-primary/20">
            <CardHeader>
              <CardTitle className="flex items-center">
                <div className="h-2 w-2 rounded-full bg-primary"></div>
                {t(
                  'settings:comfyui.workflowInputsConfiguration',
                  'Workflow Inputs Configuration'
                )}
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-6">
              {inputs.length > 0 ? (
                <div className="space-y-2">
                  {inputs.map((input, index) => (
                    <Card
                      key={`${input.node_input_name}_${input.node_id}`}
                      className="bg-background/50 border border-border/50"
                    >
                      <CardContent className="space-y-4">
                        <div className="flex items-start justify-between gap-4">
                          <div className="flex-1 space-y-3">
                            {/* Input Name and Required Badge */}
                            <div className="flex items-center gap-2 flex-wrap">
                              <Label className="font-mono text-sm bg-muted px-2 py-1 rounded">
                                {input.name}
                              </Label>
                              <Badge variant="outline" className="text-xs">
                                {input.type}
                              </Badge>
                            </div>

                            <Separator className="my-2" />

                            {/* Default Value */}
                            <div className="space-y-2">
                              <Label className="text-xs text-muted-foreground">
                                {t(
                                  'settings:comfyui.defaultValue',
                                  'Default Value'
                                )}
                              </Label>
                              <Input
                                type="text"
                                value={input.default_value.toString()}
                                disabled
                                className="bg-muted/50 text-sm"
                              />
                            </div>

                            {/* Description */}
                            <div className="space-y-2">
                              {/* <Label className="text-xs text-muted-foreground">
                                Description for Users
                              </Label> */}
                              <Textarea
                                placeholder={t(
                                  'settings:comfyui.describeInput',
                                  'Describe what this input does so that LLM can understand it and pass in the correct value...'
                                )}
                                value={input.description}
                                onChange={(e) => {
                                  const newInputs = [...inputs]
                                  newInputs[index].description = e.target.value
                                  setInputs(newInputs)
                                }}
                                className="min-h-[80px] text-sm resize-none"
                              />
                            </div>
                          </div>

                          {/* Controls */}
                          <div className="flex flex-col items-end gap-2">
                            <div className="flex items-center space-x-2">
                              <Checkbox
                                id={`required-${index}`}
                                checked={input.required}
                                onCheckedChange={(checked) => {
                                  const newInputs = [...inputs]
                                  newInputs[index].required = !!checked
                                  setInputs(newInputs)
                                }}
                              />
                              <Label
                                htmlFor={`required-${index}`}
                                className="text-xs"
                              >
                                {t('settings:comfyui.required', 'Required')}
                              </Label>
                            </div>
                            <Button
                              variant="ghost"
                              size="icon"
                              onClick={() => {
                                const newInputs = [...inputs]
                                newInputs.splice(index, 1)
                                setInputs(newInputs)
                              }}
                              className="text-destructive hover:bg-destructive/10 hover:text-destructive"
                            >
                              <TrashIcon className="w-4 h-4" />
                            </Button>
                          </div>
                        </div>
                      </CardContent>
                    </Card>
                  ))}
                </div>
              ) : (
                <Card className="border-dashed border-2 border-muted-foreground/25">
                  <CardContent className="flex flex-col items-center justify-center py-12 text-center">
                    <div className="rounded-full bg-muted p-3 mb-4">
                      <PlusIcon className="w-6 h-6 text-muted-foreground" />
                    </div>
                    <h3 className="font-medium text-foreground mb-2">
                      {t(
                        'settings:comfyui.noInputsConfigured',
                        'No inputs configured'
                      )}
                    </h3>
                    <p className="text-sm text-muted-foreground mb-4 max-w-sm">
                      {t(
                        'settings:comfyui.addWorkflowInputsFromNodeParameters',
                        'Add workflow inputs from the node parameters below. Choose at least one input to make this workflow interactive.'
                      )}
                    </p>
                    <Badge variant="outline" className="text-xs">
                      {t(
                        'settings:comfyui.selectParametersFromWorkflowNodes',
                        'Select parameters from the workflow nodes below'
                      )}
                    </Badge>
                  </CardContent>
                </Card>
              )}
            </CardContent>
          </Card>
        )}
        {workflowJson &&
          Object.keys(workflowJson).map((nodeID) => {
            const node = workflowJson[nodeID]
            return (
              <div key={nodeID}>
                <p className="font-bold">
                  {node.class_type} #{nodeID}
                </p>
                <div className="ml-4 flex flex-col gap-1">
                  {Object.keys(node.inputs).map((inputKey) => {
                    const inputValue = node.inputs[inputKey]
                    if (
                      typeof inputValue !== 'boolean' &&
                      typeof inputValue !== 'number' &&
                      typeof inputValue !== 'string'
                    ) {
                      return null
                    }
                    return (
                      <div key={inputKey} className="flex items-center gap-2">
                        <p className="bg-accent text-sm px-2 py-0.5 rounded-md">
                          {inputKey}
                        </p>
                        <Input
                          type="text"
                          value={inputValue.toString()}
                          disabled
                        />
                        <Button
                          variant="outline"
                          size="default"
                          onClick={() => {
                            setInputs([
                              ...inputs.filter(
                                (i) =>
                                  i.node_id !== nodeID ||
                                  i.node_input_name !== inputKey
                              ),
                              {
                                name: `${inputKey}_${nodeID}`,
                                type: typeof inputValue as
                                  | 'string'
                                  | 'number'
                                  | 'boolean',
                                description: '',
                                node_id: nodeID,
                                node_input_name: inputKey,
                                default_value: inputValue,
                                required: false,
                              },
                            ])
                          }}
                        >
                          <PlusIcon className="w-4 h-4" />
                          {t('settings:comfyui.addInput', 'Add Input')}
                        </Button>
                      </div>
                    )
                  })}
                </div>
              </div>
            )
          })}
        </div>
        
        {/* Fixed Submit Button at the bottom */}
        <div className="flex-shrink-0 mt-2 pt-3 border-t border-border bg-background">
          <Button onClick={handleSubmit} className="w-full">
            {workflow
              ? t('settings:comfyui.save', 'Save')
              : t('settings:comfyui.submit', 'Submit')}
          </Button>
        </div>
      </DialogContent>
    </Dialog>
  )
}



================================================
FILE: react/src/components/settings/CommonSetting.tsx
================================================
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Button } from '@/components/ui/button'
import { PROVIDER_NAME_MAPPING } from '@/constants'
import { LLMConfig } from '@/types/types'
import { useTranslation } from 'react-i18next'
import AddModelsList from './AddModelsList'
import { Trash2 } from 'lucide-react'

interface CommonSettingProps {
  providerKey: string
  config: LLMConfig
  onConfigChange: (key: string, newConfig: LLMConfig) => void
  onDeleteProvider?: (providerKey: string) => void
}

export default function CommonSetting({
  providerKey,
  config,
  onConfigChange,
  onDeleteProvider,
}: CommonSettingProps) {
  const { t } = useTranslation()
  // jaaz is official provider, so we don't need to show it here
  if (providerKey === 'jaaz') {
    return null
  }

  const provider = PROVIDER_NAME_MAPPING[providerKey] || {
    name:
      providerKey.charAt(0).toUpperCase() +
      providerKey.slice(1).replace(/_/g, ' '),
    // TODO: replace icon
    icon: 'https://openai.com/favicon.ico',
  }

  // Check if this is a custom provider (not in PROVIDER_NAME_MAPPING)
  const isCustomProvider = config.is_custom

  const handleChange = (field: keyof LLMConfig, value: string | number) => {
    onConfigChange(providerKey, {
      ...config,
      [field]: value,
    })
  }

  const handleModelsChange = (
    models: Record<string, { type?: 'text' | 'image' | 'video' }>
  ) => {
    onConfigChange(providerKey, {
      ...config,
      models,
    })
  }

  const handleDelete = () => {
    if (onDeleteProvider && isCustomProvider) {
      onDeleteProvider(providerKey)
    }
  }

  const isImageProvider =
    providerKey === 'replicate' || providerKey === 'huggingface'
  const hasMaxTokens = !isImageProvider

  return (
    <div className="space-y-4">
      {/* Provider Header */}
      <div className="flex items-center gap-2">
        <img
          src={provider.icon}
          alt={provider.name}
          className="w-10 h-10 rounded-full"
        />
        <p className="font-bold text-2xl w-fit">{provider.name}</p>
        {isCustomProvider && <span>âœ¨ Custom Provider</span>}
        {isImageProvider && <span>ğŸ¨ Image Generation</span>}

        {/* Delete Button - only for custom providers */}
        {isCustomProvider && onDeleteProvider && (
          <div className="ml-auto">
            <Button
              variant="outline"
              size="sm"
              onClick={handleDelete}
              className="text-red-600 hover:text-red-700 hover:bg-red-50"
            >
              <Trash2 className="h-4 w-4 mr-1" />
              {t('settings:provider.delete')}
            </Button>
          </div>
        )}
      </div>

      {/* API URL Input */}
      <div className="space-y-2">
        <Label htmlFor={`${providerKey}-url`}>
          {t('settings:provider.apiUrl')}
        </Label>
        <Input
          id={`${providerKey}-url`}
          placeholder={t('settings:provider.apiUrlPlaceholder')}
          value={config.url ?? ''}
          onChange={(e) => handleChange('url', e.target.value)}
          className="w-full"
        />
      </div>

      {/* API Key Input */}
      <div className="space-y-2">
        <Label htmlFor={`${providerKey}-apiKey`}>
          {t('settings:provider.apiKey')}
        </Label>
        <Input
          id={`${providerKey}-apiKey`}
          type="password"
          placeholder={t('settings:provider.apiKeyPlaceholder')}
          value={config.api_key ?? ''}
          onChange={(e) => handleChange('api_key', e.target.value)}
          className="w-full"
        />
        <p className="text-xs text-gray-500">
          {t('settings:provider.apiKeyDescription')}
        </p>
      </div>

      {/* Models Configuration - only for custom providers */}
      {providerKey !== 'ollama' && (
        <div className="space-y-2">
          <AddModelsList
            models={config.models || {}}
            onChange={handleModelsChange}
            label={t('settings:models.title')}
          />
        </div>
      )}

      {/* Max Tokens Input - only for text providers */}
      {hasMaxTokens && (
        <div className="space-y-2">
          <Label htmlFor={`${providerKey}-maxTokens`}>
            {t('settings:provider.maxTokens')}
          </Label>
          <Input
            id={`${providerKey}-maxTokens`}
            type="number"
            placeholder={t('settings:provider.maxTokensPlaceholder')}
            value={config.max_tokens ?? 8192}
            onChange={(e) =>
              handleChange('max_tokens', parseInt(e.target.value))
            }
            className="w-full"
          />
          <p className="text-xs text-gray-500">
            {t('settings:provider.maxTokensDescription')}
          </p>
        </div>
      )}
    </div>
  )
}



================================================
FILE: react/src/components/settings/JaazSetting.tsx
================================================
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Button } from '@/components/ui/button'
import { Switch } from '@/components/ui/switch'
import { LOGO_URL } from '@/constants'
import { LLMConfig } from '@/types/types'
import { useTranslation } from 'react-i18next'
import { useAuth } from '@/contexts/AuthContext'
import { useConfigs } from '@/contexts/configs'

interface JaazSettingProps {
  config: LLMConfig
  onConfigChange: (key: string, newConfig: LLMConfig) => void
}

export default function JaazSetting({
  config,
  onConfigChange,
}: JaazSettingProps) {
  const { t } = useTranslation()
  const { authStatus } = useAuth()
  const { setShowLoginDialog } = useConfigs()

  // Get available models from constants
  const availableModels = config.models || {}

  const handleModelToggle = (modelName: string, enabled: boolean) => {
    const currentModels = config.models || {}
    const updatedModels = { ...currentModels }

    if (enabled) {
      // Add model with its type from available models
      updatedModels[modelName] = {
        ...availableModels[modelName],
        is_disabled: false,
      }
    } else {
      // Remove model
      updatedModels[modelName] = {
        ...updatedModels[modelName],
        is_disabled: true,
      }
    }

    // Filter out any models that don't exist in availableModels
    const validModels: Record<string, { type?: 'text' | 'image' | 'video' }> =
      {}
    Object.keys(updatedModels).forEach((key) => {
      if (availableModels[key]) {
        validModels[key] = updatedModels[key]
      }
    })

    onConfigChange('jaaz', {
      ...config,
      models: validModels,
    })
  }

  const handleChange = (field: keyof LLMConfig, value: string | number) => {
    onConfigChange('jaaz', {
      ...config,
      [field]: value,
    })
  }

  const ModelsList = () => (
    <div className="space-y-2">
      <div className="flex items-center justify-between">
        <Label>{t('settings:models.title')}</Label>
      </div>

      <div className="space-y-2">
        {Object.entries(availableModels).map(([modelName, modelConfig]) => {
          return (
            <div key={modelName} className="flex items-center justify-between">
              <p className="w-[50%]">{modelName}</p>
              <div className="flex items-center gap-6">
                <p>{modelConfig.type || 'text'}</p>
                {/* TODO: re-enable this switch */}
                {/* <Switch
                  checked={!modelConfig.is_disabled}
                  onCheckedChange={(checked) =>
                    handleModelToggle(modelName, checked)
                  }
                /> */}
              </div>
            </div>
          )
        })}
      </div>
    </div>
  )

  return (
    <div className="space-y-4">
      {/* Provider Header */}
      <div className="flex items-center gap-2 justify-between">
        <div className="flex items-center gap-2">
          <img src={LOGO_URL} alt="Jaaz" className="w-10 h-10 rounded-full" />
          <p className="font-bold text-2xl w-fit">Jaaz</p>
          {/* <span>âœ¨ Custom Provider</span> */}
        </div>

        {/* Show login button if not logged in */}
        {!authStatus.is_logged_in && (
          <Button
            variant="outline"
            size="sm"
            onClick={() => setShowLoginDialog(true)}
          >
            {t('common:auth.login')}
          </Button>
        )}
      </div>

      {/* Only show configuration when logged in */}
      {authStatus.is_logged_in && (
        <>
          {/* Models Configuration */}
          <div className="space-y-2">
            <ModelsList />
          </div>

          {/* Max Tokens Input */}
          <div className="space-y-2">
            <Label htmlFor="jaaz-maxTokens">
              {t('settings:provider.maxTokens')}
            </Label>
            <Input
              id="jaaz-maxTokens"
              type="number"
              placeholder={t('settings:provider.maxTokensPlaceholder')}
              value={config.max_tokens ?? 8192}
              onChange={(e) =>
                handleChange('max_tokens', parseInt(e.target.value))
              }
              className="w-full"
            />
            <p className="text-xs text-gray-500">
              {t('settings:provider.maxTokensDescription')}
            </p>
          </div>
        </>
      )}
    </div>
  )
}



================================================
FILE: react/src/components/settings/dialog/index.tsx
================================================
import CommonDialogContent from '@/components/common/DialogContent'
import { Button } from '@/components/ui/button'
import { Dialog, DialogFooter } from '@/components/ui/dialog'
import { ScrollArea } from '@/components/ui/scroll-area'
import { SidebarProvider } from '@/components/ui/sidebar'
import { useConfigs } from '@/contexts/configs'
import { useState } from 'react'
import { useTranslation } from 'react-i18next'
import SettingProviders from './providers'
import SettingProxy from './proxy'
import SettingSidebar, { SettingSidebarType } from './sidebar'
import { X } from 'lucide-react'

const SettingsDialog = () => {
  const { showSettingsDialog: open, setShowSettingsDialog } = useConfigs()
  const { t } = useTranslation()
  const [current, setCurrent] = useState<SettingSidebarType>('provider')

  const renderContent = () => {
    switch (current) {
      case 'proxy':
        return <SettingProxy />
      case 'provider':
      default:
        return <SettingProviders />
    }
  }

  return (
    <Dialog open={open} onOpenChange={setShowSettingsDialog}>
      <CommonDialogContent
        open={open}
        transformPerspective={6000}
        className="flex flex-col p-0 gap-0 w-screen! h-screen! max-h-[100vh]! max-w-[100vw]! rounded-none! border-none! shadow-none!"
      >
        <SidebarProvider className="h-[calc(100vh-60px)]! min-h-[calc(100vh-60px)]! flex-1 relative">
          <SettingSidebar
            current={current}
            setCurrent={setCurrent}
            onClose={() => setShowSettingsDialog(false)}
          />
          <ScrollArea className="max-h-[calc(100vh-50px)]! w-full">
            {renderContent()}
          </ScrollArea>
        </SidebarProvider>
      </CommonDialogContent>
    </Dialog>
  )
}

export default SettingsDialog



================================================
FILE: react/src/components/settings/dialog/providers.tsx
================================================
import AddProviderDialog from '@/components/settings/AddProviderDialog'
import ComfyuiSetting from '@/components/settings/ComfyuiSetting'
import CommonSetting from '@/components/settings/CommonSetting'
import JaazSetting from '@/components/settings/JaazSetting'
import { Button } from '@/components/ui/button'
import useConfigsStore from '@/stores/configs'
import { LLMConfig } from '@/types/types'
import { getConfig, updateConfig } from '@/api/config'
import { useRefreshModels } from '@/contexts/configs'
import { Plus, Save } from 'lucide-react'
import { useEffect, useState } from 'react'
import { useTranslation } from 'react-i18next'
import { toast } from 'sonner'

const SettingProviders = () => {
  const { t } = useTranslation()
  const { providers, setProviders } = useConfigsStore()
  const refreshModels = useRefreshModels()
  const [isLoading, setIsLoading] = useState(true)
  const [errorMessage, setErrorMessage] = useState('')
  const [isAddProviderDialogOpen, setIsAddProviderDialogOpen] = useState(false)

  useEffect(() => {
    const loadConfig = async () => {
      try {
        const config: { [key: string]: LLMConfig } = await getConfig()

        setProviders(config)
      } catch (error) {
        console.error('Error loading configuration:', error)
        setErrorMessage(t('settings:messages.failedToLoad'))
      } finally {
        setIsLoading(false)
      }
    }

    loadConfig()
  }, [])

  const handleConfigChange = (key: string, newConfig: LLMConfig) => {
    setProviders({
      ...providers,
      [key]: newConfig,
    })
  }

  const handleAddProvider = (providerKey: string, newConfig: LLMConfig) => {
    setProviders({
      ...providers,
      [providerKey]: newConfig,
    })
  }

  const handleDeleteProvider = (providerKey: string) => {
    delete providers[providerKey]
    setProviders({
      ...providers,
    })
  }

  const handleSave = async () => {
    try {
      setErrorMessage('')

      const result = await updateConfig(providers)

      if (result.status === 'success') {
        toast.success(result.message)
        // Refresh models list after successful config update
        refreshModels()
      } else {
        throw new Error(result.message || 'Failed to save configuration')
      }
    } catch (error) {
      console.error('Error saving settings:', error)
      setErrorMessage(t('settings:messages.failedToSave'))
    }
  }

  return (
    <div className="flex flex-col items-center justify-center p-4 w-full sm:pb-0 pb-10 relative">
      {isLoading && (
        <div className="flex justify-center items-center h-32">
          <div className="animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-zinc-500"></div>
        </div>
      )}

      {!isLoading &&
        Object.keys(providers).map((key, index) => (
          <div key={key} className="w-full">
            {key === 'jaaz' ? (
              <JaazSetting
                config={providers[key]}
                onConfigChange={handleConfigChange}
              />
            ) : key === 'comfyui' ? (
              <ComfyuiSetting
                config={providers[key]}
                onConfigChange={handleConfigChange}
              />
            ) : (
              <CommonSetting
                providerKey={key}
                config={providers[key]}
                onConfigChange={handleConfigChange}
                onDeleteProvider={handleDeleteProvider}
              />
            )}

            {index !== Object.keys(providers).length - 1 && (
              <div className="my-6 border-t bg-border" />
            )}
          </div>
        ))}

      <div className="flex fixed bottom-0 left-[calc(var(--sidebar-width))] gap-1 right-0 px-1">
        <Button onClick={handleSave} className="w-1/2" size="lg">
          <Save className="mr-2 h-6 w-6" /> {t('settings:saveSettings')}
        </Button>

        <Button
          variant="outline"
          onClick={() => setIsAddProviderDialogOpen(true)}
          className="w-1/2"
          size="lg"
        >
          <Plus className="h-6 w-6" />
          {t('settings:provider.addProvider')}
        </Button>
      </div>

      {errorMessage && (
        <div className="text-red-500 text-center mb-4">{errorMessage}</div>
      )}

      <AddProviderDialog
        open={isAddProviderDialogOpen}
        onOpenChange={setIsAddProviderDialogOpen}
        onSave={handleAddProvider}
      />
    </div>
  )
}

export default SettingProviders



================================================
FILE: react/src/components/settings/dialog/proxy.tsx
================================================
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'
import { Network, Save } from 'lucide-react'
import { useEffect, useState } from 'react'
import { useTranslation } from 'react-i18next'
import { toast } from 'sonner'
import { getProxySettings, updateProxySettings } from '@/api/settings'

type ProxyMode = 'no_proxy' | 'system' | 'custom'

interface ProxyConfig {
  mode: ProxyMode
  url: string
}

const SettingProxy = () => {
  const { t } = useTranslation()
  const [isLoading, setIsLoading] = useState(true)
  const [errorMessage, setErrorMessage] = useState('')
  const [testing, setTesting] = useState(false)
  const [proxyConfig, setProxyConfig] = useState<ProxyConfig>({
    mode: 'system',
    url: ''
  })

  useEffect(() => {
    const loadConfig = async () => {
      try {
        const settings = await getProxySettings()

        // Extract proxy config from the response
        const proxyValue = (settings.proxy as string) || 'system'

        let mode: ProxyMode = 'system'
        let url = ''

        if (proxyValue === 'no_proxy') {
          mode = 'no_proxy'
        } else if (proxyValue === 'system') {
          mode = 'system'
        } else {
          mode = 'custom'
          url = proxyValue
        }

        setProxyConfig({ mode, url })
      } catch (error) {
        console.error('Error loading proxy settings:', error)
        const errorMessage = error instanceof Error ? error.message : 'Failed to load proxy settings'
        setErrorMessage(errorMessage)
      } finally {
        setIsLoading(false)
      }
    }

    loadConfig()
  }, [t])

  const handleModeChange = (mode: ProxyMode) => {
    setProxyConfig(prev => ({ ...prev, mode }))
  }

  const handleUrlChange = (url: string) => {
    setProxyConfig(prev => ({ ...prev, url }))
  }

  const handleSave = async () => {
    try {
      setErrorMessage('')

      let proxyValue: string
      switch (proxyConfig.mode) {
        case 'no_proxy':
          proxyValue = 'no_proxy'
          break
        case 'system':
          proxyValue = 'system'
          break
        case 'custom':
          proxyValue = proxyConfig.url.trim()
          // Validate custom proxy URL format
          if (proxyValue && !proxyValue.match(/^(https?|socks[45]):\/\/.+/)) {
            setErrorMessage('Invalid proxy URL format. Please use http://, https://, socks4://, or socks5:// protocol.')
            return
          }
          break
        default:
          proxyValue = 'system'
      }

      console.log('Saving proxy settings:', { proxy: proxyValue })

      // Save proxy settings using the dedicated proxy API
      const result = await updateProxySettings({
        proxy: proxyValue
      })

      console.log('Proxy settings save result:', result)

      if (result.status === 'success') {
        toast.success(result.message || 'Proxy settings saved successfully')
        // Show restart notification
        setTimeout(() => {
          toast.info(t('settings:messages.restartRequired'), {
            duration: 5000
          })
        }, 1000)
        setErrorMessage('')
      } else {
        const errorMsg = result.message || 'Failed to save proxy settings'
        console.error('Save failed with result:', result)
        setErrorMessage(errorMsg)
        toast.error(errorMsg)
      }
    } catch (error) {
      console.error('Error saving proxy settings:', error)
      const errorMessage = error instanceof Error ? error.message : 'Failed to save proxy settings'
      setErrorMessage(errorMessage)
      toast.error(errorMessage)
    }
  }

  return (
    <div className="flex flex-col items-center justify-center p-4 relative w-full sm:pb-0 pb-10">
      {isLoading && (
        <div className="flex justify-center items-center h-32">
          <div className="animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-zinc-500"></div>
        </div>
      )}

      {!isLoading && (
        <div className="w-full">
          <div className="flex items-center gap-2 mb-4">
            <Network className="h-5 w-5" />
            <h3 className="text-lg font-semibold">{t('settings:proxy:title')}</h3>
          </div>

          <div className="space-y-4">
            <div className="flex items-center justify-between">
              <Label htmlFor="proxy-mode" className="text-sm font-medium">
                {t('settings:proxy:mode')}
              </Label>
              <Select value={proxyConfig.mode} onValueChange={handleModeChange}>
                <SelectTrigger className="w-48">
                  <SelectValue placeholder={t('settings:proxy:selectMode')} />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="no_proxy">{t('settings:proxy:modes.no_proxy')}</SelectItem>
                  <SelectItem value="system">{t('settings:proxy:modes.system')}</SelectItem>
                  <SelectItem value="custom">{t('settings:proxy:modes.custom')}</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {proxyConfig.mode === 'custom' && (
              <div className="space-y-2">
                <Label htmlFor="proxy-url" className="text-sm font-medium">
                  {t('settings:proxy:url')}
                </Label>
                <Input
                  id="proxy-url"
                  type="text"
                  placeholder={t('settings:proxy:urlPlaceholder')}
                  value={proxyConfig.url}
                  onChange={(e) => handleUrlChange(e.target.value)}
                />
              </div>
            )}
          </div>
        </div>
      )}

      <div className="flex justify-center fixed sm:bottom-2 sm:left-[calc(var(--sidebar-width)+0.45rem)] sm:translate-x-0 -translate-x-1/2 bottom-15 left-1/2 gap-1.5">
        <Button onClick={handleSave} disabled={isLoading}>
          <Save className="mr-2 h-4 w-4" /> {t('settings:saveSettings')}
        </Button>
      </div>

      {errorMessage && (
        <div className="text-red-500 text-center mb-4">{errorMessage}</div>
      )}
    </div>
  )
}

export default SettingProxy



================================================
FILE: react/src/components/settings/dialog/sidebar.tsx
================================================
import { Button } from '@/components/ui/button'
import {
  Sidebar,
  SidebarContent,
  SidebarGroup,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarMenu,
  SidebarMenuButton,
  SidebarMenuItem,
} from '@/components/ui/sidebar'
import { cn } from '@/lib/utils'
import { PlugZap, Network, ChevronLeft } from 'lucide-react'
import { useTranslation } from 'react-i18next'

export type SettingSidebarType = 'provider' | 'proxy'

type SettingSidebar = {
  current: SettingSidebarType
  setCurrent: (current: SettingSidebarType) => void
  onClose?: () => void
}

const SettingSidebar: React.FC<SettingSidebar> = ({
  current,
  setCurrent,
  onClose,
}) => {
  const { t } = useTranslation()

  // Menu items.
  const items: {
    type: SettingSidebarType
    title: string
    icon: React.ElementType
  }[] = [
    {
      type: 'provider',
      title: 'settings:provider:title',
      icon: PlugZap,
    },
    {
      type: 'proxy',
      title: 'settings:proxy:title',
      icon: Network,
    },
  ]

  return (
    <Sidebar className="h-full rounded-l-lg overflow-hidden">
      <SidebarContent>
        <SidebarGroup>
          <div className="flex items-center justify-between mb-2">
            {onClose && (
              <Button onClick={onClose}>
                <ChevronLeft className="h-6 w-6" />
                <span className="sr-only">Close</span>
              </Button>
            )}
            <SidebarGroupLabel className="text-lg font-bold select-none">
              {t('settings:title')}
            </SidebarGroupLabel>
          </div>
          <SidebarGroupContent>
            <SidebarMenu>
              {items.map((item) => (
                <SidebarMenuItem key={item.title}>
                  <SidebarMenuButton asChild>
                    <div
                      className={cn(
                        'flex items-center gap-2 select-none cursor-pointer',
                        current === item.type && 'bg-muted'
                      )}
                      onClick={() => setCurrent(item.type)}
                    >
                      <item.icon />
                      <span>{t(item.title)}</span>
                    </div>
                  </SidebarMenuButton>
                </SidebarMenuItem>
              ))}
            </SidebarMenu>
          </SidebarGroupContent>
        </SidebarGroup>
      </SidebarContent>
    </Sidebar>
  )
}

export default SettingSidebar



================================================
FILE: react/src/components/theme/ThemeButton.tsx
================================================
import { Button } from '@/components/ui/button'
import { useTheme } from '@/hooks/use-theme'
import { MoonIcon, SunIcon } from 'lucide-react'

const ThemeButton: React.FC = () => {
  const { setTheme, theme } = useTheme()

  return (
    <Button
      size={'sm'}
      variant={'ghost'}
      onClick={() => setTheme(theme === 'dark' ? 'light' : 'dark')}
    >
      {theme === 'dark' ? <SunIcon size={30} /> : <MoonIcon size={30} />}
    </Button>
  )
}

export default ThemeButton



================================================
FILE: react/src/components/theme/ThemeProvider.tsx
================================================
import { Theme, ThemeProviderContext } from '@/contexts/theme'
import { useEffect, useState } from 'react'

type ThemeProviderProps = {
  children: React.ReactNode
  defaultTheme?: Theme
  storageKey?: string
}

export function ThemeProvider({
  children,
  defaultTheme = 'system',
  storageKey = 'vite-ui-theme',
  ...props
}: ThemeProviderProps) {
  const [theme, setTheme] = useState<Theme>(
    () => (localStorage.getItem(storageKey) as Theme) || defaultTheme
  )

  useEffect(() => {
    const root = window.document.documentElement

    root.classList.remove('light', 'dark')

    if (theme === 'system') {
      const systemTheme = window.matchMedia('(prefers-color-scheme: dark)')
        .matches
        ? 'dark'
        : 'light'

      root.classList.add(systemTheme)
      return
    }

    root.classList.add(theme)
  }, [theme])

  const value = {
    theme,
    setTheme: (theme: Theme) => {
      localStorage.setItem(storageKey, theme)
      setTheme(theme)
    },
  }

  return (
    <ThemeProviderContext.Provider {...props} value={value}>
      {children}
    </ThemeProviderContext.Provider>
  )
}



================================================
FILE: react/src/components/ui/avatar.tsx
================================================
import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"
import { cn } from "@/lib/utils"

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full",
      className
    )}
    {...props}
  />
))
Avatar.displayName = AvatarPrimitive.Root.displayName

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn("aspect-square h-full w-full", className)}
    {...props}
  />
))
AvatarImage.displayName = AvatarPrimitive.Image.displayName

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      "flex h-full w-full items-center justify-center rounded-full bg-muted",
      className
    )}
    {...props}
  />
))
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName

export { Avatar, AvatarImage, AvatarFallback }



================================================
FILE: react/src/components/ui/badge.tsx
================================================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center justify-center rounded-md border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90",
        destructive:
          "border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

function Badge({
  className,
  variant,
  asChild = false,
  ...props
}: React.ComponentProps<"span"> &
  VariantProps<typeof badgeVariants> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "span"

  return (
    <Comp
      data-slot="badge"
      className={cn(badgeVariants({ variant }), className)}
      {...props}
    />
  )
}

export { Badge, badgeVariants }



================================================
FILE: react/src/components/ui/button.tsx
================================================
import { Slot } from '@radix-ui/react-slot'
import { cva, type VariantProps } from 'class-variance-authority'
import * as React from 'react'

import { cn } from '@/lib/utils'

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive select-none",
  {
    variants: {
      variant: {
        default:
          'bg-primary text-primary-foreground shadow-xs hover:bg-primary/90',
        destructive:
          'bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60',
        outline:
          'border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50',
        secondary:
          'bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80',
        ghost:
          'hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50',
        link: 'text-primary underline-offset-4 hover:underline',
      },
      size: {
        default: 'h-9 px-4 py-2 has-[>svg]:px-3',
        xs: 'h-6 rounded-md gap-1 p-1.5 has-[>svg]:px-1.5',
        sm: 'h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5',
        lg: 'h-10 rounded-md px-6 has-[>svg]:px-4',
        icon: 'size-9',
      },
    },
    defaultVariants: {
      variant: 'default',
      size: 'default',
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<'button'> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : 'button'

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      style={{
        cursor: 'pointer',
      }}
      {...props}
    />
  )
}

export { Button, buttonVariants }



================================================
FILE: react/src/components/ui/card.tsx
================================================
import * as React from "react"

import { cn } from "@/lib/utils"

function Card({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card"
      className={cn(
        "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
        className
      )}
      {...props}
    />
  )
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-header"
      className={cn(
        "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
        className
      )}
      {...props}
    />
  )
}

function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-title"
      className={cn("leading-none font-semibold", className)}
      {...props}
    />
  )
}

function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function CardAction({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-action"
      className={cn(
        "col-start-2 row-span-2 row-start-1 self-start justify-self-end",
        className
      )}
      {...props}
    />
  )
}

function CardContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-content"
      className={cn("px-6", className)}
      {...props}
    />
  )
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-footer"
      className={cn("flex items-center px-6 [.border-t]:pt-6", className)}
      {...props}
    />
  )
}

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
}



================================================
FILE: react/src/components/ui/checkbox.tsx
================================================
import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { CheckIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Checkbox({
  className,
  ...props
}: React.ComponentProps<typeof CheckboxPrimitive.Root>) {
  return (
    <CheckboxPrimitive.Root
      data-slot="checkbox"
      className={cn(
        "peer border-input dark:bg-input/30 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground dark:data-[state=checked]:bg-primary data-[state=checked]:border-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive size-4 shrink-0 rounded-[4px] border shadow-xs transition-shadow outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <CheckboxPrimitive.Indicator
        data-slot="checkbox-indicator"
        className="flex items-center justify-center text-current transition-none"
      >
        <CheckIcon className="size-3.5" />
      </CheckboxPrimitive.Indicator>
    </CheckboxPrimitive.Root>
  )
}

export { Checkbox }



================================================
FILE: react/src/components/ui/combobox.tsx
================================================
import * as React from "react"
import { ChevronDownIcon, CheckIcon } from "lucide-react"
import { cn } from "@/lib/utils"
import { Input } from "./input"
import { Button } from "./button"

interface ComboboxOption {
  value: string
  label: string
  data?: unknown
}

interface ComboboxProps {
  value: string
  onChange: (value: string) => void
  onDataChange?: (data: unknown) => void
  options: ComboboxOption[]
  placeholder?: string
  className?: string
  id?: string
}

export function Combobox({
  value,
  onChange,
  onDataChange,
  options,
  placeholder,
  className,
  id,
}: ComboboxProps) {
  const [isOpen, setIsOpen] = React.useState(false)
  const [inputValue, setInputValue] = React.useState(value)
  const containerRef = React.useRef<HTMLDivElement>(null)

  // Update input value when external value changes
  React.useEffect(() => {
    setInputValue(value)
  }, [value])

  // Handle input change
  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newValue = e.target.value
    setInputValue(newValue)
    onChange(newValue)
    setIsOpen(true)
  }

  // Handle option selection
  const handleOptionSelect = (option: ComboboxOption) => {
    setInputValue(option.value)
    onChange(option.value)
    if (option.data && onDataChange) {
      onDataChange(option.data)
    }
    setIsOpen(false)
  }

  // Filter options based on input
  const filteredOptions = options.filter(option =>
    option.label.toLowerCase().includes(inputValue.toLowerCase()) ||
    option.value.toLowerCase().includes(inputValue.toLowerCase())
  )

  // Handle click outside
  React.useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (containerRef.current && !containerRef.current.contains(event.target as Node)) {
        setIsOpen(false)
      }
    }

    document.addEventListener('mousedown', handleClickOutside)
    return () => {
      document.removeEventListener('mousedown', handleClickOutside)
    }
  }, [])

  return (
    <div ref={containerRef} className={cn("relative", className)}>
      <div className="relative">
        <Input
          id={id}
          value={inputValue}
          onChange={handleInputChange}
          onFocus={() => setIsOpen(true)}
          placeholder={placeholder}
          className="pr-10"
        />
        <Button
          type="button"
          variant="ghost"
          size="sm"
          className="absolute right-0 top-0 h-full px-3 py-2 hover:bg-transparent"
          onClick={() => setIsOpen(!isOpen)}
        >
          <ChevronDownIcon
            className={cn(
              "h-4 w-4 transition-transform duration-200",
              isOpen && "rotate-180"
            )}
          />
        </Button>
      </div>

      {isOpen && filteredOptions.length > 0 && (
        <div className="absolute top-full left-0 right-0 z-50 mt-1 max-h-60 overflow-auto rounded-md border bg-popover shadow-md">
          <div className="p-1">
            {filteredOptions.map((option) => (
              <div
                key={option.value}
                className={cn(
                  "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none hover:bg-accent hover:text-accent-foreground",
                  value === option.value && "bg-accent text-accent-foreground"
                )}
                onClick={() => handleOptionSelect(option)}
              >
                <span className="flex-1">{option.label}</span>
                {value === option.value && (
                  <CheckIcon className="h-4 w-4" />
                )}
              </div>
            ))}
          </div>
        </div>
      )}
    </div>
  )
}



================================================
FILE: react/src/components/ui/context-menu.tsx
================================================
import * as React from "react"
import * as ContextMenuPrimitive from "@radix-ui/react-context-menu"
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function ContextMenu({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Root>) {
  return <ContextMenuPrimitive.Root data-slot="context-menu" {...props} />
}

function ContextMenuTrigger({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Trigger>) {
  return (
    <ContextMenuPrimitive.Trigger data-slot="context-menu-trigger" {...props} />
  )
}

function ContextMenuGroup({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Group>) {
  return (
    <ContextMenuPrimitive.Group data-slot="context-menu-group" {...props} />
  )
}

function ContextMenuPortal({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Portal>) {
  return (
    <ContextMenuPrimitive.Portal data-slot="context-menu-portal" {...props} />
  )
}

function ContextMenuSub({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Sub>) {
  return <ContextMenuPrimitive.Sub data-slot="context-menu-sub" {...props} />
}

function ContextMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.RadioGroup>) {
  return (
    <ContextMenuPrimitive.RadioGroup
      data-slot="context-menu-radio-group"
      {...props}
    />
  )
}

function ContextMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.SubTrigger> & {
  inset?: boolean
}) {
  return (
    <ContextMenuPrimitive.SubTrigger
      data-slot="context-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto" />
    </ContextMenuPrimitive.SubTrigger>
  )
}

function ContextMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.SubContent>) {
  return (
    <ContextMenuPrimitive.SubContent
      data-slot="context-menu-sub-content"
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-context-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg",
        className
      )}
      {...props}
    />
  )
}

function ContextMenuContent({
  className,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Content>) {
  return (
    <ContextMenuPrimitive.Portal>
      <ContextMenuPrimitive.Content
        data-slot="context-menu-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-context-menu-content-available-height) min-w-[8rem] origin-(--radix-context-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",
          className
        )}
        {...props}
      />
    </ContextMenuPrimitive.Portal>
  )
}

function ContextMenuItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Item> & {
  inset?: boolean
  variant?: "default" | "destructive"
}) {
  return (
    <ContextMenuPrimitive.Item
      data-slot="context-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function ContextMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.CheckboxItem>) {
  return (
    <ContextMenuPrimitive.CheckboxItem
      data-slot="context-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <ContextMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </ContextMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </ContextMenuPrimitive.CheckboxItem>
  )
}

function ContextMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.RadioItem>) {
  return (
    <ContextMenuPrimitive.RadioItem
      data-slot="context-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <ContextMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </ContextMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </ContextMenuPrimitive.RadioItem>
  )
}

function ContextMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Label> & {
  inset?: boolean
}) {
  return (
    <ContextMenuPrimitive.Label
      data-slot="context-menu-label"
      data-inset={inset}
      className={cn(
        "text-foreground px-2 py-1.5 text-sm font-medium data-[inset]:pl-8",
        className
      )}
      {...props}
    />
  )
}

function ContextMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Separator>) {
  return (
    <ContextMenuPrimitive.Separator
      data-slot="context-menu-separator"
      className={cn("bg-border -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function ContextMenuShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="context-menu-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}

export {
  ContextMenu,
  ContextMenuTrigger,
  ContextMenuContent,
  ContextMenuItem,
  ContextMenuCheckboxItem,
  ContextMenuRadioItem,
  ContextMenuLabel,
  ContextMenuSeparator,
  ContextMenuShortcut,
  ContextMenuGroup,
  ContextMenuPortal,
  ContextMenuSub,
  ContextMenuSubContent,
  ContextMenuSubTrigger,
  ContextMenuRadioGroup,
}



================================================
FILE: react/src/components/ui/dialog.tsx
================================================
import * as DialogPrimitive from '@radix-ui/react-dialog'
import { X } from 'lucide-react'
import * as React from 'react'

import { cn } from '@/lib/utils'

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      'fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0',
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        'fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 sm:rounded-lg',
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-md p-1 opacity-70 ring-offset-background transition-all hover:opacity-100 hover:bg-accent hover:text-accent-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none cursor-pointer">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      'flex flex-col space-y-1.5 text-center sm:text-left select-none',
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = 'DialogHeader'

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      'flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2',
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = 'DialogFooter'

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      'text-lg font-semibold leading-none tracking-tight select-none',
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn('text-sm text-muted-foreground select-none', className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
}



================================================
FILE: react/src/components/ui/dropdown-menu.tsx
================================================
import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function DropdownMenu({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Root>) {
  return <DropdownMenuPrimitive.Root data-slot="dropdown-menu" {...props} />
}

function DropdownMenuPortal({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Portal>) {
  return (
    <DropdownMenuPrimitive.Portal data-slot="dropdown-menu-portal" {...props} />
  )
}

function DropdownMenuTrigger({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger>) {
  return (
    <DropdownMenuPrimitive.Trigger
      data-slot="dropdown-menu-trigger"
      {...props}
    />
  )
}

function DropdownMenuContent({
  className,
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Content>) {
  return (
    <DropdownMenuPrimitive.Portal>
      <DropdownMenuPrimitive.Content
        data-slot="dropdown-menu-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",
          className
        )}
        {...props}
      />
    </DropdownMenuPrimitive.Portal>
  )
}

function DropdownMenuGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Group>) {
  return (
    <DropdownMenuPrimitive.Group data-slot="dropdown-menu-group" {...props} />
  )
}

function DropdownMenuItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & {
  inset?: boolean
  variant?: "default" | "destructive"
}) {
  return (
    <DropdownMenuPrimitive.Item
      data-slot="dropdown-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.CheckboxItem>) {
  return (
    <DropdownMenuPrimitive.CheckboxItem
      data-slot="dropdown-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.CheckboxItem>
  )
}

function DropdownMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioGroup>) {
  return (
    <DropdownMenuPrimitive.RadioGroup
      data-slot="dropdown-menu-radio-group"
      {...props}
    />
  )
}

function DropdownMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioItem>) {
  return (
    <DropdownMenuPrimitive.RadioItem
      data-slot="dropdown-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.RadioItem>
  )
}

function DropdownMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Label> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.Label
      data-slot="dropdown-menu-label"
      data-inset={inset}
      className={cn(
        "px-2 py-1.5 text-sm font-medium data-[inset]:pl-8",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Separator>) {
  return (
    <DropdownMenuPrimitive.Separator
      data-slot="dropdown-menu-separator"
      className={cn("bg-border -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function DropdownMenuShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="dropdown-menu-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSub({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Sub>) {
  return <DropdownMenuPrimitive.Sub data-slot="dropdown-menu-sub" {...props} />
}

function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubTrigger> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.SubTrigger
      data-slot="dropdown-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto size-4" />
    </DropdownMenuPrimitive.SubTrigger>
  )
}

function DropdownMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubContent>) {
  return (
    <DropdownMenuPrimitive.SubContent
      data-slot="dropdown-menu-sub-content"
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg",
        className
      )}
      {...props}
    />
  )
}

export {
  DropdownMenu,
  DropdownMenuPortal,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuLabel,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubTrigger,
  DropdownMenuSubContent,
}



================================================
FILE: react/src/components/ui/hotkey.tsx
================================================
import { cn } from '@/lib/utils'
import { useTheme } from 'next-themes'
import React, { useEffect, useState } from 'react'

interface HotkeyProps {
  keys: string[]
  modifier?: boolean
  isBackgroundDark?: boolean
}

export const Hotkey: React.FC<HotkeyProps> = ({
  keys,
  modifier = false,
  isBackgroundDark = false,
}) => {
  const { theme } = useTheme()

  const isMac = window.navigator.userAgent.includes('Macintosh')
  const modifierText = isMac ? 'âŒ˜' : 'âŒƒ'
  const displayKeys = modifier ? [modifierText, ...keys] : keys

  const isDarkTheme = theme === 'dark'

  const bgGradient = isDarkTheme
    ? 'bg-gradient-to-bl from-transparent via-transparent to-background/20'
    : 'bg-gradient-to-bl from-transparent via-transparent to-white/20'

  return (
    <span
      className={cn(
        'inline-flex gap-[2px]',
        isBackgroundDark ? 'text-background' : 'text-foreground'
      )}
    >
      {displayKeys.map((key, index) => (
        <kbd
          key={index}
          suppressHydrationWarning
          className={cn(
            'inline-flex items-center justify-center rounded border border-border font-sans text-[10px] font-medium h-4 w-4',
            index === 0 ? 'ml-2' : 'ml-[1px]',
            bgGradient,
            'bg-[length:100%_130%] bg-[0_100%]'
          )}
        >
          {key}
        </kbd>
      ))}
    </span>
  )
}



================================================
FILE: react/src/components/ui/input.tsx
================================================
import * as React from "react"

import { cn } from "@/lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }



================================================
FILE: react/src/components/ui/label.tsx
================================================
import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"

import { cn } from "@/lib/utils"

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props}
    />
  )
}

export { Label }



================================================
FILE: react/src/components/ui/popover.tsx
================================================
import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "@/lib/utils"

function Popover({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Root>) {
  return <PopoverPrimitive.Root data-slot="popover" {...props} />
}

function PopoverTrigger({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Trigger>) {
  return <PopoverPrimitive.Trigger data-slot="popover-trigger" {...props} />
}

function PopoverContent({
  className,
  align = "center",
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Content>) {
  return (
    <PopoverPrimitive.Portal>
      <PopoverPrimitive.Content
        data-slot="popover-content"
        align={align}
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-72 origin-(--radix-popover-content-transform-origin) rounded-md border p-4 shadow-md outline-hidden",
          className
        )}
        {...props}
      />
    </PopoverPrimitive.Portal>
  )
}

function PopoverAnchor({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Anchor>) {
  return <PopoverPrimitive.Anchor data-slot="popover-anchor" {...props} />
}

export { Popover, PopoverTrigger, PopoverContent, PopoverAnchor }



================================================
FILE: react/src/components/ui/progress.tsx
================================================
import * as React from "react"
import { cn } from "@/lib/utils"

const Progress = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & {
    value?: number
  }
>(({ className, value, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "relative h-2 w-full overflow-hidden rounded-full bg-secondary",
      className
    )}
    {...props}
  >
    <div
      className="h-full w-full flex-1 bg-primary transition-all"
      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
    />
  </div>
))
Progress.displayName = "Progress"

export { Progress }



================================================
FILE: react/src/components/ui/resizable.tsx
================================================
import * as React from "react"
import { GripVerticalIcon } from "lucide-react"
import * as ResizablePrimitive from "react-resizable-panels"

import { cn } from "@/lib/utils"

function ResizablePanelGroup({
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelGroup>) {
  return (
    <ResizablePrimitive.PanelGroup
      data-slot="resizable-panel-group"
      className={cn(
        "flex h-full w-full data-[panel-group-direction=vertical]:flex-col",
        className
      )}
      {...props}
    />
  )
}

function ResizablePanel({
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.Panel>) {
  return <ResizablePrimitive.Panel data-slot="resizable-panel" {...props} />
}

function ResizableHandle({
  withHandle,
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelResizeHandle> & {
  withHandle?: boolean
}) {
  return (
    <ResizablePrimitive.PanelResizeHandle
      data-slot="resizable-handle"
      className={cn(
        "bg-border focus-visible:ring-ring relative flex w-px items-center justify-center after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:ring-1 focus-visible:ring-offset-1 focus-visible:outline-hidden data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:translate-x-0 data-[panel-group-direction=vertical]:after:-translate-y-1/2 [&[data-panel-group-direction=vertical]>div]:rotate-90",
        className
      )}
      {...props}
    >
      {withHandle && (
        <div className="bg-border z-10 flex h-4 w-3 items-center justify-center rounded-xs border">
          <GripVerticalIcon className="size-2.5" />
        </div>
      )}
    </ResizablePrimitive.PanelResizeHandle>
  )
}

export { ResizablePanelGroup, ResizablePanel, ResizableHandle }



================================================
FILE: react/src/components/ui/scroll-area.tsx
================================================
import * as ScrollAreaPrimitive from '@radix-ui/react-scroll-area'
import * as React from 'react'

import { cn } from '@/lib/utils'

type ScrollAreaProps = React.ComponentProps<typeof ScrollAreaPrimitive.Root> & {
  viewportRef?: React.RefObject<HTMLDivElement | null>
}

function ScrollArea({
  className,
  children,
  viewportRef,
  ...props
}: ScrollAreaProps) {
  return (
    <ScrollAreaPrimitive.Root
      data-slot="scroll-area"
      className={cn('relative', className)}
      {...props}
    >
      <ScrollAreaPrimitive.Viewport
        data-slot="scroll-area-viewport"
        className="focus-visible:ring-ring/50 size-full rounded-[inherit] transition-[color,box-shadow] outline-none focus-visible:ring-[3px] focus-visible:outline-1"
        ref={viewportRef}
      >
        {children}
      </ScrollAreaPrimitive.Viewport>
      <ScrollBar />
      <ScrollAreaPrimitive.Corner />
    </ScrollAreaPrimitive.Root>
  )
}

function ScrollBar({
  className,
  orientation = 'vertical',
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>) {
  return (
    <ScrollAreaPrimitive.ScrollAreaScrollbar
      data-slot="scroll-area-scrollbar"
      orientation={orientation}
      className={cn(
        'flex touch-none p-px transition-colors select-none',
        orientation === 'vertical' &&
          'h-full w-2.5 border-l border-l-transparent',
        orientation === 'horizontal' &&
          'h-2.5 flex-col border-t border-t-transparent',
        className
      )}
      {...props}
    >
      <ScrollAreaPrimitive.ScrollAreaThumb
        data-slot="scroll-area-thumb"
        className="bg-border relative flex-1 rounded-full"
      />
    </ScrollAreaPrimitive.ScrollAreaScrollbar>
  )
}

export { ScrollArea, ScrollBar }



================================================
FILE: react/src/components/ui/select.tsx
================================================
import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Select({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />
}

function SelectGroup({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />
}

function SelectValue({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />
}

function SelectTrigger({
  className,
  size = "default",
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger> & {
  size?: "sm" | "default"
}) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      data-size={size}
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  )
}

function SelectContent({
  className,
  children,
  position = "popper",
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md",
          position === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className
        )}
        position={position}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn(
            "p-1",
            position === "popper" &&
              "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  )
}

function SelectLabel({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Label>) {
  return (
    <SelectPrimitive.Label
      data-slot="select-label"
      className={cn("text-muted-foreground px-2 py-1.5 text-xs", className)}
      {...props}
    />
  )
}

function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className
      )}
      {...props}
    >
      <span className="absolute right-2 flex size-3.5 items-center justify-center">
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  )
}

function SelectSeparator({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function SelectScrollUpButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
    <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  )
}

function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
    <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  )
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
}



================================================
FILE: react/src/components/ui/separator.tsx
================================================
"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

function Separator({
  className,
  orientation = "horizontal",
  decorative = true,
  ...props
}: React.ComponentProps<typeof SeparatorPrimitive.Root>) {
  return (
    <SeparatorPrimitive.Root
      data-slot="separator-root"
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px",
        className
      )}
      {...props}
    />
  )
}

export { Separator }



================================================
FILE: react/src/components/ui/sheet.tsx
================================================
import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Sheet({ ...props }: React.ComponentProps<typeof SheetPrimitive.Root>) {
  return <SheetPrimitive.Root data-slot="sheet" {...props} />
}

function SheetTrigger({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Trigger>) {
  return <SheetPrimitive.Trigger data-slot="sheet-trigger" {...props} />
}

function SheetClose({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Close>) {
  return <SheetPrimitive.Close data-slot="sheet-close" {...props} />
}

function SheetPortal({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Portal>) {
  return <SheetPrimitive.Portal data-slot="sheet-portal" {...props} />
}

function SheetOverlay({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Overlay>) {
  return (
    <SheetPrimitive.Overlay
      data-slot="sheet-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function SheetContent({
  className,
  children,
  side = "right",
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Content> & {
  side?: "top" | "right" | "bottom" | "left"
}) {
  return (
    <SheetPortal>
      <SheetOverlay />
      <SheetPrimitive.Content
        data-slot="sheet-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out fixed z-50 flex flex-col gap-4 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
          side === "right" &&
            "data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right inset-y-0 right-0 h-full w-3/4 border-l sm:max-w-sm",
          side === "left" &&
            "data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left inset-y-0 left-0 h-full w-3/4 border-r sm:max-w-sm",
          side === "top" &&
            "data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top inset-x-0 top-0 h-auto border-b",
          side === "bottom" &&
            "data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom inset-x-0 bottom-0 h-auto border-t",
          className
        )}
        {...props}
      >
        {children}
        <SheetPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-secondary absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none">
          <XIcon className="size-4" />
          <span className="sr-only">Close</span>
        </SheetPrimitive.Close>
      </SheetPrimitive.Content>
    </SheetPortal>
  )
}

function SheetHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sheet-header"
      className={cn("flex flex-col gap-1.5 p-4", className)}
      {...props}
    />
  )
}

function SheetFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sheet-footer"
      className={cn("mt-auto flex flex-col gap-2 p-4", className)}
      {...props}
    />
  )
}

function SheetTitle({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Title>) {
  return (
    <SheetPrimitive.Title
      data-slot="sheet-title"
      className={cn("text-foreground font-semibold", className)}
      {...props}
    />
  )
}

function SheetDescription({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Description>) {
  return (
    <SheetPrimitive.Description
      data-slot="sheet-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Sheet,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}



================================================
FILE: react/src/components/ui/shiny-text.tsx
================================================
import '@/assets/style/shiny-text.css'

type ShinyTextProps = {
  text: string
  disabled?: boolean
  speed?: number
  className?: string
}

const ShinyText: React.FC<ShinyTextProps> = ({
  text,
  disabled = false,
  speed = 5,
  className = '',
}) => {
  const animationDuration = `${speed}s`

  return (
    <div
      className={`shiny-text ${disabled ? 'disabled' : ''} ${className}`}
      style={{
        position: 'relative',
        display: 'inline-block',
        animationDuration,
      }}
    >
      {text}
      {!disabled && (
        <span
          className="shine"
          aria-hidden="true"
          style={{ animationDuration }}
        >
          {text}
        </span>
      )}
    </div>
  )
}

export default ShinyText



================================================
FILE: react/src/components/ui/sidebar.tsx
================================================
import { Slot } from '@radix-ui/react-slot'
import { VariantProps, cva } from 'class-variance-authority'
import { PanelLeftIcon } from 'lucide-react'
import * as React from 'react'

import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Separator } from '@/components/ui/separator'
import {
  Sheet,
  SheetContent,
  SheetDescription,
  SheetHeader,
  SheetTitle,
} from '@/components/ui/sheet'
import { Skeleton } from '@/components/ui/skeleton'
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from '@/components/ui/tooltip'
import { useIsMobile } from '@/hooks/use-mobile'
import { cn } from '@/lib/utils'

const SIDEBAR_COOKIE_NAME = 'sidebar_state'
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7
const SIDEBAR_WIDTH = '12rem'
const SIDEBAR_WIDTH_MOBILE = '18rem'
const SIDEBAR_WIDTH_ICON = '3rem'
const SIDEBAR_KEYBOARD_SHORTCUT = 'b'

type SidebarContextProps = {
  state: 'expanded' | 'collapsed'
  open: boolean
  setOpen: (open: boolean) => void
  openMobile: boolean
  setOpenMobile: (open: boolean) => void
  isMobile: boolean
  toggleSidebar: () => void
}

const SidebarContext = React.createContext<SidebarContextProps | null>(null)

function useSidebar() {
  const context = React.useContext(SidebarContext)
  if (!context) {
    throw new Error('useSidebar must be used within a SidebarProvider.')
  }

  return context
}

function SidebarProvider({
  defaultOpen = true,
  open: openProp,
  onOpenChange: setOpenProp,
  className,
  style,
  children,
  ...props
}: React.ComponentProps<'div'> & {
  defaultOpen?: boolean
  open?: boolean
  onOpenChange?: (open: boolean) => void
}) {
  const isMobile = useIsMobile()
  const [openMobile, setOpenMobile] = React.useState(false)

  // This is the internal state of the sidebar.
  // We use openProp and setOpenProp for control from outside the component.
  const [_open, _setOpen] = React.useState(defaultOpen)
  const open = openProp ?? _open
  const setOpen = React.useCallback(
    (value: boolean | ((value: boolean) => boolean)) => {
      const openState = typeof value === 'function' ? value(open) : value
      if (setOpenProp) {
        setOpenProp(openState)
      } else {
        _setOpen(openState)
      }

      // This sets the cookie to keep the sidebar state.
      document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`
    },
    [setOpenProp, open]
  )

  // Helper to toggle the sidebar.
  const toggleSidebar = React.useCallback(() => {
    return isMobile ? setOpenMobile((open) => !open) : setOpen((open) => !open)
  }, [isMobile, setOpen, setOpenMobile])

  // Adds a keyboard shortcut to toggle the sidebar.
  React.useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (
        event.key === SIDEBAR_KEYBOARD_SHORTCUT &&
        (event.metaKey || event.ctrlKey)
      ) {
        event.preventDefault()
        toggleSidebar()
      }
    }

    window.addEventListener('keydown', handleKeyDown)
    return () => window.removeEventListener('keydown', handleKeyDown)
  }, [toggleSidebar])

  // We add a state so that we can do data-state="expanded" or "collapsed".
  // This makes it easier to style the sidebar with Tailwind classes.
  const state = open ? 'expanded' : 'collapsed'

  const contextValue = React.useMemo<SidebarContextProps>(
    () => ({
      state,
      open,
      setOpen,
      isMobile,
      openMobile,
      setOpenMobile,
      toggleSidebar,
    }),
    [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar]
  )

  return (
    <SidebarContext.Provider value={contextValue}>
      <TooltipProvider delayDuration={0}>
        <div
          data-slot="sidebar-wrapper"
          style={
            {
              '--sidebar-width': SIDEBAR_WIDTH,
              '--sidebar-width-icon': SIDEBAR_WIDTH_ICON,
              ...style,
            } as React.CSSProperties
          }
          className={cn(
            'group/sidebar-wrapper has-data-[variant=inset]:bg-sidebar flex min-h-svh w-full',
            className
          )}
          {...props}
        >
          {children}
        </div>
      </TooltipProvider>
    </SidebarContext.Provider>
  )
}

function Sidebar({
  side = 'left',
  variant = 'sidebar',
  collapsible = 'offcanvas',
  className,
  children,
  ...props
}: React.ComponentProps<'div'> & {
  side?: 'left' | 'right'
  variant?: 'sidebar' | 'floating' | 'inset'
  collapsible?: 'offcanvas' | 'icon' | 'none'
}) {
  const { isMobile, state, openMobile, setOpenMobile } = useSidebar()

  if (collapsible === 'none') {
    return (
      <div
        data-slot="sidebar"
        className={cn(
          'bg-sidebar text-sidebar-foreground flex h-full w-(--sidebar-width) flex-col',
          className
        )}
        {...props}
      >
        {children}
      </div>
    )
  }

  if (isMobile) {
    return (
      <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>
        <SheetContent
          data-sidebar="sidebar"
          data-slot="sidebar"
          data-mobile="true"
          className="bg-sidebar text-sidebar-foreground w-(--sidebar-width) p-0 [&>button]:hidden"
          style={
            {
              '--sidebar-width': SIDEBAR_WIDTH_MOBILE,
            } as React.CSSProperties
          }
          side={side}
        >
          <SheetHeader className="sr-only">
            <SheetTitle>Sidebar</SheetTitle>
            <SheetDescription>Displays the mobile sidebar.</SheetDescription>
          </SheetHeader>
          <div className="flex h-full w-full flex-col">{children}</div>
        </SheetContent>
      </Sheet>
    )
  }

  return (
    <div
      className="group peer text-sidebar-foreground hidden md:block"
      data-state={state}
      data-collapsible={state === 'collapsed' ? collapsible : ''}
      data-variant={variant}
      data-side={side}
      data-slot="sidebar"
    >
      {/* This is what handles the sidebar gap on desktop */}
      <div
        data-slot="sidebar-gap"
        className={cn(
          'relative w-(--sidebar-width) bg-transparent transition-[width] duration-200 ease-linear',
          'group-data-[collapsible=offcanvas]:w-0',
          'group-data-[side=right]:rotate-180',
          variant === 'floating' || variant === 'inset'
            ? 'group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4)))]'
            : 'group-data-[collapsible=icon]:w-(--sidebar-width-icon)'
        )}
      />
      <div
        data-slot="sidebar-container"
        className={cn(
          'fixed inset-y-0 z-10 hidden h-svh w-(--sidebar-width) transition-[left,right,width] duration-200 ease-linear md:flex',
          side === 'left'
            ? 'left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]'
            : 'right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]',
          // Adjust the padding for floating and inset variants.
          variant === 'floating' || variant === 'inset'
            ? 'p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4))+2px)]'
            : 'group-data-[collapsible=icon]:w-(--sidebar-width-icon) group-data-[side=left]:border-r group-data-[side=right]:border-l',
          className
        )}
        {...props}
      >
        <div
          data-sidebar="sidebar"
          data-slot="sidebar-inner"
          className="bg-sidebar group-data-[variant=floating]:border-sidebar-border flex h-full w-full flex-col group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:shadow-sm"
        >
          {children}
        </div>
      </div>
    </div>
  )
}

function SidebarTrigger({
  className,
  onClick,
  ...props
}: React.ComponentProps<typeof Button>) {
  const { toggleSidebar } = useSidebar()

  return (
    <Button
      data-sidebar="trigger"
      data-slot="sidebar-trigger"
      variant="ghost"
      size="icon"
      className={cn('size-7', className)}
      onClick={(event) => {
        onClick?.(event)
        toggleSidebar()
      }}
      {...props}
    >
      <PanelLeftIcon />
      <span className="sr-only">Toggle Sidebar</span>
    </Button>
  )
}

function SidebarRail({ className, ...props }: React.ComponentProps<'button'>) {
  const { toggleSidebar } = useSidebar()

  return (
    <button
      data-sidebar="rail"
      data-slot="sidebar-rail"
      aria-label="Toggle Sidebar"
      tabIndex={-1}
      onClick={toggleSidebar}
      title="Toggle Sidebar"
      className={cn(
        'hover:after:bg-sidebar-border absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear group-data-[side=left]:-right-4 group-data-[side=right]:left-0 after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] sm:flex',
        'in-data-[side=left]:cursor-w-resize in-data-[side=right]:cursor-e-resize',
        '[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize',
        'hover:group-data-[collapsible=offcanvas]:bg-sidebar group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full',
        '[[data-side=left][data-collapsible=offcanvas]_&]:-right-2',
        '[[data-side=right][data-collapsible=offcanvas]_&]:-left-2',
        className
      )}
      {...props}
    />
  )
}

function SidebarInset({ className, ...props }: React.ComponentProps<'main'>) {
  return (
    <main
      data-slot="sidebar-inset"
      className={cn(
        'bg-background relative flex w-full flex-1 flex-col',
        'md:peer-data-[variant=inset]:m-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow-sm md:peer-data-[variant=inset]:peer-data-[state=collapsed]:ml-2',
        className
      )}
      {...props}
    />
  )
}

function SidebarInput({
  className,
  ...props
}: React.ComponentProps<typeof Input>) {
  return (
    <Input
      data-slot="sidebar-input"
      data-sidebar="input"
      className={cn('bg-background h-8 w-full shadow-none', className)}
      {...props}
    />
  )
}

function SidebarHeader({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="sidebar-header"
      data-sidebar="header"
      className={cn('flex flex-col gap-2 p-2', className)}
      {...props}
    />
  )
}

function SidebarFooter({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="sidebar-footer"
      data-sidebar="footer"
      className={cn('flex flex-col gap-2 p-2', className)}
      {...props}
    />
  )
}

function SidebarSeparator({
  className,
  ...props
}: React.ComponentProps<typeof Separator>) {
  return (
    <Separator
      data-slot="sidebar-separator"
      data-sidebar="separator"
      className={cn('bg-sidebar-border mx-2 w-auto', className)}
      {...props}
    />
  )
}

function SidebarContent({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="sidebar-content"
      data-sidebar="content"
      className={cn(
        'flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden',
        className
      )}
      {...props}
    />
  )
}

function SidebarGroup({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="sidebar-group"
      data-sidebar="group"
      className={cn('relative flex w-full min-w-0 flex-col p-2', className)}
      {...props}
    />
  )
}

function SidebarGroupLabel({
  className,
  asChild = false,
  ...props
}: React.ComponentProps<'div'> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : 'div'

  return (
    <Comp
      data-slot="sidebar-group-label"
      data-sidebar="group-label"
      className={cn(
        'text-sidebar-foreground/70 ring-sidebar-ring flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium outline-hidden transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0',
        'group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0',
        className
      )}
      {...props}
    />
  )
}

function SidebarGroupAction({
  className,
  asChild = false,
  ...props
}: React.ComponentProps<'button'> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : 'button'

  return (
    <Comp
      data-slot="sidebar-group-action"
      data-sidebar="group-action"
      className={cn(
        'text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground absolute top-3.5 right-3 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0',
        // Increases the hit area of the button on mobile.
        'after:absolute after:-inset-2 md:after:hidden',
        'group-data-[collapsible=icon]:hidden',
        className
      )}
      {...props}
    />
  )
}

function SidebarGroupContent({
  className,
  ...props
}: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="sidebar-group-content"
      data-sidebar="group-content"
      className={cn('w-full text-sm', className)}
      {...props}
    />
  )
}

function SidebarMenu({ className, ...props }: React.ComponentProps<'ul'>) {
  return (
    <ul
      data-slot="sidebar-menu"
      data-sidebar="menu"
      className={cn('flex w-full min-w-0 flex-col gap-1', className)}
      {...props}
    />
  )
}

function SidebarMenuItem({ className, ...props }: React.ComponentProps<'li'>) {
  return (
    <li
      data-slot="sidebar-menu-item"
      data-sidebar="menu-item"
      className={cn('group/menu-item relative', className)}
      {...props}
    />
  )
}

const sidebarMenuButtonVariants = cva(
  'peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-hidden ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0',
  {
    variants: {
      variant: {
        default: 'hover:bg-sidebar-accent hover:text-sidebar-accent-foreground',
        outline:
          'bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]',
      },
      size: {
        default: 'h-8 text-sm',
        sm: 'h-7 text-xs',
        lg: 'h-12 text-sm group-data-[collapsible=icon]:p-0!',
      },
    },
    defaultVariants: {
      variant: 'default',
      size: 'default',
    },
  }
)

function SidebarMenuButton({
  asChild = false,
  isActive = false,
  variant = 'default',
  size = 'default',
  tooltip,
  className,
  ...props
}: React.ComponentProps<'button'> & {
  asChild?: boolean
  isActive?: boolean
  tooltip?: string | React.ComponentProps<typeof TooltipContent>
} & VariantProps<typeof sidebarMenuButtonVariants>) {
  const Comp = asChild ? Slot : 'button'
  const { isMobile, state } = useSidebar()

  const button = (
    <Comp
      data-slot="sidebar-menu-button"
      data-sidebar="menu-button"
      data-size={size}
      data-active={isActive}
      className={cn(sidebarMenuButtonVariants({ variant, size }), className)}
      {...props}
    />
  )

  if (!tooltip) {
    return button
  }

  if (typeof tooltip === 'string') {
    tooltip = {
      children: tooltip,
    }
  }

  return (
    <Tooltip>
      <TooltipTrigger asChild>{button}</TooltipTrigger>
      <TooltipContent
        side="right"
        align="center"
        hidden={state !== 'collapsed' || isMobile}
        {...tooltip}
      />
    </Tooltip>
  )
}

function SidebarMenuAction({
  className,
  asChild = false,
  showOnHover = false,
  ...props
}: React.ComponentProps<'button'> & {
  asChild?: boolean
  showOnHover?: boolean
}) {
  const Comp = asChild ? Slot : 'button'

  return (
    <Comp
      data-slot="sidebar-menu-action"
      data-sidebar="menu-action"
      className={cn(
        'text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground peer-hover/menu-button:text-sidebar-accent-foreground absolute top-1.5 right-1 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0',
        // Increases the hit area of the button on mobile.
        'after:absolute after:-inset-2 md:after:hidden',
        'peer-data-[size=sm]/menu-button:top-1',
        'peer-data-[size=default]/menu-button:top-1.5',
        'peer-data-[size=lg]/menu-button:top-2.5',
        'group-data-[collapsible=icon]:hidden',
        showOnHover &&
          'peer-data-[active=true]/menu-button:text-sidebar-accent-foreground group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 md:opacity-0',
        className
      )}
      {...props}
    />
  )
}

function SidebarMenuBadge({
  className,
  ...props
}: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="sidebar-menu-badge"
      data-sidebar="menu-badge"
      className={cn(
        'text-sidebar-foreground pointer-events-none absolute right-1 flex h-5 min-w-5 items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums select-none',
        'peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground',
        'peer-data-[size=sm]/menu-button:top-1',
        'peer-data-[size=default]/menu-button:top-1.5',
        'peer-data-[size=lg]/menu-button:top-2.5',
        'group-data-[collapsible=icon]:hidden',
        className
      )}
      {...props}
    />
  )
}

function SidebarMenuSkeleton({
  className,
  showIcon = false,
  ...props
}: React.ComponentProps<'div'> & {
  showIcon?: boolean
}) {
  // Random width between 50 to 90%.
  const width = React.useMemo(() => {
    return `${Math.floor(Math.random() * 40) + 50}%`
  }, [])

  return (
    <div
      data-slot="sidebar-menu-skeleton"
      data-sidebar="menu-skeleton"
      className={cn('flex h-8 items-center gap-2 rounded-md px-2', className)}
      {...props}
    >
      {showIcon && (
        <Skeleton
          className="size-4 rounded-md"
          data-sidebar="menu-skeleton-icon"
        />
      )}
      <Skeleton
        className="h-4 max-w-(--skeleton-width) flex-1"
        data-sidebar="menu-skeleton-text"
        style={
          {
            '--skeleton-width': width,
          } as React.CSSProperties
        }
      />
    </div>
  )
}

function SidebarMenuSub({ className, ...props }: React.ComponentProps<'ul'>) {
  return (
    <ul
      data-slot="sidebar-menu-sub"
      data-sidebar="menu-sub"
      className={cn(
        'border-sidebar-border mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l px-2.5 py-0.5',
        'group-data-[collapsible=icon]:hidden',
        className
      )}
      {...props}
    />
  )
}

function SidebarMenuSubItem({
  className,
  ...props
}: React.ComponentProps<'li'>) {
  return (
    <li
      data-slot="sidebar-menu-sub-item"
      data-sidebar="menu-sub-item"
      className={cn('group/menu-sub-item relative', className)}
      {...props}
    />
  )
}

function SidebarMenuSubButton({
  asChild = false,
  size = 'md',
  isActive = false,
  className,
  ...props
}: React.ComponentProps<'a'> & {
  asChild?: boolean
  size?: 'sm' | 'md'
  isActive?: boolean
}) {
  const Comp = asChild ? Slot : 'a'

  return (
    <Comp
      data-slot="sidebar-menu-sub-button"
      data-sidebar="menu-sub-button"
      data-size={size}
      data-active={isActive}
      className={cn(
        'text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground active:bg-sidebar-accent active:text-sidebar-accent-foreground [&>svg]:text-sidebar-accent-foreground flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 outline-hidden focus-visible:ring-2 disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0',
        'data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground',
        size === 'sm' && 'text-xs',
        size === 'md' && 'text-sm',
        'group-data-[collapsible=icon]:hidden',
        className
      )}
      {...props}
    />
  )
}

export {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarInput,
  SidebarInset,
  SidebarMenu,
  SidebarMenuAction,
  SidebarMenuBadge,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarMenuSkeleton,
  SidebarMenuSub,
  SidebarMenuSubButton,
  SidebarMenuSubItem,
  SidebarProvider,
  SidebarRail,
  SidebarSeparator,
  SidebarTrigger,
  useSidebar,
}



================================================
FILE: react/src/components/ui/skeleton.tsx
================================================
import { cn } from "@/lib/utils"

function Skeleton({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="skeleton"
      className={cn("bg-accent animate-pulse rounded-md", className)}
      {...props}
    />
  )
}

export { Skeleton }



================================================
FILE: react/src/components/ui/slider.tsx
================================================
import React, { useRef, useState, useCallback } from 'react'
import { cn } from '@/lib/utils'

interface SliderProps {
    value: number[]
    onValueChange: (value: number[]) => void
    max?: number
    min?: number
    step?: number
    disabled?: boolean
    className?: string
}

export const Slider: React.FC<SliderProps> = ({
    value,
    onValueChange,
    max = 100,
    min = 0,
    step = 1,
    disabled = false,
    className,
}) => {
    const sliderRef = useRef<HTMLDivElement>(null)
    const [isDragging, setIsDragging] = useState(false)

    const getValueFromPosition = useCallback((clientX: number) => {
        if (!sliderRef.current) return value[0]

        const rect = sliderRef.current.getBoundingClientRect()
        const percentage = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width))
        const rawValue = min + percentage * (max - min)

        // Snap to step
        const steppedValue = Math.round(rawValue / step) * step
        return Math.max(min, Math.min(max, steppedValue))
    }, [min, max, step, value])

    const handleMouseDown = useCallback((e: React.MouseEvent) => {
        if (disabled) return

        setIsDragging(true)
        const newValue = getValueFromPosition(e.clientX)
        onValueChange([newValue])
    }, [disabled, getValueFromPosition, onValueChange])

    const handleMouseMove = useCallback((e: MouseEvent) => {
        if (!isDragging || disabled) return

        const newValue = getValueFromPosition(e.clientX)
        onValueChange([newValue])
    }, [isDragging, disabled, getValueFromPosition, onValueChange])

    const handleMouseUp = useCallback(() => {
        setIsDragging(false)
    }, [])

    React.useEffect(() => {
        if (isDragging) {
            document.addEventListener('mousemove', handleMouseMove)
            document.addEventListener('mouseup', handleMouseUp)

            return () => {
                document.removeEventListener('mousemove', handleMouseMove)
                document.removeEventListener('mouseup', handleMouseUp)
            }
        }
    }, [isDragging, handleMouseMove, handleMouseUp])

    const percentage = ((value[0] - min) / (max - min)) * 100

    return (
        <div
            ref={sliderRef}
            className={cn(
                'relative flex items-center w-full h-5 cursor-pointer',
                disabled && 'cursor-not-allowed opacity-50',
                className
            )}
            onMouseDown={handleMouseDown}
        >
            {/* Track */}
            <div className="relative w-full h-1 bg-gray-300 rounded-full">
                {/* Filled track */}
                <div
                    className="absolute h-full bg-blue-500 rounded-full"
                    style={{ width: `${percentage}%` }}
                />
                {/* Thumb */}
                <div
                    className="absolute w-4 h-4 bg-white border-2 border-blue-500 rounded-full shadow-md transform -translate-y-1/2 -translate-x-1/2 transition-transform hover:scale-110"
                    style={{ left: `${percentage}%`, top: '50%' }}
                />
            </div>
        </div>
    )
}


================================================
FILE: react/src/components/ui/sonner.tsx
================================================
import { useTheme } from "next-themes"
import { Toaster as Sonner, ToasterProps } from "sonner"

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme()

  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      style={
        {
          "--normal-bg": "var(--popover)",
          "--normal-text": "var(--popover-foreground)",
          "--normal-border": "var(--border)",
        } as React.CSSProperties
      }
      {...props}
    />
  )
}

export { Toaster }



================================================
FILE: react/src/components/ui/Spinner.tsx
================================================
import { Loader2 } from 'lucide-react'

export default function Spinner({ size = 6 }: { size?: number }) {
  return (
    <div className="flex items-center justify-center">
      <Loader2 className={`animate-spin h-${size} w-${size} text-gray-600`} />
    </div>
  )
}



================================================
FILE: react/src/components/ui/switch.tsx
================================================
'use client'

import * as React from 'react'
import * as SwitchPrimitives from '@radix-ui/react-switch'

import { cn } from '@/lib/utils'

interface SwitchProps
  extends React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root> {
  size?: 'sm' | 'default'
}

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  SwitchProps
>(({ className, size = 'default', ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      'peer inline-flex shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input',
      {
        'h-6 w-11': size === 'default',
        'h-4 w-8': size === 'sm',
      },
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        'pointer-events-none block rounded-full bg-background shadow-lg ring-0 transition-transform',
        {
          'h-5 w-5 data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0':
            size === 'default',
          'h-3 w-3 data-[state=checked]:translate-x-4 data-[state=unchecked]:translate-x-0':
            size === 'sm',
        }
      )}
    />
  </SwitchPrimitives.Root>
))
Switch.displayName = SwitchPrimitives.Root.displayName

export { Switch }



================================================
FILE: react/src/components/ui/textarea.tsx
================================================
import * as React from "react"

import { cn } from "@/lib/utils"

function Textarea({ className, ...props }: React.ComponentProps<"textarea">) {
  return (
    <textarea
      data-slot="textarea"
      className={cn(
        "border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      {...props}
    />
  )
}

export { Textarea }



================================================
FILE: react/src/components/ui/tooltip.tsx
================================================
"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

function TooltipProvider({
  delayDuration = 0,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Provider>) {
  return (
    <TooltipPrimitive.Provider
      data-slot="tooltip-provider"
      delayDuration={delayDuration}
      {...props}
    />
  )
}

function Tooltip({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Root>) {
  return (
    <TooltipProvider>
      <TooltipPrimitive.Root data-slot="tooltip" {...props} />
    </TooltipProvider>
  )
}

function TooltipTrigger({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Trigger>) {
  return <TooltipPrimitive.Trigger data-slot="tooltip-trigger" {...props} />
}

function TooltipContent({
  className,
  sideOffset = 0,
  children,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Content>) {
  return (
    <TooltipPrimitive.Portal>
      <TooltipPrimitive.Content
        data-slot="tooltip-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-primary text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-xs text-balance",
          className
        )}
        {...props}
      >
        {children}
        <TooltipPrimitive.Arrow className="bg-primary fill-primary z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px]" />
      </TooltipPrimitive.Content>
    </TooltipPrimitive.Portal>
  )
}

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }



================================================
FILE: react/src/components/ui/video-player.tsx
================================================
import React, { useRef, useState, useEffect } from 'react'
import { cn } from '@/lib/utils'
import { Button } from '@/components/ui/button'
import { Play, Pause, Volume2, VolumeX, Maximize2, RotateCcw } from 'lucide-react'

interface VideoPlayerProps {
    src: string
    poster?: string
    autoPlay?: boolean
    loop?: boolean
    muted?: boolean
    controls?: boolean
    className?: string
    width?: number
    height?: number
    onEnded?: () => void
    onTimeUpdate?: (currentTime: number, duration: number) => void
}

export const VideoPlayer: React.FC<VideoPlayerProps> = ({
    src,
    poster,
    autoPlay = false,
    loop = false,
    muted = false,
    controls = true,
    className,
    width,
    height,
    onEnded,
    onTimeUpdate,
}) => {
    const videoRef = useRef<HTMLVideoElement>(null)
    const [isPlaying, setIsPlaying] = useState(false)
    const [currentTime, setCurrentTime] = useState(0)
    const [duration, setDuration] = useState(0)
    const [volume, setVolume] = useState(1)
    const [isMuted, setIsMuted] = useState(muted)
    const [isFullscreen, setIsFullscreen] = useState(false)

    useEffect(() => {
        const video = videoRef.current
        if (!video) return

        const handleTimeUpdate = () => {
            const current = video.currentTime
            const total = video.duration
            setCurrentTime(current)
            onTimeUpdate?.(current, total)
        }

        const handleLoadedMetadata = () => {
            setDuration(video.duration)
        }

        const handleEnded = () => {
            setIsPlaying(false)
            onEnded?.()
        }

        const handlePlay = () => setIsPlaying(true)
        const handlePause = () => setIsPlaying(false)

        video.addEventListener('timeupdate', handleTimeUpdate)
        video.addEventListener('loadedmetadata', handleLoadedMetadata)
        video.addEventListener('ended', handleEnded)
        video.addEventListener('play', handlePlay)
        video.addEventListener('pause', handlePause)

        return () => {
            video.removeEventListener('timeupdate', handleTimeUpdate)
            video.removeEventListener('loadedmetadata', handleLoadedMetadata)
            video.removeEventListener('ended', handleEnded)
            video.removeEventListener('play', handlePlay)
            video.removeEventListener('pause', handlePause)
        }
    }, [onTimeUpdate, onEnded])

    const togglePlay = () => {
        const video = videoRef.current
        if (!video) return

        if (isPlaying) {
            video.pause()
        } else {
            video.play()
        }
    }

    const handleSeek = (values: number[]) => {
        const video = videoRef.current
        if (!video) return

        const newTime = values[0]
        video.currentTime = newTime
        setCurrentTime(newTime)
    }

    const handleVolumeChange = (values: number[]) => {
        const video = videoRef.current
        if (!video) return

        const newVolume = values[0]
        video.volume = newVolume
        setVolume(newVolume)
        setIsMuted(newVolume === 0)
    }

    const toggleMute = () => {
        const video = videoRef.current
        if (!video) return

        if (isMuted) {
            video.volume = volume
            setIsMuted(false)
        } else {
            video.volume = 0
            setIsMuted(true)
        }
    }

    const toggleFullscreen = () => {
        const video = videoRef.current
        if (!video) return

        if (!isFullscreen) {
            if (video.requestFullscreen) {
                video.requestFullscreen()
            }
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen()
            }
        }
        setIsFullscreen(!isFullscreen)
    }

    const restart = () => {
        const video = videoRef.current
        if (!video) return

        video.currentTime = 0
        setCurrentTime(0)
    }

    const formatTime = (time: number) => {
        const minutes = Math.floor(time / 60)
        const seconds = Math.floor(time % 60)
        return `${minutes}:${seconds.toString().padStart(2, '0')}`
    }

    return (
        <div className={cn('relative group bg-black overflow-hidden', className)}>
            <video
                ref={videoRef}
                src={src}
                poster={poster}
                autoPlay={autoPlay}
                loop={loop}
                muted={muted}
                className="w-full h-full object-cover"
                style={{ width, height }}
                playsInline
            />

            {controls && (
                <div className="absolute inset-0 bg-gradient-to-t from-black/50 to-transparent opacity-0 group-hover:opacity-100 transition-opacity duration-200">
                    {/* Play/Pause overlay */}
                    <div className="absolute inset-0 flex items-center justify-center">
                        <Button
                            variant="ghost"
                            size="lg"
                            onClick={togglePlay}
                            className="bg-black/20 hover:bg-black/40 text-white rounded-full p-4"
                        >
                            {isPlaying ? (
                                <Pause className="w-8 h-8" />
                            ) : (
                                <Play className="w-8 h-8 ml-1" />
                            )}
                        </Button>
                    </div>

                    {/* Controls bar */}
                    <div className="absolute bottom-0 left-0 right-0 p-4 space-y-2">

                        {/* Control buttons */}
                        <div className="flex items-center justify-between text-white">
                            <div className="flex items-center space-x-2">
                                <Button
                                    variant="ghost"
                                    size="sm"
                                    onClick={togglePlay}
                                    className="text-white hover:bg-white/20"
                                >
                                    {isPlaying ? <Pause className="w-4 h-4" /> : <Play className="w-4 h-4" />}
                                </Button>

                                <Button
                                    variant="ghost"
                                    size="sm"
                                    onClick={restart}
                                    className="text-white hover:bg-white/20"
                                >
                                    <RotateCcw className="w-4 h-4" />
                                </Button>

                                <div className="flex items-center space-x-2">
                                    <Button
                                        variant="ghost"
                                        size="sm"
                                        onClick={toggleMute}
                                        className="text-white hover:bg-white/20"
                                    >
                                        {isMuted ? <VolumeX className="w-4 h-4" /> : <Volume2 className="w-4 h-4" />}
                                    </Button>
                                </div>

                                <span className="text-sm">
                                    {formatTime(currentTime)} / {formatTime(duration)}
                                </span>
                            </div>

                            <Button
                                variant="ghost"
                                size="sm"
                                onClick={toggleFullscreen}
                                className="text-white hover:bg-white/20"
                            >
                                <Maximize2 className="w-4 h-4" />
                            </Button>
                        </div>
                    </div>
                </div>
            )}
        </div>
    )
}

// Lightweight video preview component for thumbnails
export const VideoPreview: React.FC<{
    src: string
    poster?: string
    className?: string
    width?: number
    height?: number
    onClick?: () => void
}> = ({ src, poster, className, width, height, onClick }) => {
    return (
        <div
            className={cn(
                'relative bg-black overflow-hidden cursor-pointer group hover:ring-2 hover:ring-blue-500',
                className
            )}
            onClick={onClick}
        >
            <video
                src={src}
                poster={poster}
                className="w-full h-full object-cover"
                style={{ width, height }}
                muted
                preload="metadata"
            />
            <div className="absolute inset-0 bg-black/20 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity">
                <Play className="w-8 h-8 text-white" />
            </div>
            <div className="absolute bottom-2 right-2 bg-black/60 text-white text-xs px-2 py-1 rounded">
                Video
            </div>
        </div>
    )
}



================================================
FILE: react/src/contexts/AuthContext.tsx
================================================
import { createContext, useContext, useEffect, useState } from 'react'
import { toast } from 'sonner'
import { AuthStatus, getAuthStatus } from '../api/auth'

interface AuthContextType {
  authStatus: AuthStatus
  isLoading: boolean
  refreshAuth: () => Promise<void>
}

const AuthContext = createContext<AuthContextType | undefined>(undefined)

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [authStatus, setAuthStatus] = useState<AuthStatus>({
    status: 'logged_out',
    is_logged_in: false,
  })
  const [isLoading, setIsLoading] = useState(true)

  const refreshAuth = async () => {
    try {
      setIsLoading(true)
      const status = await getAuthStatus()

      // Check if token expired based on the status returned by getAuthStatus
      if (status.tokenExpired) {
        toast.error('ç™»å½•çŠ¶æ€å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•', {
          duration: 5000,
        })
      }

      setAuthStatus(status)
    } catch (error) {
      console.error('è·å–è®¤è¯çŠ¶æ€å¤±è´¥:', error)
    } finally {
      setIsLoading(false)
    }
  }

  useEffect(() => {
    refreshAuth()
  }, [])

  return (
    <AuthContext.Provider value={{ authStatus, isLoading, refreshAuth }}>
      {children}
    </AuthContext.Provider>
  )
}

export function useAuth() {
  const context = useContext(AuthContext)

  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider')
  }

  return context
}



================================================
FILE: react/src/contexts/canvas.tsx
================================================
import useCanvasStore from '@/stores/canvas'
import { createContext, useContext } from 'react'

export const CanvasContext = createContext<{
  canvasStore: typeof useCanvasStore
} | null>(null)

export const CanvasProvider = ({ children }: { children: React.ReactNode }) => {
  return (
    <CanvasContext.Provider value={{ canvasStore: useCanvasStore }}>
      {children}
    </CanvasContext.Provider>
  )
}

export const useCanvas = () => {
  const context = useContext(CanvasContext)
  if (!context) {
    throw new Error('useCanvas must be used within a CanvasProvider')
  }
  return context.canvasStore()
}



================================================
FILE: react/src/contexts/configs.tsx
================================================
[Binary file]


================================================
FILE: react/src/contexts/socket.tsx
================================================
import { SocketIOManager } from '@/lib/socket'
import React, { createContext, useContext, useEffect, useRef, useState } from 'react'
import { useTranslation } from 'react-i18next'

interface SocketContextType {
  connected: boolean
  socketId?: string
  connecting: boolean
  error?: string
  socketManager: SocketIOManager | null
}

const SocketContext = createContext<SocketContextType>({
  connected: false,
  connecting: false,
  socketManager: null,
})

interface SocketProviderProps {
  children: React.ReactNode
}

export const SocketProvider: React.FC<SocketProviderProps> = ({ children }) => {
  const { t } = useTranslation()
  const [connected, setConnected] = useState(false)
  const [socketId, setSocketId] = useState<string>()
  const [connecting, setConnecting] = useState(true)
  const [error, setError] = useState<string>()

  // Use useRef to maintain socket manager instance across re-renders
  const socketManagerRef = useRef<SocketIOManager | null>(null)

  useEffect(() => {
    let mounted = true

    const initializeSocket = async () => {
      try {
        setConnecting(true)
        setError(undefined)

        // Create socket manager instance if not exists
        if (!socketManagerRef.current) {
          socketManagerRef.current = new SocketIOManager({
            serverUrl: process.env.NODE_ENV === 'development'
              ? 'http://localhost:57988'
              : window.location.origin,
            autoConnect: false
          })
        }

        const socketManager = socketManagerRef.current
        await socketManager.connect()

        if (mounted) {
          setConnected(true)
          setSocketId(socketManager.getSocketId())
          setConnecting(false)
          console.log('ğŸš€ Socket.IO initialized successfully')

          const socket = socketManager.getSocket()
          if (socket) {
            const handleConnect = () => {
              if (mounted) {
                setConnected(true)
                setSocketId(socketManager.getSocketId())
                setConnecting(false)
                setError(undefined)
              }
            }

            const handleDisconnect = () => {
              if (mounted) {
                setConnected(false)
                setSocketId(undefined)
                setConnecting(false)
              }
            }

            const handleConnectError = (error: Error) => {
              if (mounted) {
                setError(error.message || 'âŒ Socket.IO Connection Error')
                setConnected(false)
                setConnecting(false)
              }
            }

            socket.on('connect', handleConnect)
            socket.on('disconnect', handleDisconnect)
            socket.on('connect_error', handleConnectError)

            return () => {
              socket.off('connect', handleConnect)
              socket.off('disconnect', handleDisconnect)
              socket.off('connect_error', handleConnectError)
            }
          }
        }
      } catch (err) {
        if (mounted) {
          setError(err instanceof Error ? err.message : 'Unknown error')
          setConnected(false)
          setConnecting(false)
          console.error('âŒ Failed to initialize Socket.IO:', err)
        }
      }
    }

    initializeSocket()

    return () => {
      mounted = false
      // Clean up socket connection when component unmounts
      if (socketManagerRef.current) {
        socketManagerRef.current.disconnect()
        socketManagerRef.current = null
      }
    }
  }, [])

  useEffect(() => {
    console.log('ğŸ“¢ Notification manager initialized')
  }, [])

  const value: SocketContextType = {
    connected,
    socketId,
    connecting,
    error,
    socketManager: socketManagerRef.current,
  }

  return (
    <SocketContext.Provider value={value}>
      {children}

      {error && (
        <div className="fixed top-4 right-4 z-50 bg-red-500 text-white px-3 py-2 rounded-md shadow-lg">
          {socketManagerRef.current?.isMaxReconnectAttemptsReached()
            ? t('socket.maxRetriesReached')
            : t('socket.connectionError', {
              current: socketManagerRef.current?.getReconnectAttempts() || 0,
              max: 5,
              error
            })}
        </div>
      )}
    </SocketContext.Provider>
  )
}



================================================
FILE: react/src/contexts/theme.tsx
================================================
import { createContext } from 'react'

export type Theme = 'dark' | 'light' | 'system'

export type ThemeProviderState = {
  theme: Theme
  setTheme: (theme: Theme) => void
}

const initialState: ThemeProviderState = {
  theme: 'system',
  setTheme: () => null,
}

export const ThemeProviderContext =
  createContext<ThemeProviderState>(initialState)



================================================
FILE: react/src/examples/exampleMessages.ts
================================================
export const exampleMessages = [
  {
    role: "user",
    content: [
      {
        type: "text",
        text: "Can u post this marketing article [AI Marketing Agent Copilot ğŸ‘‹](https://www.reddit.com/r/AI_Agents/comments/1kj8nbu/bulk_auto_ai_video_creator/) to Medium.com",
      },
    ],
  },
  {
    role: "assistant",
    content: [
      {
        type: "text",
        text: "Sure! I'm happy to help you post your marketing post to Medium. I'll open the browser to do it.",
      },
    ],
  },
  // {
  //   role: "user",
  //   content: [
  //     {
  //       type: "text",
  //       text: "Can u search in reddit for relevant posts where people are asking about such product like my AI Marketing Agent Copilot and list 10 posts to best mention my product there!\n\n\n",
  //     },
  //   ],
  // },
  {
    role: "assistant",
    tool_calls: [
      {
        type: "function",
        id: "call_haZDmILRV90fD40lVNkkYIa6",
        function: {
          name: "browser_navigate",
          arguments: '{"url":"https://www.medium.com"}',
        },
      },
    ],
  },
  {
    role: "tool",
    tool_call_id: "call_haZDmILRV90fD40lVNkkYIa6",
    content:
      '- Ran Playwright code:\n```js\n// Navigate to https://www.reddit.com\nawait page.goto(\'https://www.reddit.com\');\n```\n\n- Page URL: https://www.reddit.com/\n- Page Title: Reddit - The heart of the internet\n- Page Snapshot\n```yaml\n- link "Skip to main content" [ref=s1e8]:\n  - /url: "#main-content"\n  - generic [ref=s1e10]: Skip to main content\n- generic [ref=s1e22]: Reddit - The heart of the internet\n- banner [ref=s1e45]:\n  - navigation [ref=s1e46]:\n    - link "Home" [ref=s1e59]:\n      - /url: /\n      - img [ref=s1e61]\n      - img [ref=s1e85]\n    - search [ref=s1e101]:\n      - textbox [ref=s1e107]\n    - link "Advertise on Reddit" [ref=s1e119]:\n      - /url: https://ads.reddit.com/register?utm_source=web3x_consumer&utm_name=nav_cta\n      - img [ref=s1e122]\n      - generic [ref=s1e124]:\n        - generic: Advertise on Reddit\n    - button "Open chat" [ref=s1e136]:\n      - img [ref=s1e139]\n      - generic [ref=s1e141]:\n        - generic: Open chat\n    - link "Create post" [ref=s1e152]:\n      - /url: /submit\n      - img [ref=s1e155]\n      - generic [ref=s1e157]: Create\n      - generic [ref=s1e158]:\n        - generic: Create post\n    - generic [ref=s1e161]:\n      - link "Open inbox" [ref=s1e167]:\n        - /url: /notifications\n        - img [ref=s1e170]\n        - generic [ref=s1e172]:\n          - generic: Open inbox\n      - generic:\n        - generic:\n          - generic:\n            - generic: "2"\n    - button "Expand user menu" [ref=s1e188]:\n      - img [ref=s1e199]\n      - generic [ref=s1e205]:\n        - generic: Expand user menu\n- link "Skip to Navigation" [ref=s1e255]:\n  - /url: "#left-sidebar-container"\n- link "Skip to Right Sidebar" [ref=s1e256]:\n  - /url: "#right-sidebar-container"\n- main [ref=s1e260]:\n  - \'button "Sort by: Best" [ref=s1e279]\':\n    - generic [ref=s1e281]: Best\n    - img [ref=s1e283]\n  - button "View:" [ref=s1e293]:\n    - img [ref=s1e296]\n    - img [ref=s1e299]\n  - separator [ref=s1e303]\n  - heading "Feed" [level=1] [ref=s1e327]\n  - article "Bulk Auto AI Video Creator" [ref=s1e330]:\n    - link "Bulk Auto AI Video Creator" [ref=s1e333]:\n      - /url: /r/AI_Agents/comments/1kj8nbu/bulk_auto_ai_video_creator/\n      - generic [ref=s1e334]:\n        - generic: Bulk Auto AI Video Creator\n    - link "r/AI_Agents icon r/AI_Agents" [ref=s1e344]:\n      - /url: /r/AI_Agents/\n      - img "r/AI_Agents icon" [ref=s1e348]\n      - generic [ref=s1e349]: r/AI_Agents\n    - generic [ref=s1e352]: â€¢\n    - time [ref=s1e354]: 37 min. ago\n    - button "Open user actions" [ref=s1e362]:\n      - img [ref=s1e365]\n    - generic [ref=s1e373]:\n      - heading "Bulk Auto AI Video Creator" [level=2] [ref=s1e374]:\n        - link "Bulk Auto AI Video Creator" [ref=s1e376]:\n          - /url: /r/AI_Agents/comments/1kj8nbu/bulk_auto_ai_video_creator/\n          - text: Bulk Auto AI Video Creator\n      - generic:\n        - link "So there are obviously tools where you can feed it pictures and videos and theyâ€™ll piece something together. I am looking for something where you give it access to your phones gallery and it just goes to town creating reels based on day, location, etc. Yes I know this sounds ultra lazy, but I have like 10k mediaâ€™s taken from my years of traveling. Only other option is to hire someone to go through my stuff and create, though that in itself would be invasive as personal info and non of rated stuff through my gallery lol. Would hope if there is a tool out there that they wouldnâ€™t store or steal your data but would have to do research once I found one. If no such auto AI tool, then whatâ€™s the best (in your opinion) for making videos from 5-10 medias you feed it?":\n          - /url: /r/AI_Agents/comments/1kj8nbu/bulk_auto_ai_video_creator/\n          - generic:\n            - generic:\n              - paragraph: So there are obviously tools where you can feed it pictures and\n                  videos and theyâ€™ll piece something together. I am looking for\n                  something where you give it access to your phones gallery and\n                  it just goes to town creating reels based on day, location,\n                  etc.\n              - paragraph: Yes I know this sounds ultra lazy, but I have like 10k mediaâ€™s taken\n                  from my years of traveling. Only other option is to hire\n                  someone to go through my stuff and create, though that in\n                  itself would be invasive as personal info and non of rated\n                  stuff through my gallery lol. Would hope if there is a tool\n                  out there that they wouldnâ€™t store or steal your data but\n                  would have to do research once I found one.\n              - paragraph: If no such auto AI tool, then whatâ€™s the best (in your opinion) for\n                  making videos from 5-10 medias you feed it?\n    - button "Upvote" [ref=s1e403]:\n      - img [ref=s1e405]\n      - generic [ref=s1e407]:\n        - generic: Upvote\n    - generic [ref=s1e410]: "2"\n    - button "Downvote" [ref=s1e411]:\n      - img [ref=s1e413]\n      - generic [ref=s1e415]:\n        - generic: Downvote\n    - link "0 Go to comments" [ref=s1e417]:\n      - /url: /r/AI_Agents/comments/1kj8nbu/bulk_auto_ai_video_creator/\n      - generic [ref=s1e421]: "0"\n      - generic [ref=s1e422]:\n        - generic: Go to comments\n    - button "Give award" [ref=s1e425]\n    - button "Share Share" [ref=s1e432]:\n      - generic [ref=s1e435]: Share\n      - generic [ref=s1e436]:\n        - generic: Share\n  - separator [ref=s1e449]\n  - \'link "Advertisement: Torn City - World\'\'s Largest Text-based RPG" [ref=s1e455]\':\n    - /url: https://alb.reddit.com/cr?za=c44-mTC9pCxhjKpl85zLDzK3VVUydx8p4t56VVKJEpIaTd2uFAvs0yAsFHm6phNU5o1EvBwKBt_f8gG0-HRCo9UrjjXvHNxG_9JlA01Sb00iaxLUAKeJ6rdxbh0H3gmk3yPMzYoltCSTaNE314-VNXbW-OnvHL3brFkVaOwDNCuqtAI8N2nbrGBbGO7xTPUpSwPvddrKxxrsJn3eoH5ycSkxaWAtdSrKVdzLrwxOV6xB9jUOa1ocf3zPktE7iSY_uV-dsSL6F24Yrd0OpmUZ5V9_7AKpc0Waoal1GYsPrH2Wya3Lx84VP5mDfU768chBPfHUOxaxmh4zzsNWvi2quzyi1OsH-PZc-rwU9K4Wx6RvDSGB4dXzzH3kFyCIHluOV95ckebF_c7xtDHipOBxY0f_1C5nJDcws_rputTcYce63tOSP-PFF_J7A9AwNC5ybHfzSdtIKHh9qCUk9AX1xX0aUsENwAMmjCGG_Z8HUwboIvFyRdshDujdf06UZ9jikPPt-bi8CRvC14pv9GktqGjcY5OpXSq6Yy3I8NcDvnCM8gfcfgcMtLTZ&zp=VlLzGiIXlDpO2ysFkNwyI9zxY6znhwXYkWVELnnTBgWak3rFHK99VHj_4IQO7o_GuD2MIiB0G2tZyV_lUIDpWV0GgGw16_gWN841hkSnFNcg-rZ-5A8k756HrVk8H4-t1nVqDsfXIf42xY1ndmoOk-U3mW04qsC2wCnw_H681qy9c8bE0Xn1SgmH5gEmIXukFQboJLBr-CWUcysf72MFK9cWsxhtTf3gJ9xjl_6loSsqqYnqv4IUXHLa6qfaMQvvXKl6WNRnWXzi9TtPtlQlBKyobLeyGNz95QkWsfiTx_2Njjc5GOpeFpC2uZQAo7l5xdWVWknfrRYyYanFGiApWqlmcB-AtOphrl1J7qpT8erVDYkZlueOgAiysACRPBmkN016-TQsDBL_AbUhtD-hgo5HU3CV1XhqlPPVw9tueU8yR2HEq5GtmNdnDAPV0sqNQKKOG33iMF6cfzTDXOwz9vypJDgXDA\n  - link "u/TORNRPG avatar u/TORNRPG" [ref=s1e464]:\n    - /url: /user/TORNRPG/\n    - img "u/TORNRPG avatar" [ref=s1e469]\n    - generic [ref=s1e470]: u/TORNRPG\n  - generic [ref=s1e471]: â€¢\n  - link "Promoted" [ref=s1e473]:\n    - /url: https://alb.reddit.com/cr?za=c44-mTC9pCxhjKpl85zLDzK3VVUydx8p4t56VVKJEpIaTd2uFAvs0yAsFHm6phNU5o1EvBwKBt_f8gG0-HRCo9UrjjXvHNxG_9JlA01Sb00iaxLUAKeJ6rdxbh0H3gmk3yPMzYoltCSTaNE314-VNXbW-OnvHL3brFkVaOwDNCuqtAI8N2nbrGBbGO7xTPUpSwPvddrKxxrsJn3eoH5ycSkxaWAtdSrKVdzLrwxOV6xB9jUOa1ocf3zPktE7iSY_uV-dsSL6F24Yrd0OpmUZ5V9_7AKpc0Waoal1GYsPrH2Wya3Lx84VP5mDfU768chBPfHUOxaxmh4zzsNWvi2quzyi1OsH-PZc-rwU9K4Wx6RvDSGB4dXzzH3kFyCIHluOV95ckebF_c7xtDHipOBxY0f_1C5nJDcws_rputTcYce63tOSP-PFF_J7A9AwNC5ybHfzSdtIKHh9qCUk9AX1xX0aUsENwAMmjCGG_Z8HUwboIvFyRdshDujdf06UZ9jikPPt-bi8CRvC14pv9GktqGjcY5OpXSq6Yy3I8NcDvnCM8gfcfgcMtLTZ&zp=VlLzGiIXlDpO2ysFkNwyI9zxY6znhwXYkWVELnnTBgWak3rFHK99VHj_4IQO7o_GuD2MIiB0G2tZyV_lUIDpWV0GgGw16_gWN841hkSnFNcg-rZ-5A8k756HrVk8H4-t1nVqDsfXIf42xY1ndmoOk-U3mW04qsC2wCnw_H681qy9c8bE0Xn1SgmH5gEmIXukFQboJLBr-CWUcysf72MFK9cWsxhtTf3gJ9xjl_6loSsqqYnqv4IUXHLa6qfaMQvvXKl6WNRnWXzi9TtPtlQlBKyobLeyGNz95QkWsfiTx_2Njjc5GOpeFpC2uZQAo7l5xdWVWknfrRYyYanFGiApWqlmcB-AtOphrl1J7qpT8erVDYkZlueOgAiysACRPBmkN016-TQsDBL_AbUhtD-hgo5HU3CV1XhqlPPVw9tueU8yR2HEq5GtmNdnDAPV0sqNQKKOG33iMF6cfzTDXOwz9vypJDgXDA\n    - generic [ref=s1e475]: Promoted\n  - link [ref=s1e477]:\n    - /url: https://alb.reddit.com/cr?za=c44-mTC9pCxhjKpl85zLDzK3VVUydx8p4t56VVKJEpIaTd2uFAvs0yAsFHm6phNU5o1EvBwKBt_f8gG0-HRCo9UrjjXvHNxG_9JlA01Sb00iaxLUAKeJ6rdxbh0H3gmk3yPMzYoltCSTaNE314-VNXbW-OnvHL3brFkVaOwDNCuqtAI8N2nbrGBbGO7xTPUpSwPvddrKxxrsJn3eoH5ycSkxaWAtdSrKVdzLrwxOV6xB9jUOa1ocf3zPktE7iSY_uV-dsSL6F24Yrd0OpmUZ5V9_7AKpc0Waoal1GYsPrH2Wya3Lx84VP5mDfU768chBPfHUOxaxmh4zzsNWvi2quzyi1OsH-PZc-rwU9K4Wx6RvDSGB4dXzzH3kFyCIHluOV95ckebF_c7xtDHipOBxY0f_1C5nJDcws_rputTcYce63tOSP-PFF_J7A9AwNC5ybHfzSdtIKHh9qCUk9AX1xX0aUsENwAMmjCGG_Z8HUwboIvFyRdshDujdf06UZ9jikPPt-bi8CRvC14pv9GktqGjcY5OpXSq6Yy3I8NcDvnCM8gfcfgcMtLTZ&zp=VlLzGiIXlDpO2ysFkNwyI9zxY6znhwXYkWVELnnTBgWak3rFHK99VHj_4IQO7o_GuD2MIiB0G2tZyV_lUIDpWV0GgGw16_gWN841hkSnFNcg-rZ-5A8k756HrVk8H4-t1nVqDsfXIf42xY1ndmoOk-U3mW04qsC2wCnw_H681qy9c8bE0Xn1SgmH5gEmIXukFQboJLBr-CWUcysf72MFK9cWsxhtTf3gJ9xjl_6loSsqqYnqv4IUXHLa6qfaMQvvXKl6WNRnWXzi9TtPtlQlBKyobLeyGNz95QkWsfiTx_2Njjc5GOpeFpC2uZQAo7l5xdWVWknfrRYyYanFGiApWqlmcB-AtOphrl1J7qpT8erVDYkZlueOgAiysACRPBmkN016-TQsDBL_AbUhtD-hgo5HU3CV1XhqlPPVw9tueU8yR2HEq5GtmNdnDAPV0sqNQKKOG33iMF6cfzTDXOwz9vypJDgXDA\n  - button "Open user actions" [ref=s1e485]:\n    - img [ref=s1e488]\n  - heading "Torn City - World\'s Largest Text-based RPG Free to Play â€” Be Anyone. Do Anything. Go Anywhere" [level=2] [ref=s1e496]:\n    - link "Torn City - World\'s Largest Text-based RPG" [ref=s1e500]:\n      - /url: https://alb.reddit.com/cr?za=c44-mTC9pCxhjKpl85zLDzK3VVUydx8p4t56VVKJEpIaTd2uFAvs0yAsFHm6phNU5o1EvBwKBt_f8gG0-HRCo9UrjjXvHNxG_9JlA01Sb00iaxLUAKeJ6rdxbh0H3gmk3yPMzYoltCSTaNE314-VNXbW-OnvHL3brFkVaOwDNCuqtAI8N2nbrGBbGO7xTPUpSwPvddrKxxrsJn3eoH5ycSkxaWAtdSrKVdzLrwxOV6xB9jUOa1ocf3zPktE7iSY_uV-dsSL6F24Yrd0OpmUZ5V9_7AKpc0Waoal1GYsPrH2Wya3Lx84VP5mDfU768chBPfHUOxaxmh4zzsNWvi2quzyi1OsH-PZc-rwU9K4Wx6RvDSGB4dXzzH3kFyCIHluOV95ckebF_c7xtDHipOBxY0f_1C5nJDcws_rputTcYce63tOSP-PFF_J7A9AwNC5ybHfzSdtIKHh9qCUk9AX1xX0aUsENwAMmjCGG_Z8HUwboIvFyRdshDujdf06UZ9jikPPt-bi8CRvC14pv9GktqGjcY5OpXSq6Yy3I8NcDvnCM8gfcfgcMtLTZ&zp=V...Content truncated to 8000 characters due to length limit',
  },
  {
    role: "tool",
    tool_call_id: "call_gQSenAJ1Cjfq7YraGb8JV8wJ",
    content:
      '- Ran Playwright code:\n```js\n// Fill "AI marketing tool" into "search box"\nawait page.getByLabel(\'\', { exact: true }).fill(\'AI marketing tool\');\n```\n\n- Page URL: https://www.reddit.com/\n- Page Title: Reddit - The heart of the internet\n- Page Snapshot\n```yaml\n- link "Skip to main content" [ref=s2e8]:\n  - /url: "#main-content"\n  - generic [ref=s2e10]: Skip to main content\n- generic [ref=s2e22]: Reddit - The heart of the internet\n- banner [ref=s2e45]:\n  - navigation [ref=s2e46]:\n    - link "Home" [ref=s2e59]:\n      - /url: /\n      - img [ref=s2e61]\n      - img [ref=s2e85]\n    - search [ref=s2e101]:\n      - textbox "Clear search" [ref=s2e107]: AI marketing tool\n      - button "Clear search" [ref=s2e110]:\n        - img [ref=s2e113]\n        - generic [ref=s2e115]:\n          - generic: Clear search\n    - menu [ref=s2e118]:\n      - menuitem "ai marketing tool" [ref=s2e122]:\n        - img [ref=s2e125]\n        - generic [ref=s2e130]: ai marketing tool\n      - menuitem "ai marketing tools" [ref=s2e137]:\n        - img [ref=s2e140]\n        - generic [ref=s2e144]:\n          - generic [ref=s2e145]: ai marketing tool\n          - text: s\n      - generic [ref=s2e149]: Communities\n      - menuitem "r/aimarketing 2.4K members" [ref=s2e153]:\n        - generic [ref=s2e161]: r/aimarketing\n        - generic [ref=s2e163]: 2.4K members\n      - menuitem "r/AIToolTracker 3.5K members" [ref=s2e167]:\n        - generic [ref=s2e175]: r/AIToolTracker\n        - generic [ref=s2e177]: 3.5K members\n      - menuitem "r/AI_tool 193 members" [ref=s2e181]:\n        - generic [ref=s2e189]: r/AI_tool\n        - generic [ref=s2e191]: 193 members\n      - menuitem "r/content_marketing 141K members" [ref=s2e195]:\n        - generic [ref=s2e203]: r/content_marketing\n        - generic [ref=s2e205]: 141K members\n      - menuitem "r/PopularAiTool 566 members" [ref=s2e209]:\n        - generic [ref=s2e217]: r/PopularAiTool\n        - generic [ref=s2e219]: 566 members\n    - link "Advertise on Reddit" [ref=s2e230]:\n      - /url: https://ads.reddit.com/register?utm_source=web3x_consumer&utm_name=nav_cta\n      - img [ref=s2e233]\n      - generic [ref=s2e235]:\n        - generic: Advertise on Reddit\n    - button "Open chat" [ref=s2e247]:\n      - img [ref=s2e250]\n      - generic [ref=s2e252]:\n        - generic: Open chat\n    - link "Create post" [ref=s2e263]:\n      - /url: /submit\n      - img [ref=s2e266]\n      - generic [ref=s2e268]: Create\n      - generic [ref=s2e269]:\n        - generic: Create post\n    - generic [ref=s2e272]:\n      - link "Open inbox" [ref=s2e278]:\n        - /url: /notifications\n        - img [ref=s2e281]\n        - generic [ref=s2e283]:\n          - generic: Open inbox\n      - generic:\n        - generic:\n          - generic:\n            - generic: "2"\n    - button "Expand user menu" [ref=s2e299]:\n      - img [ref=s2e310]\n      - generic [ref=s2e316]:\n        - generic: Expand user menu\n- link "Skip to Navigation" [ref=s2e366]:\n  - /url: "#left-sidebar-container"\n- link "Skip to Right Sidebar" [ref=s2e367]:\n  - /url: "#right-sidebar-container"\n- main [ref=s2e371]:\n  - \'button "Sort by: Best" [ref=s2e390]\':\n    - generic [ref=s2e392]: Best\n    - img [ref=s2e394]\n  - button "View:" [ref=s2e404]:\n    - img [ref=s2e407]\n    - img [ref=s2e410]\n  - separator [ref=s2e414]\n  - heading "Feed" [level=1] [ref=s2e438]\n  - article "Bulk Auto AI Video Creator" [ref=s2e441]:\n    - link "Bulk Auto AI Video Creator" [ref=s2e444]:\n      - /url: /r/AI_Agents/comments/1kj8nbu/bulk_auto_ai_video_creator/\n      - generic [ref=s2e445]:\n        - generic: Bulk Auto AI Video Creator\n    - link "r/AI_Agents icon r/AI_Agents" [ref=s2e455]:\n      - /url: /r/AI_Agents/\n      - img "r/AI_Agents icon" [ref=s2e459]\n      - generic [ref=s2e460]: r/AI_Agents\n    - generic [ref=s2e463]: â€¢\n    - time [ref=s2e465]: 37 min. ago\n    - button "Open user actions" [ref=s2e473]:\n      - img [ref=s2e476]\n    - generic [ref=s2e484]:\n      - heading "Bulk Auto AI Video Creator" [level=2] [ref=s2e485]:\n        - link "Bulk Auto AI Video Creator" [ref=s2e487]:\n          - /url: /r/AI_Agents/comments/1kj8nbu/bulk_auto_ai_video_creator/\n          - text: Bulk Auto AI Video Creator\n      - generic:\n        - link "So there are obviously tools where you can feed it pictures and videos and theyâ€™ll piece something together. I am looking for something where you give it access to your phones gallery and it just goes to town creating reels based on day, location, etc. Yes I know this sounds ultra lazy, but I have like 10k mediaâ€™s taken from my years of traveling. Only other option is to hire someone to go through my stuff and create, though that in itself would be invasive as personal info and non of rated stuff through my gallery lol. Would hope if there is a tool out there that they wouldnâ€™t store or steal your data but would have to do research once I found one. If no such auto AI tool, then whatâ€™s the best (in your opinion) for making videos from 5-10 medias you feed it?":\n          - /url: /r/AI_Agents/comments/1kj8nbu/bulk_auto_ai_video_creator/\n          - generic:\n            - generic:\n              - paragraph: So there are obviously tools where you can feed it pictures and\n                  videos and theyâ€™ll piece something together. I am looking for\n                  something where you give it access to your phones gallery and\n                  it just goes to town creating reels based on day, location,\n                  etc.\n              - paragraph: Yes I know this sounds ultra lazy, but I have like 10k mediaâ€™s taken\n                  from my years of traveling. Only other option is to hire\n                  someone to go through my stuff and create, though that in\n                  itself would be invasive as personal info and non of rated\n                  stuff through my gallery lol. Would hope if there is a tool\n                  out there that they wouldnâ€™t store or steal your data but\n                  would have to do research once I found one.\n              - paragraph: If no such auto AI tool, then whatâ€™s the best (in your opinion) for\n                  making videos from 5-10 medias you feed it?\n    - button "Upvote" [ref=s2e514]:\n      - img [ref=s2e516]\n      - generic [ref=s2e518]:\n        - generic: Upvote\n    - generic [ref=s2e521]: "2"\n    - button "Downvote" [ref=s2e522]:\n      - img [ref=s2e524]\n      - generic [ref=s2e526]:\n        - generic: Downvote\n    - link "0 Go to comments" [ref=s2e528]:\n      - /url: /r/AI_Agents/comments/1kj8nbu/bulk_auto_ai_video_creator/\n      - generic [ref=s2e532]: "0"\n      - generic [ref=s2e533]:\n        - generic: Go to comments\n    - button "Give award" [ref=s2e536]\n    - button "Share Share" [ref=s2e543]:\n      - generic [ref=s2e546]: Share\n      - generic [ref=s2e547]:\n        - generic: Share\n  - separator [ref=s2e560]\n  - \'link "Advertisement: Torn City - World\'\'s Largest Text-based RPG" [ref=s2e566]\':\n    - /url: https://alb.reddit.com/cr?za=c44-mTC9pCxhjKpl85zLDzK3VVUydx8p4t56VVKJEpIaTd2uFAvs0yAsFHm6phNU5o1EvBwKBt_f8gG0-HRCo9UrjjXvHNxG_9JlA01Sb00iaxLUAKeJ6rdxbh0H3gmk3yPMzYoltCSTaNE314-VNXbW-OnvHL3brFkVaOwDNCuqtAI8N2nbrGBbGO7xTPUpSwPvddrKxxrsJn3eoH5ycSkxaWAtdSrKVdzLrwxOV6xB9jUOa1ocf3zPktE7iSY_uV-dsSL6F24Yrd0OpmUZ5V9_7AKpc0Waoal1GYsPrH2Wya3Lx84VP5mDfU768chBPfHUOxaxmh4zzsNWvi2quzyi1OsH-PZc-rwU9K4Wx6RvDSGB4dXzzH3kFyCIHluOV95ckebF_c7xtDHipOBxY0f_1C5nJDcws_rputTcYce63tOSP-PFF_J7A9AwNC5ybHfzSdtIKHh9qCUk9AX1xX0aUsENwAMmjCGG_Z8HUwboIvFyRdshDujdf06UZ9jikPPt-bi8CRvC14pv9GktqGjcY5OpXSq6Yy3I8NcDvnCM8gfcfgcMtLTZ&zp=VlLzGiIXlDpO2ysFkNwyI9zxY6znhwXYkWVELnnTBgWak3rFHK99VHj_4IQO7o_GuD2MIiB0G2tZyV_lUIDpWV0GgGw16_gWN841hkSnFNcg-rZ-5A8k756HrVk8H4-t1nVqDsfXIf42xY1ndmoOk-U3mW04qsC2wCnw_H681qy9c8bE0Xn1SgmH5gEmIXukFQboJLBr-CWUcysf72MFK9cWsxhtTf3gJ9xjl_6loSsqqYnqv4IUXHLa6qfaMQvvXKl6WNRnWXzi9TtPtlQlBKyobLeyGNz95QkWsfiTx_2Njjc5GOpeFpC2uZQAo7l5xdWVWknfrRYyYanFGiApWqlmcB-AtOphrl1J7qpT8erVDYkZlueOgAiysACRPBmkN016-TQsDBL_AbUhtD-hgo5HU3CV1XhqlPPVw9tueU8yR2HEq5GtmNdnDAPV0sqNQKKOG33iMF6cfzTDXOwz9vypJDgXDA\n  - link "u/TORNRPG avatar u/TORNRPG" [ref=s2e575]:\n    - /url: /user/TORNRPG/\n    - img "u/TORNRPG avatar" [ref=s2e580]\n    - generic [ref=s2e581]: u/TORNRPG\n  - generic [ref=s2e582]: â€¢\n  - link "Promoted" [ref=s2e584]:\n    - /url: https://alb.reddit.com/cr?za=c44-mTC9pCxhjKpl85zLDzK3VVUydx8p4t56VVKJEpIaTd2uFAvs0yAsFHm6phNU5o1EvBwKBt_f8gG0-HRCo9UrjjXvHNxG_9JlA01Sb00iaxLUAKeJ6rdxbh0H3gmk3yPMzYoltCSTaNE314-VNXbW-OnvHL3brFkVaOwDNCuqtAI8N2nbrGBbGO7xTPUpSwPvddrKxxrsJn3eoH5ycSkxaWAtdSrKVdzLrwxOV6xB9jUOa1ocf3zPktE7iSY_uV-dsSL6F24Yrd0OpmUZ5V9_7AKpc0Waoal1GYsPrH2Wya3Lx84VP5mDfU768chBPfHUOxaxmh4zzsNWvi2quzyi1OsH-PZc-rwU9K4Wx6RvDSGB4dXzzH3kFyCIHluOV95ckebF_c7xtDHipOBxY0f_1C5nJDcws_rputTcYce63tOSP-PFF_J7A9AwNC5ybHfzSdtIKHh9qCUk9AX1xX0aUsENwAMmjCGG_Z8HUwboIvFyRdshDujdf06UZ9jikPPt-bi8CRvC14pv9GktqGjcY5OpXSq6Yy3I8NcDvnCM8gfcfgcMtLTZ&zp=VlLzGiIXlDpO2ysFkNwyI9zxY6znhwXYkWVELnnTBgWak3rFHK99VHj_4IQO7o_GuD2MIiB0G2tZyV_lUIDpWV0GgGw16_gWN841hkSnFNcg-rZ-5A8k756HrVk8H4-t1nVqDsfXIf42xY1ndmoOk-U3mW04qsC2wCnw_H681qy9c8bE0Xn1SgmH5gEmIXukFQboJLBr-CWUcysf72MFK9cWsxhtTf3gJ9xjl_6loSsqqYnqv4IUXHLa6qfaMQvvXKl6WNRnWXzi9TtPtlQlBKyobLeyGNz95QkWsfiTx_2Njjc5GOpeFpC2uZQAo7l5xdWVWknfrRYyYanFGiApWqlmcB-AtOphrl1J7qpT8erVDYkZlueOgAiysACRPBmkN016-TQsDBL_AbUhtD-hgo5HU3CV1XhqlPPVw9tueU8yR2HEq5GtmNdnDAPV0sqNQKKOG33iMF6cfzTDXOwz9vypJDgXDA\n    - generic [ref=s2e586]: Promoted\n  - link [ref=s2e588]:\n    - /url: https://alb.reddit.com/cr?za=c44-mTC9pCxhjKpl85zLDzK3VVUydx8p4t56VVKJEpIaTd2uFAvs0yAsFHm6phNU5o1EvBwKBt_f8gG0-HRCo9UrjjXvHNxG_9JlA01Sb00iaxLUAKeJ6rdxbh0H3gmk3yPMzYoltCSTaNE314-VNXbW-OnvHL3brFkVaOwDNCuqtAI8N2nbrGBbGO7xTPUpSwPvddrKxxrsJn3eoH5ycSkxaWAtdSrKVdzLrwxOV6xB9jUOa1ocf3zPktE7iSY_uV-dsSL6F24Yrd0OpmUZ5V9_7AKpc0Waoal1GYsPrH2Wya3Lx84VP5mDfU768chBPfHUOxaxmh4zzsNWvi2quzyi1OsH-PZc-rwU9K4Wx6RvDSGB4dXzzH3kFyCIHluOV95ckebF_c7xtDHipOBxY0f_1C5nJDcws_rputTcYce63tOSP-PFF_J7A9AwNC5ybHfzSdtIKHh9qCUk9AX1xX0aUsENwAMmjCGG_Z8HUwboIvFyRdshDujdf06UZ9jikPPt-bi8CRvC14pv9GktqGjcY5OpXSq6Yy3I8NcDvnCM8gfcfgcMtLTZ&zp=VlLzGiIXlDpO2ysFkN...Content truncated to 8000 characters due to length limit',
  },
  {
    role: "assistant",
    tool_calls: [
      {
        type: "function",
        id: "call_xr8RR9AJq5HSydbnP40k9Qgp",
        function: {
          name: "browser_press_key",
          arguments: '{"key":"Enter"}',
        },
      },
    ],
  },
  {
    role: "tool",
    tool_call_id: "call_xr8RR9AJq5HSydbnP40k9Qgp",
    content:
      '- Ran Playwright code:\n```js\n// Press Enter\nawait page.keyboard.press(\'Enter\');\n```\n\n- Page URL: https://www.reddit.com/search/?q=AI+marketing+tool&cId=76c4ee55-d828-4b32-bf15-288533d53843&iId=24b96aee-a2c9-4c2a-a1be-b1f8bf4d6ff0\n- Page Title: Reddit - The heart of the internet\n- Page Snapshot\n```yaml\n- link "Skip to main content" [ref=s3e8]:\n  - /url: "#main-content"\n  - generic [ref=s3e10]: Skip to main content\n- generic [ref=s3e22]: Reddit - The heart of the internet\n- banner [ref=s3e45]:\n  - navigation [ref=s3e46]:\n    - link "Home" [ref=s3e59]:\n      - /url: /\n      - img [ref=s3e61]\n      - img [ref=s3e85]\n    - search [ref=s3e101]:\n      - textbox "Clear search" [ref=s3e107]: AI marketing tool\n      - button "Clear search" [ref=s3e110]:\n        - img [ref=s3e113]\n        - generic [ref=s3e115]:\n          - generic: Clear search\n    - menu [ref=s3e118]:\n      - menuitem "ai marketing tool" [ref=s3e122]:\n        - img [ref=s3e125]\n        - generic [ref=s3e130]: ai marketing tool\n      - menuitem "ai marketing tools" [ref=s3e137]:\n        - img [ref=s3e140]\n        - generic [ref=s3e144]:\n          - generic [ref=s3e145]: ai marketing tool\n          - text: s\n      - generic [ref=s3e149]: Communities\n      - menuitem "r/aimarketing 2.4K members" [ref=s3e153]:\n        - generic [ref=s3e161]: r/aimarketing\n        - generic [ref=s3e163]: 2.4K members\n      - menuitem "r/AIToolTracker 3.5K members" [ref=s3e167]:\n        - generic [ref=s3e175]: r/AIToolTracker\n        - generic [ref=s3e177]: 3.5K members\n      - menuitem "r/AI_tool 193 members" [ref=s3e181]:\n        - generic [ref=s3e189]: r/AI_tool\n        - generic [ref=s3e191]: 193 members\n      - menuitem "r/content_marketing 141K members" [ref=s3e195]:\n        - generic [ref=s3e203]: r/content_marketing\n        - generic [ref=s3e205]: 141K members\n      - menuitem "r/PopularAiTool 566 members" [ref=s3e209]:\n        - generic [ref=s3e217]: r/PopularAiTool\n        - generic [ref=s3e219]: 566 members\n    - link "Advertise on Reddit" [ref=s3e230]:\n      - /url: https://ads.reddit.com/register?utm_source=web3x_consumer&utm_name=nav_cta\n      - img [ref=s3e233]\n      - generic [ref=s3e235]:\n        - generic: Advertise on Reddit\n    - button "Open chat" [ref=s3e247]:\n      - img [ref=s3e250]\n      - generic [ref=s3e252]:\n        - generic: Open chat\n    - link "Create post" [ref=s3e263]:\n      - /url: /submit\n      - img [ref=s3e266]\n      - generic [ref=s3e268]: Create\n      - generic [ref=s3e269]:\n        - generic: Create post\n    - generic [ref=s3e272]:\n      - link "Open inbox" [ref=s3e278]:\n        - /url: /notifications\n        - img [ref=s3e281]\n        - generic [ref=s3e283]:\n          - generic: Open inbox\n      - generic:\n        - generic:\n          - generic:\n            - generic: "2"\n    - button "Expand user menu" [ref=s3e299]:\n      - img [ref=s3e310]\n      - generic [ref=s3e316]:\n        - generic: Expand user menu\n- link "Skip to Navigation" [ref=s3e366]:\n  - /url: "#left-sidebar-container"\n- link "Skip to Right Sidebar" [ref=s3e367]:\n  - /url: "#right-sidebar-container"\n- main [ref=s3e371]:\n  - \'button "Sort by: Best" [ref=s3e390]\':\n    - generic [ref=s3e392]: Best\n    - img [ref=s3e394]\n  - button "View:" [ref=s3e404]:\n    - img [ref=s3e407]\n    - img [ref=s3e410]\n  - separator [ref=s3e414]\n  - heading "Feed" [level=1] [ref=s3e438]\n  - article "Bulk Auto AI Video Creator" [ref=s3e441]:\n    - link "Bulk Auto AI Video Creator" [ref=s3e444]:\n      - /url: /r/AI_Agents/comments/1kj8nbu/bulk_auto_ai_video_creator/\n      - generic [ref=s3e445]:\n        - generic: Bulk Auto AI Video Creator\n    - link "r/AI_Agents icon r/AI_Agents" [ref=s3e455]:\n      - /url: /r/AI_Agents/\n      - img "r/AI_Agents icon" [ref=s3e459]\n      - generic [ref=s3e460]: r/AI_Agents\n    - generic [ref=s3e463]: â€¢\n    - time [ref=s3e465]: 37 min. ago\n    - button "Open user actions" [ref=s3e473]:\n      - img [ref=s3e476]\n    - generic [ref=s3e484]:\n      - heading "Bulk Auto AI Video Creator" [level=2] [ref=s3e485]:\n        - link "Bulk Auto AI Video Creator" [ref=s3e487]:\n          - /url: /r/AI_Agents/comments/1kj8nbu/bulk_auto_ai_video_creator/\n          - text: Bulk Auto AI Video Creator\n      - generic:\n        - link "So there are obviously tools where you can feed it pictures and videos and theyâ€™ll piece something together. I am looking for something where you give it access to your phones gallery and it just goes to town creating reels based on day, location, etc. Yes I know this sounds ultra lazy, but I have like 10k mediaâ€™s taken from my years of traveling. Only other option is to hire someone to go through my stuff and create, though that in itself would be invasive as personal info and non of rated stuff through my gallery lol. Would hope if there is a tool out there that they wouldnâ€™t store or steal your data but would have to do research once I found one. If no such auto AI tool, then whatâ€™s the best (in your opinion) for making videos from 5-10 medias you feed it?":\n          - /url: /r/AI_Agents/comments/1kj8nbu/bulk_auto_ai_video_creator/\n          - generic:\n            - generic:\n              - paragraph: So there are obviously tools where you can feed it pictures and\n                  videos and theyâ€™ll piece something together. I am looking for\n                  something where you give it access to your phones gallery and\n                  it just goes to town creating reels based on day, location,\n                  etc.\n              - paragraph: Yes I know this sounds ultra lazy, but I have like 10k mediaâ€™s taken\n                  from my years of traveling. Only other option is to hire\n                  someone to go through my stuff and create, though that in\n                  itself would be invasive as personal info and non of rated\n                  stuff through my gallery lol. Would hope if there is a tool\n                  out there that they wouldnâ€™t store or steal your data but\n                  would have to do research once I found one.\n              - paragraph: If no such auto AI tool, then whatâ€™s the best (in your opinion) for\n                  making videos from 5-10 medias you feed it?\n    - button "Upvote" [ref=s3e514]:\n      - img [ref=s3e516]\n      - generic [ref=s3e518]:\n        - generic: Upvote\n    - generic [ref=s3e521]: "2"\n    - button "Downvote" [ref=s3e522]:\n      - img [ref=s3e524]\n      - generic [ref=s3e526]:\n        - generic: Downvote\n    - link "0 Go to comments" [ref=s3e528]:\n      - /url: /r/AI_Agents/comments/1kj8nbu/bulk_auto_ai_video_creator/\n      - generic [ref=s3e532]: "0"\n      - generic [ref=s3e533]:\n        - generic: Go to comments\n    - button "Give award" [ref=s3e536]\n    - button "Share Share" [ref=s3e543]:\n      - generic [ref=s3e546]: Share\n      - generic [ref=s3e547]:\n        - generic: Share\n  - separator [ref=s3e560]\n  - \'link "Advertisement: Torn City - World\'\'s Largest Text-based RPG" [ref=s3e566]\':\n    - /url: https://alb.reddit.com/cr?za=c44-mTC9pCxhjKpl85zLDzK3VVUydx8p4t56VVKJEpIaTd2uFAvs0yAsFHm6phNU5o1EvBwKBt_f8gG0-HRCo9UrjjXvHNxG_9JlA01Sb00iaxLUAKeJ6rdxbh0H3gmk3yPMzYoltCSTaNE314-VNXbW-OnvHL3brFkVaOwDNCuqtAI8N2nbrGBbGO7xTPUpSwPvddrKxxrsJn3eoH5ycSkxaWAtdSrKVdzLrwxOV6xB9jUOa1ocf3zPktE7iSY_uV-dsSL6F24Yrd0OpmUZ5V9_7AKpc0Waoal1GYsPrH2Wya3Lx84VP5mDfU768chBPfHUOxaxmh4zzsNWvi2quzyi1OsH-PZc-rwU9K4Wx6RvDSGB4dXzzH3kFyCIHluOV95ckebF_c7xtDHipOBxY0f_1C5nJDcws_rputTcYce63tOSP-PFF_J7A9AwNC5ybHfzSdtIKHh9qCUk9AX1xX0aUsENwAMmjCGG_Z8HUwboIvFyRdshDujdf06UZ9jikPPt-bi8CRvC14pv9GktqGjcY5OpXSq6Yy3I8NcDvnCM8gfcfgcMtLTZ&zp=VlLzGiIXlDpO2ysFkNwyI9zxY6znhwXYkWVELnnTBgWak3rFHK99VHj_4IQO7o_GuD2MIiB0G2tZyV_lUIDpWV0GgGw16_gWN841hkSnFNcg-rZ-5A8k756HrVk8H4-t1nVqDsfXIf42xY1ndmoOk-U3mW04qsC2wCnw_H681qy9c8bE0Xn1SgmH5gEmIXukFQboJLBr-CWUcysf72MFK9cWsxhtTf3gJ9xjl_6loSsqqYnqv4IUXHLa6qfaMQvvXKl6WNRnWXzi9TtPtlQlBKyobLeyGNz95QkWsfiTx_2Njjc5GOpeFpC2uZQAo7l5xdWVWknfrRYyYanFGiApWqlmcB-AtOphrl1J7qpT8erVDYkZlueOgAiysACRPBmkN016-TQsDBL_AbUhtD-hgo5HU3CV1XhqlPPVw9tueU8yR2HEq5GtmNdnDAPV0sqNQKKOG33iMF6cfzTDXOwz9vypJDgXDA\n  - link "u/TORNRPG avatar u/TORNRPG" [ref=s3e575]:\n    - /url: /user/TORNRPG/\n    - img "u/TORNRPG avatar" [ref=s3e580]\n    - generic [ref=s3e581]: u/TORNRPG\n  - generic [ref=s3e582]: â€¢\n  - link "Promoted" [ref=s3e584]:\n    - /url: https://alb.reddit.com/cr?za=c44-mTC9pCxhjKpl85zLDzK3VVUydx8p4t56VVKJEpIaTd2uFAvs0yAsFHm6phNU5o1EvBwKBt_f8gG0-HRCo9UrjjXvHNxG_9JlA01Sb00iaxLUAKeJ6rdxbh0H3gmk3yPMzYoltCSTaNE314-VNXbW-OnvHL3brFkVaOwDNCuqtAI8N2nbrGBbGO7xTPUpSwPvddrKxxrsJn3eoH5ycSkxaWAtdSrKVdzLrwxOV6xB9jUOa1ocf3zPktE7iSY_uV-dsSL6F24Yrd0OpmUZ5V9_7AKpc0Waoal1GYsPrH2Wya3Lx84VP5mDfU768chBPfHUOxaxmh4zzsNWvi2quzyi1OsH-PZc-rwU9K4Wx6RvDSGB4dXzzH3kFyCIHluOV95ckebF_c7xtDHipOBxY0f_1C5nJDcws_rputTcYce63tOSP-PFF_J7A9AwNC5ybHfzSdtIKHh9qCUk9AX1xX0aUsENwAMmjCGG_Z8HUwboIvFyRdshDujdf06UZ9jikPPt-bi8CRvC14pv9GktqGjcY5OpXSq6Yy3I8NcDvnCM8gfcfgcMtLTZ&zp=VlLzGiIXlDpO2ysFkNwyI9zxY6znhwXYkWVELnnTBgWak3rFHK99VHj_4IQO7o_GuD2MIiB0G2tZyV_lUIDpWV0GgGw16_gWN841hkSnFNcg-rZ-5A8k756HrVk8H4-t1nVqDsfXIf42xY1ndmoOk-U3mW04qsC2wCnw_H681qy9c8bE0Xn1SgmH5gEmIXukFQboJLBr-CWUcysf72MFK9cWsxhtTf3gJ9xjl_6loSsqqYnqv4IUXHLa6qfaMQvvXKl6WNRnWXzi9TtPtlQlBKyobLeyGNz95QkWsfiTx_2Njjc5GOpeFpC2uZQAo7l5xdWVWknfrRYyYanFGiApWqlmcB-AtOphrl1J7qpT8erVDYkZlueOgAiysACRPBmkN016-TQsDBL_AbUhtD-hgo5HU3CV1XhqlPPVw9tueU8yR2HEq5GtmNdnDAPV0sqNQKKOG33iMF6cfzTDXOwz9vypJDgXDA\n    - generic [ref=s3e586]: Promoted\n  - link [ref=s3e588]:\n    - /url: https://alb.reddit.com/cr?za=c44-mTC9pCxhjKpl85zLDzK3VVUydx8p4t56VVKJEpIaTd2uFAvs0yAsFHm6phNU5o1EvBwKBt_f8gG0-HRCo9UrjjXvHNxG_9JlA01Sb00iaxLUAKeJ6rdxbh0H3gmk3yPMzYoltCSTaNE314-VNXbW-OnvHL3brFkVaOwDNCuqtAI8N2nbrGBbGO7xTPUpSwPvddrKxxrsJn3eoH5ycSkxaWAtdSrKVdzLrwxOV6xB9jUOa1ocf3zPktE7iSY_uV-dsSL6F24Yrd0OpmUZ5V9_7AKpc0Waoal1GYsPrH2Wya3Lx84VP5mDfU768chBPfHUOxaxmh4zzsNWvi2quzyi1OsH-PZc-rwU9K4Wx6RvDSGB4dXzzH3kFyCIHluOV95ckebF_c7xtDHipOBxY0f_1C5nJDcws_rputTcYce63tOSP-PFF_J7A9AwNC5ybHfzSdtIKHh9qCUk9AX1xX0aUsENwAMmjCGG_Z8HUwboIvFyRdshDujdf06UZ9jikPPt-bi8CRvC14pv9GktqGjcY5OpXSq6Yy...Content truncated to 8000 characters due to length limit',
  },
  {
    role: "assistant",
    tool_calls: [
      {
        type: "function",
        id: "call_haZDmILRV90fD40lVNkkYIa6",
        function: {
          name: "browser_click",
          arguments: '{"element":"input"}',
        },
      },
    ],
  },
  {
    role: "assistant",
    tool_calls: [
      {
        type: "function",
        id: "call_haZDmILRV90fD40lVNkkYIa6",
        function: {
          name: "browser_type",
          arguments:
            '{"text":"AI Marketing Agent Copilot ğŸ‘‹ \n this is a great new product we are working at "}',
        },
      },
    ],
  },
  {
    role: "assistant",
    tool_calls: [
      {
        type: "function",
        id: "call_gQSenAJ1Cjfq7YraGb8JV8wJ",
        function: {
          name: "prompt_user_single_choice",
          arguments:
            '{"element":"search box","ref":"s1e107","text":"AI marketing tool"}',
        },
      },
    ],
  },
  // {
  //   role: "assistant",
  //   content: [
  //     {
  //       type: "text",
  //       text: "Here are **10 Reddit posts where people might be interested** in your AI marketing tool, choose the ones you want to generate a reply:\n\n ",
  //     },
  //   ],
  // },
  // {
  //   role: "assistant",
  //   tool_calls: [
  //     {
  //       type: "function",
  //       id: "call_gQSenAJ1Cjfq7YraGb8JV8wJ",
  //       function: {
  //         name: "prompt_user_multi_choice",
  //         arguments:
  //           '{"element":"search box","ref":"s1e107","text":"AI marketing tool"}',
  //       },
  //     },
  //   ],
  // },
];



================================================
FILE: react/src/hooks/use-balance.ts
================================================
import { useQuery } from '@tanstack/react-query'
import { getBalance } from '@/api/billing'
import { useAuth } from '@/contexts/AuthContext'

export function useBalance() {
  const { authStatus } = useAuth()

  const {
    data,
    error,
    refetch,
  } = useQuery({
    queryKey: ['balance'],
    queryFn: getBalance,
    enabled: authStatus.is_logged_in, // åªæœ‰ç™»å½•æ—¶æ‰è·å–ä½™é¢
    staleTime: 30000, // 30ç§’å†…ä¸é‡æ–°è·å–
    gcTime: 5 * 60 * 1000, // 5åˆ†é’Ÿåæ¸…ç†ç¼“å­˜
    refetchOnWindowFocus: true, // çª—å£èšç„¦æ—¶é‡æ–°è·å–
    refetchOnMount: true, // ç»„ä»¶æŒ‚è½½æ—¶é‡æ–°è·å–
  })

  return {
    balance: data?.balance || '0.00',
    error,
    refreshBalance: refetch,
  }
}



================================================
FILE: react/src/hooks/use-debounce.ts
================================================
import { useCallback, useRef } from 'react'

export default function useDebounce<T extends (...args: any[]) => any>(
  callback: T,
  delay: number
): (...args: Parameters<T>) => void {
  const timeoutRef = useRef<NodeJS.Timeout | undefined>(undefined)

  return useCallback(
    (...args: Parameters<T>) => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current)
      }

      timeoutRef.current = setTimeout(() => {
        callback(...args)
      }, delay)
    },
    [callback, delay]
  )
}



================================================
FILE: react/src/hooks/use-language.ts
================================================
import { useTranslation } from 'react-i18next'

export const useLanguage = () => {
  const { i18n } = useTranslation()

  const changeLanguage = (language: string) => {
    i18n.changeLanguage(language)
  }

  const getCurrentLanguage = () => i18n.language

  return {
    currentLanguage: getCurrentLanguage(),
    changeLanguage,
    isEnglish: getCurrentLanguage() === 'en',
    isChinese: getCurrentLanguage() === 'zh-CN',
  }
}



================================================
FILE: react/src/hooks/use-mobile.ts
================================================
import * as React from "react"

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener("change", onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener("change", onChange)
  }, [])

  return !!isMobile
}



================================================
FILE: react/src/hooks/use-notifications.ts
================================================
import { Notification, notificationManager } from '@/lib/notifications'
import { useEffect, useState } from 'react'

export function useNotifications() {
  const [notifications, setNotifications] = useState<Notification[]>([])

  useEffect(() => {
    setNotifications(notificationManager.getNotifications())
    const unsubscribe = notificationManager.subscribe(setNotifications)

    return unsubscribe
  }, [])

  return {
    notifications,
    unreadCount: notificationManager.getUnreadCount(),
    markAsRead: notificationManager.markAsRead.bind(notificationManager),
    markAllAsRead: notificationManager.markAllAsRead.bind(notificationManager),
    clearNotifications:
      notificationManager.clearNotifications.bind(notificationManager),
    getCanvasNotifications:
      notificationManager.getCanvasNotifications.bind(notificationManager),
    getSessionNotifications:
      notificationManager.getSessionNotifications.bind(notificationManager),
  }
}



================================================
FILE: react/src/hooks/use-theme.ts
================================================
import { ThemeProviderContext } from '@/contexts/theme'
import { useContext } from 'react'

export const useTheme = () => {
  const context = useContext(ThemeProviderContext)

  if (context === undefined)
    throw new Error('useTheme must be used within a ThemeProvider')

  return context
}



================================================
FILE: react/src/i18n/README.md
================================================
# å›½é™…åŒ– (i18n) ä½¿ç”¨æŒ‡å—

## æ¦‚è¿°

æœ¬é¡¹ç›®ä½¿ç”¨ `react-i18next` è¿›è¡Œå›½é™…åŒ–å¤„ç†ï¼Œæ”¯æŒä¸­è‹±æ–‡åˆ‡æ¢ã€‚ç¿»è¯‘æ–‡ä»¶æŒ‰åŠŸèƒ½æ¨¡å—ç»„ç»‡ï¼Œä¾¿äºç»´æŠ¤å’Œæ‰©å±•ã€‚

## æ–‡ä»¶ç»“æ„

```
src/i18n/
â”œâ”€â”€ index.ts                 # i18n é…ç½®æ–‡ä»¶
â”œâ”€â”€ locales/
â”‚   â”œâ”€â”€ en/                 # è‹±æ–‡ç¿»è¯‘
â”‚   â”‚   â”œâ”€â”€ common.json     # é€šç”¨ç¿»è¯‘
â”‚   â”‚   â”œâ”€â”€ home.json       # é¦–é¡µç¿»è¯‘
â”‚   â”‚   â”œâ”€â”€ canvas.json     # ç”»å¸ƒé¡µé¢ç¿»è¯‘
â”‚   â”‚   â”œâ”€â”€ chat.json       # èŠå¤©åŠŸèƒ½ç¿»è¯‘
â”‚   â”‚   â””â”€â”€ settings.json   # è®¾ç½®é¡µé¢ç¿»è¯‘
â”‚   â””â”€â”€ zh/                 # ä¸­æ–‡ç¿»è¯‘
â”‚       â”œâ”€â”€ common.json
â”‚       â”œâ”€â”€ home.json
â”‚       â”œâ”€â”€ canvas.json
â”‚       â”œâ”€â”€ chat.json
â”‚       â””â”€â”€ settings.json
â””â”€â”€ README.md               # æœ¬è¯´æ˜æ–‡æ¡£
```

## åŸºæœ¬ä½¿ç”¨

### 1. åœ¨ç»„ä»¶ä¸­ä½¿ç”¨ç¿»è¯‘

```tsx
import { useTranslation } from 'react-i18next'

function MyComponent() {
  const { t } = useTranslation()

  return (
    <div>
      <h1>{t('title')}</h1>
    </div>
  )
}
```

### 2. ä½¿ç”¨åµŒå¥—é”®å€¼

```tsx
// ç¿»è¯‘æ–‡ä»¶ä¸­ï¼š
// {
//   "buttons": {
//     "save": "ä¿å­˜",
//     "cancel": "å–æ¶ˆ"
//   }
// }

const { t } = useTranslation()
return <button>{t('common:buttons.save')}</button>
```

### 3. ä½¿ç”¨æ’å€¼

```tsx
// ç¿»è¯‘æ–‡ä»¶ä¸­ï¼š
// {
//   "welcome": "æ¬¢è¿, {{name}}!"
// }

const { t } = useTranslation()
return <div>{t('common:welcome', { name: 'Jaaz' })}</div>
```

### 4. è¯­è¨€åˆ‡æ¢

```tsx
import { useLanguage } from '@/hooks/use-language'

function LanguageButton() {
  const { changeLanguage, currentLanguage } = useLanguage()

  return (
    <button
      onClick={() => changeLanguage(currentLanguage === 'zh-CN' ? 'en' : 'zh-CN')}
    >
      {currentLanguage === 'zh-CN' ? 'English' : 'ä¸­æ–‡'}
    </button>
  )
}
```

## å‘½åç©ºé—´è¯´æ˜

- **common**: é€šç”¨ç¿»è¯‘ï¼ŒåŒ…æ‹¬æŒ‰é’®ã€æ¶ˆæ¯ã€å¯¼èˆªç­‰
- **home**: é¦–é¡µç›¸å…³ç¿»è¯‘
- **canvas**: ç”»å¸ƒåŠŸèƒ½ç›¸å…³ç¿»è¯‘
- **chat**: èŠå¤©åŠŸèƒ½ç›¸å…³ç¿»è¯‘
- **settings**: è®¾ç½®é¡µé¢ç›¸å…³ç¿»è¯‘

## ç¿»è¯‘é”®å‘½åè§„èŒƒ

1. ä½¿ç”¨å°é©¼å³°å‘½åæ³•ï¼š`newCanvas`
2. åµŒå¥—å¯¹è±¡ä½¿ç”¨ç‚¹åˆ†éš”ï¼š`buttons.save`
3. åŠ¨ä½œç›¸å…³ï¼š`create`, `edit`, `delete`, `save`
4. çŠ¶æ€ç›¸å…³ï¼š`loading`, `success`, `error`
5. æ¶ˆæ¯ç›¸å…³ï¼š`messages.success`, `messages.error`

## æ·»åŠ æ–°ç¿»è¯‘

1. åœ¨å¯¹åº”çš„è‹±æ–‡ JSON æ–‡ä»¶ä¸­æ·»åŠ æ–°çš„é”®å€¼å¯¹
2. åœ¨å¯¹åº”çš„ä¸­æ–‡ JSON æ–‡ä»¶ä¸­æ·»åŠ å¯¹åº”çš„ç¿»è¯‘
3. åœ¨ç»„ä»¶ä¸­ä½¿ç”¨ `t('newKey')` è°ƒç”¨

## ç»„ä»¶ä½¿ç”¨ç¤ºä¾‹

### è¯­è¨€åˆ‡æ¢å™¨ç»„ä»¶

```tsx
import { LanguageSwitcher } from '@/components/common/LanguageSwitcher'

function Header() {
  return (
    <div className="header">
      <LanguageSwitcher />
    </div>
  )
}
```

### è‡ªå®šä¹‰é’©å­

```tsx
import { useLanguage } from '@/hooks/use-language'

function MyComponent() {
  const { currentLanguage, changeLanguage, isEnglish, isChinese } = useLanguage()

  // æ ¹æ®å½“å‰è¯­è¨€æ‰§è¡Œä¸åŒé€»è¾‘
  if (isEnglish) {
    // è‹±æ–‡é€»è¾‘
  }

  if (isChinese) {
    // ä¸­æ–‡é€»è¾‘
  }
}
```

## æ³¨æ„äº‹é¡¹

1. ç¿»è¯‘æ–‡ä»¶ä¿®æ”¹åéœ€è¦é‡å¯å¼€å‘æœåŠ¡å™¨
2. ç¡®ä¿ä¸­è‹±æ–‡ç¿»è¯‘æ–‡ä»¶çš„é”®ä¿æŒä¸€è‡´
3. ä½¿ç”¨æœ‰æ„ä¹‰çš„é”®åï¼Œé¿å…ä½¿ç”¨ `text1`, `label2` ç­‰æ— æ„ä¹‰çš„å‘½å
4. é•¿æ–‡æœ¬å»ºè®®åˆ†æ®µå¤„ç†ï¼Œä¾¿äºç»´æŠ¤
5. æ¶‰åŠå¤æ•°å½¢å¼æ—¶ï¼Œè€ƒè™‘ä½¿ç”¨ i18next çš„å¤æ•°åŠŸèƒ½



================================================
FILE: react/src/i18n/index.ts
================================================
import i18n from 'i18next'
import { initReactI18next } from 'react-i18next'
import LanguageDetector from 'i18next-browser-languagedetector'

// Import translation files
import commonEn from './locales/en/common.json'
import homeEn from './locales/en/home.json'
import canvasEn from './locales/en/canvas.json'
import chatEn from './locales/en/chat.json'
import settingsEn from './locales/en/settings.json'

import commonZh from './locales/zh-CN/common.json'
import homeZh from './locales/zh-CN/home.json'
import canvasZh from './locales/zh-CN/canvas.json'
import chatZh from './locales/zh-CN/chat.json'
import settingsZh from './locales/zh-CN/settings.json'

const resources = {
  en: {
    common: commonEn,
    home: homeEn,
    canvas: canvasEn,
    chat: chatEn,
    settings: settingsEn,
  },
  'zh-CN': {
    common: commonZh,
    home: homeZh,
    canvas: canvasZh,
    chat: chatZh,
    settings: settingsZh,
  },
}

i18n
  .use(LanguageDetector)
  .use(initReactI18next)
  .init({
    resources,
    fallbackLng: 'en',
    defaultNS: 'common',
    ns: ['common', 'home', 'canvas', 'chat', 'settings'],

    detection: {
      order: ['localStorage', 'navigator', 'htmlTag'],
      lookupLocalStorage: 'language',
      caches: ['localStorage'],
    },

    interpolation: {
      escapeValue: false,
    },

    react: {
      useSuspense: true,
    },
  })

export default i18n



================================================
FILE: react/src/i18n/locales/en/canvas.json
================================================
{
  "title": "Canvas",
  "rename": "Rename Canvas",
  "delete": "Delete Canvas",
  "share": "Share Canvas",
  "export": "Export Canvas",
  "exportImages": "Export",
  "import": "Import Canvas",
  "untitled": "Untitled",
  "back": "Back",
  "saveSnapshot": "Save Snapshot",
  "loadSnapshot": "Load Snapshot",
  "saved": "Saved âœ…",
  "messages": {
    "canvasRenamed": "Canvas renamed successfully",
    "canvasDeleted": "Canvas deleted successfully",
    "canvasExported": "Canvas exported successfully",
    "canvasImported": "Canvas imported successfully",
    "failedToRename": "Failed to rename canvas",
    "failedToDelete": "Failed to delete canvas",
    "failedToCreateFile": "Failed to create file",
    "nothingSelected": "No assets selected",
    "exportingAssets": "Exporting assets...",
    "failedToExportImages": "Failed to export images",
    "gptImagePermissionRequired": "You must enable gpt-image-1 model permissions to use this feature!"
  },
  "deleteDialog": {
    "title": "Delete Canvas",
    "description": "Are you sure you want to delete this Canvas? This action cannot be undone.",
    "cancel": "Cancel",
    "delete": "Delete"
  },
  "tool": {
    "hand": "Hand",
    "selection": "Selection",
    "rectangle": "Rectangle",
    "ellipse": "Ellipse",
    "text": "Text",
    "image": "Image",
    "shape": "Shape",
    "arrow": "Arrow",
    "line": "Line",
    "zoomFit": "Zoom to fit"
  },
  "popbar": {
    "addToChat": "Add to chat",
    "magicGenerate": "âœ¨ Magic Generate"
  },
  "myAssets": "My Assets",
  "selectAFolder": "Select a folder",
  "selectAFolderDescription": "Select a folder to view its images and videos",
  "noMediaFiles": "No media files",
  "noMediaFilesDescription": "No images or videos in this folder",
  "mediaFiles": "media files",
  "openInExplorer": "Open in system file browser",
  "basicInfo": "Basic info",
  "fileName": "File name",
  "fileSize": "File size",
  "modifiedTime": "Modified time",
  "dimensions": "Dimensions",
  "filePath": "File path",
  "pngMetadata": "PNG Metadata"
}



================================================
FILE: react/src/i18n/locales/en/chat.json
================================================
{
  "newChat": "New Chat",
  "placeholder": "Type your message here...",
  "insufficientBalance": "Insufficient Balance",
  "insufficientBalanceDescription": "Your credits are depleted. Please recharge to continue.",
  "textarea": {
    "placeholder": "Enter your design requirements",
    "selectModel": "Please select a text model! Go to Settings to set your API keys if you haven't done so.",
    "selectTool": "Please go to settings to add image or video generation tools, or you won't be able to generate any images or videos!!",
    "enterPrompt": "Please enter a prompt",
    "quantity": "Image Quantity"
  },
  "messages": {
    "imagePositioning": "Go to image",
    "showMore": "Show More",
    "showLess": "Show Less"
  },
  "thinking": {
    "title": "Thinking"
  },
  "plan": {
    "title": "Plan",
    "steps": {
      "singular": "step",
      "plural": "steps"
    }
  },
  "shareTemplate": {
    "title": "Share as Template",
    "templateName": "Template Name",
    "templateNamePlaceholder": "Enter template name...",
    "coverPhoto": "Cover Photo",
    "noImagesFound": "No images found in canvas",
    "nameRequired": "Template name is required",
    "coverImageRequired": "Cover image is required",
    "create": "Create Template",
    "creating": "Creating...",
    "success": "Template created successfully!",
    "error": "Failed to create template"
  },
  "modelSelector": {
    "title": "Model",
    "auto": "Auto",
    "tabs": {
      "image": "Image",
      "video": "Video",
      "text": "Text"
    }
  }
}



================================================
FILE: react/src/i18n/locales/en/common.json
================================================
{
  "languages": {
    "en": "English",
    "zh-CN": "ç®€ä½“ä¸­æ–‡"
  },
  "buttons": {
    "save": "Save",
    "cancel": "Cancel",
    "delete": "Delete",
    "edit": "Edit",
    "create": "Create",
    "submit": "Submit",
    "loading": "Loading...",
    "retry": "Retry"
  },
  "common": {
    "yes": "Yes",
    "no": "No",
    "ok": "OK",
    "error": "Error",
    "success": "Success",
    "warning": "Warning",
    "info": "Information"
  },
  "messages": {
    "success": "Operation completed successfully",
    "error": "An error occurred",
    "loading": "Loading, please wait...",
    "noData": "No data available",
    "confirmDelete": "Are you sure you want to delete this item?",
    "saved": "Saved successfully",
    "deleted": "Deleted successfully"
  },
  "notifications": {
    "title": "Notifications",
    "clear": "Clear",
    "markAllAsRead": "Mark all as read",
    "allRead": "All read",
    "newImageGenerated": "New image generated"
  },
  "navigation": {
    "home": "Home",
    "canvas": "Canvas",
    "settings": "Settings",
    "back": "Back"
  },
  "update": {
    "title": "ğŸ‰ New Version Available",
    "description": "New version v{{version}} is available. Would you like to install it now?",
    "installNote": "Click \"Install Update\" to restart the app and install the new version.",
    "laterButton": "Remind Later",
    "installButton": "Install Update",
    "installing": "Installing..."
  },
  "auth": {
    "login": "Login",
    "logout": "Logout",
    "loginToJaaz": "Login to Jaaz",
    "myAccount": "My Account",
    "loginDescription": "Login to use cloud AI models",
    "startLogin": "Start Login",
    "preparingLogin": "Preparing login...",
    "cancel": "Cancel",
    "loginSuccessMessage": "Login successful!",
    "authExpiredMessage": "Authorization expired, please login again",
    "authErrorMessage": "Error occurred while checking authorization status",
    "waitingForBrowser": "Waiting for login completion in browser...",
    "pollErrorMessage": "Failed to check login status, please try again",
    "preparingLoginMessage": "Preparing login...",
    "browserLoginMessage": "Please complete login in browser",
    "loginRequestFailed": "Login request failed, please try again",
    "logoutSuccessMessage": "Successfully logged out",
    "notLoggedIn": "Not logged in",
    "balance": "Balance",
    "recharge": "Recharge"
  },
  "socket": {
    "connectionError": "Connection error ({{current}}/{{max}}): {{error}}",
    "maxRetriesReached": "Connection failed, please restart the application"
  }
}



================================================
FILE: react/src/i18n/locales/en/home.json
================================================
{
  "title": "Hello, Jaaz!",
  "subtitle": "Ready to turn your ideas into art?",
  "allProjects": "All Projects",
  "noCanvases": "No canvases yet",
  "newCanvas": "Untitled"
}



================================================
FILE: react/src/i18n/locales/en/settings.json
================================================
{
  "title": "Settings",
  "messages": {
    "settingsSaved": "Settings saved successfully",
    "settingsReset": "Settings reset to default",
    "failedToSave": "Failed to save settings",
    "failedToLoad": "Failed to load configuration",
    "restartRequired": "Please restart the application for proxy settings to take effect"
  },
  "models": {
    "title": "Models",
    "placeholder": "Enter model name",
    "addModel": "Add Model",
    "types": {
      "text": "text",
      "image": "image",
      "video": "video"
    }
  },
  "provider": {
    "title": "Providers",
    "addProvider": "Add Provider",
    "providerName": "Provider Name",
    "providerNamePlaceholder": "Enter provider name",
    "apiUrl": "API URL",
    "apiUrlPlaceholder": "Enter API URL",
    "apiKey": "API Key",
    "apiKeyPlaceholder": "Enter API key",
    "apiKeyDescription": "Your API key will be stored securely",
    "maxTokens": "Max Tokens",
    "maxTokensPlaceholder": "Enter your max tokens",
    "maxTokensDescription": "The maximum number of tokens in the response",
    "customProvider": "âœ¨ Custom Provider",
    "imageGeneration": "ğŸ¨ Image Generation",
    "delete": "Delete",
    "save": "Save",
    "cancel": "Cancel",
    "noModelsSelected": "Please add at least one model"
  },
  "proxy": {
    "title": "Proxy Settings",
    "mode": "Proxy Mode",
    "selectMode": "Select proxy mode",
    "modes": {
      "no_proxy": "No Proxy",
      "system": "System Proxy",
      "custom": "Custom Proxy"
    },
    "enable": "Enable Proxy",
    "url": "Proxy URL",
    "urlPlaceholder": "http://proxy.example.com:8080",
    "testConnection": "Test Connection",
    "testing": "Testing...",
    "testSuccess": "Proxy connection test successful",
    "testFailed": "Proxy connection test failed: {{message}}",
    "testError": "Proxy connection test error",
    "status": {
      "enabled": "Enabled",
      "disabled": "Disabled",
      "misconfigured": "Misconfigured"
    }
  },
  "comfyui": {
    "title": "ComfyUI",
    "localImageGeneration": "ğŸ¨ Local Image Generation",
    "enable": "Enable",
    "debugStatus": "ğŸ” Debug Status",
    "status": {
      "disabled": "Disabled",
      "running": "Running",
      "installed": "Installed (Not Running)",
      "notInstalled": "Not Installed",
      "notRunning": "Not Running",
      "checking": "Checking..."
    },
    "urlDescription": "ComfyUI service URL, enter the address if already installed",
    "invalidUrl": "Please enter a valid URL (e.g., http://127.0.0.1:8188)",
    "notInstalledTitle": "ComfyUI Not Installed",
    "notInstalledDescription": "Install ComfyUI to enable local image generation with Flux models",
    "installButton": "Install ComfyUI",
    "startButton": "Start ComfyUI",
    "uninstallButton": "Uninstall ComfyUI",
    "confirmUninstall": "Are you sure you want to uninstall ComfyUI? This will completely remove ComfyUI from your system, including all downloaded models and configurations.",
    "confirmUninstallButton": "Confirm Uninstall",
    "deleteWorkflowConfirmation": "Are you sure you want to delete this workflow?",
    "uninstallProgress": {
      "title": "Uninstalling ComfyUI",
      "preparing": "Preparing to uninstall...",
      "inProgress": "Uninstallation in progress... Please wait.",
      "logTitle": "Uninstallation Log:",
      "completed": "Uninstallation completed"
    },
    "notInstalled": "ComfyUI is not installed",
    "addWorkflow": "Add Workflow",
    "addInput": "Add Input",
    "workflows": "Workflows",
    "editWorkflow": "Edit Workflow"
  },
  "saveSettings": "Save Settings",
  "close": "Close",
  "cancel": "Cancel"
}



================================================
FILE: react/src/i18n/locales/zh-CN/canvas.json
================================================
[Binary file]


================================================
FILE: react/src/i18n/locales/zh-CN/chat.json
================================================
{
  "newChat": "æ–°å»ºèŠå¤©",
  "placeholder": "åœ¨è¿™é‡Œè¾“å…¥ä½ çš„æ¶ˆæ¯...",
  "insufficientBalance": "ä½™é¢ä¸è¶³",
  "insufficientBalanceDescription": "æ‚¨çš„ç§¯åˆ†å·²ç”¨å®Œï¼Œè¯·å……å€¼åç»§ç»­ä½¿ç”¨",
  "textarea": {
    "placeholder": "è¾“å…¥æ‚¨çš„è®¾è®¡éœ€æ±‚",
    "selectModel": "è¯·é€‰æ‹©ä¸€ä¸ªæ–‡æœ¬æ¨¡å‹ï¼å¦‚æœæ‚¨è¿˜æ²¡æœ‰è®¾ç½® API å¯†é’¥ï¼Œè¯·å‰å¾€è®¾ç½®é¡µé¢è¿›è¡Œé…ç½®ã€‚",
    "selectTool": "è¯·é€‰æ‹©ä¸€ä¸ªå›¾ç‰‡æ¨¡å‹ï¼å¦‚æœæ‚¨è¿˜æ²¡æœ‰è®¾ç½® API å¯†é’¥ï¼Œè¯·å‰å¾€è®¾ç½®é¡µé¢è¿›è¡Œé…ç½®ã€‚",
    "enterPrompt": "è¯·è¾“å…¥æç¤ºå†…å®¹",
    "quantity": "ç”Ÿæˆæ•°é‡"
  },
  "messages": {
    "imagePositioning": "å®šä½åˆ°å›¾ç‰‡",
    "showMore": "æ˜¾ç¤ºæ›´å¤š",
    "showLess": "æ”¶èµ·"
  },
  "thinking": {
    "title": "æ€è€ƒè¿‡ç¨‹"
  },
  "plan": {
    "title": "è®¡åˆ’",
    "steps": {
      "singular": "æ­¥éª¤",
      "plural": "æ­¥éª¤"
    }
  },
  "single_select_mode": "å•é€‰æ¨¡å¼",
  "shareTemplate": {
    "title": "åˆ†äº«ä¸ºæ¨¡æ¿",
    "templateName": "æ¨¡æ¿åç§°",
    "templateNamePlaceholder": "è¾“å…¥æ¨¡æ¿åç§°...",
    "coverPhoto": "å°é¢å›¾ç‰‡",
    "noImagesFound": "ç”»å¸ƒä¸­æ²¡æœ‰æ‰¾åˆ°å›¾ç‰‡",
    "nameRequired": "æ¨¡æ¿åç§°æ˜¯å¿…å¡«é¡¹",
    "coverImageRequired": "å°é¢å›¾ç‰‡æ˜¯å¿…å¡«é¡¹",
    "create": "åˆ›å»ºæ¨¡æ¿",
    "creating": "åˆ›å»ºä¸­...",
    "success": "æ¨¡æ¿åˆ›å»ºæˆåŠŸï¼",
    "error": "åˆ›å»ºæ¨¡æ¿å¤±è´¥"
  },
  "toolCall": {
    "requiresConfirmation": "éœ€ç¡®è®¤",
    "cancelled": "å·²å–æ¶ˆ",
    "confirm": "ç¡®è®¤æ‰§è¡Œ",
    "cancel": "å–æ¶ˆ"
  },
  "modelSelector": {
    "title": "æ¨¡å‹",
    "auto": "è‡ªåŠ¨",
    "tabs": {
      "image": "å›¾åƒ",
      "video": "è§†é¢‘",
      "text": "æ–‡æœ¬"
    }
  }
}



================================================
FILE: react/src/i18n/locales/zh-CN/common.json
================================================
{
  "languages": {
    "en": "English",
    "zh-CN": "ç®€ä½“ä¸­æ–‡"
  },
  "buttons": {
    "save": "ä¿å­˜",
    "cancel": "å–æ¶ˆ",
    "delete": "åˆ é™¤",
    "edit": "ç¼–è¾‘",
    "create": "åˆ›å»º",
    "submit": "æäº¤",
    "loading": "åŠ è½½ä¸­...",
    "retry": "é‡è¯•"
  },
  "common": {
    "yes": "æ˜¯",
    "no": "å¦",
    "ok": "ç¡®å®š",
    "error": "é”™è¯¯",
    "success": "æˆåŠŸ",
    "warning": "è­¦å‘Š",
    "info": "ä¿¡æ¯"
  },
  "messages": {
    "success": "æ“ä½œæˆåŠŸå®Œæˆ",
    "error": "å‘ç”Ÿäº†é”™è¯¯",
    "loading": "æ­£åœ¨åŠ è½½ï¼Œè¯·ç¨å€™...",
    "noData": "æš‚æ— æ•°æ®",
    "confirmDelete": "ç¡®å®šè¦åˆ é™¤æ­¤é¡¹å—ï¼Ÿ",
    "saved": "ä¿å­˜æˆåŠŸ",
    "deleted": "åˆ é™¤æˆåŠŸ"
  },
  "notifications": {
    "title": "é€šçŸ¥",
    "clear": "æ¸…ç©º",
    "markAllAsRead": "å…¨éƒ¨å·²è¯»",
    "allRead": "å…¨éƒ¨å·²è¯»",
    "newImageGenerated": "æ–°å›¾ç‰‡ç”Ÿæˆ"
  },
  "navigation": {
    "home": "é¦–é¡µ",
    "canvas": "ç”»å¸ƒ",
    "settings": "è®¾ç½®",
    "back": "è¿”å›"
  },
  "dialog": {
    "confirmTitle": "ç¡®è®¤æ“ä½œ",
    "confirmDescription": "æ­¤æ“ä½œæ— æ³•æ’¤é”€",
    "cancel": "å–æ¶ˆ",
    "confirm": "ç¡®è®¤"
  },
  "update": {
    "title": "ğŸ‰ æ–°ç‰ˆæœ¬å¯ç”¨",
    "description": "å‘ç°æ–°ç‰ˆæœ¬ v{{version}}ï¼Œæ˜¯å¦ç«‹å³å®‰è£…æ›´æ–°ï¼Ÿ",
    "installNote": "ç‚¹å‡»â€œå®‰è£…æ›´æ–°â€å°†é‡å¯åº”ç”¨å¹¶å®‰è£…ã€‚",
    "laterButton": "ç¨åæé†’",
    "installButton": "å®‰è£…æ›´æ–°",
    "installing": "æ­£åœ¨å®‰è£…..."
  },
  "auth": {
    "login": "ç™»å½•",
    "logout": "é€€å‡ºç™»å½•",
    "loginToJaaz": "ç™»å½•åˆ° Jaaz",
    "myAccount": "æˆ‘çš„è´¦æˆ·",
    "loginDescription": "ç™»å½•åå¯ä»¥ä½¿ç”¨äº‘ç«¯ AI æ¨¡å‹",
    "startLogin": "å¼€å§‹ç™»å½•",
    "preparingLogin": "å‡†å¤‡ç™»å½•ä¸­...",
    "cancel": "å–æ¶ˆ",
    "loginSuccessMessage": "ç™»å½•æˆåŠŸï¼",
    "authExpiredMessage": "æˆæƒå·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•",
    "authErrorMessage": "æ£€æŸ¥æˆæƒçŠ¶æ€æ—¶å‘ç”Ÿé”™è¯¯",
    "waitingForBrowser": "ç­‰å¾…æµè§ˆå™¨ä¸­å®Œæˆç™»å½•...",
    "pollErrorMessage": "æ£€æŸ¥ç™»å½•çŠ¶æ€å¤±è´¥ï¼Œè¯·é‡è¯•",
    "preparingLoginMessage": "æ­£åœ¨å‡†å¤‡ç™»å½•...",
    "browserLoginMessage": "è¯·åœ¨æµè§ˆå™¨ä¸­å®Œæˆç™»å½•",
    "loginRequestFailed": "ç™»å½•è¯·æ±‚å¤±è´¥ï¼Œè¯·é‡è¯•",
    "logoutSuccessMessage": "å·²æˆåŠŸç™»å‡º",
    "notLoggedIn": "æœªç™»å½•",
    "balance": "ä½™é¢",
    "recharge": "å……å€¼"
  },
  "socket": {
    "connectionError": "è¿æ¥é”™è¯¯ ({{current}}/{{max}}): {{error}}",
    "maxRetriesReached": "è¿æ¥å¤±è´¥ï¼Œè¯·é‡å¯åº”ç”¨é‡è¯•"
  }
}



================================================
FILE: react/src/i18n/locales/zh-CN/home.json
================================================
{
  "title": "ä½ å¥½ï¼ŒJaazï¼",
  "subtitle": "å‡†å¤‡å¥½å°†ä½ çš„æƒ³æ³•å˜æˆè‰ºæœ¯å—ï¼Ÿ",
  "allProjects": "æ‰€æœ‰é¡¹ç›®",
  "noCanvases": "è¿˜æ²¡æœ‰ç”»å¸ƒ",
  "newCanvas": "æœªå‘½å"
}



================================================
FILE: react/src/i18n/locales/zh-CN/settings.json
================================================
{
  "title": "è®¾ç½®",
  "messages": {
    "settingsSaved": "è®¾ç½®ä¿å­˜æˆåŠŸ",
    "settingsReset": "è®¾ç½®å·²é‡ç½®ä¸ºé»˜è®¤å€¼",
    "failedToSave": "ä¿å­˜è®¾ç½®å¤±è´¥",
    "failedToLoad": "åŠ è½½é…ç½®å¤±è´¥",
    "restartRequired": "è¯·é‡å¯åº”ç”¨ä»¥ä½¿ä»£ç†è®¾ç½®ç”Ÿæ•ˆ"
  },
  "models": {
    "title": "æ¨¡å‹",
    "placeholder": "è¾“å…¥æ¨¡å‹åç§°",
    "addModel": "æ·»åŠ æ¨¡å‹",
    "types": {
      "text": "è¯­è¨€æ¨¡å‹",
      "image": "ç”Ÿå›¾æ¨¡å‹",
      "video": "è§†é¢‘ç”Ÿæˆæ¨¡å‹"
    }
  },
  "provider": {
    "title": "æä¾›å•†",
    "addProvider": "æ·»åŠ æä¾›å•†",
    "providerName": "æä¾›å•†åç§°",
    "providerNamePlaceholder": "è¾“å…¥æä¾›å•†åç§°",
    "apiUrl": "API åœ°å€",
    "apiUrlPlaceholder": "è¾“å…¥ API åœ°å€",
    "apiKey": "API å¯†é’¥",
    "apiKeyPlaceholder": "è¾“å…¥ API å¯†é’¥",
    "apiKeyDescription": "æ‚¨çš„ API å¯†é’¥å°†è¢«å®‰å…¨å­˜å‚¨",
    "maxTokens": "æœ€å¤§ä»¤ç‰Œæ•°",
    "maxTokensPlaceholder": "è¾“å…¥æœ€å¤§ä»¤ç‰Œæ•°",
    "maxTokensDescription": "å“åº”ä¸­çš„æœ€å¤§ä»¤ç‰Œæ•°",
    "customProvider": "âœ¨ è‡ªå®šä¹‰æä¾›å•†",
    "imageGeneration": "ğŸ¨ å›¾åƒç”Ÿæˆ",
    "delete": "åˆ é™¤",
    "save": "ä¿å­˜",
    "cancel": "å–æ¶ˆ",
    "noModelsSelected": "è¯·æ·»åŠ è‡³å°‘ä¸€ä¸ªæ¨¡å‹"
  },
  "proxy": {
    "title": "ä»£ç†è®¾ç½®",
    "mode": "ä»£ç†æ¨¡å¼",
    "selectMode": "é€‰æ‹©ä»£ç†æ¨¡å¼",
    "modes": {
      "no_proxy": "ä¸ä½¿ç”¨ä»£ç†",
      "system": "ç³»ç»Ÿä»£ç†",
      "custom": "è‡ªå®šä¹‰ä»£ç†"
    },
    "enable": "å¯ç”¨ä»£ç†",
    "url": "ä»£ç†åœ°å€",
    "urlPlaceholder": "http://proxy.example.com:8080",
    "testConnection": "æµ‹è¯•è¿æ¥",
    "testing": "æµ‹è¯•ä¸­...",
    "testSuccess": "ä»£ç†è¿æ¥æµ‹è¯•æˆåŠŸ",
    "testFailed": "ä»£ç†è¿æ¥æµ‹è¯•å¤±è´¥: {{message}}",
    "testError": "ä»£ç†è¿æ¥æµ‹è¯•å‡ºé”™",
    "status": {
      "enabled": "å·²å¯ç”¨",
      "disabled": "å·²ç¦ç”¨",
      "misconfigured": "é…ç½®é”™è¯¯"
    }
  },
  "comfyui": {
    "title": "ComfyUI",
    "localImageGeneration": "ğŸ¨ æœ¬åœ°å›¾åƒç”Ÿæˆ",
    "enable": "å¯ç”¨",
    "debugStatus": "ğŸ” è°ƒè¯•çŠ¶æ€",
    "status": {
      "disabled": "å·²ç¦ç”¨",
      "running": "è¿è¡Œä¸­",
      "installed": "å·²å®‰è£…ï¼ˆæœªè¿è¡Œï¼‰",
      "notInstalled": "æœªå®‰è£…",
      "notRunning": "æœªè¿è¡Œ",
      "checking": "æ£€æŸ¥ä¸­..."
    },
    "urlDescription": "ComfyUI æœåŠ¡åœ°å€ï¼Œå¦‚æœå·²å®‰è£…è¯·è¾“å…¥åœ°å€",
    "invalidUrl": "è¯·è¾“å…¥æœ‰æ•ˆçš„ URL åœ°å€ï¼ˆå¦‚ï¼šhttp://127.0.0.1:8188ï¼‰",
    "notInstalledTitle": "ComfyUI æœªå®‰è£…",
    "notInstalledDescription": "å®‰è£… ComfyUI ä»¥å¯ç”¨ Flux æ¨¡å‹çš„æœ¬åœ°å›¾åƒç”Ÿæˆ",
    "installButton": "å®‰è£… ComfyUI",
    "startButton": "å¯åŠ¨ ComfyUI",
    "uninstallButton": "å¸è½½ ComfyUI",
    "confirmUninstall": "ç¡®å®šè¦å¸è½½ ComfyUI å—ï¼Ÿè¿™å°†å®Œå…¨ä»æ‚¨çš„ç³»ç»Ÿä¸­ç§»é™¤ ComfyUIï¼ŒåŒ…æ‹¬æ‰€æœ‰å·²ä¸‹è½½çš„æ¨¡å‹å’Œé…ç½®ã€‚",
    "confirmUninstallButton": "ç¡®è®¤å¸è½½",
    "uninstallProgress": {
      "title": "æ­£åœ¨å¸è½½ ComfyUI",
      "preparing": "å‡†å¤‡å¸è½½ä¸­...",
      "inProgress": "å¸è½½è¿›è¡Œä¸­... è¯·ç¨å€™ã€‚",
      "logTitle": "å¸è½½æ—¥å¿—ï¼š",
      "completed": "å¸è½½å®Œæˆ"
    },
    "notInstalled": "ComfyUI æœªå®‰è£…",
    "deleteWorkflowConfirmation": "æ‚¨ç¡®å®šè¦åˆ é™¤æ­¤å·¥ä½œæµå—ï¼Ÿ",
    "addInput": "æ·»åŠ è¾“å…¥å‚æ•°",
    "editWorkflow": "ç¼–è¾‘å·¥ä½œæµ",
    "addWorkflow": "æ·»åŠ å·¥ä½œæµ",
    "save": "ä¿å­˜",
    "submit": "æäº¤",
    "uploadWorkflowApiJson": "ä¸Šä¼ å·¥ä½œæµAPI JSON",
    "workflowInputsConfiguration": "å·¥ä½œæµè¾“å…¥å‚æ•°è®¾ç½®",
    "defaultValue": "é»˜è®¤å€¼",
    "describeInput": "è¯·æè¿°è¿™ä¸ªå‚æ•°æ˜¯åšä»€ä¹ˆçš„ï¼Œè®©LLMå¯ä»¥ç†è§£è¿™ä¸ªå‚æ•°çš„ä½œç”¨ï¼Œæ¥æ›´æ™ºèƒ½çš„è°ƒç”¨å·¥å…·ï¼ŒåŠ¨æ€ä¼ å…¥æ­£ç¡®å‚æ•°",
    "workflowName": "å·¥ä½œæµåç§°ï¼Œåªèƒ½åŒ…å«a-Z, 0-9, ä¸‹åˆ’çº¿_",
    "workflowDescription": "å·¥ä½œæµæè¿°ï¼Œæè¿°å·¥ä½œæµçš„ç”¨é€”ï¼ŒåŠŸèƒ½ä½œç”¨ï¼Œè®©å¤§æ¨¡å‹æ›´å¥½çš„è°ƒç”¨",
    "workflowNameInvalid": "å·¥ä½œæµåç§°åªèƒ½å…è®¸å­—æ¯ã€æ•°å­—ã€ä¸‹åˆ’çº¿ï¼Œä»¥æ–¹ä¾¿å¤§æ¨¡å‹åŠ¨æ€è°ƒç”¨"
  },
  "saveSettings": "ä¿å­˜è®¾ç½®",
  "close": "å…³é—­",
  "cancel": "å–æ¶ˆ"
}



================================================
FILE: react/src/lib/event.ts
================================================
import * as ISocket from '@/types/socket'
import mitt from 'mitt'

export type TCanvasAddImagesToChatEvent = {
  fileId: string
  base64?: string
  width: number
  height: number
}[]

export type TCanvasMagicGenerateEvent = {
  fileId: string
  base64: string
  width: number
  height: number
  timestamp: string
}

export type TMaterialAddImagesToChatEvent = {
  filePath: string
  fileName: string
  fileType: string
  width?: number
  height?: number
}[]

export type TEvents = {
  // ********** Socket events - Start **********
  'Socket::Session::Error': ISocket.SessionErrorEvent
  'Socket::Session::Done': ISocket.SessionDoneEvent
  'Socket::Session::Info': ISocket.SessionInfoEvent
  'Socket::Session::ImageGenerated': ISocket.SessionImageGeneratedEvent
  'Socket::Session::VideoGenerated': ISocket.SessionVideoGeneratedEvent
  'Socket::Session::Delta': ISocket.SessionDeltaEvent
  'Socket::Session::ToolCall': ISocket.SessionToolCallEvent
  'Socket::Session::ToolCallArguments': ISocket.SessionToolCallArgumentsEvent
  'Socket::Session::ToolCallResult': ISocket.SessionToolCallResultEvent
  'Socket::Session::AllMessages': ISocket.SessionAllMessagesEvent
  'Socket::Session::ToolCallProgress': ISocket.SessionToolCallProgressEvent
  'Socket::Session::ToolCallPendingConfirmation': ISocket.SessionToolCallPendingConfirmationEvent
  'Socket::Session::ToolCallConfirmed': ISocket.SessionToolCallConfirmedEvent
  'Socket::Session::ToolCallCancelled': ISocket.SessionToolCallCancelledEvent
  // ********** Socket events - End **********

  // ********** Canvas events - Start **********
  'Canvas::AddImagesToChat': TCanvasAddImagesToChatEvent
  'Canvas::MagicGenerate': TCanvasMagicGenerateEvent
  // ********** Canvas events - End **********

  // ********** Material events - Start **********
  'Material::AddImagesToChat': TMaterialAddImagesToChatEvent
  // ********** Material events - End **********
}

export const eventBus = mitt<TEvents>()



================================================
FILE: react/src/lib/notifications.ts
================================================
import { eventBus } from './event'

type NotificationType = 'canvas_update' | 'session_done' | 'error' | 'info'

export interface Notification {
  id: string
  type: NotificationType
  title: string
  message: string
  canvasId?: string
  sessionId?: string
  timestamp: Date
  read: boolean
  imageUrl?: string
}

class NotificationManager {
  private notifications: Notification[] = []
  private listeners: ((notifications: Notification[]) => void)[] = []
  private currentCanvasId: string | null = null

  constructor() {
    this.initializeEventListeners()
  }

  public setCurrentCanvasId(canvasId: string | null) {
    this.currentCanvasId = canvasId
  }

  private initializeEventListeners() {
    // Image Generated
    eventBus.on('Socket::Session::ImageGenerated', (data) => {
      this.addNotification({
        type: 'canvas_update',
        title: 'Image generated',
        message: 'Image added to canvas',
        canvasId: data.canvas_id,
        imageUrl: data.image_url,
      })
    })

    // Info
    eventBus.on('Socket::Session::Info', (data) => {
      this.addNotification({
        type: 'info',
        title: 'Info',
        message: data.info,
      })
    })
  }

  private addNotification(
    notification: Omit<Notification, 'id' | 'timestamp' | 'read'>
  ) {
    if (
      notification.type === 'canvas_update' &&
      notification.canvasId === this.currentCanvasId
    ) {
      return
    }

    const uniqueKey = `${notification.type}_${notification.title}_${notification.canvasId || ''}_${notification.sessionId || ''}`
    if (
      this.notifications.some(
        (n) =>
          `${n.type}_${n.title}_${n.canvasId || ''}_${n.sessionId || ''}` ===
          uniqueKey
      )
    ) {
      return
    }

    const newNotification: Notification = {
      ...notification,
      id: Date.now().toString(),
      timestamp: new Date(),
      read: false,
    }

    this.notifications.unshift(newNotification)

    if (this.notifications.length > 50) {
      this.notifications = this.notifications.slice(0, 50)
    }

    this.notifyListeners()
  }

  public getNotifications(): Notification[] {
    return [...this.notifications]
  }

  public getUnreadCount(): number {
    return this.notifications.filter((n) => !n.read).length
  }

  public markAsRead(id: string) {
    const notification = this.notifications.find((n) => n.id === id)
    if (notification) {
      notification.read = true
      this.notifyListeners()
    }
  }

  public markAllAsRead() {
    this.notifications.forEach((n) => (n.read = true))
    this.notifyListeners()
  }

  public clearNotifications() {
    this.notifications = []
    this.notifyListeners()
  }

  public subscribe(listener: (notifications: Notification[]) => void) {
    this.listeners.push(listener)
    return () => {
      const index = this.listeners.indexOf(listener)
      if (index > -1) {
        this.listeners.splice(index, 1)
      }
    }
  }

  private notifyListeners() {
    this.listeners.forEach((listener) => listener(this.notifications))
  }

  // Get canvas notifications
  public getCanvasNotifications(canvasId: string): Notification[] {
    return this.notifications.filter((n) => n.canvasId === canvasId)
  }

  // Get session notifications
  public getSessionNotifications(sessionId: string): Notification[] {
    return this.notifications.filter((n) => n.sessionId === sessionId)
  }
}

export const notificationManager = new NotificationManager()



================================================
FILE: react/src/lib/socket.ts
================================================
import * as ISocket from '@/types/socket'
import { io, Socket } from 'socket.io-client'
import { eventBus } from './event'

export interface SocketConfig {
  serverUrl?: string
  autoConnect?: boolean
}

export class SocketIOManager {
  private socket: Socket | null = null
  private connected = false
  private reconnectAttempts = 0
  private maxReconnectAttempts = 5
  private reconnectDelay = 1000

  constructor(private config: SocketConfig = {}) {
    if (config.autoConnect !== false) {
      this.connect()
    }
  }

  connect(serverUrl?: string): Promise<boolean> {
    return new Promise((resolve, reject) => {
      const url = serverUrl || this.config.serverUrl

      if (this.socket) {
        this.socket.disconnect()
      }

      this.socket = io(url, {
        transports: ['websocket'],
        upgrade: false,
        reconnection: true,
        reconnectionAttempts: this.maxReconnectAttempts,
        reconnectionDelay: this.reconnectDelay,
      })

      this.socket.on('connect', () => {
        console.log('âœ… Socket.IO connected:', this.socket?.id)
        this.connected = true
        this.reconnectAttempts = 0
        resolve(true)
      })

      this.socket.on('connect_error', (error) => {
        console.error('âŒ Socket.IO connection error:', error)
        this.connected = false
        this.reconnectAttempts++

        if (this.reconnectAttempts >= this.maxReconnectAttempts) {
          reject(
            new Error(
              `Failed to connect after ${this.maxReconnectAttempts} attempts`
            )
          )
        }
      })

      this.socket.on('disconnect', (reason) => {
        console.log('ğŸ”Œ Socket.IO disconnected:', reason)
        this.connected = false
      })

      this.registerEventHandlers()
    })
  }

  private registerEventHandlers() {
    if (!this.socket) return

    this.socket.on('connected', (data) => {
      console.log('ğŸ”— Socket.IO connection confirmed:', data)
    })

    this.socket.on('init_done', (data) => {
      console.log('ğŸ”— Server initialization done:', data)
    })

    this.socket.on('session_update', (data) => {
      this.handleSessionUpdate(data)
    })

    this.socket.on('pong', (data) => {
      console.log('ğŸ”— Pong received:', data)
    })
  }

  private handleSessionUpdate(data: ISocket.SessionUpdateEvent) {
    const { session_id, type } = data

    if (!session_id) {
      console.warn('âš ï¸ Session update missing session_id:', data)
      return
    }

    switch (type) {
      case ISocket.SessionEventType.Delta:
        eventBus.emit('Socket::Session::Delta', data)
        break
      case ISocket.SessionEventType.ToolCall:
        eventBus.emit('Socket::Session::ToolCall', data)
        break
      case ISocket.SessionEventType.ToolCallPendingConfirmation:
        eventBus.emit('Socket::Session::ToolCallPendingConfirmation', data)
        break
      case ISocket.SessionEventType.ToolCallConfirmed:
        eventBus.emit('Socket::Session::ToolCallConfirmed', data)
        break
      case ISocket.SessionEventType.ToolCallCancelled:
        eventBus.emit('Socket::Session::ToolCallCancelled', data)
        break
      case ISocket.SessionEventType.ToolCallArguments:
        eventBus.emit('Socket::Session::ToolCallArguments', data)
        break
      case ISocket.SessionEventType.ToolCallProgress:
        eventBus.emit('Socket::Session::ToolCallProgress', data)
        break
      case ISocket.SessionEventType.ImageGenerated:
        eventBus.emit('Socket::Session::ImageGenerated', data)
        break
      case ISocket.SessionEventType.VideoGenerated:
        eventBus.emit('Socket::Session::VideoGenerated', data)
        break
      case ISocket.SessionEventType.AllMessages:
        eventBus.emit('Socket::Session::AllMessages', data)
        break
      case ISocket.SessionEventType.Done:
        eventBus.emit('Socket::Session::Done', data)
        break
      case ISocket.SessionEventType.Error:
        eventBus.emit('Socket::Session::Error', data)
        break
      case ISocket.SessionEventType.Info:
        eventBus.emit('Socket::Session::Info', data)
        break
      case ISocket.SessionEventType.ToolCallResult:
        eventBus.emit('Socket::Session::ToolCallResult', data)
        break
      default:
        console.log('âš ï¸ Unknown session update type:', type)
    }
  }

  ping(data: unknown) {
    if (this.socket && this.connected) {
      this.socket.emit('ping', data)
    }
  }

  disconnect() {
    if (this.socket) {
      this.socket.disconnect()
      this.socket = null
      this.connected = false
      console.log('ğŸ”Œ Socket.IO manually disconnected')
    }
  }

  isConnected(): boolean {
    return this.connected
  }

  getSocketId(): string | undefined {
    return this.socket?.id
  }

  getSocket(): Socket | null {
    return this.socket
  }

  getReconnectAttempts(): number {
    return this.reconnectAttempts
  }

  isMaxReconnectAttemptsReached(): boolean {
    return this.reconnectAttempts >= this.maxReconnectAttempts
  }
}



================================================
FILE: react/src/lib/utils.ts
================================================
import { clsx, type ClassValue } from 'clsx'
import { twMerge } from 'tailwind-merge'

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

export function dataURLToFile(dataURL: string, filename: string) {
  const arr = dataURL.split(',')
  const mime = arr[0].match(/:(.*?);/)?.[1]
  const bstr = atob(arr[1])
  let n = bstr.length
  const u8arr = new Uint8Array(n)
  while (n--) {
    u8arr[n] = bstr.charCodeAt(n)
  }
  return new File([u8arr], filename, { type: mime })
}



================================================
FILE: react/src/routes/__root.tsx
================================================
import ErrorBoundary from '@/components/common/ErrorBoundary'
import { createRootRoute, Outlet } from '@tanstack/react-router'
import { TanStackRouterDevtools } from '@tanstack/react-router-devtools'

export const Route = createRootRoute({
  component: () => (
    <>
      <Outlet />
      <TanStackRouterDevtools />
    </>
  ),
  errorComponent: ErrorBoundary,
})



================================================
FILE: react/src/routes/agent_studio.tsx
================================================
import AgentStudio from '@/components/agent_studio/AgentStudio'
import { createFileRoute } from '@tanstack/react-router'

export const Route = createFileRoute('/agent_studio')({
  component: RouteComponent,
})

function RouteComponent() {
  return <AgentStudio />
}



================================================
FILE: react/src/routes/assets.tsx
================================================
import MaterialManager from '@/components/material/MaterialManager'
import TopMenu from '@/components/TopMenu'
import { ResizablePanel, ResizablePanelGroup } from '@/components/ui/resizable'
import { createFileRoute } from '@tanstack/react-router'

export const Route = createFileRoute('/assets')({
  component: Home,
})

function Home() {
  return (
    <div className="flex flex-col w-screen h-screen">
      <TopMenu />
      <ResizablePanelGroup
        direction="horizontal"
        className="w-screen h-screen"
        autoSaveId="jaaz-chat-panel"
      >
        <ResizablePanel className="relative" defaultSize={100}>
          <MaterialManager />
        </ResizablePanel>

        {/* <ResizableHandle /> */}

        {/* <ResizablePanel defaultSize={25} minSize={25}>
            <div className="flex-1 flex-grow bg-accent/50 w-full">
              <ChatInterface
                canvasId={canvasId}
                sessionList={sessionList}
                setSessionList={setSessionList}
                sessionId={sessionId}
              />
            </div>
          </ResizablePanel> */}
      </ResizablePanelGroup>
    </div>
  )
}



================================================
FILE: react/src/routes/canvas.$id.tsx
================================================
import { getCanvas, renameCanvas } from '@/api/canvas'
import CanvasExcali from '@/components/canvas/CanvasExcali'
import CanvasHeader from '@/components/canvas/CanvasHeader'
import CanvasMenu from '@/components/canvas/menu'
import CanvasPopbarWrapper from '@/components/canvas/pop-bar'
// VideoCanvasOverlay removed - using native Excalidraw embeddable elements instead
import ChatInterface from '@/components/chat/Chat'
import { ResizableHandle, ResizablePanel, ResizablePanelGroup } from '@/components/ui/resizable'
import { CanvasProvider } from '@/contexts/canvas'
import { Session } from '@/types/types'
import { createFileRoute, useParams, useSearch } from '@tanstack/react-router'
import { Loader2 } from 'lucide-react'
import { useEffect, useState } from 'react'

export const Route = createFileRoute('/canvas/$id')({
  component: Canvas,
})

function Canvas() {
  const { id } = useParams({ from: '/canvas/$id' })
  const [canvas, setCanvas] = useState<any>(null)
  const [isLoading, setIsLoading] = useState(true)
  const [error, setError] = useState<Error | null>(null)
  const [canvasName, setCanvasName] = useState('')
  const [sessionList, setSessionList] = useState<Session[]>([])
  // initialVideos removed - using native Excalidraw embeddable elements instead
  const search = useSearch({ from: '/canvas/$id' }) as {
    sessionId: string
  }
  const searchSessionId = search?.sessionId || ''
  useEffect(() => {
    let mounted = true

    const fetchCanvas = async () => {
      try {
        setIsLoading(true)
        setError(null)
        const data = await getCanvas(id)
        if (mounted) {
          setCanvas(data)
          setCanvasName(data.name)
          setSessionList(data.sessions)
          // Video elements now handled by native Excalidraw embeddable elements
        }
      } catch (err) {
        if (mounted) {
          setError(err instanceof Error ? err : new Error('Failed to fetch canvas data'))
          console.error('Failed to fetch canvas data:', err)
        }
      } finally {
        if (mounted) {
          setIsLoading(false)
        }
      }
    }

    fetchCanvas()

    return () => {
      mounted = false
    }
  }, [id])

  const handleNameSave = async () => {
    await renameCanvas(id, canvasName)
  }

  return (
    <CanvasProvider>
      <div className='flex flex-col w-screen h-screen'>
        <CanvasHeader
          canvasName={canvasName}
          canvasId={id}
          onNameChange={setCanvasName}
          onNameSave={handleNameSave}
        />
        <ResizablePanelGroup
          direction='horizontal'
          className='w-screen h-screen'
          autoSaveId='jaaz-chat-panel'
        >
          <ResizablePanel className='relative' defaultSize={75}>
            <div className='w-full h-full'>
              {isLoading ? (
                <div className='flex-1 flex-grow px-4 bg-accent w-[24%] absolute right-0'>
                  <div className='flex items-center justify-center h-full'>
                    <Loader2 className='w-4 h-4 animate-spin' />
                  </div>
                </div>
              ) : (
                <div className='relative w-full h-full'>
                  <CanvasExcali canvasId={id} initialData={canvas?.data} />
                  <CanvasMenu />
                  <CanvasPopbarWrapper />
                </div>
              )}
            </div>
          </ResizablePanel>

          <ResizableHandle />

          <ResizablePanel defaultSize={25}>
            <div className='flex-1 flex-grow bg-accent/50 w-full'>
              <ChatInterface
                canvasId={id}
                sessionList={sessionList}
                setSessionList={setSessionList}
                sessionId={searchSessionId}
              />
            </div>
          </ResizablePanel>
        </ResizablePanelGroup>
      </div>
    </CanvasProvider>
  )
}



================================================
FILE: react/src/routes/index.tsx
================================================
import { createCanvas } from '@/api/canvas'
import ChatTextarea from '@/components/chat/ChatTextarea'
import CanvasList from '@/components/home/CanvasList'
import { ScrollArea } from '@/components/ui/scroll-area'
import { useConfigs } from '@/contexts/configs'
import { DEFAULT_SYSTEM_PROMPT } from '@/constants'
import { useMutation } from '@tanstack/react-query'
import { createFileRoute, useNavigate } from '@tanstack/react-router'
import { motion } from 'motion/react'
import { nanoid } from 'nanoid'
import { useState } from 'react'
import { useTranslation } from 'react-i18next'
import { toast } from 'sonner'
import TopMenu from '@/components/TopMenu'

export const Route = createFileRoute('/')({
  component: Home,
})

function Home() {
  const navigate = useNavigate()
  const { t } = useTranslation()
  const { setInitCanvas } = useConfigs()

  const { mutate: createCanvasMutation, isPending } = useMutation({
    mutationFn: createCanvas,
    onSuccess: (data, variables) => {
      setInitCanvas(true)
      navigate({
        to: '/canvas/$id',
        params: { id: data.id },
        search: {
          sessionId: variables.session_id,
        },
      })
    },
    onError: (error) => {
      toast.error(t('common:messages.error'), {
        description: error.message,
      })
    },
  })

  return (
    <div className='flex flex-col h-screen'>
      <ScrollArea className='h-full'>
        <TopMenu />

        <div className='relative flex flex-col items-center justify-center h-fit min-h-[calc(100vh-460px)] pt-[60px] select-none'>
          <motion.div
            initial={{ opacity: 0, y: 10 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.5 }}
          >
            <h1 className='text-5xl font-bold mb-2 mt-8 text-center'>{t('home:title')}</h1>
          </motion.div>
          <motion.div
            initial={{ opacity: 0, y: 10 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.5 }}
          >
            <p className='text-xl text-gray-500 mb-8 text-center'>{t('home:subtitle')}</p>
          </motion.div>

          <ChatTextarea
            className='w-full max-w-xl'
            messages={[]}
            onSendMessages={(messages, configs) => {
              createCanvasMutation({
                name: t('home:newCanvas'),
                canvas_id: nanoid(),
                messages: messages,
                session_id: nanoid(),
                text_model: configs.textModel,
                tool_list: configs.toolList,
                system_prompt: localStorage.getItem('system_prompt') || DEFAULT_SYSTEM_PROMPT,
              })
            }}
            pending={isPending}
          />
        </div>

        <CanvasList />
      </ScrollArea>
    </div>
  )
}



================================================
FILE: react/src/routes/knowledge.tsx
================================================
import Knowledge from '@/components/knowledge/Knowledge'
import { createFileRoute } from '@tanstack/react-router'

export const Route = createFileRoute('/knowledge')({
  component: RouteComponent,
})

function RouteComponent() {
  return <Knowledge />
}



================================================
FILE: react/src/stores/canvas.ts
================================================
import { ExcalidrawImperativeAPI } from '@excalidraw/excalidraw/types'
import { create } from 'zustand'

type CanvasStore = {
  canvasId: string
  excalidrawAPI: ExcalidrawImperativeAPI | null

  setCanvasId: (canvasId: string) => void
  setExcalidrawAPI: (excalidrawAPI: ExcalidrawImperativeAPI) => void
}

const useCanvasStore = create<CanvasStore>((set) => ({
  canvasId: '',
  excalidrawAPI: null,

  setCanvasId: (canvasId) => set({ canvasId }),
  setExcalidrawAPI: (excalidrawAPI) => set({ excalidrawAPI }),
}))

export default useCanvasStore



================================================
FILE: react/src/stores/configs.ts
================================================
import { ModelInfo, ToolInfo } from '@/api/model'
import { LLMConfig, Model } from '@/types/types'
import { create } from 'zustand'

type ConfigsStore = {
  initCanvas: boolean
  setInitCanvas: (initCanvas: boolean) => void

  textModels: Model[]
  setTextModels: (models: Model[]) => void

  selectedTools: ToolInfo[]
  setSelectedTools: (models: ToolInfo[]) => void

  textModel?: Model
  setTextModel: (model?: Model) => void

  showInstallDialog: boolean
  setShowInstallDialog: (show: boolean) => void

  showUpdateDialog: boolean
  setShowUpdateDialog: (show: boolean) => void

  showSettingsDialog: boolean
  setShowSettingsDialog: (show: boolean) => void

  showLoginDialog: boolean
  setShowLoginDialog: (show: boolean) => void

  allTools: ToolInfo[]
  setAllTools: (tools: ToolInfo[]) => void

  providers: {
    [key: string]: LLMConfig
  }
  setProviders: (providers: { [key: string]: LLMConfig }) => void
}

const useConfigsStore = create<ConfigsStore>((set) => ({
  initCanvas: false,
  setInitCanvas: (initCanvas) => set({ initCanvas }),

  textModels: [],
  setTextModels: (models) => set({ textModels: models }),

  textModel: undefined,
  setTextModel: (model) => set({ textModel: model }),

  showInstallDialog: false,
  setShowInstallDialog: (show) => set({ showInstallDialog: show }),

  showUpdateDialog: false,
  setShowUpdateDialog: (show) => set({ showUpdateDialog: show }),

  showSettingsDialog: false,
  setShowSettingsDialog: (show) => set({ showSettingsDialog: show }),

  showLoginDialog: false,
  setShowLoginDialog: (show) => set({ showLoginDialog: show }),

  providers: {},
  setProviders: (providers) => set({ providers }),

  allTools: [],
  setAllTools: (tools) => set({ allTools: tools }),

  selectedTools: [],
  setSelectedTools: (tools) => set({ selectedTools: tools }),
}))

export default useConfigsStore



================================================
FILE: react/src/types/electron.d.ts
================================================
interface ElectronAPI {
  publishPost: (data: {
    channel: string
    title: string
    content: string
    images: string[]
    video: string
  }) => Promise<{ success?: boolean; error?: string }>
  pickImage: () => Promise<string[] | null>
  pickVideo: () => Promise<string | null>
  installComfyUI: () => Promise<{ success: boolean; error?: string }>
  uninstallComfyUI: () => Promise<{ success: boolean; error?: string }>
  cancelComfyUIInstall: () => Promise<{
    success?: boolean
    error?: string
    message?: string
  }>
  checkComfyUIInstalled: () => Promise<boolean>
  // ComfyUI process management methods
  startComfyUIProcess: () => Promise<{ success: boolean; message?: string }>
  stopComfyUIProcess: () => Promise<{ success: boolean; message?: string }>
  getComfyUIProcessStatus: () => Promise<{ running: boolean; pid?: number }>
  // Auto-updater methods
  checkForUpdates: () => Promise<{ message: string }>
  restartAndInstall: () => Promise<void>
  onUpdateDownloaded: (callback: (info: UpdateInfo) => void) => void
  removeUpdateDownloadedListener: () => void
  // Auth methods
  openBrowserUrl: (url: string) => Promise<{ success: boolean; error?: string }>
}

interface UpdateInfo {
  version: string
  files: unknown[]
  path: string
  sha512: string
  releaseDate: string
}

declare global {
  interface Window {
    electronAPI?: ElectronAPI
  }
}

export {}



================================================
FILE: react/src/types/socket.ts
================================================
import { ExcalidrawImageElement } from '@excalidraw/excalidraw/element/types'
import { BinaryFileData } from '@excalidraw/excalidraw/types'
import { Message, ToolCallFunctionName, ToolResultMessage } from './types'

export enum SessionEventType {
  Error = 'error',
  Done = 'done',
  Info = 'info',
  ImageGenerated = 'image_generated',
  VideoGenerated = 'video_generated',
  Delta = 'delta',
  ToolCall = 'tool_call',
  ToolCallArguments = 'tool_call_arguments',
  ToolCallResult = 'tool_call_result',
  AllMessages = 'all_messages',
  ToolCallProgress = 'tool_call_progress',
  ToolCallPendingConfirmation = 'tool_call_pending_confirmation',
  ToolCallConfirmed = 'tool_call_confirmed',
  ToolCallCancelled = 'tool_call_cancelled',
}

export interface SessionBaseEvent {
  session_id: string
}

export interface SessionErrorEvent extends SessionBaseEvent {
  type: SessionEventType.Error
  error: string
}
export interface SessionDoneEvent extends SessionBaseEvent {
  type: SessionEventType.Done
}
export interface SessionInfoEvent extends SessionBaseEvent {
  type: SessionEventType.Info
  info: string
}
export interface SessionImageGeneratedEvent extends SessionBaseEvent {
  type: SessionEventType.ImageGenerated
  element: ExcalidrawImageElement
  file: BinaryFileData
  canvas_id: string
  image_url: string
}
export interface SessionVideoGeneratedEvent extends SessionBaseEvent {
  type: SessionEventType.VideoGenerated
  element: any
  file: BinaryFileData & { duration?: number }
  canvas_id: string
  video_url: string
}

export interface SessionDeltaEvent extends SessionBaseEvent {
  type: SessionEventType.Delta
  text: string
}
export interface SessionToolCallEvent extends SessionBaseEvent {
  type: SessionEventType.ToolCall
  id: string
  name: ToolCallFunctionName
}
export interface SessionToolCallArgumentsEvent extends SessionBaseEvent {
  type: SessionEventType.ToolCallArguments
  id: string
  text: string
}
export interface SessionToolCallResultEvent extends SessionBaseEvent {
  type: SessionEventType.ToolCallResult
  id: string
  message: ToolResultMessage
}
export interface SessionAllMessagesEvent extends SessionBaseEvent {
  type: SessionEventType.AllMessages
  messages: Message[]
}
export interface SessionToolCallProgressEvent extends SessionBaseEvent {
  type: SessionEventType.ToolCallProgress
  tool_call_id: string
  update: string
}

export interface SessionToolCallPendingConfirmationEvent
  extends SessionBaseEvent {
  type: SessionEventType.ToolCallPendingConfirmation
  id: string
  name: ToolCallFunctionName
  arguments: string
}

export interface SessionToolCallConfirmedEvent extends SessionBaseEvent {
  type: SessionEventType.ToolCallConfirmed
  id: string
}

export interface SessionToolCallCancelledEvent extends SessionBaseEvent {
  type: SessionEventType.ToolCallCancelled
  id: string
}

export type SessionUpdateEvent =
  | SessionDeltaEvent
  | SessionToolCallEvent
  | SessionToolCallArgumentsEvent
  | SessionToolCallProgressEvent
  | SessionImageGeneratedEvent
  | SessionVideoGeneratedEvent
  | SessionAllMessagesEvent
  | SessionDoneEvent
  | SessionErrorEvent
  | SessionInfoEvent
  | SessionToolCallResultEvent
  | SessionToolCallPendingConfirmationEvent
  | SessionToolCallConfirmedEvent
  | SessionToolCallCancelledEvent



================================================
FILE: react/src/types/types.ts
================================================
import { OrderedExcalidrawElement } from '@excalidraw/excalidraw/element/types'
import { AppState, BinaryFiles } from '@excalidraw/excalidraw/types'

export type ToolCallFunctionName =
  | 'generate_image'
  | 'prompt_user_multi_choice'
  | 'prompt_user_single_choice'
  | 'write_plan'
  | 'finish'

export type ToolCall = {
  id: string
  type: 'function'
  function: {
    name: ToolCallFunctionName
    arguments: string
  }
  result?: string // Only for manually merged message list by mergeToolCallResult
}
export type MessageContentType = MessageContent[] | string
export type MessageContent =
  | { text: string; type: 'text' }
  | { image_url: { url: string }; type: 'image_url' }

export type ToolResultMessage = {
  role: 'tool'
  tool_call_id: string
  content: string
}
export type AssistantMessage = {
  role: 'assistant'
  tool_calls?: ToolCall[]
  content?: MessageContent[] | string
}
export type UserMessage = {
  role: 'user'
  content: MessageContent[] | string
}
export type Message = UserMessage | AssistantMessage | ToolResultMessage

export type PendingType = 'text' | 'image' | 'tool' | false

export interface ChatSession {
  id: string
  model: string
  provider: string
  title: string | null
  created_at: string
  updated_at: string
}
export interface MessageGroup {
  id: number
  role: string
  messages: Message[]
}

export enum EAgentState {
  IDLE = 'IDLE',
  RUNNING = 'RUNNING',
  FINISHED = 'FINISHED',
  ERROR = 'ERROR',
}

export type LLMConfig = {
  models: Record<
    string,
    {
      type?: 'text' | 'image' | 'video'
      is_custom?: boolean
      is_disabled?: boolean
    }
  >
  url: string
  api_key: string
  max_tokens?: number
  is_custom?: boolean
}

export interface AppStateWithVideos extends AppState {
  videoElements?: any[]
}

export type CanvasData = {
  elements: Readonly<OrderedExcalidrawElement[]>
  appState: AppStateWithVideos
  files: BinaryFiles
}

export type Session = {
  created_at: string
  id: string
  model: string
  provider: string
  title: string
  updated_at: string
}

export type Model = {
  provider: string
  model: string
  url: string
}



================================================
FILE: react/src/utils/formatDate.ts
================================================
import i18next from "i18next"

export function formatDate(isoString: string): string {
    if (!isoString) return ''
    const date = new Date(isoString)
    const locale = i18next.language || 'en'
    return date.toLocaleString(locale, {
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit',
    })
  }
  



================================================
FILE: react/src/utils/imageUtils.ts
================================================
/**
 * Simple image processing utilities
 */

import { dataURLToFile } from '@/lib/utils'

interface ProcessedImage {
  url: string
  filename: string
}

/**
 * Convert file to base64 data URL
 */
function fileToBase64(file: File): Promise<string> {
  return new Promise((resolve, reject) => {
    const reader = new FileReader()
    reader.onload = () => resolve(reader.result as string)
    reader.onerror = () =>
      reject(new Error(`Failed to read file: ${file.name}`))
    reader.readAsDataURL(file)
  })
}

/**
 * Compress large image (>2MB) to ~1MB
 */
function compressLargeImage(file: File): Promise<string> {
  return new Promise((resolve, reject) => {
    const canvas = document.createElement('canvas')
    const ctx = canvas.getContext('2d')
    const img = new Image()

    img.onload = () => {
      try {
        // Calculate new dimensions (max 2048px)
        let { width, height } = img
        const maxSize = 2048

        if (width > maxSize || height > maxSize) {
          const ratio = Math.min(maxSize / width, maxSize / height)
          width = Math.round(width * ratio)
          height = Math.round(height * ratio)
        }

        canvas.width = width
        canvas.height = height

        // Draw and compress
        ctx?.drawImage(img, 0, 0, width, height)

        // Try different quality levels to get under 2MB
        let quality = 1
        let dataUrl: string
        let attempts = 0

        do {
          dataUrl = canvas.toDataURL('image/jpeg', quality)
          const size = Math.round(dataUrl.length * 0.75) // Estimate size

          // Stop if under 2MB or tried 5 times
          if (size <= 2048 * 1024 || attempts >= 5) {
            resolve(dataUrl)
            return
          }

          quality *= 0.8
          attempts++
        } while (attempts < 5)

        resolve(dataUrl)
      } catch (error) {
        reject(new Error(`Failed to compress image: ${file.name}`))
      }
    }

    img.onerror = () => reject(new Error(`Failed to load image: ${file.name}`))

    // Create object URL for the image
    const objectUrl = URL.createObjectURL(file)
    const originalOnload = img.onload
    img.onload = function (ev: Event) {
      URL.revokeObjectURL(objectUrl)
      return originalOnload?.call(this, ev)
    }

    img.src = objectUrl
  })
}

/**
 * Compress image file and return compressed File object
 */
export async function compressImageFile(file: File): Promise<File> {
  // Check file size (2MB = 2048KB)
  const fileSizeKB = file.size / 1024

  // If file is small enough, return as is
  if (fileSizeKB <= 2048) {
    return file
  }

  console.log(
    `Compressing large image: ${file.name} (${Math.round(fileSizeKB)}KB)`
  )

  try {
    const compressedDataURL = await compressLargeImage(file)
    const compressedFile = dataURLToFile(compressedDataURL, file.name)

    console.log(
      `Image compressed: ${file.name} (${Math.round(fileSizeKB)}KB â†’ ${Math.round(compressedFile.size / 1024)}KB)`
    )

    return compressedFile
  } catch (error) {
    console.warn(
      `Failed to compress image ${file.name}, using original:`,
      error
    )
    return file
  }
}

/**
 * Process image files - compress only if larger than 2MB
 */
export async function processImageFiles(
  files: File[]
): Promise<ProcessedImage[]> {
  const results = await Promise.allSettled(
    files.map(async (file) => {
      // Check file size (2MB = 2048KB)
      const fileSizeKB = file.size / 1024

      let url: string
      if (fileSizeKB > 2048) {
        // Large file - compress it
        console.log(
          `[Silent] Compressing large image: ${file.name} (${Math.round(fileSizeKB)}KB)`
        )
        url = await compressLargeImage(file)
      } else {
        // Small file - use as is
        url = await fileToBase64(file)
      }

      return {
        url,
        filename: file.name,
      }
    })
  )

  // Extract successful results
  const processedImages: ProcessedImage[] = []
  const errors: string[] = []

  results.forEach((result, index) => {
    if (result.status === 'fulfilled') {
      processedImages.push(result.value)
    } else {
      errors.push(`${files[index].name}: ${result.reason.message}`)
    }
  })

  // Handle errors
  if (errors.length > 0 && processedImages.length === 0) {
    throw new Error(`All images failed to process:\n${errors.join('\n')}`)
  }

  if (errors.length > 0) {
    console.warn('Some images failed to process:', errors)
  }

  return processedImages
}



================================================
FILE: react/src/utils/pngMetadata.ts
================================================
/**
 * PNG Metadata Reader - å‰ç«¯ç›´æ¥è¯»å–PNGæ–‡ä»¶çš„metadata
 *
 * PNGæ–‡ä»¶æ ¼å¼ï¼š
 * - PNG signature: 8å­—èŠ‚
 * - Chunks: æ¯ä¸ªchunkåŒ…å«é•¿åº¦(4å­—èŠ‚) + ç±»å‹(4å­—èŠ‚) + æ•°æ® + CRC(4å­—èŠ‚)
 * - æ–‡æœ¬ä¿¡æ¯å­˜å‚¨åœ¨tEXtã€zTXtã€iTXt chunksä¸­
 * - ä¼˜åŒ–ï¼šåªè¯»å–metadata chunksï¼Œä¸è¯»å–å›¾åƒæ•°æ®
 */

interface PngChunk {
  length: number
  type: string
  data: Uint8Array
  crc: number
}

interface PngMetadata {
  success: boolean
  metadata: Record<string, any>
  has_metadata: boolean
  error?: string
}

/**
 * ä»ArrayBufferä¸­è¯»å–4å­—èŠ‚big-endianæ•´æ•°
 */
function readUint32BE(buffer: Uint8Array, offset: number): number {
  return (
    (buffer[offset] << 24) |
    (buffer[offset + 1] << 16) |
    (buffer[offset + 2] << 8) |
    buffer[offset + 3]
  )
}

/**
 * ä»ArrayBufferä¸­è¯»å–å­—ç¬¦ä¸²
 */
function readString(
  buffer: Uint8Array,
  offset: number,
  length: number
): string {
  return new TextDecoder('utf-8').decode(buffer.slice(offset, offset + length))
}

/**
 * æ£€æŸ¥PNGæ–‡ä»¶å¤´
 */
function isPNG(buffer: Uint8Array): boolean {
  const pngSignature = [0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]
  if (buffer.length < 8) return false

  for (let i = 0; i < 8; i++) {
    if (buffer[i] !== pngSignature[i]) return false
  }
  return true
}

/**
 * è§£æPNG chunksï¼Œåªè§£æmetadataç›¸å…³çš„chunks
 */
function parsePNGMetadataChunks(buffer: Uint8Array): PngChunk[] {
  const chunks: PngChunk[] = []
  let offset = 8 // è·³è¿‡PNG signature

  while (offset < buffer.length - 8) {
    if (offset + 8 > buffer.length) break

    const length = readUint32BE(buffer, offset)
    const type = readString(buffer, offset + 4, 4)

    // å¦‚æœæ²¡æœ‰è¶³å¤Ÿçš„æ•°æ®æ¥è¯»å–å®Œæ•´çš„chunkï¼Œé€€å‡ºå¾ªç¯
    if (offset + 12 + length > buffer.length) break

    // å¦‚æœé‡åˆ°å›¾åƒæ•°æ®chunkï¼Œè¯´æ˜metadataéƒ¨åˆ†å·²ç»ç»“æŸï¼Œå¯ä»¥åœæ­¢è§£æ
    if (type === 'IDAT') {
      console.log('Reached IDAT chunk, stopping metadata parsing')
      break
    }

    const data = buffer.slice(offset + 8, offset + 8 + length)
    const crc = readUint32BE(buffer, offset + 8 + length)

    chunks.push({ length, type, data, crc })

    offset += 12 + length

    // å¦‚æœé‡åˆ°IEND chunkï¼Œåœæ­¢è§£æ
    if (type === 'IEND') break
  }

  return chunks
}

/**
 * è§£ætEXt chunk
 */
function parseTextChunk(data: Uint8Array): [string, string] | null {
  try {
    const text = new TextDecoder('latin1').decode(data)
    const nullIndex = text.indexOf('\0')
    if (nullIndex === -1) return null

    const keyword = text.substring(0, nullIndex)
    const value = text.substring(nullIndex + 1)

    return [keyword, value]
  } catch (error) {
    console.error('Error parsing tEXt chunk:', error)
    return null
  }
}

/**
 * è§£æzTXt chunk (å‹ç¼©æ–‡æœ¬)
 */
function parseZTextChunk(data: Uint8Array): [string, string] | null {
  try {
    const text = new TextDecoder('latin1').decode(data)
    const nullIndex = text.indexOf('\0')
    if (nullIndex === -1) return null

    const keyword = text.substring(0, nullIndex)
    // è·³è¿‡compression method byte
    const compressedData = data.slice(nullIndex + 2)

    // è¿™é‡Œéœ€è¦zlibè§£å‹ç¼©ï¼Œä¸ºäº†ç®€åŒ–æˆ‘ä»¬å…ˆè·³è¿‡zTXt
    console.warn('zTXt chunk found but decompression not implemented')
    return [keyword, '[Compressed Text - Not Implemented]']
  } catch (error) {
    console.error('Error parsing zTXt chunk:', error)
    return null
  }
}

/**
 * è§£æiTXt chunk (å›½é™…åŒ–æ–‡æœ¬)
 */
function parseITextChunk(data: Uint8Array): [string, string] | null {
  try {
    let offset = 0
    const text = new TextDecoder('utf-8').decode(data)

    // æŸ¥æ‰¾ç¬¬ä¸€ä¸ªnullå­—ç¬¦ï¼ˆkeywordç»“æŸï¼‰
    const keywordEnd = text.indexOf('\0')
    if (keywordEnd === -1) return null

    const keyword = text.substring(0, keywordEnd)
    offset = keywordEnd + 1

    // è·³è¿‡compression flagå’Œcompression method
    offset += 2

    // æŸ¥æ‰¾language tagç»“æŸ
    const languageEnd = text.indexOf('\0', offset)
    if (languageEnd === -1) return null
    offset = languageEnd + 1

    // æŸ¥æ‰¾translated keywordç»“æŸ
    const translatedEnd = text.indexOf('\0', offset)
    if (translatedEnd === -1) return null
    offset = translatedEnd + 1

    // å‰©ä½™çš„å°±æ˜¯æ–‡æœ¬å†…å®¹
    const value = text.substring(offset)

    return [keyword, value]
  } catch (error) {
    console.error('Error parsing iTXt chunk:', error)
    return null
  }
}

/**
 * æ¸è¿›å¼è¯»å–PNGæ–‡ä»¶ï¼Œåªè¯»å–metadataéƒ¨åˆ†
 */
async function readPNGHeaderAndMetadata(filePath: string): Promise<Uint8Array> {
  let totalBuffer = new Uint8Array(0)
  let offset = 0
  const chunkSize = 8192 // æ¯æ¬¡è¯»å–8KB
  let maxReadSize = 512 * 1024 // æœ€å¤§è¯»å–512KBï¼Œé¿å…æ— é™è¯»å–

  try {
    while (offset < maxReadSize) {
      // ä½¿ç”¨Rangeè¯·æ±‚è¯»å–ç‰¹å®šå­—èŠ‚èŒƒå›´
      const endByte = Math.min(offset + chunkSize - 1, maxReadSize - 1)
      const response = await fetch(filePath, {
        headers: { Range: `bytes=${offset}-${endByte}` },
      })

      if (!response.ok) {
        if (response.status === 416 || response.status === 206) {
          // å·²ç»è¯»å–åˆ°æ–‡ä»¶æœ«å°¾æˆ–å®Œæˆéƒ¨åˆ†å†…å®¹è¯»å–
          break
        }
        throw new Error(`Failed to fetch file: ${response.status}`)
      }

      const chunk = await response.arrayBuffer()
      if (chunk.byteLength === 0) break

      // åˆå¹¶ç¼“å†²åŒº
      const newBuffer = new Uint8Array(totalBuffer.length + chunk.byteLength)
      newBuffer.set(totalBuffer)
      newBuffer.set(new Uint8Array(chunk), totalBuffer.length)
      totalBuffer = newBuffer

      // æ£€æŸ¥æ˜¯å¦ä¸ºPNGæ–‡ä»¶ï¼ˆç¬¬ä¸€æ¬¡è¯»å–æ—¶ï¼‰
      if (offset === 0 && !isPNG(totalBuffer)) {
        throw new Error('Not a valid PNG file')
      }

      // å°è¯•è§£æå½“å‰æ•°æ®ï¼Œçœ‹æ˜¯å¦å·²ç»åŒ…å«è¶³å¤Ÿçš„metadata
      if (totalBuffer.length >= 8) {
        let parseOffset = 8 // è·³è¿‡PNG signature
        let foundIDAT = false
        let hasValidChunks = false

        while (parseOffset < totalBuffer.length - 8) {
          if (parseOffset + 8 > totalBuffer.length) break

          const length = readUint32BE(totalBuffer, parseOffset)
          if (parseOffset + 12 + length > totalBuffer.length) {
            // å½“å‰chunkè¿˜æ²¡æœ‰å®Œå…¨ä¸‹è½½ï¼Œç»§ç»­è¯»å–
            break
          }

          const type = readString(totalBuffer, parseOffset + 4, 4)
          hasValidChunks = true

          if (type === 'IDAT') {
            foundIDAT = true
            console.log(
              `Found IDAT at offset ${parseOffset}, stopping progressive read`
            )
            break
          }

          parseOffset += 12 + length
        }

        // å¦‚æœæ‰¾åˆ°äº†IDATæˆ–è€…å·²ç»æœ‰æœ‰æ•ˆçš„chunksï¼Œå¯ä»¥åœæ­¢è¯»å–
        if (
          foundIDAT ||
          (hasValidChunks && parseOffset >= totalBuffer.length - 8)
        ) {
          console.log(
            `Progressive read complete. Total read: ${totalBuffer.length} bytes`
          )
          break
        }
      }

      offset += chunk.byteLength

      // å¦‚æœè¯»å–çš„æ•°æ®å°‘äºè¯·æ±‚çš„æ•°æ®ï¼Œè¯´æ˜å·²ç»åˆ°æ–‡ä»¶æœ«å°¾
      if (chunk.byteLength < chunkSize) {
        break
      }
    }

    return totalBuffer
  } catch (error) {
    console.error('Error during progressive read:', error)
    throw error
  }
}

/**
 * ä»PNGæ–‡ä»¶ä¸­æå–metadata (ä¼˜åŒ–ç‰ˆæœ¬)
 */
export async function readPNGMetadata(filePath: string): Promise<PngMetadata> {
  try {
    console.log('Starting PNG metadata extraction for:', filePath)

    // æ¸è¿›å¼è¯»å–PNGæ–‡ä»¶çš„å¤´éƒ¨å’Œmetadataéƒ¨åˆ†
    const buffer = await readPNGHeaderAndMetadata(filePath)

    console.log(`Read ${buffer.length} bytes for metadata extraction`)

    // è§£æPNG chunks (åªè§£æmetadataç›¸å…³çš„)
    const chunks = parsePNGMetadataChunks(buffer)
    const metadata: Record<string, any> = {}

    console.log(`Found ${chunks.length} chunks before image data`)

    // å¤„ç†æ–‡æœ¬chunks
    for (const chunk of chunks) {
      let result: [string, string] | null = null

      switch (chunk.type) {
        case 'tEXt':
          result = parseTextChunk(chunk.data)
          break
        case 'zTXt':
          result = parseZTextChunk(chunk.data)
          break
        case 'iTXt':
          result = parseITextChunk(chunk.data)
          break
      }

      if (result) {
        const [key, value] = result
        try {
          // å°è¯•è§£æJSON
          if (value.startsWith('{') || value.startsWith('[')) {
            metadata[key] = JSON.parse(value)
          } else {
            metadata[key] = value
          }
        } catch (e) {
          metadata[key] = value
        }
      }
    }

    console.log(`Extracted ${Object.keys(metadata).length} metadata entries`)

    return {
      success: true,
      metadata,
      has_metadata: Object.keys(metadata).length > 0,
    }
  } catch (error) {
    console.error('Error reading PNG metadata:', error)
    return {
      success: false,
      metadata: {},
      has_metadata: false,
      error: error instanceof Error ? error.message : 'Unknown error',
    }
  }
}

/**
 * æ£€æŸ¥æ–‡ä»¶æ˜¯å¦ä¸ºPNGæ ¼å¼ (ä¼˜åŒ–ç‰ˆæœ¬)
 */
export async function isPNGFile(filePath: string): Promise<boolean> {
  try {
    const response = await fetch(filePath, {
      headers: { Range: 'bytes=0-7' }, // åªè·å–å‰8å­—èŠ‚
    })

    if (!response.ok) return false

    const arrayBuffer = await response.arrayBuffer()
    const buffer = new Uint8Array(arrayBuffer)

    return isPNG(buffer)
  } catch (error) {
    console.error('Error checking PNG file:', error)
    return false
  }
}



================================================
FILE: scripts/notarize.js
================================================
// scripts/notarize.js
import { notarize } from "@electron/notarize";

export default async function notarizing(context) {
  const { electronPlatformName, appOutDir } = context;
  if (electronPlatformName !== "darwin") return;
  const appPath = `${appOutDir}/Jaaz.app`;
  console.log("appPath", appPath);
  return await notarize({
    appPath,
    appleId: process.env.APPLE_ID,
    appleIdPassword: process.env.APPLE_APP_PASSWORD,
    teamId: process.env.TEAM_ID,
  });
}



================================================
FILE: server/common.py
================================================
import os

DEFAULT_PORT = int(os.environ.get('DEFAULT_PORT', 57988))



================================================
FILE: server/main.py
================================================
import os
import sys
import io
# Ensure stdout and stderr use utf-8 encoding to prevent emoji logs from crashing python server
sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding="utf-8")
sys.stderr = io.TextIOWrapper(sys.stderr.buffer, encoding="utf-8")
print('Importing websocket_router')
from routers.websocket_router import *  # DO NOT DELETE THIS LINE, OTHERWISE, WEBSOCKET WILL NOT WORK
print('Importing routers')
from routers import config_router, image_router, root_router, workspace, canvas, ssl_test, chat_router, settings, tool_confirmation
from fastapi.responses import FileResponse
from fastapi.staticfiles import StaticFiles
from fastapi import FastAPI
import argparse
from contextlib import asynccontextmanager
from starlette.types import Scope
from starlette.responses import Response
import socketio # type: ignore
print('Importing websocket_state')
from services.websocket_state import sio
print('Importing websocket_service')
from services.websocket_service import broadcast_init_done
print('Importing config_service')
from services.config_service import config_service
print('Importing tool_service')
from services.tool_service import tool_service

async def initialize():
    print('Initializing config_service')
    await config_service.initialize()
    print('Initializing broadcast_init_done')
    await broadcast_init_done()

root_dir = os.path.dirname(__file__)

@asynccontextmanager
async def lifespan(app: FastAPI):
    # onstartup
    # TODO: Check if there will be racing conditions when user send chat request but tools and models are not initialized yet.
    await initialize()
    await tool_service.initialize()
    yield
    # onshutdown

print('Creating FastAPI app')
app = FastAPI(lifespan=lifespan)

# Include routers
print('Including routers')
app.include_router(config_router.router)
app.include_router(settings.router)
app.include_router(root_router.router)
app.include_router(canvas.router)
app.include_router(workspace.router)
app.include_router(image_router.router)
app.include_router(ssl_test.router)
app.include_router(chat_router.router)
app.include_router(tool_confirmation.router)

# Mount the React build directory
react_build_dir = os.environ.get('UI_DIST_DIR', os.path.join(
    os.path.dirname(root_dir), "react", "dist"))


# æ— ç¼“å­˜é™æ€æ–‡ä»¶ç±»
class NoCacheStaticFiles(StaticFiles):
    async def get_response(self, path: str, scope: Scope) -> Response:
        response = await super().get_response(path, scope)
        if response.status_code == 200:
            response.headers["Cache-Control"] = "no-store, no-cache, must-revalidate, max-age=0"
            response.headers["Pragma"] = "no-cache"
            response.headers["Expires"] = "0"
        return response


static_site = os.path.join(react_build_dir, "assets")
if os.path.exists(static_site):
    app.mount("/assets", NoCacheStaticFiles(directory=static_site), name="assets")


@app.get("/")
async def serve_react_app():
    response = FileResponse(os.path.join(react_build_dir, "index.html"))
    response.headers["Cache-Control"] = "no-store, no-cache, must-revalidate, max-age=0"
    response.headers["Pragma"] = "no-cache"
    response.headers["Expires"] = "0"
    return response

print('Creating socketio app')
socket_app = socketio.ASGIApp(sio, other_asgi_app=app, socketio_path='/socket.io')

if __name__ == "__main__":
    # bypass localhost request for proxy, fix ollama proxy issue
    _bypass = {"127.0.0.1", "localhost", "::1"}
    current = set(os.environ.get("no_proxy", "").split(",")) | set(
        os.environ.get("NO_PROXY", "").split(","))
    os.environ["no_proxy"] = os.environ["NO_PROXY"] = ",".join(
        sorted(_bypass | current - {""}))

    parser = argparse.ArgumentParser()
    parser.add_argument('--port', type=int, default=57988,
                        help='Port to run the server on')
    args = parser.parse_args()
    import uvicorn
    print("ğŸŒŸStarting server, UI_DIST_DIR:", os.environ.get('UI_DIST_DIR'))

    uvicorn.run(socket_app, host="127.0.0.1", port=args.port)



================================================
FILE: server/main.spec
================================================
# -*- mode: python ; coding: utf-8 -*-
import certifi
import os

a = Analysis(
    ['main.py'],
    pathex=[],
    binaries=[],
    datas=[(certifi.where(), 'certifi'), ('asset', 'asset')],
    hiddenimports=['certifi'],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    noarchive=False,
    optimize=0,
)
pyz = PYZ(a.pure)

exe = EXE(
    pyz,
    a.scripts,
    [],
    exclude_binaries=True,
    name='main',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    console=True,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
)
coll = COLLECT(
    exe,
    a.binaries,
    a.datas,
    strip=False,
    upx=True,
    upx_exclude=[],
    name='main',
)



================================================
FILE: server/requirements.txt
================================================
fastapi
uvicorn[standard]
anthropic
mcp
toml
pyinstaller
openai
ollama
httpx
aiohttp
gunicorn
aiosqlite
requests
Pillow
nanoid
python-multipart
aiofiles
certifi
websocket-client # needed for comfyui execution
rich # needed for comfyui execution
typer # needed for comfyui execution
langgraph==0.4.8
langgraph-checkpoint==2.0.26
langgraph-prebuilt==0.2.2
langgraph-sdk==0.1.70
langgraph-swarm==0.0.11
langchain-ollama==0.3.3
langchain-openai==0.3.21
python-socketio==5.13.0
pymediainfo
openai-agents
socksio # For vpn from command line like export https_proxy=http://127.0.0.1:7897 http_proxy=http://127.0.0.1:7897 all_proxy=socks5://127.0.0.1:7897
piexif # For EXIF metadata handling in JPEG files 



================================================
FILE: server/asset/default_comfy_t2i_workflow.json
================================================
{
  "3": {
    "inputs": {
      "seed": 1119423977597512,
      "steps": 20,
      "cfg": 8,
      "sampler_name": "euler",
      "scheduler": "normal",
      "denoise": 1,
      "model": ["4", 0],
      "positive": ["6", 0],
      "negative": ["7", 0],
      "latent_image": ["5", 0]
    },
    "class_type": "KSampler",
    "_meta": {
      "title": "KSampler"
    }
  },
  "4": {
    "inputs": {
      "ckpt_name": "v1-5-pruned-emaonly.ckpt"
    },
    "class_type": "CheckpointLoaderSimple",
    "_meta": {
      "title": "Load Checkpoint"
    }
  },
  "5": {
    "inputs": {
      "width": 512,
      "height": 512,
      "batch_size": 1
    },
    "class_type": "EmptyLatentImage",
    "_meta": {
      "title": "Empty Latent Image"
    }
  },
  "6": {
    "inputs": {
      "text": "beautiful scenery nature glass bottle landscape, , purple galaxy bottle,",
      "clip": ["4", 1]
    },
    "class_type": "CLIPTextEncode",
    "_meta": {
      "title": "CLIP Text Encode (Prompt)"
    }
  },
  "7": {
    "inputs": {
      "text": "text, watermark",
      "clip": ["4", 1]
    },
    "class_type": "CLIPTextEncode",
    "_meta": {
      "title": "CLIP Text Encode (Prompt)"
    }
  },
  "8": {
    "inputs": {
      "samples": ["3", 0],
      "vae": ["4", 2]
    },
    "class_type": "VAEDecode",
    "_meta": {
      "title": "VAE Decode"
    }
  },
  "9": {
    "inputs": {
      "filename_prefix": "ComfyUI",
      "images": ["8", 0]
    },
    "class_type": "SaveImage",
    "_meta": {
      "title": "Save Image"
    }
  }
}



================================================
FILE: server/asset/flux_comfy_workflow.json
================================================
{
  "6": {
    "inputs": {
      "text": "a bottle with a beautiful rainbow galaxy inside it on top of a wooden table in the middle of a modern kitchen beside a plate of vegetables and mushrooms and a wine glasse that contains a planet earth with a plate with a half eaten apple pie on it",
      "clip": ["30", 1]
    },
    "class_type": "CLIPTextEncode",
    "_meta": {
      "title": "CLIP Text Encode (Positive Prompt)"
    }
  },
  "8": {
    "inputs": {
      "samples": ["31", 0],
      "vae": ["30", 2]
    },
    "class_type": "VAEDecode",
    "_meta": {
      "title": "VAE Decode"
    }
  },
  "9": {
    "inputs": {
      "filename_prefix": "ComfyUI",
      "images": ["8", 0]
    },
    "class_type": "SaveImage",
    "_meta": {
      "title": "Save Image"
    }
  },
  "27": {
    "inputs": {
      "width": 1024,
      "height": 1024,
      "batch_size": 1
    },
    "class_type": "EmptySD3LatentImage",
    "_meta": {
      "title": "EmptySD3LatentImage"
    }
  },
  "30": {
    "inputs": {
      "ckpt_name": "flux1-schnell-fp8.safetensors"
    },
    "class_type": "CheckpointLoaderSimple",
    "_meta": {
      "title": "Load Checkpoint"
    }
  },
  "31": {
    "inputs": {
      "seed": 447689078885528,
      "steps": 20,
      "cfg": 1,
      "sampler_name": "euler",
      "scheduler": "simple",
      "denoise": 1,
      "model": ["30", 0],
      "positive": ["6", 0],
      "negative": ["33", 0],
      "latent_image": ["27", 0]
    },
    "class_type": "KSampler",
    "_meta": {
      "title": "KSampler"
    }
  },
  "33": {
    "inputs": {
      "text": "",
      "clip": ["30", 1]
    },
    "class_type": "CLIPTextEncode",
    "_meta": {
      "title": "CLIP Text Encode (Negative Prompt)"
    }
  }
}



================================================
FILE: server/models/__init__.py
================================================
[Empty file]


================================================
FILE: server/models/config_model.py
================================================
from pydantic import BaseModel
from typing import Literal, TypedDict

class LLMConfig(BaseModel):
    model: str
    base_url: str
    api_key: str
    max_tokens: int
    temperature: float

class ConfigUpdate(BaseModel):
    llm: LLMConfig

class ModelInfo(TypedDict):
    provider: str
    model: str # For tool type, it is the function name
    url: str
    type: Literal['text', 'image', 'tool', 'video']



================================================
FILE: server/models/db_model.py
================================================
from pydantic import BaseModel


class ComfyWorkflow(BaseModel):
    id: int
    name: str
    description: str
    inputs: str
    outputs: str



================================================
FILE: server/models/tool_model.py
================================================
from typing import Optional, TypedDict
from langchain_core.tools import BaseTool

class ToolInfoRequired(TypedDict):
    tool_function: BaseTool
    provider: str

class ToolInfoOptional(TypedDict, total=False):
    display_name: Optional[str]
    type: Optional[str]

class ToolInfo(ToolInfoRequired, ToolInfoOptional):
    pass

class ToolInfoJsonRequired(TypedDict):
    provider: str
    id: str

class ToolInfoJson(ToolInfoJsonRequired, ToolInfoOptional):
    pass


================================================
FILE: server/routers/__init__.py
================================================
[Empty file]


================================================
FILE: server/routers/canvas.py
================================================
from fastapi import APIRouter, Request
#from routers.agent import chat
from services.chat_service import handle_chat
from services.db_service import db_service
import asyncio
import json

router = APIRouter(prefix="/api/canvas")

@router.get("/list")
async def list_canvases():
    return await db_service.list_canvases()

@router.post("/create")
async def create_canvas(request: Request):
    data = await request.json()
    id = data.get('canvas_id')
    name = data.get('name')

    asyncio.create_task(handle_chat(data))
    await db_service.create_canvas(id, name)
    return {"id": id }

@router.get("/{id}")
async def get_canvas(id: str):
    return await db_service.get_canvas_data(id)

@router.post("/{id}/save")
async def save_canvas(id: str, request: Request):
    payload = await request.json()
    data_str = json.dumps(payload['data'])
    await db_service.save_canvas_data(id, data_str, payload['thumbnail'])
    return {"id": id }

@router.post("/{id}/rename")
async def rename_canvas(id: str, request: Request):
    data = await request.json()
    name = data.get('name')
    await db_service.rename_canvas(id, name)
    return {"id": id }

@router.delete("/{id}/delete")
async def delete_canvas(id: str):
    await db_service.delete_canvas(id)
    return {"id": id }


================================================
FILE: server/routers/chat_router.py
================================================
#server/routers/chat_router.py
from fastapi import APIRouter, Request
from services.chat_service import handle_chat
from services.magic_service import handle_magic
from services.stream_service import get_stream_task
from typing import Dict

router = APIRouter(prefix="/api")

@router.post("/chat")
async def chat(request: Request):
    """
    Endpoint to handle chat requests.

    Receives a JSON payload from the client, passes it to the chat handler,
    and returns a success status.

    Request body:
        JSON object containing chat data.

    Response:
        {"status": "done"}
    """
    data = await request.json()
    await handle_chat(data)
    return {"status": "done"}

@router.post("/cancel/{session_id}")
async def cancel_chat(session_id: str):
    """
    Endpoint to cancel an ongoing stream task for a given session_id.

    If the task exists and is not yet completed, it will be cancelled.

    Path parameter:
        session_id (str): The ID of the session whose task should be cancelled.

    Response:
        {"status": "cancelled"} if the task was cancelled.
        {"status": "not_found_or_done"} if no such task exists or it is already done.
    """
    task = get_stream_task(session_id)
    if task and not task.done():
        task.cancel()
        return {"status": "cancelled"}
    return {"status": "not_found_or_done"}

@router.post("/magic")
async def magic(request: Request):
    """
    Endpoint to handle magic generation requests.

    Receives a JSON payload from the client, passes it to the magic handler,
    and returns a success status.

    Request body:
        JSON object containing magic generation data.

    Response:
        {"status": "done"}
    """
    data = await request.json()
    await handle_magic(data)
    return {"status": "done"}

@router.post("/magic/cancel/{session_id}")
async def cancel_magic(session_id: str) -> Dict[str, str]:
    """
    Endpoint to cancel an ongoing magic generation task for a given session_id.

    If the task exists and is not yet completed, it will be cancelled.

    Path parameter:
        session_id (str): The ID of the session whose task should be cancelled.

    Response:
        {"status": "cancelled"} if the task was cancelled.
        {"status": "not_found_or_done"} if no such task exists or it is already done.
    """
    task = get_stream_task(session_id)
    if task and not task.done():
        task.cancel()
        return {"status": "cancelled"}
    return {"status": "not_found_or_done"}



================================================
FILE: server/routers/comfyui_execution.py
================================================
import json
import os
from socket import timeout
import sys
import time
import urllib.error
import urllib.parse
import uuid
from datetime import timedelta
import asyncio

import httpx
import websockets
import typer
from rich import print as pprint
from rich.progress import BarColumn, Column, Progress, Table, TimeElapsedColumn
from utils.http_client import HttpClient

from services.websocket_service import send_to_websocket


async def check_comfy_server_running(base_url):
    async with HttpClient.create(timeout=10) as client:
        url = f"{base_url}/api/prompt"
        response = await client.get(url)
        return response.status_code == 200


async def execute(
    workflow: dict,
    base_url,
    wait=True,
    verbose=False,
    local_paths=False,
    timeout=300,
    ctx: dict = {},
):
    if not await check_comfy_server_running(base_url):
        pprint(
            f"[bold red]ComfyUI not running on specified address ({base_url})[/bold red]"
        )
        raise typer.Exit(code=1)

    progress = None
    start = time.time()
    if wait:
        pprint("Executing comfyui workflow")
        progress = ExecutionProgress()
        # Remove or comment out the line below to avoid starting the live display
        # progress.start()
    else:
        print("Queuing comfyui workflow")

    execution = WorkflowExecution(
        workflow, base_url, verbose, progress, local_paths, timeout, ctx=ctx
    )

    try:
        if wait:
            await execution.connect()
        await execution.queue()
        if wait:
            await execution.watch_execution()
            end = time.time()
            progress.stop()
            progress = None

            if len(execution.outputs) > 0:
                pprint("[bold green]\nOutputs:[/bold green]")

                for f in execution.outputs:
                    pprint(f)

            elapsed = timedelta(seconds=end - start)
            pprint(
                f"[bold green]\nWorkflow execution completed ({elapsed})[/bold green]"
            )
        else:
            pprint("[bold green]Workflow queued[/bold green]")
    finally:
        if progress:
            progress.stop()
    return execution


class ExecutionProgress(Progress):
    def get_renderables(self):
        table_columns = (
            (
                Column(no_wrap=True)
                if isinstance(_column, str)
                else _column.get_table_column().copy()
            )
            for _column in self.columns
        )

        for task in self.tasks:
            percent = "[progress.percentage]{task.percentage:>3.0f}%".format(task=task)
            if task.fields.get("progress_type") == "overall":
                overall_table = Table.grid(
                    *table_columns, padding=(0, 1), expand=self.expand
                )
                overall_table.add_row(
                    BarColumn().render(task), percent, TimeElapsedColumn().render(task)
                )
                yield overall_table
            else:
                yield self.make_tasks_table([task])


class WorkflowExecution:
    def __init__(
        self,
        workflow,
        base_url,
        verbose,
        progress,
        local_paths,
        timeout=30,
        ctx: dict = {},
    ):
        self.workflow = workflow
        self.base_url = base_url
        self.verbose = verbose
        self.local_paths = local_paths
        self.client_id = str(uuid.uuid4())
        self.outputs = []
        self.progress = progress
        self.remaining_nodes = set(self.workflow.keys())
        self.total_nodes = len(self.remaining_nodes)
        if progress:
            self.overall_task = self.progress.add_task(
                "", total=self.total_nodes, progress_type="overall"
            )
        self.current_node = None
        self.progress_task = None
        self.progress_node = None
        self.prompt_id = None
        self.ws = None
        self.timeout = timeout
        self.ctx = ctx

    async def connect(self):
        if self.base_url.startswith("https"):
            self.ws_core = "wss://"
        else:
            self.ws_core = "ws://"
        ws_url = self.base_url.split("//")[1]
        if "/" in ws_url:
            ws_url = ws_url.split("/")[0]
        self.ws = await websockets.connect(
            f"{self.ws_core}{ws_url}/ws?clientId={self.client_id}"
        )

    async def queue(self):
        data = {"prompt": self.workflow, "client_id": self.client_id}
        async with HttpClient.create() as client:
            try:
                response = await client.post(f"{self.base_url}/prompt", json=data)
                body = response.json()
                self.prompt_id = body["prompt_id"]
            except httpx.HTTPStatusError as e:
                message = "An unknown error occurred"
                if e.response.status_code == 500:
                    message = e.response.text
                elif e.response.status_code == 400:
                    body = e.response.json()
                    if body["node_errors"].keys():
                        message = json.dumps(body["node_errors"], indent=2)

                self.progress.stop()

                pprint(f"[bold red]Error running workflow\n{message}[/bold red]")
                await send_to_websocket(
                    self.ctx.get("session_id"), {"type": "error", "error": message}
                )
                raise Exception(message)

    async def watch_execution(self):
        async for message in self.ws:
            if isinstance(message, str):
                message = json.loads(message)
                if message.get("data", {}).get("prompt_id") != self.prompt_id:
                    continue
                if not await self.on_message(message):
                    # get task_id and check if task_id is saved to prompt
                    async with HttpClient.create() as client:
                        try:
                            response = await client.get(f"{self.base_url}/history/{self.prompt_id}")
                            if response.status_code != 200:
                                raise Exception(response)
                            response_body = response.json()
                            if self.prompt_id in response_body:
                                break
                            else:
                                continue
                        except Exception as e:
                            pprint(f"[bold red]Error getting history\n{str(e)}[/bold red]")
                            raise Exception(message)

    def update_overall_progress(self):
        self.progress.update(
            self.overall_task, completed=self.total_nodes - len(self.remaining_nodes)
        )

    def get_node_title(self, node_id):
        node = self.workflow[node_id]
        if "_meta" in node and "title" in node["_meta"]:
            return node["_meta"]["title"]
        return node["class_type"]

    def log_node(self, type, node_id):
        if not self.verbose:
            return

        node = self.workflow[node_id]
        class_type = node["class_type"]
        title = self.get_node_title(node_id)

        if title != class_type:
            title += f"[bright_black] - {class_type}[/]"
        title += f"[bright_black] ({node_id})[/]"

        pprint(f"{type} : {title}")

    def format_image_path(self, img):
        query = urllib.parse.urlencode(img)
        return f"{self.base_url}/view?{query}"

    async def on_message(self, message):
        data = message["data"] if "data" in message else {}
        if "prompt_id" not in data or data["prompt_id"] != self.prompt_id:
            return True

        if message["type"] == "status":
            return await self.on_status(data)
        elif message["type"] == "executing":
            return await self.on_executing(data)
        elif message["type"] == "execution_cached":
            await self.on_cached(data)
        elif message["type"] == "progress":
            await self.on_progress(data)
        elif message["type"] == "executed":
            await self.on_executed(data)
        elif message["type"] == "execution_error":
            await self.on_error(data)

        return True

    async def on_status(self, data):
        queue = data['data']['status']['exec_info']['queue_remaining']
        await send_to_websocket(
            self.ctx.get("session_id"),
            {
                "type": "tool_call_progress",
                "tool_call_id": self.ctx.get("tool_call_id"),
                "session_id": self.ctx.get("session_id"),
                "update": f"In queue, there's {queue} works ahead...",
            },
        )

    async def on_executing(self, data):
        if self.progress_task:
            self.progress.remove_task(self.progress_task)
            self.progress_task = None

        if data["node"] is None:
            return False
        else:
            if self.current_node:
                self.remaining_nodes.discard(self.current_node)
                self.update_overall_progress()
            # Use display_node if available, otherwise use node
            node_id = data.get("display_node", data.get('node'))
            
            self.current_node = node_id
            self.log_node("Executing", node_id)
            if self.ctx.get("session_id"):
                await send_to_websocket(
                    self.ctx.get("session_id"),
                    {
                        "type": "tool_call_progress",
                        "tool_call_id": self.ctx.get("tool_call_id"),
                        "session_id": self.ctx.get("session_id"),
                        "update": f"Executing {self.get_node_title(node_id)}",
                    },
                )
        return True

    async def on_cached(self, data):
        nodes = data["nodes"]
        for n in nodes:
            self.remaining_nodes.discard(n)
            self.log_node("Cached", n)
        self.update_overall_progress()

    async def on_progress(self, data):
        node = data["node"]
        if self.ctx.get("session_id"):
            await send_to_websocket(
                self.ctx.get("session_id"),
                {
                    "type": "tool_call_progress",
                    "tool_call_id": self.ctx.get("tool_call_id"),
                    "session_id": self.ctx.get("session_id"),
                    "update": f"Executing {self.get_node_title(node)} {round(data['value'] / data['max'] * 100)}%",
                },
            )
        if self.progress_node != node:
            self.progress_node = node
            if self.progress_task:
                self.progress.remove_task(self.progress_task)

            self.progress_task = self.progress.add_task(
                self.get_node_title(node), total=data["max"], progress_type="node"
            )

        self.progress.update(self.progress_task, completed=data["value"])

    async def on_executed(self, data):
        self.remaining_nodes.discard(data["node"])
        self.update_overall_progress()

        if "output" not in data:
            return

        output = data["output"]

        if output is None:
            return

        for img in output.get("images", []):
            self.outputs.append(self.format_image_path(img))

        for gif in output.get("gifs", []):
            self.outputs.append(self.format_image_path(gif))

        await send_to_websocket(
            self.ctx.get("session_id"),
            {
                "type": "tool_call_progress",
                "tool_call_id": self.ctx.get("tool_call_id"),
                "session_id": self.ctx.get("session_id"),
                "update": "",  # clear the progress update section by send empty string
            },
        )

    async def on_error(self, data):
        pprint(
            f"[bold red]Error running workflow\n{json.dumps(data, indent=2)}[/bold red]"
        )
        await send_to_websocket(
            self.ctx.get("session_id"),
            {"type": "error", "error": json.dumps(data, indent=2)},
        )
        raise Exception(json.dumps(data, indent=2))


async def upload_image(image, base_url, filename=None, subfolder='jaaz'):
    # Create a tuple with (filename, file_content) for proper multipart upload
    files = {"image": (filename, image)}
    data = {"type": "input", "subfolder": subfolder, "overwrite": "false"}
    async with HttpClient.create() as client:
        try:
            response = await client.post(
                f"{base_url}/upload/image", files=files, data=data
            )
            body = response.json()
            image_name = body["name"]
            return f"{subfolder}/{image_name}"
        except httpx.HTTPStatusError as e:
            message = "An unknown error occurred"
            if e.response.status_code == 500:
                message = e.response.text
            elif e.response.status_code == 400:
                body = e.response.json()
                if body["node_errors"].keys():
                    message = json.dumps(body["node_errors"], indent=2)
            pprint(f"[bold red]Error uploading image\n{message}[/bold red]")
            raise Exception(message)



================================================
FILE: server/routers/config_router.py
================================================
from fastapi import APIRouter, Request
from services.config_service import config_service
# from tools.video_models_dynamic import register_video_models  # Disabled video models
from services.tool_service import tool_service

router = APIRouter(prefix="/api/config")


@router.get("/exists")
async def config_exists():
    return {"exists": config_service.exists_config()}


@router.get("")
async def get_config():
    return config_service.app_config


@router.post("")
async def update_config(request: Request):
    data = await request.json()
    res = await config_service.update_config(data)

    # æ¯æ¬¡æ›´æ–°é…ç½®åï¼Œé‡æ–°åˆå§‹åŒ–å·¥å…·
    await tool_service.initialize()
    return res



================================================
FILE: server/routers/image_router.py
================================================
from fastapi.responses import FileResponse
from fastapi.concurrency import run_in_threadpool
from common import DEFAULT_PORT
from tools.utils.image_canvas_utils import generate_file_id
from services.config_service import FILES_DIR

from PIL import Image
from io import BytesIO
import os
from fastapi import APIRouter, HTTPException, UploadFile, File
import httpx
import aiofiles
from mimetypes import guess_type
from utils.http_client import HttpClient

router = APIRouter(prefix="/api")
os.makedirs(FILES_DIR, exist_ok=True)

# ä¸Šä¼ å›¾ç‰‡æ¥å£ï¼Œæ”¯æŒè¡¨å•æäº¤
@router.post("/upload_image")
async def upload_image(file: UploadFile = File(...), max_size_mb: float = 3.0):
    print('ğŸ¦„upload_image file', file.filename)
    # ç”Ÿæˆæ–‡ä»¶ ID å’Œæ–‡ä»¶å
    file_id = generate_file_id()
    filename = file.filename or ''

    # Read the file content
    try:
        content = await file.read()
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error reading file: {e}")
    original_size_mb = len(content) / (1024 * 1024)  # Convert to MB

    # Open the image from bytes to get its dimensions
    with Image.open(BytesIO(content)) as img:
        width, height = img.size
        
        # Check if compression is needed
        if original_size_mb > max_size_mb:
            print(f'ğŸ¦„ Image size ({original_size_mb:.2f}MB) exceeds limit ({max_size_mb}MB), compressing...')
            
            # Convert to RGB if necessary (for JPEG compression)
            if img.mode in ('RGBA', 'LA', 'P'):
                # Create a white background for transparent images
                background = Image.new('RGB', img.size, (255, 255, 255))
                if img.mode == 'P':
                    img = img.convert('RGBA')
                background.paste(img, mask=img.split()[-1] if img.mode == 'RGBA' else None)
                img = background
            elif img.mode != 'RGB':
                img = img.convert('RGB')
            
            # Compress the image
            compressed_content = compress_image(img, max_size_mb)
            
            # Save compressed image using Image.save
            extension = 'jpg'  # Force JPEG for compressed images
            file_path = os.path.join(FILES_DIR, f'{file_id}.{extension}')
            
            # Create new image from compressed content and save
            with Image.open(BytesIO(compressed_content)) as compressed_img:
                width, height = compressed_img.size
                await run_in_threadpool(compressed_img.save, file_path, format='JPEG', quality=95, optimize=True)
                # compressed_img.save(file_path, format='JPEG', quality=95, optimize=True)
            
            final_size_mb = len(compressed_content) / (1024 * 1024)
            print(f'ğŸ¦„ Compressed from {original_size_mb:.2f}MB to {final_size_mb:.2f}MB')
        else:
            # Determine the file extension from original file
            mime_type, _ = guess_type(filename)
            if mime_type and mime_type.startswith('image/'):
                extension = mime_type.split('/')[-1]
                # Handle common image format mappings
                if extension == 'jpeg':
                    extension = 'jpg'
            else:
                extension = 'jpg'  # Default to jpg for unknown types
            
            # Save original image using Image.save
            file_path = os.path.join(FILES_DIR, f'{file_id}.{extension}')
            
            # Determine save format based on extension
            save_format = 'JPEG' if extension.lower() in ['jpg', 'jpeg'] else extension.upper()
            if save_format == 'JPEG':
                img = img.convert('RGB')
            
            # img.save(file_path, format=save_format)
            await run_in_threadpool(img.save, file_path, format=save_format)

    # è¿”å›æ–‡ä»¶ä¿¡æ¯
    print('ğŸ¦„upload_image file_path', file_path)
    return {
        'file_id': f'{file_id}.{extension}',
        'url': f'http://localhost:{DEFAULT_PORT}/api/file/{file_id}.{extension}',
        'width': width,
        'height': height,
    }


def compress_image(img: Image.Image, max_size_mb: float) -> bytes:
    """
    Compress an image to be under the specified size limit.
    """
    # Start with high quality
    quality = 95
    
    while quality > 10:
        # Save to bytes buffer
        buffer = BytesIO()
        img.save(buffer, format='JPEG', quality=quality, optimize=True)
        
        # Check size
        size_mb = len(buffer.getvalue()) / (1024 * 1024)
        
        if size_mb <= max_size_mb:
            return buffer.getvalue()
        
        # Reduce quality for next iteration
        quality -= 10
    
    # If still too large, try reducing dimensions
    original_width, original_height = img.size
    scale_factor = 0.8
    
    while scale_factor > 0.3:
        new_width = int(original_width * scale_factor)
        new_height = int(original_height * scale_factor)
        resized_img = img.resize((new_width, new_height), Image.Resampling.LANCZOS)
        
        # Try with moderate quality
        buffer = BytesIO()
        resized_img.save(buffer, format='JPEG', quality=70, optimize=True)
        
        size_mb = len(buffer.getvalue()) / (1024 * 1024)
        
        if size_mb <= max_size_mb:
            return buffer.getvalue()
        
        scale_factor -= 0.1
    
    # Last resort: very low quality
    buffer = BytesIO()
    resized_img.save(buffer, format='JPEG', quality=30, optimize=True)
    return buffer.getvalue()


# æ–‡ä»¶ä¸‹è½½æ¥å£
@router.get("/file/{file_id}")
async def get_file(file_id: str):
    file_path = os.path.join(FILES_DIR, f'{file_id}')
    print('ğŸ¦„get_file file_path', file_path)
    if not os.path.exists(file_path):
        raise HTTPException(status_code=404, detail="File not found")
    return FileResponse(file_path)


@router.post("/comfyui/object_info")
async def get_object_info(data: dict):
    url = data.get('url', '')
    if not url:
        raise HTTPException(status_code=400, detail="URL is required")

    try:
        timeout = httpx.Timeout(10.0)
        async with HttpClient.create(timeout=timeout) as client:
            response = await client.get(f"{url}/api/object_info")
            if response.status_code == 200:
                return response.json()
            else:
                raise HTTPException(
                    status_code=response.status_code, detail=f"ComfyUI server returned status {response.status_code}")
    except Exception as e:
        if "ConnectError" in str(type(e)) or "timeout" in str(e).lower():
            print(f"ComfyUI connection error: {str(e)}")
            raise HTTPException(
                status_code=503, detail="ComfyUI server is not available. Please make sure ComfyUI is running.")
        print(f"Unexpected error connecting to ComfyUI: {str(e)}")
        raise HTTPException(
            status_code=500, detail=f"Failed to connect to ComfyUI: {str(e)}")



================================================
FILE: server/routers/root_router.py
================================================
import os
from fastapi import APIRouter
import requests
import httpx
from models.tool_model import ToolInfoJson
from services.tool_service import tool_service
from services.config_service import config_service
from services.db_service import db_service
from utils.http_client import HttpClient
# services
from models.config_model import ModelInfo
from typing import List
from services.tool_service import TOOL_MAPPING

router = APIRouter(prefix="/api")


def get_ollama_model_list() -> List[str]:
    base_url = config_service.get_config().get('ollama', {}).get(
        'url', os.getenv('OLLAMA_HOST', 'http://localhost:11434'))
    try:
        response = requests.get(f'{base_url}/api/tags', timeout=5)
        response.raise_for_status()
        data = response.json()
        return [model['name'] for model in data.get('models', [])]
    except requests.RequestException as e:
        print(f"Error querying Ollama: {e}")
        return []


async def get_comfyui_model_list(base_url: str) -> List[str]:
    """Get ComfyUI model list from object_info API"""
    try:
        timeout = httpx.Timeout(10.0)
        async with HttpClient.create(timeout=timeout) as client:
            response = await client.get(f"{base_url}/api/object_info")
            if response.status_code == 200:
                data = response.json()
                # Extract models from CheckpointLoaderSimple node
                models = data.get('CheckpointLoaderSimple', {}).get(
                    'input', {}).get('required', {}).get('ckpt_name', [[]])[0]
                return models if isinstance(models, list) else []  # type: ignore
            else:
                print(f"ComfyUI server returned status {response.status_code}")
                return []
    except Exception as e:
        print(f"Error querying ComfyUI: {e}")
        return []

# List all LLM models
@router.get("/list_models")
async def get_models() -> list[ModelInfo]:
    config = config_service.get_config()
    res: List[ModelInfo] = []

    # Handle Ollama models separately
    ollama_url = config.get('ollama', {}).get(
        'url', os.getenv('OLLAMA_HOST', 'http://localhost:11434'))
    # Add Ollama models if URL is available
    if ollama_url and ollama_url.strip():
        ollama_models = get_ollama_model_list()
        for ollama_model in ollama_models:
            res.append({
                'provider': 'ollama',
                'model': ollama_model,
                'url': ollama_url,
                'type': 'text'
            })

    for provider in config.keys():
        if provider in ['ollama']:
            continue

        provider_config = config[provider]
        provider_url = provider_config.get('url', '').strip()
        provider_api_key = provider_config.get('api_key', '').strip()

        # Skip provider if URL is empty or API key is empty
        if not provider_url or not provider_api_key:
            continue

        models = provider_config.get('models', {})
        for model_name in models:
            model = models[model_name]
            model_type = model.get('type', 'text')
            # Only return text models
            if model_type == 'text':
                res.append({
                    'provider': provider,
                    'model': model_name,
                    'url': provider_url,
                    'type': model_type
                })
    return res


@router.get("/list_tools")
async def list_tools() -> list[ToolInfoJson]:
    config = config_service.get_config()
    res: list[ToolInfoJson] = []
    for tool_id, tool_info in tool_service.tools.items():
        if tool_info.get('provider') == 'system':
            continue
        provider = tool_info['provider']
        provider_api_key = config[provider].get('api_key', '').strip()
        if provider != 'comfyui' and not provider_api_key:
            continue
        res.append({
            'id': tool_id,
            'provider': tool_info.get('provider', ''),
            'type': tool_info.get('type', ''),
            'display_name': tool_info.get('display_name', ''),
        })

    # Handle ComfyUI models separately
    # comfyui_config = config.get('comfyui', {})
    # comfyui_url = comfyui_config.get('url', '').strip()
    # comfyui_config_models = comfyui_config.get('models', {})
    # if comfyui_url:
    #     comfyui_models = await get_comfyui_model_list(comfyui_url)
    #     for comfyui_model in comfyui_models:
    #         if comfyui_model in comfyui_config_models:
    #             res.append({
    #                 'provider': 'comfyui',
    #                 'model': comfyui_model,
    #                 'url': comfyui_url,
    #                 'type': 'image'
    #             })

    return res


@router.get("/list_chat_sessions")
async def list_chat_sessions():
    return await db_service.list_sessions()


@router.get("/chat_session/{session_id}")
async def get_chat_session(session_id: str):
    return await db_service.get_chat_history(session_id)



================================================
FILE: server/routers/settings.py
================================================
"""
Settings Router - è®¾ç½®è·¯ç”±æ¨¡å—

è¯¥æ¨¡å—æä¾›è®¾ç½®ç›¸å…³çš„ API è·¯ç”±ç«¯ç‚¹ï¼ŒåŒ…æ‹¬ï¼š
- è®¾ç½®æ–‡ä»¶å­˜åœ¨æ€§æ£€æŸ¥
- è®¾ç½®çš„è·å–å’Œæ›´æ–°
- ä»£ç†é…ç½®ç®¡ç†
- ä»£ç†è¿æ¥æµ‹è¯•

ä¸»è¦ç«¯ç‚¹ï¼š
- GET /api/settings/exists - æ£€æŸ¥è®¾ç½®æ–‡ä»¶æ˜¯å¦å­˜åœ¨
- GET /api/settings - è·å–æ‰€æœ‰è®¾ç½®ï¼ˆæ•æ„Ÿä¿¡æ¯å·²æ©ç ï¼‰
- POST /api/settings - æ›´æ–°è®¾ç½®
- GET /api/settings/proxy/status - è·å–ä»£ç†çŠ¶æ€
- GET /api/settings/proxy/test - æµ‹è¯•ä»£ç†è¿æ¥
- GET /api/settings/proxy - è·å–ä»£ç†è®¾ç½®
- POST /api/settings/proxy - æ›´æ–°ä»£ç†è®¾ç½®
- GET /api/settings/knowledge/enabled - è·å–å¯ç”¨çš„çŸ¥è¯†åº“åˆ—è¡¨
ä¾èµ–æ¨¡å—ï¼š
- services.settings_service - è®¾ç½®æœåŠ¡
- services.db_service - æ•°æ®åº“æœåŠ¡
- services.config_service - é…ç½®æœåŠ¡
- services.knowledge_service - çŸ¥è¯†åº“æœåŠ¡
"""

import json
import os
import shutil
import httpx
from fastapi import APIRouter, HTTPException, Request, UploadFile, File, Form
from services.db_service import db_service
from services.settings_service import settings_service
from services.tool_service import tool_service
from services.knowledge_service import list_user_enabled_knowledge
from pydantic import BaseModel

# åˆ›å»ºè®¾ç½®ç›¸å…³çš„è·¯ç”±å™¨ï¼Œæ‰€æœ‰ç«¯ç‚¹éƒ½ä»¥ /api/settings ä¸ºå‰ç¼€
router = APIRouter(prefix="/api/settings")


@router.get("/exists")
async def settings_exists():
    """
    æ£€æŸ¥è®¾ç½®æ–‡ä»¶æ˜¯å¦å­˜åœ¨

    Returns:
        dict: åŒ…å« exists å­—æ®µçš„å­—å…¸ï¼ŒæŒ‡ç¤ºè®¾ç½®æ–‡ä»¶æ˜¯å¦å­˜åœ¨

    Description:
        ç”¨äºå‰ç«¯æ£€æŸ¥æ˜¯å¦éœ€è¦æ˜¾ç¤ºåˆå§‹è®¾ç½®å‘å¯¼ã€‚
        å¦‚æœè®¾ç½®æ–‡ä»¶ä¸å­˜åœ¨ï¼Œé€šå¸¸éœ€è¦å¼•å¯¼ç”¨æˆ·è¿›è¡Œåˆå§‹é…ç½®ã€‚
    """
    return {"exists": await settings_service.exists_settings()}


@router.get("")
async def get_settings():
    """
    è·å–æ‰€æœ‰è®¾ç½®é…ç½®

    Returns:
        dict: å®Œæ•´çš„è®¾ç½®é…ç½®å­—å…¸ï¼Œæ•æ„Ÿä¿¡æ¯å·²è¢«æ©ç å¤„ç†

    Description:
        è¿”å›æ‰€æœ‰åº”ç”¨è®¾ç½®ï¼ŒåŒ…æ‹¬ä»£ç†é…ç½®ã€ç³»ç»Ÿæç¤ºè¯ç­‰ã€‚
        æ•æ„Ÿä¿¡æ¯ï¼ˆå¦‚å¯†ç ï¼‰ä¼šè¢«æ›¿æ¢ä¸º '*' å­—ç¬¦ä»¥ä¿æŠ¤éšç§ã€‚
        è®¾ç½®ä¼šä¸é»˜è®¤é…ç½®åˆå¹¶ï¼Œç¡®ä¿æ‰€æœ‰å¿…éœ€çš„é”®éƒ½å­˜åœ¨ã€‚
    """
    return settings_service.get_settings()


@router.post("")
async def update_settings(request: Request):
    """
    æ›´æ–°è®¾ç½®é…ç½®

    Args:
        request (Request): HTTP è¯·æ±‚å¯¹è±¡ï¼ŒåŒ…å«è¦æ›´æ–°çš„è®¾ç½®æ•°æ®

    Returns:
        dict: æ“ä½œç»“æœï¼ŒåŒ…å« status å’Œ message å­—æ®µ

    Description:
        æ¥æ”¶ JSON æ ¼å¼çš„è®¾ç½®æ•°æ®å¹¶æ›´æ–°åˆ°é…ç½®æ–‡ä»¶ã€‚
        æ”¯æŒéƒ¨åˆ†æ›´æ–°ï¼Œæ–°æ•°æ®ä¼šä¸ç°æœ‰è®¾ç½®åˆå¹¶è€Œä¸æ˜¯å®Œå…¨æ›¿æ¢ã€‚

    Example:
        POST /api/settings
        {
            "proxy": "http://proxy.com:8080"  // æˆ– "no_proxy" æˆ– "system"
        }
    """
    data = await request.json()
    result = await settings_service.update_settings(data)
    return result


@router.get("/proxy/status")
async def get_proxy_status():
    """
    è·å–ä»£ç†é…ç½®çŠ¶æ€

    Returns:
        dict: ä»£ç†çŠ¶æ€ä¿¡æ¯ï¼ŒåŒ…å«ä»¥ä¸‹å­—æ®µï¼š
            - enable (bool): ä»£ç†æ˜¯å¦å¯ç”¨
            - configured (bool): ä»£ç†æ˜¯å¦æ­£ç¡®é…ç½®
            - message (str): çŠ¶æ€æè¿°ä¿¡æ¯

    Description:
        æ£€æŸ¥å½“å‰ä»£ç†é…ç½®çš„çŠ¶æ€ï¼ŒåŒ…æ‹¬æ˜¯å¦å¯ç”¨å’Œæ˜¯å¦æ­£ç¡®é…ç½®ã€‚
        è¯¥ç«¯ç‚¹ä¸ä¼šæš´éœ²å®Œæ•´çš„ä»£ç† URL ä»¥ä¿æŠ¤å®‰å…¨æ€§ã€‚

    Status Logic:
        - enable=True, configured=True: ä»£ç†å·²å¯ç”¨ä¸”é…ç½®æ­£ç¡®
        - enable=True, configured=False: ä»£ç†å·²å¯ç”¨ä½†é…ç½®æœ‰è¯¯
        - enable=False, configured=False: ä»£ç†æœªå¯ç”¨
    """
    # è·å–è®¾ç½®ä¸­çš„ä»£ç†é…ç½®
    settings = settings_service.get_raw_settings()
    proxy_setting = settings.get('proxy', 'system')

    if proxy_setting == 'no_proxy':
        # ä¸ä½¿ç”¨ä»£ç†
        return {
            "enable": False,
            "configured": True,
            "message": "Proxy is disabled"
        }
    elif proxy_setting == 'system':
        # ä½¿ç”¨ç³»ç»Ÿä»£ç†
        return {
            "enable": True,
            "configured": True,
            "message": "Using system proxy"
        }
    elif proxy_setting.startswith(('http://', 'https://', 'socks4://', 'socks5://')):
        # ä½¿ç”¨æŒ‡å®šçš„ä»£ç†URL
        return {
            "enable": True,
            "configured": True,
            "message": "Using custom proxy"
        }
    else:
        # ä»£ç†è®¾ç½®æ ¼å¼ä¸æ­£ç¡®
        return {
            "enable": True,
            "configured": False,
            "message": "Proxy configuration is invalid"
        }


@router.get("/proxy")
async def get_proxy_settings():
    """
    è·å–ä»£ç†è®¾ç½®

    Returns:
        dict: ä»£ç†é…ç½®å­—å…¸ï¼ŒåŒ…å« proxy å­—æ®µ

    Description:
        ä»…è¿”å›ä»£ç†ç›¸å…³çš„è®¾ç½®ï¼Œä¸åŒ…å«å…¶ä»–é…ç½®é¡¹ã€‚
        ç”¨äºå‰ç«¯ä»£ç†è®¾ç½®é¡µé¢çš„æ•°æ®åŠ è½½ã€‚

    Response Format:
        {
            "proxy": "no_proxy" | "system" | "http://proxy.example.com:8080"
        }
    """
    proxy_config = settings_service.get_proxy_config()
    return {"proxy": proxy_config}


@router.post("/proxy")
async def update_proxy_settings(request: Request):
    """
    æ›´æ–°ä»£ç†è®¾ç½®

    Args:
        request (Request): HTTP è¯·æ±‚å¯¹è±¡ï¼ŒåŒ…å«ä»£ç†é…ç½®æ•°æ®

    Returns:
        dict: æ“ä½œç»“æœï¼ŒåŒ…å« status å’Œ message å­—æ®µ

    Raises:
        HTTPException: å½“ä»£ç†é…ç½®æ•°æ®æ ¼å¼ä¸æ­£ç¡®æ—¶æŠ›å‡º 400 é”™è¯¯

    Description:
        ä»…æ›´æ–°ä»£ç†ç›¸å…³çš„è®¾ç½®ï¼Œä¸å½±å“å…¶ä»–é…ç½®é¡¹ã€‚
        ä»£ç†é…ç½®åº”è¯¥æ˜¯ä¸€ä¸ªåŒ…å« "proxy" é”®çš„å¯¹è±¡ã€‚

    Example:
        POST /api/settings/proxy
        {
            "proxy": "no_proxy"  // ä¸ä½¿ç”¨ä»£ç†
        }
        æˆ–
        {
            "proxy": "system"  // ä½¿ç”¨ç³»ç»Ÿä»£ç†
        }
        æˆ–
        {
            "proxy": "http://proxy.example.com:8080"  // ä½¿ç”¨æŒ‡å®šä»£ç†
        }
    """
    proxy_data = await request.json()

    # éªŒè¯ä»£ç†æ•°æ®æ ¼å¼
    if not isinstance(proxy_data, dict) or "proxy" not in proxy_data:
        raise HTTPException(
            status_code=400,
            detail="Invalid proxy configuration. Expected format: {'proxy': 'value'}")

    proxy_value = proxy_data["proxy"]

    # éªŒè¯ä»£ç†å€¼çš„æ ¼å¼
    if not isinstance(proxy_value, str):
        raise HTTPException(
            status_code=400,
            detail="Proxy value must be a string")

    # éªŒè¯ä»£ç†å€¼çš„æœ‰æ•ˆæ€§
    if proxy_value not in ['no_proxy', 'system'] and not proxy_value.startswith(('http://', 'https://', 'socks4://', 'socks5://')):
        raise HTTPException(
            status_code=400,
            detail="Invalid proxy value. Must be 'no_proxy', 'system', or a valid proxy URL")

    # æ›´æ–°ä»£ç†è®¾ç½®
    result = await settings_service.update_settings({"proxy": proxy_value})
    return result


class CreateWorkflowRequest(BaseModel):
    name: str
    api_json: dict  # or str if you want it as string
    description: str
    inputs: list   # or str if you want it as string
    outputs: str = None


@router.post("/comfyui/create_workflow")
async def create_workflow(request: CreateWorkflowRequest):
    if not request.name:
        raise HTTPException(status_code=400, detail="Name is required")
    if not request.api_json:
        raise HTTPException(status_code=400, detail="API JSON is required")
    if not request.description:
        raise HTTPException(status_code=400, detail="Description is required")
    if not request.inputs:
        raise HTTPException(status_code=400, detail="Inputs are required")
    try:
        name = request.name.replace(" ", "_")
        api_json = json.dumps(request.api_json)
        inputs = json.dumps(request.inputs)
        outputs = json.dumps(request.outputs)
        await db_service.create_comfy_workflow(name, api_json, request.description, inputs, outputs)
        await tool_service.initialize()
        return {"success": True}
    except Exception as e:
        raise HTTPException(
            status_code=400, detail=f"Failed to create workflow: {str(e)}")


@router.get("/comfyui/list_workflows")
async def list_workflows():
    return await db_service.list_comfy_workflows()


@router.delete("/comfyui/delete_workflow/{id}")
async def delete_workflow(id: int):
    result = await db_service.delete_comfy_workflow(id)
    await tool_service.initialize()
    return result


@router.post("/comfyui/proxy")
async def comfyui_proxy(request: Request):
    try:
        # ä»è¯·æ±‚ä¸­è·å–ComfyUIçš„ç›®æ ‡URLå’Œè·¯å¾„
        data = await request.json()
        target_url = data.get("url")  # å‰ç«¯ä¼ é€’çš„ComfyUIåœ°å€ï¼ˆå¦‚http://127.0.0.1:8188ï¼‰
        path = data.get("path", "")   # è¯·æ±‚çš„è·¯å¾„ï¼ˆå¦‚/system_statsï¼‰

        if not target_url or not path:
            raise HTTPException(
                status_code=400, detail="Missing 'url' or 'path' in request body")

        # æ„é€ å®Œæ•´çš„ComfyUIè¯·æ±‚URL
        full_url = f"{target_url}{path}"

        # ä½¿ç”¨httpxè½¬å‘è¯·æ±‚ï¼ˆæ”¯æŒGET/POSTç­‰æ–¹æ³•ï¼Œè¿™é‡Œç¤ºä¾‹ç”¨GETï¼‰
        async with httpx.AsyncClient() as client:
            response = await client.get(full_url)
            # å°†ComfyUIçš„å“åº”åŸæ ·è¿”å›ç»™å‰ç«¯
            return response.json()

    except Exception as e:
        raise HTTPException(
            status_code=500, detail=f"Proxy request failed: {str(e)}")


@router.get("/knowledge/enabled")
async def get_enabled_knowledge():
    """
    è·å–å¯ç”¨çš„çŸ¥è¯†åº“åˆ—è¡¨

    Returns:
        dict: åŒ…å«å¯ç”¨çŸ¥è¯†åº“åˆ—è¡¨çš„å“åº”
    """
    try:
        knowledge_list = list_user_enabled_knowledge()
        return {
            "success": True,
            "data": knowledge_list,
            "count": len(knowledge_list)
        }
    except Exception as e:
        return {
            "success": False,
            "error": str(e),
            "data": []
        }


@router.get("/my_assets_dir_path")
async def get_my_assets_dir_path():
    """
    è·å–ç”¨æˆ·çš„My Assetsç›®å½•è·¯å¾„
    
    Returns:
        dict: åŒ…å«ç›®å½•è·¯å¾„çš„å“åº”
    """
    from services.config_service import FILES_DIR
    
    try:
        # ç¡®ä¿ç›®å½•å­˜åœ¨
        os.makedirs(FILES_DIR, exist_ok=True)
        
        return {
            "success": True,
            "path": FILES_DIR,
            "message": "My Assets directory path retrieved successfully"
        }
    except Exception as e:
        return {
            "success": False,
            "error": str(e),
            "path": ""
        }



================================================
FILE: server/routers/ssl_test.py
================================================
"""
SSLé…ç½®æµ‹è¯•è·¯ç”±æ¨¡å—

æœ¬æ–‡ä»¶ä»…ç”¨äºæµ‹è¯•SSLè¯ä¹¦é…ç½®æ˜¯å¦æ­£å¸¸å·¥ä½œï¼Œç‰¹åˆ«æ˜¯åœ¨PyInstalleræ‰“åŒ…åçš„ç¯å¢ƒä¸­ã€‚
ä¸»è¦è§£å†³è°ƒç”¨å¤–éƒ¨APIï¼ˆå¦‚Replicate APIï¼‰æ—¶å‡ºç°çš„SSLè¯ä¹¦éªŒè¯å¤±è´¥é—®é¢˜ã€‚

æä¾›çš„APIç«¯ç‚¹ï¼š
- GET /api/test_ssl: å¿«é€ŸSSLæµ‹è¯•ï¼Œæµ‹è¯•åŸºæœ¬çš„HTTPSè¿æ¥
- GET /api/test_ssl_full: å®Œæ•´SSLæµ‹è¯•ï¼ŒåŒ…æ‹¬ç¯å¢ƒæ£€æŸ¥å’Œå¤šä¸ªAPIè¿æ¥æµ‹è¯•
- GET /api/ssl_status: SSLçŠ¶æ€æ£€æŸ¥ï¼Œä»…æ£€æŸ¥æœ¬åœ°é…ç½®ï¼Œä¸è¿›è¡Œç½‘ç»œè¿æ¥

æ³¨æ„ï¼šæ­¤æ¨¡å—ä»…ç”¨äºè¯Šæ–­å’Œæµ‹è¯•ç›®çš„ï¼Œä¸åº”åœ¨ç”Ÿäº§ç¯å¢ƒä¸­é¢‘ç¹è°ƒç”¨ã€‚
"""

from fastapi import APIRouter
import traceback
import asyncio
import ssl
import sys
import os
from utils.http_client import HttpClient

router = APIRouter(prefix="/api")


async def quick_ssl_test():
    """Quick SSL test for API endpoint"""
    try:
        async with HttpClient.create() as client:
            response = await client.get('https://httpbin.org/get', timeout=5)
            return {
                'ssl_working': response.status_code == 200,
                'status_code': response.status_code,
                'message': 'SSL configuration is working' if response.status_code == 200 else f'Unexpected status: {response.status_code}'
            }
    except ssl.SSLError as e:
        return {
            'ssl_working': False,
            'error': 'SSL_ERROR',
            'message': f'SSL certificate verification failed: {str(e)}'
        }
    except Exception as e:
        return {
            'ssl_working': False,
            'error': 'CONNECTION_ERROR',
            'message': f'Connection failed: {str(e)}'
        }


@router.get("/test_ssl")
async def test_ssl_endpoint():
    """API endpoint to test SSL configuration"""
    try:
        result = await quick_ssl_test()
        return result
    except Exception as e:
        return {
            'ssl_working': False,
            'error': 'TEST_ERROR',
            'message': f'SSL test failed: {str(e)}'
        }


async def test_ssl_configuration():
    """Run comprehensive SSL tests"""
    test_results = []
    is_bundled = getattr(sys, 'frozen', False)

    def log_result(test_name, success, message, details=None):
        test_results.append({
            'test': test_name,
            'success': success,
            'message': message,
            'details': details or {}
        })

    # Test 1: Environment check
    try:
        import certifi
        ca_path = certifi.where()
        ca_exists = os.path.exists(ca_path)
        ca_size = os.path.getsize(ca_path) if ca_exists else 0

        log_result(
            "Certifi Package",
            ca_exists and ca_size > 0,
            f"CA bundle {'found' if ca_exists else 'not found'}",
            {
                'path': ca_path,
                'exists': ca_exists,
                'size': f"{ca_size} bytes" if ca_exists else "N/A",
                'is_bundled': is_bundled
            }
        )
    except Exception as e:
        log_result("Certifi Package", False, f"Error: {str(e)}")

    # Test 2: SSL context creation
    try:
        ssl_context = HttpClient._get_ssl_context()
        log_result(
            "SSL Context Creation",
            True,
            "SSL context created successfully",
            {
                'protocol': str(ssl_context.protocol),
                'verify_mode': str(ssl_context.verify_mode)
            }
        )
        ssl_context_ok = True
    except Exception as e:
        log_result("SSL Context Creation", False, f"Failed: {str(e)}")
        ssl_context_ok = False

    # Test 2.5: httpx client creation for ChatOpenAI
    try:
        httpx_client = HttpClient.create_sync_client()

        # Get SSL verification info safely
        verify_info = "SSL context configured"
        try:
            # Try to access the verify attribute safely
            if hasattr(httpx_client, '_verify'):
                verify_info = str(httpx_client._verify)
            elif hasattr(httpx_client, 'verify'):
                verify_info = str(httpx_client.verify)
        except:
            verify_info = "SSL verification enabled"

        log_result(
            "httpx Client Creation",
            True,
            "httpx client with SSL created successfully",
            {
                'client_type': str(type(httpx_client)),
                'verify_info': verify_info
            }
        )
        httpx_client.close()  # Clean up
        httpx_ok = True
    except Exception as e:
        log_result("httpx Client Creation", False, f"Failed: {str(e)}")
        httpx_ok = False

    # Test 3: Basic HTTPS connectivity
    if ssl_context_ok:
        test_urls = [
            'https://httpbin.org/get',
            'https://www.google.com',
            'https://api.github.com'
        ]

        https_ok = False
        for url in test_urls:
            try:
                async with HttpClient.create() as client:
                    response = await client.get(url, timeout=10)
                    success = response.status_code in [200, 301, 302]
                    log_result(
                        f"HTTPS Test ({url})",
                        success,
                        f"Status: {response.status_code}",
                        {'url': str(response.url)}
                    )
                    if success:
                        https_ok = True
                        break
            except Exception as e:
                log_result(f"HTTPS Test ({url})", False, f"Failed: {str(e)}")

        # Test 4: Replicate API connectivity
        try:
            async with HttpClient.create() as client:
                response = await client.get('https://api.replicate.com', timeout=15)
                success = response.status_code in [200, 401, 403, 404]
                log_result(
                    "Replicate API SSL",
                    success,
                    f"SSL verification {'successful' if success else 'failed'} (Status: {response.status_code})",
                    {'status_code': response.status_code}
                )
        except ssl.SSLError as e:
            log_result("Replicate API SSL", False, f"SSL Error: {str(e)}")
        except Exception as e:
            log_result("Replicate API SSL", False,
                       f"Connection Error: {str(e)}")

    # Test 5: Basic httpx connectivity test
    if httpx_ok:
        try:
            with HttpClient.create_sync() as client:
                # Test basic HTTPS connection first
                response = client.get('https://httpbin.org/get', timeout=10)
                success = response.status_code == 200
                log_result(
                    "httpx HTTPS Test",
                    success,
                    f"httpx SSL connection {'successful' if success else 'failed'} (Status: {response.status_code})",
                    {'status_code': response.status_code}
                )
        except ssl.SSLError as e:
            log_result("httpx HTTPS Test", False, f"SSL Error: {str(e)}")
        except Exception as e:
            log_result("httpx HTTPS Test", False,
                       f"Connection Error: {str(e)}")

    # Test 6: OpenAI API connectivity using httpx (for ChatOpenAI)
    if httpx_ok:
        try:
            with HttpClient.create_sync() as client:
                # Test OpenAI API endpoint (just check SSL connection, not actual API call)
                response = client.get('https://api.openai.com', timeout=15)
                # Accept more status codes as successful SSL connection
                # 421 = Misdirected Request (HTTP/2 issue, but SSL worked)
                # 200 = OK, 401 = Unauthorized, 403 = Forbidden, 404 = Not Found
                success = response.status_code in [200, 401, 403, 404, 421]

                if response.status_code == 421:
                    message = "SSL verification successful (HTTP/2 misdirected request - normal)"
                elif response.status_code in [200, 401, 403, 404]:
                    message = f"SSL verification successful (Status: {response.status_code})"
                else:
                    message = f"SSL verification failed (Status: {response.status_code})"

                log_result(
                    "OpenAI API SSL (httpx)",
                    success,
                    message,
                    {
                        'status_code': response.status_code,
                        'note': '421 status is normal for OpenAI API with HTTP/1.1' if response.status_code == 421 else None
                    }
                )
        except ssl.SSLError as e:
            log_result("OpenAI API SSL (httpx)", False, f"SSL Error: {str(e)}")
        except Exception as e:
            log_result("OpenAI API SSL (httpx)", False,
                       f"Connection Error: {str(e)}")

    # Generate summary
    total_tests = len(test_results)
    passed_tests = sum(1 for result in test_results if result['success'])

    if passed_tests == total_tests:
        status = "success"
    elif passed_tests > 0:
        status = "partial"
    else:
        status = "failed"

    return {
        'status': status,
        'total': total_tests,
        'passed': passed_tests,
        'failed': total_tests - passed_tests,
        'results': test_results,
        'environment': {
            'python_version': sys.version,
            'is_bundled': is_bundled,
            'bundle_path': getattr(sys, '_MEIPASS', None) if is_bundled else None
        }
    }


@router.get("/test_ssl_full")
async def test_ssl_full_endpoint():
    """API endpoint to run full SSL tests"""
    try:
        result = await test_ssl_configuration()
        return result
    except Exception as e:
        return {
            'status': 'error',
            'message': f'SSL test failed: {str(e)}'
        }


@router.get("/ssl_status")
async def ssl_status_endpoint():
    """Get SSL configuration status without running network tests"""
    try:
        import ssl
        import certifi
        import sys
        import os

        # Check environment
        is_bundled = getattr(sys, 'frozen', False)
        ca_path = certifi.where()
        ca_exists = os.path.exists(ca_path)
        ca_size = os.path.getsize(ca_path) if ca_exists else 0

        # Try to create SSL context
        ssl_context_ok = False
        ssl_error = None
        try:
            ssl_context = ssl.create_default_context(cafile=certifi.where())
            ssl_context_ok = True
        except Exception as e:
            ssl_error = str(e)

        return {
            'environment': {
                'python_version': sys.version,
                'is_bundled': is_bundled,
                'bundle_path': getattr(sys, '_MEIPASS', None) if is_bundled else None
            },
            'certifi': {
                'ca_path': ca_path,
                'ca_exists': ca_exists,
                'ca_size': ca_size
            },
            'ssl_context': {
                'creation_ok': ssl_context_ok,
                'error': ssl_error
            },
            'overall_status': 'ok' if ssl_context_ok and ca_exists else 'error'
        }

    except Exception as e:
        return {
            'overall_status': 'error',
            'error': str(e)
        }



================================================
FILE: server/routers/tool_confirmation.py
================================================
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from typing import Dict, Any
from services.websocket_service import send_to_websocket
from services.tool_confirmation_manager import tool_confirmation_manager

router = APIRouter(prefix="/api")

class ToolConfirmationRequest(BaseModel):
    session_id: str
    tool_call_id: str
    confirmed: bool

@router.post("/tool_confirmation")
async def handle_tool_confirmation(request: ToolConfirmationRequest):
    """å¤„ç†å·¥å…·è°ƒç”¨ç¡®è®¤"""
    try:
        if request.confirmed:
            # ç¡®è®¤å·¥å…·è°ƒç”¨
            success = tool_confirmation_manager.confirm_tool(
                request.tool_call_id)
            if success:
                await send_to_websocket(request.session_id, {
                    'type': 'tool_call_confirmed',
                    'id': request.tool_call_id
                })
            else:
                raise HTTPException(
                    status_code=404, detail="Tool call not found or already processed")
        else:
            # å–æ¶ˆå·¥å…·è°ƒç”¨
            success = tool_confirmation_manager.cancel_confirmation(
                request.tool_call_id)
            if success:
                await send_to_websocket(request.session_id, {
                    'type': 'tool_call_cancelled',
                    'id': request.tool_call_id
                })
            else:
                raise HTTPException(
                    status_code=404, detail="Tool call not found or already processed")

        return {"status": "success"}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))



================================================
FILE: server/routers/websocket_router.py
================================================
# routers/websocket_router.py
from services.websocket_state import sio, add_connection, remove_connection

@sio.event
async def connect(sid, environ, auth):
    print(f"Client {sid} connected")
    
    user_info = auth or {}
    add_connection(sid, user_info)
    
    await sio.emit('connected', {'status': 'connected'}, room=sid)

@sio.event
async def disconnect(sid):
    print(f"Client {sid} disconnected")
    remove_connection(sid)

@sio.event
async def ping(sid, data):
    await sio.emit('pong', data, room=sid)



================================================
FILE: server/routers/workspace.py
================================================
import os
import traceback
import platform
import subprocess
import mimetypes
from fastapi import APIRouter, Request, HTTPException
from fastapi.responses import FileResponse, StreamingResponse
from services.config_service import USER_DATA_DIR
from typing import List, Dict, Any
import io

router = APIRouter(prefix="/api")

WORKSPACE_ROOT = os.path.join(USER_DATA_DIR, "workspace")

@router.post("/update_file")
async def update_file(request: Request):
    try:
        data = await request.json()
        path = data["path"]
        full_path = os.path.join(WORKSPACE_ROOT, path)
        content = data["content"]
        with open(full_path, "w") as f:
            f.write(content)
        return {"success": True}
    except Exception as e:
        return {"error": str(e), "path": path}

@router.post("/create_file")
async def create_file(request: Request):
    data = await request.json()
    rel_dir = data["rel_dir"]
    path = os.path.join(WORKSPACE_ROOT, rel_dir, 'Untitled.md')
    # Split the path into directory, filename, and extension
    dir_name, base_name = os.path.split(path)
    name, ext = os.path.splitext(base_name)

    candidate_path = path
    counter = 1
    while os.path.exists(candidate_path):
        # Generate new filename with incremented counter
        new_base = f"{name} {counter}{ext}"
        candidate_path = os.path.join(dir_name, new_base)
        counter += 1
    print('candidate_path', candidate_path)
    os.makedirs(os.path.dirname(candidate_path), exist_ok=True)
    with open(candidate_path, "w") as f:
        f.write("")
    return {"path": os.path.relpath(candidate_path, WORKSPACE_ROOT)}

@router.post("/delete_file")
async def delete_file(request: Request):
    data = await request.json()
    path = data["path"]
    os.remove(path)
    return {"success": True}

@router.post("/rename_file")
async def rename_file(request: Request):
    try:
        data = await request.json()
        old_path = data["old_path"]
        old_path = os.path.join(WORKSPACE_ROOT, old_path)
        new_title = data["new_title"]
        if os.path.exists(old_path):
            new_path = os.path.join(os.path.dirname(old_path), new_title)
            os.rename(old_path, new_path)
            return {"success": True, "path": new_path}
        else:
            return {"error": f"File {old_path} does not exist", "path": old_path}
    except Exception as e:
        traceback.print_exc()
        return {"error": str(e)}

@router.post("/read_file")
async def read_file(request: Request):
    try:
        data = await request.json()
        path = data["path"]
        full_path = os.path.join(WORKSPACE_ROOT, path)
        if os.path.exists(full_path):
            with open(full_path, "r") as f:
                content = f.read()
                return {"content": content}
        else:
            return {"error": f"File {path} does not exist", "path": path}
    except Exception as e:
        return {"error": str(e), "path": path}

@router.get("/list_files_in_dir")
async def list_files_in_dir(rel_path: str):
    try:
        full_path = os.path.join(WORKSPACE_ROOT, rel_path)
        files = os.listdir(full_path)
        file_nodes = []
        for file in files:
            file_path = os.path.join(full_path, file)
            file_nodes.append({
                "name": file,
                "is_dir": os.path.isdir(file_path),
                "rel_path": os.path.join(rel_path, file),
                "mtime": os.path.getmtime(file_path)  # Get modification time
            })
        # Sort by modification time in descending order
        file_nodes.sort(key=lambda x: x["mtime"], reverse=True)
        # Remove mtime from response as it was only used for sorting
        for node in file_nodes:
            node.pop("mtime")
        return file_nodes
    except Exception as e:
        return []

@router.post("/open_folder_in_explorer")
async def open_folder_in_explorer(request: Request):
    """
    åœ¨ç³»ç»Ÿæ–‡ä»¶æµè§ˆå™¨ä¸­æ‰“å¼€æŒ‡å®šæ–‡ä»¶å¤¹
    
    Args:
        request: åŒ…å«æ–‡ä»¶å¤¹è·¯å¾„çš„è¯·æ±‚
    
    Returns:
        æ“ä½œç»“æœ
    """
    try:
        data = await request.json()
        folder_path = data.get("path")
        
        if not folder_path:
            raise HTTPException(status_code=400, detail="Missing folder path")
        
        # éªŒè¯è·¯å¾„æ˜¯å¦å­˜åœ¨ä¸”ä¸ºæ–‡ä»¶å¤¹
        if not os.path.exists(folder_path):
            raise HTTPException(status_code=404, detail="Folder not found")
        
        if not os.path.isdir(folder_path):
            raise HTTPException(status_code=400, detail="Path is not a directory")
        
        # æ ¹æ®ä¸åŒæ“ä½œç³»ç»Ÿæ‰“å¼€æ–‡ä»¶ç®¡ç†å™¨
        system = platform.system()
        
        if system == "Windows":
            # Windows
            subprocess.run(["explorer", folder_path], check=True)
        elif system == "Darwin":
            # macOS
            subprocess.run(["open", folder_path], check=True)
        elif system == "Linux":
            # Linux
            subprocess.run(["xdg-open", folder_path], check=True)
        else:
            raise HTTPException(status_code=500, detail=f"Unsupported operating system: {system}")
        
        return {"success": True, "message": "Folder opened in system explorer"}
        
    except subprocess.CalledProcessError as e:
        raise HTTPException(status_code=500, detail=f"Failed to open folder: {str(e)}")
    except Exception as e:
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"Error opening folder: {str(e)}")

@router.get("/browse_filesystem")
async def browse_filesystem(path: str = ""):
    """
    æµè§ˆç”µè„‘ä»»æ„ä½ç½®çš„æ–‡ä»¶ç³»ç»Ÿ
    
    Args:
        path: è¦æµè§ˆçš„è·¯å¾„ï¼Œå¦‚æœä¸ºç©ºåˆ™ä»ç”¨æˆ·å®¶ç›®å½•å¼€å§‹
    
    Returns:
        åŒ…å«æ–‡ä»¶å¤¹å’Œæ–‡ä»¶ä¿¡æ¯çš„åˆ—è¡¨
    """
    try:
        # å¦‚æœpathä¸ºç©ºï¼Œä»ç”¨æˆ·å®¶ç›®å½•å¼€å§‹
        if not path:
            path = os.path.expanduser("~")
        
        # ç¡®ä¿è·¯å¾„å­˜åœ¨ä¸”å¯è®¿é—®
        if not os.path.exists(path):
            raise HTTPException(status_code=404, detail="Path not found")
        
        if not os.path.isdir(path):
            raise HTTPException(status_code=400, detail="Path is not a directory")
        
        items = []
        
        try:
            # è·å–ç›®å½•ä¸‹çš„æ‰€æœ‰é¡¹ç›®
            for item in os.listdir(path):
                item_path = os.path.join(path, item)
                
                # è·³è¿‡éšè—æ–‡ä»¶ï¼ˆå¯é€‰ï¼‰
                if item.startswith('.'):
                    continue
                
                try:
                    stat = os.stat(item_path)
                    is_dir = os.path.isdir(item_path)
                    
                    # è·å–æ–‡ä»¶ç±»å‹
                    file_type = "folder" if is_dir else get_file_type(item_path)
                    
                    # è·å–æ–‡ä»¶å¤§å°ï¼ˆä»…å¯¹æ–‡ä»¶ï¼‰
                    size = stat.st_size if not is_dir else None
                    
                    # è·å–ä¿®æ”¹æ—¶é—´
                    mtime = stat.st_mtime
                    
                    # æ£€æŸ¥æ˜¯å¦æ˜¯å›¾ç‰‡æˆ–è§†é¢‘æ–‡ä»¶
                    is_media = file_type in ["image", "video"]
                    
                    item_info = {
                        "name": item,
                        "path": item_path,
                        "type": file_type,
                        "size": size,
                        "mtime": mtime,
                        "is_directory": is_dir,
                        "is_media": is_media,
                        "has_thumbnail": is_media  # å¯ä»¥ç”Ÿæˆç¼©ç•¥å›¾
                    }
                    
                    items.append(item_info)
                    
                except (OSError, PermissionError):
                    # è·³è¿‡æ— æ³•è®¿é—®çš„æ–‡ä»¶
                    continue
                    
        except PermissionError:
            raise HTTPException(status_code=403, detail="Permission denied")
        
        # æŒ‰ç±»å‹å’Œåç§°æ’åºï¼šæ–‡ä»¶å¤¹åœ¨å‰ï¼Œç„¶åæŒ‰åç§°æ’åº
        items.sort(key=lambda x: (not x["is_directory"], x["name"].lower()))
        
        return {
            "current_path": path,
            "parent_path": os.path.dirname(path) if path != os.path.dirname(path) else None,
            "items": items
        }
        
    except Exception as e:
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/get_media_files")
async def get_media_files(path: str):
    """
    è·å–æŒ‡å®šæ–‡ä»¶å¤¹ä¸‹çš„æ‰€æœ‰åª’ä½“æ–‡ä»¶ï¼ˆå›¾ç‰‡å’Œè§†é¢‘ï¼‰
    
    Args:
        path: æ–‡ä»¶å¤¹è·¯å¾„
    
    Returns:
        åª’ä½“æ–‡ä»¶åˆ—è¡¨
    """
    try:
        if not os.path.exists(path) or not os.path.isdir(path):
            raise HTTPException(status_code=400, detail="Invalid directory path")
        
        media_files = []
        
        try:
            for item in os.listdir(path):
                item_path = os.path.join(path, item)
                
                if os.path.isfile(item_path):
                    file_type = get_file_type(item_path)
                    
                    if file_type in ["image", "video"]:
                        stat = os.stat(item_path)
                        
                        media_files.append({
                            "name": item,
                            "path": item_path,
                            "type": file_type,
                            "size": stat.st_size,
                            "mtime": stat.st_mtime
                        })
                        
        except PermissionError:
            raise HTTPException(status_code=403, detail="Permission denied")
        
        # æŒ‰ä¿®æ”¹æ—¶é—´æ’åº
        media_files.sort(key=lambda x: x["mtime"], reverse=True)
        
        return media_files
        
    except Exception as e:
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/get_file_thumbnail")
async def get_file_thumbnail(file_path: str):
    """
    è·å–æ–‡ä»¶çš„ç¼©ç•¥å›¾ä¿¡æ¯
    
    Args:
        file_path: æ–‡ä»¶è·¯å¾„
    
    Returns:
        ç¼©ç•¥å›¾ä¿¡æ¯æˆ–æ–‡ä»¶ä¿¡æ¯
    """
    try:
        if not os.path.exists(file_path):
            raise HTTPException(status_code=404, detail="File not found")
        
        file_type = get_file_type(file_path)
        
        return {
            "path": file_path,
            "type": file_type,
            "exists": True,
            "can_preview": file_type in ["image", "video"]
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

def get_file_type(file_path: str) -> str:
    """
    æ ¹æ®æ–‡ä»¶æ‰©å±•ååˆ¤æ–­æ–‡ä»¶ç±»å‹
    
    Args:
        file_path: æ–‡ä»¶è·¯å¾„
    
    Returns:
        æ–‡ä»¶ç±»å‹: 'image', 'video', 'audio', 'document', 'archive', 'code', 'file'
    """
    if os.path.isdir(file_path):
        return "folder"
    
    _, ext = os.path.splitext(file_path.lower())
    
    image_extensions = {'.jpg', '.jpeg', '.png', '.gif', '.bmp', '.tiff', '.webp', '.svg', '.ico'}
    video_extensions = {'.mp4', '.avi', '.mkv', '.mov', '.wmv', '.flv', '.webm', '.m4v', '.3gp'}
    audio_extensions = {'.mp3', '.wav', '.flac', '.aac', '.ogg', '.wma', '.m4a'}
    document_extensions = {'.pdf', '.doc', '.docx', '.txt', '.rtf', '.odt', '.pages'}
    archive_extensions = {'.zip', '.rar', '.7z', '.tar', '.gz', '.bz2', '.xz'}
    code_extensions = {'.py', '.js', '.html', '.css', '.java', '.cpp', '.c', '.php', '.rb', '.go', '.rs'}
    
    if ext in image_extensions:
        return "image"
    elif ext in video_extensions:
        return "video"
    elif ext in audio_extensions:
        return "audio"
    elif ext in document_extensions:
        return "document"
    elif ext in archive_extensions:
        return "archive"
    elif ext in code_extensions:
        return "code"
    else:
        return "file"

@router.get("/serve_file")
async def serve_file(file_path: str):
    """
    æä¾›æ–‡ä»¶å†…å®¹æœåŠ¡ï¼Œç”¨äºåœ¨æµè§ˆå™¨ä¸­é¢„è§ˆå›¾ç‰‡å’Œè§†é¢‘
    
    Args:
        file_path: æ–‡ä»¶è·¯å¾„
    
    Returns:
        æ–‡ä»¶å†…å®¹
    """
    try:
        if not os.path.exists(file_path):
            raise HTTPException(status_code=404, detail="File not found")
        
        if not os.path.isfile(file_path):
            raise HTTPException(status_code=400, detail="Path is not a file")
        
        # æ£€æŸ¥æ–‡ä»¶ç±»å‹
        file_type = get_file_type(file_path)
        if file_type not in ["image", "video"]:
            raise HTTPException(status_code=400, detail="File type not supported for preview")
        
        # è·å–MIMEç±»å‹
        mime_type, _ = mimetypes.guess_type(file_path)
        if not mime_type:
            mime_type = "application/octet-stream"
        
        return FileResponse(
            file_path,
            media_type=mime_type,
            filename=os.path.basename(file_path)
        )
        
    except Exception as e:
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/get_file_info")
async def get_file_info(file_path: str):
    """
    è·å–æ–‡ä»¶è¯¦ç»†ä¿¡æ¯
    
    Args:
        file_path: æ–‡ä»¶è·¯å¾„
    
    Returns:
        æ–‡ä»¶è¯¦ç»†ä¿¡æ¯
    """
    try:
        if not os.path.exists(file_path):
            raise HTTPException(status_code=404, detail="File not found")
        
        stat = os.stat(file_path)
        file_type = get_file_type(file_path)
        
        return {
            "name": os.path.basename(file_path),
            "path": file_path,
            "type": file_type,
            "size": stat.st_size,
            "mtime": stat.st_mtime,
            "ctime": stat.st_ctime,
            "is_directory": os.path.isdir(file_path),
            "is_media": file_type in ["image", "video"],
            "mime_type": mimetypes.guess_type(file_path)[0] or "application/octet-stream"
        }
        
    except Exception as e:
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=str(e))


================================================
FILE: server/services/__init__.py
================================================
[Empty file]


================================================
FILE: server/services/chat_service.py
================================================
# services/chat_service.py

# Import necessary modules
import asyncio
import json
from typing import Dict, Any, List, Optional

# Import service modules
from models.tool_model import ToolInfoJson
from services.db_service import db_service
from services.langgraph_service import langgraph_multi_agent
from services.websocket_service import send_to_websocket
from services.stream_service import add_stream_task, remove_stream_task
from models.config_model import ModelInfo


async def handle_chat(data: Dict[str, Any]) -> None:
    """
    Handle an incoming chat request.

    Workflow:
    - Parse incoming chat data.
    - Optionally inject system prompt.
    - Save chat session and messages to the database.
    - Launch langgraph_agent task to process chat.
    - Manage stream task lifecycle (add, remove).
    - Notify frontend via WebSocket when stream is done.

    Args:
        data (dict): Chat request data containing:
            - messages: list of message dicts
            - session_id: unique session identifier
            - canvas_id: canvas identifier (contextual use)
            - text_model: text model configuration
            - tool_list: list of tool model configurations (images/videos)
    """
    # Extract fields from incoming data
    messages: List[Dict[str, Any]] = data.get('messages', [])
    session_id: str = data.get('session_id', '')
    canvas_id: str = data.get('canvas_id', '')
    text_model: ModelInfo = data.get('text_model', {})
    tool_list: List[ToolInfoJson] = data.get('tool_list', [])

    print('ğŸ‘‡ chat_service got tool_list', tool_list)

    # TODO: save and fetch system prompt from db or settings config
    system_prompt: Optional[str] = data.get('system_prompt')

    # If there is only one message, create a new chat session
    if len(messages) == 1:
        # create new session
        prompt = messages[0].get('content', '')
        # TODO: Better way to determin when to create new chat session.
        await db_service.create_chat_session(session_id, text_model.get('model'), text_model.get('provider'), canvas_id, (prompt[:200] if isinstance(prompt, str) else ''))

    await db_service.create_message(session_id, messages[-1].get('role', 'user'), json.dumps(messages[-1])) if len(messages) > 0 else None

    # Create and start langgraph_agent task for chat processing
    task = asyncio.create_task(langgraph_multi_agent(
        messages, canvas_id, session_id, text_model, tool_list, system_prompt))

    # Register the task in stream_tasks (for possible cancellation)
    add_stream_task(session_id, task)
    try:
        # Await completion of the langgraph_agent task
        await task
    except asyncio.exceptions.CancelledError:
        print(f"ğŸ›‘Session {session_id} cancelled during stream")
    finally:
        # Always remove the task from stream_tasks after completion/cancellation
        remove_stream_task(session_id)
        # Notify frontend WebSocket that chat processing is done
        await send_to_websocket(session_id, {
            'type': 'done'
        })



================================================
FILE: server/services/config_service.py
================================================
import copy
import os
import traceback
import aiofiles
import toml
from typing import Dict, TypedDict, Literal, Optional

# å®šä¹‰é…ç½®æ–‡ä»¶çš„ç±»å‹ç»“æ„


class ModelConfig(TypedDict, total=False):
    type: Literal["text", "image", "video"]
    is_custom: Optional[bool]
    is_disabled: Optional[bool]


class ProviderConfig(TypedDict, total=False):
    url: str
    api_key: str
    max_tokens: int
    models: Dict[str, ModelConfig]
    is_custom: Optional[bool]


AppConfig = Dict[str, ProviderConfig]


DEFAULT_PROVIDERS_CONFIG: AppConfig = {
    'jaaz': {
        'models': {
            # text models
            'gpt-4o': {'type': 'text'},
            'gpt-4o-mini': {'type': 'text'},
            'deepseek/deepseek-chat-v3-0324': {'type': 'text'},
            'anthropic/claude-sonnet-4': {'type': 'text'},
            'anthropic/claude-3.7-sonnet': {'type': 'text'},
        },
        'url': os.getenv('BASE_API_URL', 'https://jaaz.app').rstrip('/') + '/api/v1/',
        'api_key': '',
        'max_tokens': 8192,
    },
    'comfyui': {
        'models': {},
        'url': 'http://127.0.0.1:8188',
        'api_key': '',
    },
    'ollama': {
        'models': {},
        'url': 'http://localhost:11434',
        'api_key': '',
        'max_tokens': 8192,
    },
    'openai': {
        'models': {
            'gpt-4o': {'type': 'text'},
            'gpt-4o-mini': {'type': 'text'},
        },
        'url': 'https://api.openai.com/v1/',
        'api_key': '',
        'max_tokens': 8192,
    },

}

SERVER_DIR = os.path.dirname(os.path.dirname(__file__))
USER_DATA_DIR = os.getenv(
    "USER_DATA_DIR",
    os.path.join(SERVER_DIR, "user_data"),
)
FILES_DIR = os.path.join(USER_DATA_DIR, "files")


IMAGE_FORMATS = (
    ".png",
    ".jpg",
    ".jpeg",
    ".webp",  # åŸºç¡€æ ¼å¼
    ".bmp",
    ".tiff",
    ".tif",  # å…¶ä»–å¸¸è§æ ¼å¼
    ".webp",
)
VIDEO_FORMATS = (
    ".mp4",
    ".avi",
    ".mkv",
    ".mov",
    ".wmv",
    ".flv",
)


class ConfigService:
    def __init__(self):
        self.app_config: AppConfig = copy.deepcopy(DEFAULT_PROVIDERS_CONFIG)
        self.config_file = os.getenv(
            "CONFIG_PATH", os.path.join(USER_DATA_DIR, "config.toml")
        )
        self.initialized = False

    def _get_jaaz_url(self) -> str:
        """Get the correct jaaz URL"""
        return os.getenv('BASE_API_URL', 'https://jaaz.app').rstrip('/') + '/api/v1/'

    async def initialize(self) -> None:
        try:
            # Ensure the user_data directory exists
            os.makedirs(os.path.dirname(self.config_file), exist_ok=True)

            # Check if config file exists
            if not self.exists_config():
                print(
                    f"Config file not found at {self.config_file}, creating default configuration")
                # Create default config file
                with open(self.config_file, "w") as f:
                    toml.dump(self.app_config, f)
                print(f"Default config file created at {self.config_file}")
                self.initialized = True
                return

            async with aiofiles.open(self.config_file, "r") as f:
                content = await f.read()
                config: AppConfig = toml.loads(content)
            for provider, provider_config in config.items():
                if provider not in DEFAULT_PROVIDERS_CONFIG:
                    provider_config['is_custom'] = True
                self.app_config[provider] = provider_config
                # image/video models are hardcoded in the default provider config
                provider_models = DEFAULT_PROVIDERS_CONFIG.get(
                    provider, {}).get('models', {})
                for model_name, model_config in provider_config.get('models', {}).items():
                    # Only text model can be self added
                    if model_config.get('type') == 'text' and model_name not in provider_models:
                        provider_models[model_name] = model_config
                        provider_models[model_name]['is_custom'] = True
                self.app_config[provider]['models'] = provider_models

            # ç¡®ä¿ jaaz URL å§‹ç»ˆæ­£ç¡®
            if 'jaaz' in self.app_config:
                self.app_config['jaaz']['url'] = self._get_jaaz_url()
        except Exception as e:
            print(f"Error loading config: {e}")
            traceback.print_exc()
        finally:
            self.initialized = True

    def get_config(self) -> AppConfig:
        if 'jaaz' in self.app_config:
            self.app_config['jaaz']['url'] = self._get_jaaz_url()
        return self.app_config

    async def update_config(self, data: AppConfig) -> Dict[str, str]:
        try:
            if 'jaaz' in data:
                data['jaaz']['url'] = self._get_jaaz_url()

            os.makedirs(os.path.dirname(self.config_file), exist_ok=True)
            with open(self.config_file, "w") as f:
                toml.dump(data, f)
            self.app_config = data

            return {
                "status": "success",
                "message": "Configuration updated successfully",
            }
        except Exception as e:
            traceback.print_exc()
            return {"status": "error", "message": str(e)}

    def exists_config(self) -> bool:
        return os.path.exists(self.config_file)


config_service = ConfigService()



================================================
FILE: server/services/db_service.py
================================================
import sqlite3
import json
import os
from typing import List, Dict, Any, Optional
import aiosqlite
from .config_service import USER_DATA_DIR
from .migrations.manager import MigrationManager, CURRENT_VERSION

DB_PATH = os.path.join(USER_DATA_DIR, "localmanus.db")

class DatabaseService:
    def __init__(self):
        self.db_path = DB_PATH
        self._ensure_db_directory()
        self._migration_manager = MigrationManager()
        self._init_db()

    def _ensure_db_directory(self):
        """Ensure the database directory exists"""
        os.makedirs(os.path.dirname(self.db_path), exist_ok=True)

    def _init_db(self):
        """Initialize the database with the current schema"""
        with sqlite3.connect(self.db_path) as conn:
            # Create version table if it doesn't exist
            conn.execute("""
                CREATE TABLE IF NOT EXISTS db_version (
                    version INTEGER PRIMARY KEY
                )
            """)
            
            # Get current version
            cursor = conn.execute("SELECT version FROM db_version")
            current_version = cursor.fetchone()
            print('local db version', current_version, 'latest version', CURRENT_VERSION)
            
            if current_version is None:
                # First time setup - start from version 0
                conn.execute("INSERT INTO db_version (version) VALUES (0)")
                self._migration_manager.migrate(conn, 0, CURRENT_VERSION)
            elif current_version[0] < CURRENT_VERSION:
                print('Migrating database from version', current_version[0], 'to', CURRENT_VERSION)
                # Need to migrate
                self._migration_manager.migrate(conn, current_version[0], CURRENT_VERSION)

    async def create_canvas(self, id: str, name: str):
        """Create a new canvas"""
        async with aiosqlite.connect(self.db_path) as db:
            await db.execute("""
                INSERT INTO canvases (id, name)
                VALUES (?, ?)
            """, (id, name))
            await db.commit()

    async def list_canvases(self) -> List[Dict[str, Any]]:
        """Get all canvases"""
        async with aiosqlite.connect(self.db_path) as db:
            db.row_factory = sqlite3.Row
            cursor = await db.execute("""
                SELECT id, name, description, thumbnail, created_at, updated_at
                FROM canvases
                ORDER BY updated_at DESC
            """)
            rows = await cursor.fetchall()
            return [dict(row) for row in rows]

    async def create_chat_session(self, id: str, model: str, provider: str, canvas_id: str, title: Optional[str] = None):
        """Save a new chat session"""
        async with aiosqlite.connect(self.db_path) as db:
            await db.execute("""
                INSERT INTO chat_sessions (id, model, provider, canvas_id, title)
                VALUES (?, ?, ?, ?, ?)
            """, (id, model, provider, canvas_id, title))
            await db.commit()

    async def create_message(self, session_id: str, role: str, message: str):
        """Save a chat message"""
        async with aiosqlite.connect(self.db_path) as db:
            await db.execute("""
                INSERT INTO chat_messages (session_id, role, message)
                VALUES (?, ?, ?)
            """, (session_id, role, message))
            await db.commit()

    async def get_chat_history(self, session_id: str) -> List[Dict[str, Any]]:
        """Get chat history for a session"""
        async with aiosqlite.connect(self.db_path) as db:
            db.row_factory = sqlite3.Row
            cursor = await db.execute("""
                SELECT role, message, id
                FROM chat_messages
                WHERE session_id = ?
                ORDER BY id ASC
            """, (session_id,))
            rows = await cursor.fetchall()
            
            messages = []
            for row in rows:
                row_dict = dict(row)
                if row_dict['message']:
                    try:
                        msg = json.loads(row_dict['message'])
                        messages.append(msg)
                    except:
                        pass
                
            return messages

    async def list_sessions(self, canvas_id: str) -> List[Dict[str, Any]]:
        """List all chat sessions"""
        async with aiosqlite.connect(self.db_path) as db:
            db.row_factory = sqlite3.Row
            if canvas_id:
                cursor = await db.execute("""
                    SELECT id, title, model, provider, created_at, updated_at
                    FROM chat_sessions
                    WHERE canvas_id = ?
                    ORDER BY updated_at DESC
                """, (canvas_id,))
            else:
                cursor = await db.execute("""
                    SELECT id, title, model, provider, created_at, updated_at
                    FROM chat_sessions
                    ORDER BY updated_at DESC
                """)
            rows = await cursor.fetchall()
            return [dict(row) for row in rows]

    async def save_canvas_data(self, id: str, data: str, thumbnail: str = None):
        """Save canvas data"""
        async with aiosqlite.connect(self.db_path) as db:
            await db.execute("""
                UPDATE canvases 
                SET data = ?, thumbnail = ?, updated_at = STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now')
                WHERE id = ?
            """, (data, thumbnail, id))
            await db.commit()

    async def get_canvas_data(self, id: str) -> Optional[Dict[str, Any]]:
        """Get canvas data"""
        async with aiosqlite.connect(self.db_path) as db:
            db.row_factory = sqlite3.Row
            cursor = await db.execute("""
                SELECT data, name
                FROM canvases
                WHERE id = ?
            """, (id,))
            row = await cursor.fetchone()

            sessions = await self.list_sessions(id)
            
            if row:
                return {
                    'data': json.loads(row['data']) if row['data'] else {},
                    'name': row['name'],
                    'sessions': sessions
                }
            return None

    async def delete_canvas(self, id: str):
        """Delete canvas and related data"""
        async with aiosqlite.connect(self.db_path) as db:
            await db.execute("DELETE FROM canvases WHERE id = ?", (id,))
            await db.commit()

    async def rename_canvas(self, id: str, name: str):
        """Rename canvas"""
        async with aiosqlite.connect(self.db_path) as db:
            await db.execute("UPDATE canvases SET name = ? WHERE id = ?", (name, id))
            await db.commit()

    async def create_comfy_workflow(self, name: str, api_json: str, description: str, inputs: str, outputs: str = None):
        """Create a new comfy workflow"""
        async with aiosqlite.connect(self.db_path) as db:
            await db.execute("""
                INSERT INTO comfy_workflows (name, api_json, description, inputs, outputs)
                VALUES (?, ?, ?, ?, ?)
            """, (name, api_json, description, inputs, outputs))
            await db.commit()

    async def list_comfy_workflows(self) -> List[Dict[str, Any]]:
        """List all comfy workflows"""
        async with aiosqlite.connect(self.db_path) as db:
            db.row_factory = sqlite3.Row
            cursor = await db.execute("SELECT id, name, description, api_json, inputs, outputs FROM comfy_workflows ORDER BY id DESC")
            rows = await cursor.fetchall()
            return [dict(row) for row in rows]

    async def delete_comfy_workflow(self, id: int):
        """Delete a comfy workflow"""
        async with aiosqlite.connect(self.db_path) as db:
            await db.execute("DELETE FROM comfy_workflows WHERE id = ?", (id,))
            await db.commit()

    async def get_comfy_workflow(self, id: int):
        """Get comfy workflow dict"""
        async with aiosqlite.connect(self.db_path) as db:
            db.row_factory = sqlite3.Row
            cursor = await db.execute(
                "SELECT api_json FROM comfy_workflows WHERE id = ?", (id,)
            )
            row = await cursor.fetchone()
        try:
            workflow_json = (
                row["api_json"]
                if isinstance(row["api_json"], dict)
                else json.loads(row["api_json"])
            )
            return workflow_json
        except json.JSONDecodeError as exc:
            raise ValueError(f"Stored workflow api_json is not valid JSON: {exc}")

# Create a singleton instance
db_service = DatabaseService()



================================================
FILE: server/services/jaaz_service.py
================================================
# services/OpenAIAgents_service/jaaz_service.py

import asyncio
import aiohttp
from typing import Dict, Any, Optional, List
from utils.http_client import HttpClient
from services.config_service import config_service


class JaazService:
    """Jaaz äº‘ç«¯ API æœåŠ¡
    """

    def __init__(self):
        """åˆå§‹åŒ– Jaaz æœåŠ¡"""
        config = config_service.app_config.get('jaaz', {})
        self.api_url = str(config.get("url", "")).rstrip("/")
        self.api_token = str(config.get("api_key", ""))

        if not self.api_url:
            raise ValueError("Jaaz API URL is not configured")
        if not self.api_token:
            raise ValueError("Jaaz API token is not configured")

        # ç¡®ä¿ API åœ°å€ä»¥ /api/v1 ç»“å°¾
        if not self.api_url.endswith('/api/v1'):
            self.api_url = f"{self.api_url}/api/v1"

        print(f"âœ… Jaaz service initialized with API URL: {self.api_url}")

    def _is_configured(self) -> bool:
        """æ£€æŸ¥ Jaaz API æ˜¯å¦å·²é…ç½®"""
        return bool(self.api_url and self.api_token)

    def _build_headers(self) -> Dict[str, str]:
        """æ„å»ºè¯·æ±‚å¤´"""
        return {
            "Authorization": f"Bearer {self.api_token}",
            "Content-Type": "application/json"
        }

    async def create_magic_task(self, image_content: str) -> str:
        """
        åˆ›å»ºäº‘ç«¯é­”æ³•å›¾åƒç”Ÿæˆä»»åŠ¡

        Args:
            image_content: å›¾ç‰‡å†…å®¹ï¼ˆbase64 æˆ– URLï¼‰

        Returns:
            str: ä»»åŠ¡ IDï¼Œå¤±è´¥æ—¶è¿”å›ç©ºå­—ç¬¦ä¸²
        """
        try:
            if not image_content or not image_content.startswith('data:image/'):
                print("âŒ Invalid image content format")
                return ""

            async with HttpClient.create_aiohttp() as session:
                async with session.post(
                    f"{self.api_url}/image/magic",
                    headers=self._build_headers(),
                    json={
                        "image": image_content
                    },
                    timeout=aiohttp.ClientTimeout(total=60.0)
                ) as response:
                    if response.status == 200:
                        data = await response.json()
                        task_id = data.get('task_id', '')
                        if task_id:
                            print(f"âœ… Magic task created: {task_id}")
                            return task_id
                        else:
                            print("âŒ No task_id in response")
                            return ""
                    else:
                        error_text = await response.text()
                        print(
                            f"âŒ Failed to create magic task: {response.status} - {error_text}")
                        return ""

        except Exception as e:
            print(f"âŒ Error creating magic task: {e}")
            return ""

    async def create_video_task(
        self,
        prompt: str,
        model: str,
        resolution: Optional[str] = None,
        duration: Optional[int] = None,
        aspect_ratio: Optional[str] = None,
        input_images: Optional[List[str]] = None,
        **kwargs: Any
    ) -> str:
        """
        åˆ›å»ºäº‘ç«¯è§†é¢‘ç”Ÿæˆä»»åŠ¡

        Args:
            prompt: è§†é¢‘ç”Ÿæˆæç¤ºè¯
            model: è§†é¢‘ç”Ÿæˆæ¨¡å‹
            resolution: è§†é¢‘åˆ†è¾¨ç‡
            duration: è§†é¢‘æ—¶é•¿ï¼ˆç§’ï¼‰
            aspect_ratio: å®½é«˜æ¯”
            input_images: è¾“å…¥å›¾ç‰‡åˆ—è¡¨ï¼ˆå¯é€‰ï¼‰
            **kwargs: å…¶ä»–å‚æ•°

        Returns:
            str: ä»»åŠ¡ ID

        Raises:
            Exception: å½“ä»»åŠ¡åˆ›å»ºå¤±è´¥æ—¶æŠ›å‡ºå¼‚å¸¸
        """
        async with HttpClient.create_aiohttp() as session:
            payload = {
                "prompt": prompt,
                "model": model,
                "resolution": resolution,
                "duration": duration,
                "aspect_ratio": aspect_ratio,
                **kwargs
            }

            if input_images:
                payload["input_images"] = input_images

            async with session.post(
                f"{self.api_url}/video/sunra/generations",
                headers=self._build_headers(),
                json=payload,
                timeout=aiohttp.ClientTimeout(total=120.0)
            ) as response:
                if response.status == 200:
                    data = await response.json()
                    task_id = data.get('task_id', '')
                    if task_id:
                        print(f"âœ… Video task created: {task_id}")
                        return task_id
                    else:
                        raise Exception("No task_id in response")
                else:
                    error_text = await response.text()
                    raise Exception(f"Failed to create video task: HTTP {response.status} - {error_text}")

    async def poll_for_task_completion(
        self,
        task_id: str,
        max_attempts: Optional[int] = None,
        interval: Optional[float] = None
    ) -> Dict[str, Any]:
        """
        ç­‰å¾…ä»»åŠ¡å®Œæˆå¹¶è¿”å›ç»“æœ

        Args:
            task_id: ä»»åŠ¡ ID
            max_attempts: æœ€å¤§è½®è¯¢æ¬¡æ•°
            interval: è½®è¯¢é—´éš”ï¼ˆç§’ï¼‰

        Returns:
            Dict[str, Any]: ä»»åŠ¡ç»“æœ

        Raises:
            Exception: å½“ä»»åŠ¡å¤±è´¥æˆ–è¶…æ—¶æ—¶æŠ›å‡ºå¼‚å¸¸
        """
        max_attempts = max_attempts or 150  # é»˜è®¤æœ€å¤šè½®è¯¢ 150 æ¬¡
        interval = interval or 2.0  # é»˜è®¤è½®è¯¢é—´éš” 2 ç§’

        async with HttpClient.create_aiohttp() as session:
            for _ in range(max_attempts):
                async with session.get(
                    f"{self.api_url}/task/{task_id}",
                    headers=self._build_headers(),
                    timeout=aiohttp.ClientTimeout(total=20.0)
                ) as response:
                    if response.status == 200:
                        data = await response.json()
                        if data.get('success') and data.get('data', {}).get('found'):
                            task = data['data']['task']
                            status = task.get('status')

                            if status == 'succeeded':
                                print(
                                    f"âœ… Task {task_id} completed successfully")
                                return task
                            elif status == 'failed':
                                error_msg = task.get('error', 'Unknown error')
                                raise Exception(f"Task failed: {error_msg}")
                            elif status == 'cancelled':
                                raise Exception("Task was cancelled")
                            elif status == 'processing':
                                # ç»§ç»­è½®è¯¢
                                await asyncio.sleep(interval)
                                continue
                            else:
                                raise Exception(f"Unknown task status: {status}")
                        else:
                            raise Exception("Task not found")
                    else:
                        raise Exception(f"Failed to get task status: HTTP {response.status}")

            raise Exception(f"Task polling timeout after {max_attempts} attempts")

    async def generate_magic_image(self, image_content: str) -> Optional[Dict[str, Any]]:
        """
        ç”Ÿæˆé­”æ³•å›¾åƒçš„å®Œæ•´æµç¨‹

        Args:
            image_content: å›¾ç‰‡å†…å®¹ï¼ˆbase64 æˆ– URLï¼‰

        Returns:
            Dict[str, Any]: åŒ…å« result_url çš„ä»»åŠ¡ç»“æœï¼Œå¤±è´¥æ—¶è¿”å›åŒ…å« error ä¿¡æ¯çš„å­—å…¸
        """
        try:
            # 1. åˆ›å»ºä»»åŠ¡
            task_id = await self.create_magic_task(image_content)
            if not task_id:
                print("âŒ Failed to create magic task")
                return {"error": "Failed to create magic task"}

            # 2. ç­‰å¾…ä»»åŠ¡å®Œæˆ
            result = await self.poll_for_task_completion(task_id, max_attempts=120, interval=5.0) # 10 åˆ†é’Ÿ
            if not result:
                print("âŒ Magic generation failed")
                return {"error": "Magic generation failed"}

            if not result.get('result_url'):
                error_msg = result.get('error', 'No result URL found')
                print(f"âŒ Magic generation failed: {error_msg}")
                return {"error": f"Magic generation failed: {error_msg}"}

            print(
                f"âœ… Magic image generated successfully: {result.get('result_url')}")
            return result

        except Exception as e:
            error_msg = f"Error in magic image generation: {str(e)}"
            print(f"âŒ {error_msg}")
            return {"error": error_msg}

    async def generate_video(
        self,
        prompt: str,
        model: str,
        resolution: Optional[str] = None,
        duration: Optional[int] = None,
        aspect_ratio: Optional[str] = None,
        input_images: Optional[List[str]] = None,
        **kwargs: Any
    ) -> Dict[str, Any]:
        """
        ç”Ÿæˆè§†é¢‘çš„å®Œæ•´æµç¨‹

        Args:
            prompt: è§†é¢‘ç”Ÿæˆæç¤ºè¯
            model: è§†é¢‘ç”Ÿæˆæ¨¡å‹
            resolution: è§†é¢‘åˆ†è¾¨ç‡
            duration: è§†é¢‘æ—¶é•¿ï¼ˆç§’ï¼‰
            aspect_ratio: å®½é«˜æ¯”
            input_images: è¾“å…¥å›¾ç‰‡åˆ—è¡¨ï¼ˆå¯é€‰ï¼‰
            **kwargs: å…¶ä»–å‚æ•°

        Returns:
            Dict[str, Any]: åŒ…å« result_url çš„ä»»åŠ¡ç»“æœ

        Raises:
            Exception: å½“è§†é¢‘ç”Ÿæˆå¤±è´¥æ—¶æŠ›å‡ºå¼‚å¸¸
        """
        # 1. åˆ›å»ºè§†é¢‘ç”Ÿæˆä»»åŠ¡
        task_id = await self.create_video_task(
            prompt=prompt,
            model=model,
            resolution=resolution,
            duration=duration,
            aspect_ratio=aspect_ratio,
            input_images=input_images,
            **kwargs
        )

        if not task_id:
            raise Exception("Failed to create video task")

        # 2. ç­‰å¾…ä»»åŠ¡å®Œæˆ
        result = await self.poll_for_task_completion(task_id)
        if not result:
            raise Exception("Video generation failed")

        if result.get('error'):
            raise Exception(f"Video generation failed: {result['error']}")

        if not result.get('result_url'):
            raise Exception("No result URL found in video generation response")

        print(
            f"âœ… Video generated successfully: {result.get('result_url')}")
        return result

    async def generate_video_by_seedance(
        self,
        prompt: str,
        model: str,
        resolution: str = "480p",
        duration: int = 5,
        aspect_ratio: str = "16:9",
        input_images: Optional[List[str]] = None,
        **kwargs: Any
    ) -> Dict[str, Any]:
        """
        ä½¿ç”¨ Seedance æ¨¡å‹ç”Ÿæˆè§†é¢‘çš„å®Œæ•´æµç¨‹

        Args:
            prompt: è§†é¢‘ç”Ÿæˆæç¤ºè¯
            model: è§†é¢‘ç”Ÿæˆæ¨¡å‹
            resolution: è§†é¢‘åˆ†è¾¨ç‡
            duration: è§†é¢‘æ—¶é•¿ï¼ˆç§’ï¼‰
            aspect_ratio: å®½é«˜æ¯”
            input_images: è¾“å…¥å›¾ç‰‡åˆ—è¡¨ï¼ˆå¯é€‰ï¼‰
            **kwargs: å…¶ä»–å‚æ•°

        Returns:
            Dict[str, Any]: åŒ…å« result_url çš„ä»»åŠ¡ç»“æœ

        Raises:
            Exception: å½“è§†é¢‘ç”Ÿæˆå¤±è´¥æ—¶æŠ›å‡ºå¼‚å¸¸
        """
        # 1. åˆ›å»º Seedance è§†é¢‘ç”Ÿæˆä»»åŠ¡
        async with HttpClient.create_aiohttp() as session:
            payload = {
                "prompt": prompt,
                "model": model,
                "resolution": resolution,
                "duration": duration,
                "aspect_ratio": aspect_ratio,
                **kwargs
            }

            if input_images:
                payload["input_images"] = input_images

            async with session.post(
                f"{self.api_url}/video/seedance/generation",
                headers=self._build_headers(),
                json=payload,
                timeout=aiohttp.ClientTimeout(total=120.0)
            ) as response:
                if response.status == 200:
                    data = await response.json()
                    task_id = data.get('task_id', '')
                    if not task_id:
                        raise Exception("No task_id in response")
                else:
                    error_text = await response.text()
                    raise Exception(f"Failed to create Seedance video task: HTTP {response.status} - {error_text}")

        print(f"âœ… Seedance video task created: {task_id}")

        # 2. ç­‰å¾…ä»»åŠ¡å®Œæˆ
        result = await self.poll_for_task_completion(task_id)
        if not result:
            raise Exception("Seedance video generation failed")

        if result.get('error'):
            raise Exception(f"Seedance video generation failed: {result['error']}")

        if not result.get('result_url'):
            raise Exception("No result URL found in Seedance video generation response")

        print(
            f"âœ… Seedance video generated successfully: {result.get('result_url')}")
        return result

    async def create_midjourney_task(
        self,
        prompt: str,
        model: str = "midjourney",
        **kwargs: Any
    ) -> str:
        """
        åˆ›å»ºäº‘ç«¯ Midjourney å›¾åƒç”Ÿæˆä»»åŠ¡

        Args:
            prompt: å›¾åƒç”Ÿæˆæç¤ºè¯
            model: å›¾åƒç”Ÿæˆæ¨¡å‹ï¼ˆé»˜è®¤ä¸º midjourneyï¼‰
            **kwargs: å…¶ä»–å‚æ•°ï¼ˆå¦‚ mode ç­‰ï¼‰

        Returns:
            str: ä»»åŠ¡ ID

        Raises:
            Exception: å½“ä»»åŠ¡åˆ›å»ºå¤±è´¥æ—¶æŠ›å‡ºå¼‚å¸¸
        """
        async with HttpClient.create_aiohttp() as session:
            payload = {
                "prompt": prompt,
                "model": model,
                **kwargs
            }

            async with session.post(
                f"{self.api_url}/image/midjourney/generation",
                headers=self._build_headers(),
                json=payload,
                timeout=aiohttp.ClientTimeout(total=60.0)
            ) as response:
                if response.status == 200:
                    data = await response.json()
                    task_id = data.get('task_id', '')
                    if task_id:
                        print(f"âœ… Midjourney task created: {task_id}")
                        return task_id
                    else:
                        raise Exception("No task_id in response")
                else:
                    error_text = await response.text()
                    raise Exception(f"Failed to create Midjourney task: HTTP {response.status} - {error_text}")

    async def generate_image_by_midjourney(
        self,
        prompt: str,
        model: str = "midjourney",
        **kwargs: Any
    ) -> Dict[str, Any]:
        """
        ä½¿ç”¨ Midjourney ç”Ÿæˆå›¾åƒçš„å®Œæ•´æµç¨‹

        Args:
            prompt: å›¾åƒç”Ÿæˆæç¤ºè¯
            model: å›¾åƒç”Ÿæˆæ¨¡å‹ï¼ˆé»˜è®¤ä¸º midjourneyï¼‰
            **kwargs: å…¶ä»–å‚æ•°ï¼ˆå¦‚ mode ç­‰ï¼‰

        Returns:
            Dict[str, Any]: åŒ…å« result_url çš„ä»»åŠ¡ç»“æœ

        Raises:
            Exception: å½“å›¾åƒç”Ÿæˆå¤±è´¥æ—¶æŠ›å‡ºå¼‚å¸¸
        """
        # 1. åˆ›å»º Midjourney å›¾åƒç”Ÿæˆä»»åŠ¡
        task_id = await self.create_midjourney_task(
            prompt=prompt,
            model=model,
            **kwargs
        )

        if not task_id:
            raise Exception("Failed to create Midjourney task")

        # 2. ç­‰å¾…ä»»åŠ¡å®Œæˆ
        task_result = await self.poll_for_task_completion(task_id, max_attempts=150, interval=2.0)
        print(f"ğŸ¨ Midjourney task result: {task_result}")
        if not task_result:
            raise Exception("Midjourney image generation failed")

        if task_result.get('error'):
            raise Exception(f"Midjourney image generation failed: {task_result['error']}")

        if not task_result.get('result'):
            raise Exception("No result found in Midjourney image generation response")

        result = task_result.get('result')
        print(f"âœ… Midjourney image generated successfully: {result}")
        return result or {}

    def is_configured(self) -> bool:
        """
        æ£€æŸ¥æœåŠ¡æ˜¯å¦å·²æ­£ç¡®é…ç½®

        Returns:
            bool: é…ç½®æ˜¯å¦æœ‰æ•ˆ
        """
        return self._is_configured()



================================================
FILE: server/services/knowledge_service.py
================================================
"""
Knowledge Service - çŸ¥è¯†åº“æœåŠ¡æ¨¡å—

è¯¥æ¨¡å—è´Ÿè´£ç®¡ç†çŸ¥è¯†åº“ç›¸å…³åŠŸèƒ½ï¼š
- ä»æœ¬åœ°è®¾ç½®ä¸­è·å–å¯ç”¨çš„çŸ¥è¯†åº“æ•°æ®
- æä¾›ç»Ÿä¸€çš„çŸ¥è¯†åº“è®¿é—®æ¥å£

æ¶æ„è¯´æ˜ï¼š
- å‰ç«¯ä»äº‘ç«¯APIè·å–çŸ¥è¯†åº“æ•°æ®
- å‰ç«¯å°†å¯ç”¨çš„çŸ¥è¯†åº“å®Œæ•´æ•°æ®å­˜å‚¨åˆ°æœ¬åœ°settingsä¸­
- Pythonæœ¬åœ°æœåŠ¡ä»settingsç›´æ¥è¯»å–çŸ¥è¯†åº“æ•°æ®ï¼Œæ— éœ€è®¿é—®äº‘ç«¯

ä¸»è¦åŠŸèƒ½ï¼š
1. ä»è®¾ç½®ä¸­è·å–å¯ç”¨çš„çŸ¥è¯†åº“å®Œæ•´æ•°æ®
2. æä¾›æ ¼å¼åŒ–çš„çŸ¥è¯†åº“ä¿¡æ¯è®¿é—®æ¥å£
3. ä¸è®¾ç½®æœåŠ¡é›†æˆç®¡ç†çŸ¥è¯†åº“æ•°æ®
"""

from typing import List, Dict, Any
from .settings_service import settings_service


class KnowledgeService:
    """
    çŸ¥è¯†åº“æœåŠ¡ç±»

    è´Ÿè´£ä»æœ¬åœ°è®¾ç½®ä¸­ç®¡ç†å’Œè®¿é—®çŸ¥è¯†åº“æ•°æ®
    """

    def __init__(self):
        """åˆå§‹åŒ–çŸ¥è¯†åº“æœåŠ¡"""
        pass

    def get_enabled_knowledge_ids(self) -> List[str]:
        """
        è·å–ç”¨æˆ·å¯ç”¨çš„çŸ¥è¯†åº“IDåˆ—è¡¨

        Returns:
            List[str]: å¯ç”¨çš„çŸ¥è¯†åº“IDåˆ—è¡¨
        """
        return settings_service.get_enabled_knowledge_ids()

    def get_enabled_knowledge_data(self) -> List[Dict[str, Any]]:
        """
        è·å–ç”¨æˆ·å¯ç”¨çš„çŸ¥è¯†åº“å®Œæ•´æ•°æ®åˆ—è¡¨

        Returns:
            List[Dict[str, Any]]: çŸ¥è¯†åº“æ•°æ®åˆ—è¡¨
        """
        return settings_service.get_enabled_knowledge_data()

    def list_user_enabled_knowledge(self) -> List[Dict[str, Any]]:
        """
        è·å–ç”¨æˆ·å¯ç”¨çš„çŸ¥è¯†åº“è¯¦ç»†ä¿¡æ¯åˆ—è¡¨

        è¿™æ˜¯ä¸»è¦çš„å¯¹å¤–æ¥å£ï¼Œè¿”å›åŒ…å«nameã€descriptionã€contentç­‰ä¿¡æ¯çš„çŸ¥è¯†åº“åˆ—è¡¨

        Returns:
            List[Dict[str, Any]]: çŸ¥è¯†åº“ä¿¡æ¯åˆ—è¡¨ï¼Œæ¯ä¸ªé¡¹ç›®åŒ…å«ï¼š
                - id: çŸ¥è¯†åº“ID
                - name: çŸ¥è¯†åº“åç§°
                - description: çŸ¥è¯†åº“æè¿°
                - content: çŸ¥è¯†åº“å†…å®¹
                - cover: å°é¢å›¾ç‰‡URL
                - is_public: æ˜¯å¦å…¬å¼€
                - created_at: åˆ›å»ºæ—¶é—´
                - updated_at: æ›´æ–°æ—¶é—´
        """
        knowledge_list = self.get_enabled_knowledge_data()

        # ç¡®ä¿è¿”å›çš„æ•°æ®åŒ…å«å¿…è¦å­—æ®µ
        formatted_list = []
        for kb in knowledge_list:
            formatted_kb = {
                'id': kb.get('id', ''),
                'name': kb.get('name', ''),
                'description': kb.get('description', ''),
                'content': kb.get('content', ''),
                'cover': kb.get('cover', ''),
                'is_public': kb.get('is_public', False),
                'created_at': kb.get('created_at', ''),
                'updated_at': kb.get('updated_at', ''),
            }
            formatted_list.append(formatted_kb)

        return formatted_list

    async def update_enabled_knowledge_data(self, knowledge_data_list: List[Dict[str, Any]]) -> Dict[str, Any]:
        """
        æ›´æ–°å¯ç”¨çš„çŸ¥è¯†åº“å®Œæ•´æ•°æ®

        Args:
            knowledge_data_list (List[Dict[str, Any]]): çŸ¥è¯†åº“æ•°æ®åˆ—è¡¨

        Returns:
            Dict[str, Any]: æ“ä½œç»“æœ
        """
        return await settings_service.update_enabled_knowledge_data(knowledge_data_list)


# åˆ›å»ºå…¨å±€çŸ¥è¯†åº“æœåŠ¡å®ä¾‹
knowledge_service = KnowledgeService()


# æä¾›ä¾¿æ·çš„å…¨å±€å‡½æ•°
def list_user_enabled_knowledge() -> List[Dict[str, Any]]:
    """
    è·å–ç”¨æˆ·å¯ç”¨çš„çŸ¥è¯†åº“è¯¦ç»†ä¿¡æ¯åˆ—è¡¨ (å…¨å±€å‡½æ•°)

    è¿™æ˜¯ä¸€ä¸ªä¾¿æ·çš„å…¨å±€å‡½æ•°ï¼Œå¯ä»¥ç›´æ¥è°ƒç”¨è·å–ç”¨æˆ·å¯ç”¨çš„çŸ¥è¯†åº“ä¿¡æ¯

    Returns:
        List[Dict[str, Any]]: çŸ¥è¯†åº“ä¿¡æ¯åˆ—è¡¨
    """
    return knowledge_service.list_user_enabled_knowledge()



================================================
FILE: server/services/magic_service.py
================================================
# services/magic_service.py

# Import necessary modules
import asyncio
import json
from typing import Dict, Any, List

# Import service modules
from services.db_service import db_service
from services.OpenAIAgents_service import create_jaaz_response
from services.websocket_service import send_to_websocket  # type: ignore
from services.stream_service import add_stream_task, remove_stream_task


async def handle_magic(data: Dict[str, Any]) -> None:
    """
    Handle an incoming magic generation request.

    Workflow:
    - Parse incoming magic generation data.
    - Run Agents.
    - Save magic session and messages to the database.
    - Notify frontend via WebSocket.

    Args:
        data (dict): Magic generation request data containing:
            - messages: list of message dicts
            - session_id: unique session identifier
            - canvas_id: canvas identifier (contextual use)
            - text_model: text model configuration
            - tool_list: list of tool model configurations (images/videos)
    """
    # Extract fields from incoming data
    messages: List[Dict[str, Any]] = data.get('messages', [])
    session_id: str = data.get('session_id', '')
    canvas_id: str = data.get('canvas_id', '')

    # print('âœ¨ magic_service æ¥æ”¶åˆ°æ•°æ®:', {
    #     'session_id': session_id,
    #     'canvas_id': canvas_id,
    #     'messages_count': len(messages),
    # })

    # If there is only one message, create a new magic session
    if len(messages) == 1:
        # create new session
        prompt = messages[0].get('content', '')
        await db_service.create_chat_session(session_id, 'gpt', 'jaaz', canvas_id, (prompt[:200] if isinstance(prompt, str) else ''))

    # Save user message to database
    if len(messages) > 0:
        await db_service.create_message(
            session_id, messages[-1].get('role', 'user'), json.dumps(messages[-1])
        )

    # Create and start magic generation task
    task = asyncio.create_task(_process_magic_generation(messages, session_id, canvas_id))

    # Register the task in stream_tasks (for possible cancellation)
    add_stream_task(session_id, task)
    try:
        # Await completion of the magic generation task
        await task
    except asyncio.exceptions.CancelledError:
        print(f"ğŸ›‘Magic generation session {session_id} cancelled")
    finally:
        # Always remove the task from stream_tasks after completion/cancellation
        remove_stream_task(session_id)
        # Notify frontend WebSocket that magic generation is done
        await send_to_websocket(session_id, {'type': 'done'})

    print('âœ¨ magic_service å¤„ç†å®Œæˆ')


async def _process_magic_generation(
    messages: List[Dict[str, Any]],
    session_id: str,
    canvas_id: str,
) -> None:
    """
    Process magic generation in a separate async task.

    Args:
        messages: List of messages
        session_id: Session ID
        canvas_id: Canvas ID
    """

    ai_response = await create_jaaz_response(messages, session_id, canvas_id)

    # Save AI response to database
    await db_service.create_message(session_id, 'assistant', json.dumps(ai_response))

    # Send messages to frontend immediately
    all_messages = messages + [ai_response]
    await send_to_websocket(
        session_id, {'type': 'all_messages', 'messages': all_messages}
    )



================================================
FILE: server/services/mcp.py
================================================
import asyncio
from typing import List, Optional, Any, Dict
from pydantic import BaseModel
from contextlib import AsyncExitStack
from mcp import ClientSession, StdioServerParameters
from mcp.client.stdio import stdio_client
from anthropic import Anthropic



class MCPClient:
    def __init__(self):
        # Initialize session and client objects
        self.session: Optional[ClientSession] = None
        self.exit_stack = AsyncExitStack()
        self.anthropic = Anthropic()
        self.tools: List[Dict[str, Any]]  = []

    async def connect_to_server(self, command: str, args: list[str], env: Optional[dict[str, str]] = None):
            
        server_params = StdioServerParameters(
            command=command,
            args=args,
            env=env
        )
        
        stdio_transport = await self.exit_stack.enter_async_context(stdio_client(server_params))
        self.stdio, self.write = stdio_transport
        self.session = await self.exit_stack.enter_async_context(ClientSession(self.stdio, self.write))

        await self.session.initialize()
        
        # List available tools
        response = await self.session.list_tools()
        self.tools = [{ 
            "name": tool.name,
            "description": tool.description,
            "input_schema": tool.inputSchema
        } for tool in response.tools]

    async def process_query(self, query: str) -> str:
        """Process a query using Claude and available tools"""
        messages = [
            {
                "role": "user",
                "content": query
            }
        ]

        response = await self.session.list_tools()
        available_tools = [{ 
            "name": tool.name,
            "description": tool.description,
            "input_schema": tool.inputSchema
        } for tool in response.tools]

        # Initial Claude API call
        response = self.anthropic.messages.create(
            model="claude-3-5-sonnet-20241022",
            max_tokens=1000,
            messages=messages,
            tools=available_tools
        )

        # Process response and handle tool calls
        final_text = []

        for content in response.content:
            if content.type == 'text':
                final_text.append(content.text)
            elif content.type == 'tool_use':
                tool_name = content.name
                tool_args = content.input
                
                # Execute tool call
                result = await self.session.call_tool(tool_name, tool_args)
                final_text.append(f"[Calling tool {tool_name} with args {tool_args}]")

                # Continue conversation with tool results
                if hasattr(content, 'text') and content.text:
                    messages.append({
                      "role": "assistant",
                      "content": content.text
                    })
                messages.append({
                    "role": "user", 
                    "content": result.content
                })

                # Get next response from Claude
                response = self.anthropic.messages.create(
                    model="claude-3-5-sonnet-20241022",
                    max_tokens=1000,
                    messages=messages,
                )

                final_text.append(response.content[0].text)

        return "\n".join(final_text)

    # async def chat_loop(self):
    #     """Run an interactive chat loop"""
    #     print("\nMCP Client Started!")
    #     print("Type your queries or 'quit' to exit.")
        
    #     while True:
    #         try:
    #             query = input("\nQuery: ").strip()
                
    #             if query.lower() == 'quit':
    #                 break
                    
    #             response = await self.process_query(query)
    #             print("\n" + response)
                    
    #         except Exception as e:
    #             print(f"\nError: {str(e)}")
    
    async def cleanup(self):
        """Clean up resources"""
        await self.exit_stack.aclose()

async def main():
    import sys
    if len(sys.argv) < 2:
        print("Usage: python client.py <path_to_server_script>")
        sys.exit(1)
        
    client = MCPClient()
    try:
        await client.connect_to_server(sys.argv[1])
        await client.chat_loop()
    finally:
        await client.cleanup()

# if __name__ == "__main__":
#     import sys
#     asyncio.run(main())


================================================
FILE: server/services/settings_service.py
================================================
"""
Settings Service - è®¾ç½®æœåŠ¡æ¨¡å—

è¯¥æ¨¡å—è´Ÿè´£ç®¡ç†åº”ç”¨ç¨‹åºçš„æ‰€æœ‰é…ç½®è®¾ç½®ï¼ŒåŒ…æ‹¬ï¼š
- ä»£ç†é…ç½®ï¼ˆproxy settingsï¼‰
- ç³»ç»Ÿæç¤ºè¯ï¼ˆsystem promptsï¼‰
- å…¶ä»–åº”ç”¨é…ç½®é¡¹

ä¸»è¦åŠŸèƒ½ï¼š
1. è¯»å–å’Œå†™å…¥ JSON æ ¼å¼çš„è®¾ç½®æ–‡ä»¶
2. æä¾›é»˜è®¤è®¾ç½®é…ç½®
3. æ•æ„Ÿä¿¡æ¯æ©ç å¤„ç†ï¼ˆå¦‚å¯†ç ï¼‰
4. è®¾ç½®çš„åˆå¹¶å’Œæ›´æ–°æ“ä½œ
5. å…¨å±€è®¾ç½®çŠ¶æ€ç®¡ç†

æ–‡ä»¶ç»“æ„ï¼š
- DEFAULT_SETTINGS: é»˜è®¤é…ç½®æ¨¡æ¿
- SettingsService: æ ¸å¿ƒè®¾ç½®æœåŠ¡ç±»
- settings_service: å…¨å±€æœåŠ¡å®ä¾‹
- app_settings: å…¨å±€è®¾ç½®ç¼“å­˜
"""

import os
import traceback
import json

# ç”¨æˆ·æ•°æ®ç›®å½•è·¯å¾„ï¼Œä¼˜å…ˆä½¿ç”¨ç¯å¢ƒå˜é‡ï¼Œå¦åˆ™ä½¿ç”¨é»˜è®¤è·¯å¾„
USER_DATA_DIR = os.getenv("USER_DATA_DIR", os.path.join(
    os.path.dirname(os.path.dirname(__file__)), "user_data"))

# å…¨å±€è®¾ç½®é…ç½®ç¼“å­˜ï¼Œç”¨äºåœ¨åº”ç”¨è¿è¡Œæ—¶å¿«é€Ÿè®¿é—®è®¾ç½®
app_settings = {}

# é»˜è®¤è®¾ç½®é…ç½®æ¨¡æ¿
# å®šä¹‰äº†åº”ç”¨ç¨‹åºçš„åŸºç¡€é…ç½®ç»“æ„å’Œé»˜è®¤å€¼
DEFAULT_SETTINGS = {
    "proxy": "system",  # ä»£ç†è®¾ç½®ï¼š'' (ä¸ä½¿ç”¨ä»£ç†), 'system' (ä½¿ç”¨ç³»ç»Ÿä»£ç†), æˆ–å…·ä½“çš„ä»£ç†URLåœ°å€
    "enabled_knowledge": [],  # å¯ç”¨çš„çŸ¥è¯†åº“IDåˆ—è¡¨ï¼ˆä¿æŒå…¼å®¹æ€§ï¼‰
    "enabled_knowledge_data": []  # å¯ç”¨çš„çŸ¥è¯†åº“å®Œæ•´æ•°æ®åˆ—è¡¨
}


class SettingsService:
    """
    è®¾ç½®æœåŠ¡ç±»

    è´Ÿè´£ç®¡ç†åº”ç”¨ç¨‹åºçš„æ‰€æœ‰é…ç½®è®¾ç½®ï¼ŒåŒ…æ‹¬è¯»å–ã€å†™å…¥ã€æ›´æ–°ç­‰æ“ä½œã€‚
    ä½¿ç”¨ TOML æ ¼å¼å­˜å‚¨é…ç½®æ–‡ä»¶ï¼Œæ”¯æŒè®¾ç½®çš„åˆå¹¶å’Œæ•æ„Ÿä¿¡æ¯æ©ç ã€‚

    Attributes:
        root_dir (str): é¡¹ç›®æ ¹ç›®å½•è·¯å¾„
        settings_file (str): è®¾ç½®æ–‡ä»¶çš„å®Œæ•´è·¯å¾„
    """

    def __init__(self):
        """
        åˆå§‹åŒ–è®¾ç½®æœåŠ¡

        è®¾ç½®é¡¹ç›®æ ¹ç›®å½•å’Œé…ç½®æ–‡ä»¶è·¯å¾„ã€‚
        é…ç½®æ–‡ä»¶è·¯å¾„å¯é€šè¿‡ç¯å¢ƒå˜é‡ SETTINGS_PATH è‡ªå®šä¹‰ã€‚
        """
        self.root_dir = os.path.dirname(
            os.path.dirname(os.path.dirname(__file__)))
        self.settings_file = os.getenv(
            "SETTINGS_PATH", os.path.join(USER_DATA_DIR, "settings.json"))

    async def exists_settings(self):
        """
        æ£€æŸ¥è®¾ç½®æ–‡ä»¶æ˜¯å¦å­˜åœ¨

        Returns:
            bool: å¦‚æœè®¾ç½®æ–‡ä»¶å­˜åœ¨è¿”å› Trueï¼Œå¦åˆ™è¿”å› False

        Note:
            è¿™æ˜¯ä¸€ä¸ªå¼‚æ­¥æ–¹æ³•ï¼Œä¸»è¦æ˜¯ä¸ºäº†ä¿æŒ API æ¥å£çš„ä¸€è‡´æ€§
        """
        return os.path.exists(self.settings_file)

    def get_settings(self):
        """
        è·å–æ‰€æœ‰è®¾ç½®é…ç½®ï¼ˆç”¨äº API å“åº”ï¼‰

        è¯¥æ–¹æ³•ä¼šï¼š
        1. è¯»å–è®¾ç½®æ–‡ä»¶ï¼ˆå¦‚æœä¸å­˜åœ¨åˆ™åˆ›å»ºé»˜è®¤é…ç½®ï¼‰
        2. ä¸é»˜è®¤è®¾ç½®åˆå¹¶ï¼Œç¡®ä¿æ‰€æœ‰å¿…éœ€çš„é”®éƒ½å­˜åœ¨
        3. å¯¹æ•æ„Ÿä¿¡æ¯è¿›è¡Œæ©ç å¤„ç†
        4. æ›´æ–°å…¨å±€è®¾ç½®ç¼“å­˜

        Returns:
            dict: åŒ…å«æ‰€æœ‰è®¾ç½®çš„å­—å…¸ï¼Œæ•æ„Ÿä¿¡æ¯å·²è¢«æ©ç 

        Note:
            è¿”å›çš„è®¾ç½®é€‚ç”¨äº API å“åº”ï¼Œæ•æ„Ÿä¿¡æ¯ï¼ˆå¦‚å¯†ç ï¼‰ä¼šè¢« '*' æ©ç 
        """
        try:
            if not os.path.exists(self.settings_file):
                # å¦‚æœè®¾ç½®æ–‡ä»¶ä¸å­˜åœ¨ï¼Œåˆ›å»ºé»˜è®¤è®¾ç½®æ–‡ä»¶
                self.create_default_settings()

            # è¯»å– JSON é…ç½®æ–‡ä»¶
            with open(self.settings_file, 'r', encoding='utf-8') as f:
                settings = json.load(f)

            # ä¸é»˜è®¤è®¾ç½®åˆå¹¶ï¼Œç¡®ä¿æ‰€æœ‰é”®éƒ½å­˜åœ¨
            merged_settings = {**DEFAULT_SETTINGS}
            for key, value in settings.items():
                if key in merged_settings and isinstance(merged_settings[key], dict) and isinstance(value, dict):
                    # å¯¹äºå­—å…¸ç±»å‹çš„è®¾ç½®ï¼Œè¿›è¡Œæ·±åº¦åˆå¹¶
                    merged_settings[key].update(value)
                else:
                    # å…¶ä»–ç±»å‹ç›´æ¥è¦†ç›–
                    merged_settings[key] = value

            # æ›´æ–°å…¨å±€è®¾ç½®ç¼“å­˜ï¼ˆå­˜å‚¨æœªæ©ç çš„å®Œæ•´ç‰ˆæœ¬ï¼‰
            global app_settings
            app_settings = merged_settings
            return merged_settings
        except Exception as e:
            print(f"Error loading settings: {e}")
            traceback.print_exc()
            return DEFAULT_SETTINGS

    def get_raw_settings(self):
        """
        è·å–åŸå§‹è®¾ç½®ï¼ˆå†…éƒ¨ä½¿ç”¨ï¼Œä¸æ©ç æ•æ„Ÿä¿¡æ¯ï¼‰

        è¯¥æ–¹æ³•è¿”å›å®Œæ•´çš„è®¾ç½®é…ç½®ï¼ŒåŒ…æ‹¬æ•æ„Ÿä¿¡æ¯ï¼Œä¸»è¦ç”¨äºï¼š
        1. ç³»ç»Ÿå†…éƒ¨é€»è¾‘ä½¿ç”¨
        2. ä»£ç†é…ç½®ç­‰éœ€è¦å®Œæ•´ä¿¡æ¯çš„åœºæ™¯
        3. è®¾ç½®çš„éªŒè¯å’Œå¤„ç†

        Returns:
            dict: åŒ…å«æ‰€æœ‰è®¾ç½®çš„å®Œæ•´å­—å…¸ï¼Œæ•æ„Ÿä¿¡æ¯æœªè¢«æ©ç 

        Note:
            æ­¤æ–¹æ³•è¿”å›çš„æ•°æ®åŒ…å«æ•æ„Ÿä¿¡æ¯ï¼Œä»…ä¾›å†…éƒ¨ä½¿ç”¨ï¼Œä¸åº”ç›´æ¥ç”¨äº API å“åº”
        """
        try:
            if not os.path.exists(self.settings_file):
                # å¦‚æœè®¾ç½®æ–‡ä»¶ä¸å­˜åœ¨ï¼Œåˆ›å»ºé»˜è®¤è®¾ç½®
                self.create_default_settings()

            # è¯»å– JSON é…ç½®æ–‡ä»¶
            with open(self.settings_file, 'r', encoding='utf-8') as f:
                settings = json.load(f)

            # ä¸é»˜è®¤è®¾ç½®åˆå¹¶
            merged_settings = {**DEFAULT_SETTINGS}
            for key, value in settings.items():
                if key in merged_settings and isinstance(merged_settings[key], dict) and isinstance(value, dict):
                    merged_settings[key].update(value)
                else:
                    merged_settings[key] = value

            # æ›´æ–°å…¨å±€è®¾ç½®ç¼“å­˜
            global app_settings
            app_settings = merged_settings
            return merged_settings
        except Exception as e:
            print(f"Error loading raw settings: {e}")
            return DEFAULT_SETTINGS

    def get_proxy_config(self):
        """
        è·å–ä»£ç†é…ç½®

        Returns:
            str: ä»£ç†é…ç½®å­—ç¬¦ä¸²
                - '' : ä¸ä½¿ç”¨ä»£ç†
                - 'system' : ä½¿ç”¨ç³»ç»Ÿä»£ç†
                - URLåœ°å€ : ä½¿ç”¨æŒ‡å®šçš„ä»£ç†æœåŠ¡å™¨
        """
        settings = self.get_raw_settings()
        return settings.get('proxy', '')

    def get_enabled_knowledge_ids(self):
        """
        è·å–å¯ç”¨çš„çŸ¥è¯†åº“IDåˆ—è¡¨

        Returns:
            list: å¯ç”¨çš„çŸ¥è¯†åº“IDåˆ—è¡¨
        """
        settings = self.get_raw_settings()
        return settings.get('enabled_knowledge', [])

    async def update_enabled_knowledge(self, knowledge_ids):
        """
        æ›´æ–°å¯ç”¨çš„çŸ¥è¯†åº“åˆ—è¡¨

        Args:
            knowledge_ids (list): çŸ¥è¯†åº“IDåˆ—è¡¨

        Returns:
            dict: æ“ä½œç»“æœ
        """
        return await self.update_settings({"enabled_knowledge": knowledge_ids})

    def get_enabled_knowledge_data(self):
        """
        è·å–å¯ç”¨çš„çŸ¥è¯†åº“å®Œæ•´æ•°æ®åˆ—è¡¨

        Returns:
            list: çŸ¥è¯†åº“æ•°æ®åˆ—è¡¨ï¼Œæ¯ä¸ªé¡¹ç›®åŒ…å«nameã€descriptionã€contentç­‰ä¿¡æ¯
        """
        settings = self.get_raw_settings()
        return settings.get('enabled_knowledge_data', [])

    async def update_enabled_knowledge_data(self, knowledge_data_list):
        """
        æ›´æ–°å¯ç”¨çš„çŸ¥è¯†åº“å®Œæ•´æ•°æ®

        Args:
            knowledge_data_list (list): çŸ¥è¯†åº“æ•°æ®åˆ—è¡¨ï¼ŒåŒ…å«å®Œæ•´çš„çŸ¥è¯†åº“ä¿¡æ¯

        Returns:
            dict: æ“ä½œç»“æœ
        """
        # åŒæ—¶æ›´æ–°IDåˆ—è¡¨å’Œå®Œæ•´æ•°æ®
        knowledge_ids = [kb.get('id', '')
                         for kb in knowledge_data_list if kb.get('id')]
        return await self.update_settings({
            "enabled_knowledge": knowledge_ids,
            "enabled_knowledge_data": knowledge_data_list
        })

    def create_default_settings(self):
        """
        åˆ›å»ºé»˜è®¤è®¾ç½®æ–‡ä»¶

        å½“è®¾ç½®æ–‡ä»¶ä¸å­˜åœ¨æ—¶ï¼Œæ ¹æ® DEFAULT_SETTINGS æ¨¡æ¿åˆ›å»ºæ–°çš„é…ç½®æ–‡ä»¶ã€‚
        ä¼šè‡ªåŠ¨åˆ›å»ºå¿…è¦çš„ç›®å½•ç»“æ„ã€‚

        Raises:
            Exception: å½“æ–‡ä»¶åˆ›å»ºå¤±è´¥æ—¶æŠ›å‡ºå¼‚å¸¸
        """
        try:
            # ç¡®ä¿ç›®å½•å­˜åœ¨
            os.makedirs(os.path.dirname(self.settings_file), exist_ok=True)

            # å†™å…¥é»˜è®¤è®¾ç½®åˆ° JSON æ–‡ä»¶
            with open(self.settings_file, 'w', encoding='utf-8') as f:
                json.dump(DEFAULT_SETTINGS, f, indent=2)
        except Exception as e:
            print(f"Error creating default settings: {e}")

    async def update_settings(self, data):
        """
        æ›´æ–°è®¾ç½®é…ç½®

        è¯¥æ–¹æ³•ä¼šï¼š
        1. è¯»å–ç°æœ‰è®¾ç½®
        2. ä¸æ–°æ•°æ®è¿›è¡Œåˆå¹¶ï¼ˆæ·±åº¦åˆå¹¶å­—å…¸ç±»å‹ï¼‰
        3. ä¿å­˜æ›´æ–°åçš„è®¾ç½®åˆ°æ–‡ä»¶
        4. æ›´æ–°å…¨å±€è®¾ç½®ç¼“å­˜

        Args:
            data (dict): è¦æ›´æ–°çš„è®¾ç½®æ•°æ®ï¼Œå¯ä»¥æ˜¯éƒ¨åˆ†è®¾ç½®

        Returns:
            dict: åŒ…å«æ“ä½œçŠ¶æ€å’Œæ¶ˆæ¯çš„å­—å…¸
                - status (str): "success" æˆ– "error"
                - message (str): æ“ä½œç»“æœæè¿°

        Example:
            result = await settings_service.update_settings({
                "proxy": {"enable": True, "url": "http://proxy.com:8080"}
            })
        """
        try:
            # åŠ è½½ç°æœ‰è®¾ç½®ï¼Œå¦‚æœæ–‡ä»¶ä¸å­˜åœ¨åˆ™ä½¿ç”¨é»˜è®¤è®¾ç½®
            existing_settings = DEFAULT_SETTINGS.copy()
            if os.path.exists(self.settings_file):
                try:
                    with open(self.settings_file, 'r', encoding='utf-8') as f:
                        existing_settings = json.load(f)
                except Exception as e:
                    print(f"Error reading existing settings: {e}")

            # åˆå¹¶æ–°æ•°æ®åˆ°ç°æœ‰è®¾ç½®
            for key, value in data.items():
                if key in existing_settings and isinstance(existing_settings[key], dict) and isinstance(value, dict):
                    # å¯¹äºå­—å…¸ç±»å‹ï¼Œè¿›è¡Œæ·±åº¦åˆå¹¶è€Œä¸æ˜¯æ›¿æ¢
                    existing_settings[key].update(value)
                else:
                    # å…¶ä»–ç±»å‹ç›´æ¥è¦†ç›–
                    existing_settings[key] = value

            # ç¡®ä¿ç›®å½•å­˜åœ¨
            os.makedirs(os.path.dirname(self.settings_file), exist_ok=True)

            # ä¿å­˜æ›´æ–°åçš„è®¾ç½®åˆ°æ–‡ä»¶
            with open(self.settings_file, 'w', encoding='utf-8') as f:
                json.dump(existing_settings, f, indent=2)

            # æ›´æ–°å…¨å±€è®¾ç½®ç¼“å­˜
            global app_settings
            app_settings = existing_settings

            return {"status": "success", "message": "Settings updated successfully"}
        except Exception as e:
            traceback.print_exc()
            return {"status": "error", "message": str(e)}


# åˆ›å»ºå…¨å±€è®¾ç½®æœåŠ¡å®ä¾‹
# æ•´ä¸ªåº”ç”¨ç¨‹åºä½¿ç”¨è¿™ä¸ªå•ä¾‹å®ä¾‹æ¥ç®¡ç†è®¾ç½®
settings_service = SettingsService()

# åœ¨æ¨¡å—å¯¼å…¥æ—¶åˆå§‹åŒ–è®¾ç½®
# ç¡®ä¿å…¨å±€è®¾ç½®ç¼“å­˜åœ¨åº”ç”¨å¯åŠ¨æ—¶å°±è¢«åŠ è½½
settings_service.get_raw_settings()



================================================
FILE: server/services/stream_service.py
================================================
# services/stream_service.py
from typing import Dict, Optional, Any
import asyncio

# Dictionary to store active stream tasks, keyed by session_id
stream_tasks: Dict[str, asyncio.Task[Any]] = {}

def add_stream_task(session_id: str, task: asyncio.Task[Any]) -> None:
    """
    Add a stream task for the given session_id.

    Args:
        session_id (str): Unique identifier for the session.
        task: The task object to associate with the session.
    """
    stream_tasks[session_id] = task

def remove_stream_task(session_id: str) -> None:
    """
    Remove the stream task associated with the given session_id.

    Args:
        session_id (str): Unique identifier for the session.
    """
    stream_tasks.pop(session_id, None)

def get_stream_task(session_id: str) -> Optional[asyncio.Task[Any]]:
    """
    Retrieve the stream task associated with the given session_id.

    Args:
        session_id (str): Unique identifier for the session.

    Returns:
        The task object if found, otherwise None.
    """
    return stream_tasks.get(session_id)

# ä½ ä¹Ÿå¯ä»¥åŠ ä¸€ä¸ª list_stream_tasks() è¿”å›æ‰€æœ‰ session_id



================================================
FILE: server/services/tool_confirmation_manager.py
================================================
import asyncio
from typing import Dict, Any, Optional
from dataclasses import dataclass
from datetime import datetime, timedelta


@dataclass
class ToolConfirmationRequest:
    tool_call_id: str
    session_id: str
    tool_name: str
    arguments: Dict[str, Any]
    created_at: datetime
    confirmed: Optional[bool] = None


class ToolConfirmationManager:
    """å·¥å…·ç¡®è®¤ç®¡ç†å™¨"""

    def __init__(self):
        self.pending_confirmations: Dict[str, ToolConfirmationRequest] = {}
        self.confirmation_timeout = timedelta(minutes=5)  # 5åˆ†é’Ÿè¶…æ—¶

    async def request_confirmation(self, tool_call_id: str, session_id: str, tool_name: str, arguments: Dict[str, Any]) -> bool:
        """è¯·æ±‚å·¥å…·ç¡®è®¤ï¼Œè¿”å›æ˜¯å¦å·²ç¡®è®¤"""
        request = ToolConfirmationRequest(
            tool_call_id=tool_call_id,
            session_id=session_id,
            tool_name=tool_name,
            arguments=arguments,
            created_at=datetime.now()
        )

        self.pending_confirmations[tool_call_id] = request

        # ç­‰å¾…ç¡®è®¤æˆ–è¶…æ—¶
        try:
            await asyncio.wait_for(
                self._wait_for_confirmation(tool_call_id),
                timeout=self.confirmation_timeout.total_seconds()
            )
            return request.confirmed is True
        except asyncio.TimeoutError:
            # è¶…æ—¶ï¼Œè‡ªåŠ¨å–æ¶ˆ
            self.cancel_confirmation(tool_call_id)
            return False

    async def _wait_for_confirmation(self, tool_call_id: str):
        """ç­‰å¾…ç¡®è®¤"""
        while tool_call_id in self.pending_confirmations:
            request = self.pending_confirmations[tool_call_id]
            if request.confirmed is not None:
                return
            await asyncio.sleep(0.1)

    def confirm_tool(self, tool_call_id: str) -> bool:
        """ç¡®è®¤å·¥å…·è°ƒç”¨"""
        if tool_call_id in self.pending_confirmations:
            self.pending_confirmations[tool_call_id].confirmed = True
            return True
        return False

    def cancel_confirmation(self, tool_call_id: str) -> bool:
        """å–æ¶ˆå·¥å…·è°ƒç”¨"""
        if tool_call_id in self.pending_confirmations:
            self.pending_confirmations[tool_call_id].confirmed = False
            return True
        return False

    def get_pending_request(self, tool_call_id: str) -> Optional[ToolConfirmationRequest]:
        """è·å–å¾…ç¡®è®¤çš„è¯·æ±‚"""
        return self.pending_confirmations.get(tool_call_id)

    def cleanup_expired(self):
        """æ¸…ç†è¿‡æœŸçš„ç¡®è®¤è¯·æ±‚"""
        now = datetime.now()
        expired_ids = [
            tool_call_id for tool_call_id, request in self.pending_confirmations.items()
            if now - request.created_at > self.confirmation_timeout
        ]
        for tool_call_id in expired_ids:
            del self.pending_confirmations[tool_call_id]


# å…¨å±€å®ä¾‹
tool_confirmation_manager = ToolConfirmationManager()



================================================
FILE: server/services/tool_service.py
================================================
import traceback
from typing import Dict
from langchain_core.tools import BaseTool
from models.tool_model import ToolInfo
from tools.comfy_dynamic import build_tool
from tools.write_plan import write_plan_tool
from tools.generate_image_by_gpt_image_1_jaaz import generate_image_by_gpt_image_1_jaaz
from tools.generate_image_by_imagen_4_jaaz import generate_image_by_imagen_4_jaaz
from tools.generate_image_by_imagen_4_replicate import (
    generate_image_by_imagen_4_replicate,
)
from tools.generate_image_by_ideogram3_bal_jaaz import (
    generate_image_by_ideogram3_bal_jaaz,
)

# from tools.generate_image_by_flux_1_1_pro import generate_image_by_flux_1_1_pro
from tools.generate_image_by_flux_kontext_pro_jaaz import (
    generate_image_by_flux_kontext_pro_jaaz,
)
from tools.generate_image_by_flux_kontext_pro_replicate import (
    generate_image_by_flux_kontext_pro_replicate,
)
from tools.generate_image_by_flux_kontext_max_jaaz import (
    generate_image_by_flux_kontext_max,
)
from tools.generate_image_by_flux_kontext_max_replicate import (
    generate_image_by_flux_kontext_max_replicate,
)
from tools.generate_image_by_doubao_seedream_3_jaaz import (
    generate_image_by_doubao_seedream_3_jaaz,
)
from tools.generate_image_by_doubao_seedream_3_volces import (
    generate_image_by_doubao_seedream_3_volces,
)
from tools.generate_image_by_doubao_seededit_3_volces import (
    edit_image_by_doubao_seededit_3_volces,
)
from tools.generate_video_by_seedance_v1_jaaz import generate_video_by_seedance_v1_jaaz
from tools.generate_video_by_seedance_v1_pro_volces import (
    generate_video_by_seedance_v1_pro_volces,
)
from tools.generate_video_by_seedance_v1_lite_volces import (
    generate_video_by_seedance_v1_lite_t2v,
    generate_video_by_seedance_v1_lite_i2v,
)
from tools.generate_video_by_kling_v2_jaaz import generate_video_by_kling_v2_jaaz
from tools.generate_image_by_recraft_v3_jaaz import generate_image_by_recraft_v3_jaaz
from tools.generate_image_by_recraft_v3_replicate import (
    generate_image_by_recraft_v3_replicate,
)
from tools.generate_video_by_hailuo_02_jaaz import generate_video_by_hailuo_02_jaaz
from tools.generate_video_by_veo3_fast_jaaz import generate_video_by_veo3_fast_jaaz
from tools.generate_image_by_midjourney_jaaz import generate_image_by_midjourney_jaaz
from services.config_service import config_service
from services.db_service import db_service

TOOL_MAPPING: Dict[str, ToolInfo] = {
    "generate_image_by_gpt_image_1_jaaz": {
        "display_name": "GPT Image 1",
        "type": "image",
        "provider": "jaaz",
        "tool_function": generate_image_by_gpt_image_1_jaaz,
    },
    "generate_image_by_imagen_4_jaaz": {
        "display_name": "Imagen 4",
        "type": "image",
        "provider": "jaaz",
        "tool_function": generate_image_by_imagen_4_jaaz,
    },
    "generate_image_by_recraft_v3_jaaz": {
        "display_name": "Recraft v3",
        "type": "image",
        "provider": "jaaz",
        "tool_function": generate_image_by_recraft_v3_jaaz,
    },
    "generate_image_by_ideogram3_bal_jaaz": {
        "display_name": "Ideogram 3 Balanced",
        "type": "image",
        "provider": "jaaz",
        "tool_function": generate_image_by_ideogram3_bal_jaaz,
    },
    # "generate_image_by_flux_1_1_pro_jaaz": {
    #     "display_name": "Flux 1.1 Pro",
    #     "type": "image",
    #     "provider": "jaaz",
    #     "tool_function": generate_image_by_flux_1_1_pro,
    # },
    "generate_image_by_flux_kontext_pro_jaaz": {
        "display_name": "Flux Kontext Pro",
        "type": "image",
        "provider": "jaaz",
        "tool_function": generate_image_by_flux_kontext_pro_jaaz,
    },
    "generate_image_by_flux_kontext_max_jaaz": {
        "display_name": "Flux Kontext Max",
        "type": "image",
        "provider": "jaaz",
        "tool_function": generate_image_by_flux_kontext_max,
    },
    "generate_image_by_midjourney_jaaz": {
        "display_name": "Midjourney",
        "type": "image",
        "provider": "jaaz",
        "tool_function": generate_image_by_midjourney_jaaz,
    },
    "generate_image_by_doubao_seedream_3_jaaz": {
        "display_name": "Doubao Seedream 3",
        "type": "image",
        "provider": "jaaz",
        "tool_function": generate_image_by_doubao_seedream_3_jaaz,
    },
    "generate_image_by_doubao_seedream_3_volces": {
        "display_name": "Doubao Seedream 3 by volces",
        "type": "image",
        "provider": "volces",
        "tool_function": generate_image_by_doubao_seedream_3_volces,
    },
    "edit_image_by_doubao_seededit_3_volces": {
        "display_name": "Doubao Seededit 3 by volces",
        "type": "image",
        "provider": "volces",
        "tool_function": edit_image_by_doubao_seededit_3_volces,
    },
    "generate_video_by_seedance_v1_jaaz": {
        "display_name": "Doubao Seedance v1",
        "type": "video",
        "provider": "jaaz",
        "tool_function": generate_video_by_seedance_v1_jaaz,
    },
    "generate_video_by_hailuo_02_jaaz": {
        "display_name": "Hailuo 02",
        "type": "video",
        "provider": "jaaz",
        "tool_function": generate_video_by_hailuo_02_jaaz,
    },
    "generate_video_by_kling_v2_jaaz": {
        "display_name": "Kling v2.1 Standard",
        "type": "video",
        "provider": "jaaz",
        "tool_function": generate_video_by_kling_v2_jaaz,
    },
    "generate_video_by_seedance_v1_pro_volces": {
        "display_name": "Doubao Seedance v1 by volces",
        "type": "video",
        "provider": "volces",
        "tool_function": generate_video_by_seedance_v1_pro_volces,
    },
    "generate_video_by_seedance_v1_lite_volces_t2v": {
        "display_name": "Doubao Seedance v1 lite(text-to-video)",
        "type": "video",
        "provider": "volces",
        "tool_function": generate_video_by_seedance_v1_lite_t2v,
    },
    "generate_video_by_seedance_v1_lite_i2v_volces": {
        "display_name": "Doubao Seedance v1 lite(images-to-video)",
        "type": "video",
        "provider": "volces",
        "tool_function": generate_video_by_seedance_v1_lite_i2v,
    },
    "generate_video_by_veo3_fast_jaaz": {
        "display_name": "Veo3 Fast",
        "type": "video",
        "provider": "jaaz",
        "tool_function": generate_video_by_veo3_fast_jaaz,
    },
    # ---------------
    # Replicate Tools
    # ---------------
    "generate_image_by_imagen_4_replicate": {
        "display_name": "Imagen 4",
        "type": "image",
        "provider": "replicate",
        "tool_function": generate_image_by_imagen_4_replicate,
    },
    "generate_image_by_recraft_v3_replicate": {
        "display_name": "Recraft v3",
        "type": "image",
        "provider": "replicate",
        "tool_function": generate_image_by_recraft_v3_replicate,
    },
    "generate_image_by_flux_kontext_pro_replicate": {
        "display_name": "Flux Kontext Pro",
        "type": "image",
        "provider": "replicate",
        "tool_function": generate_image_by_flux_kontext_pro_replicate,
    },
    "generate_image_by_flux_kontext_max_replicate": {
        "display_name": "Flux Kontext Max",
        "type": "image",
        "provider": "replicate",
        "tool_function": generate_image_by_flux_kontext_max_replicate,
    },
}


class ToolService:
    def __init__(self):
        self.tools: Dict[str, ToolInfo] = {}
        self._register_required_tools()

    def _register_required_tools(self):
        """æ³¨å†Œå¿…é¡»çš„å·¥å…·"""
        try:
            self.tools["write_plan"] = {
                "provider": "system",
                "tool_function": write_plan_tool,
            }
        except ImportError as e:
            print(f"âŒ æ³¨å†Œå¿…é¡»å·¥å…·å¤±è´¥ write_plan: {e}")

    def register_tool(self, tool_id: str, tool_info: ToolInfo):
        """æ³¨å†Œå•ä¸ªå·¥å…·"""
        if tool_id in self.tools:
            print(f"ğŸ”„ TOOL ALREADY REGISTERED: {tool_id}")
            return

        self.tools[tool_id] = tool_info

    # TODO: Check if there will be racing conditions when server just starting up but tools are not ready yet.
    async def initialize(self):
        self.clear_tools()
        try:
            for provider_name, provider_config in config_service.app_config.items():
                # register all tools by api provider with api key
                if provider_config.get("api_key", ""):
                    for tool_id, tool_info in TOOL_MAPPING.items():
                        if tool_info.get("provider") == provider_name:
                            self.register_tool(tool_id, tool_info)
            # Register comfyui workflow tools
            if config_service.app_config.get("comfyui", {}).get("url", ""):
                await register_comfy_tools()
        except Exception as e:
            print(f"âŒ Failed to initialize tool service: {e}")
            traceback.print_stack()

    def get_tool(self, tool_name: str) -> BaseTool | None:
        tool_info = self.tools.get(tool_name)
        return tool_info.get("tool_function") if tool_info else None

    def remove_tool(self, tool_id: str):
        self.tools.pop(tool_id)

    def get_all_tools(self) -> Dict[str, ToolInfo]:
        return self.tools.copy()

    def clear_tools(self):
        self.tools.clear()
        # é‡æ–°æ³¨å†Œå¿…é¡»çš„å·¥å…·
        self._register_required_tools()


tool_service = ToolService()


async def register_comfy_tools() -> Dict[str, BaseTool]:
    """
    Fetch all workflows from DB and build tool callables.
    Run inside the current event loop.
    """
    dynamic_comfy_tools: Dict[str, BaseTool] = {}
    try:
        workflows = await db_service.list_comfy_workflows()
    except Exception as exc:  # pragma: no cover
        print("[comfy_dynamic] Failed to list comfy workflows:", exc)
        traceback.print_stack()
        return {}

    for wf in workflows:
        try:
            tool_fn = build_tool(wf)
            # Export with a unique python identifier so that `dir(module)` works
            unique_name = f"comfyui_{wf['name']}"
            dynamic_comfy_tools[unique_name] = tool_fn
            tool_service.register_tool(
                unique_name,
                {
                    "provider": "comfyui",
                    "tool_function": tool_fn,
                    "display_name": wf["name"],
                    # TODO: Add comfyui workflow type! Not hardcoded!
                    "type": "image",
                },
            )
        except Exception as exc:  # pragma: no cover
            print(
                f"[comfy_dynamic] Failed to create tool for workflow {wf.get('id')}: {exc}"
            )
            print(traceback.print_stack())

    return dynamic_comfy_tools



================================================
FILE: server/services/websocket_service.py
================================================
# services/websocket_service.py
from services.websocket_state import sio, get_all_socket_ids
import traceback
from typing import Any, Dict


async def broadcast_session_update(session_id: str, canvas_id: str | None, event: Dict[str, Any]):
    socket_ids = get_all_socket_ids()
    if socket_ids:
        try:
            for socket_id in socket_ids:
                await sio.emit('session_update', {
                    'canvas_id': canvas_id,
                    'session_id': session_id,
                    **event
                }, room=socket_id)
        except Exception as e:
            print(f"Error broadcasting session update for {session_id}: {e}")
            traceback.print_exc()

# compatible with legacy codes
# TODO: All Broadcast should have a canvas_id


async def send_to_websocket(session_id: str, event: Dict[str, Any]):
    await broadcast_session_update(session_id, None, event)


async def broadcast_init_done():
    try:
        await sio.emit('init_done', {
            'type': 'init_done'
        })
        print("Broadcasted init_done to all clients")
    except Exception as e:
        print(f"Error broadcasting init_done: {e}")
        traceback.print_exc()



================================================
FILE: server/services/websocket_state.py
================================================
# services/websocket_state.py
import socketio
from typing import Dict

sio = socketio.AsyncServer(
    cors_allowed_origins="*",
    async_mode='asgi'
)

active_connections: Dict[str, dict] = {}

def add_connection(socket_id: str, user_info: dict = None):
    active_connections[socket_id] = user_info or {}
    print(f"New connection added: {socket_id}, total connections: {len(active_connections)}")

def remove_connection(socket_id: str):
    if socket_id in active_connections:
        del active_connections[socket_id]
        print(f"Connection removed: {socket_id}, total connections: {len(active_connections)}")

def get_all_socket_ids():
    return list(active_connections.keys())

def get_connection_count():
    return len(active_connections)



================================================
FILE: server/services/langgraph_service/__init__.py
================================================
from .agent_service import langgraph_multi_agent

__all__ = ['langgraph_multi_agent']



================================================
FILE: server/services/langgraph_service/agent_manager.py
================================================
from typing import List, Dict, Any, Optional
from langgraph.prebuilt import create_react_agent  # type: ignore
from langgraph.graph.graph import CompiledGraph
from langchain_core.tools import BaseTool
from models.tool_model import ToolInfoJson
from services.langgraph_service.configs.image_vide_creator_config import ImageVideoCreatorAgentConfig
from .configs import PlannerAgentConfig, create_handoff_tool, BaseAgentConfig
from services.tool_service import tool_service


class AgentManager:
    """æ™ºèƒ½ä½“ç®¡ç†å™¨ - è´Ÿè´£åˆ›å»ºå’Œç®¡ç†æ‰€æœ‰æ™ºèƒ½ä½“

    æ­¤ç±»è´Ÿè´£åè°ƒæ™ºèƒ½ä½“é…ç½®çš„è·å–å’Œå®é™… LangGraph æ™ºèƒ½ä½“çš„åˆ›å»ºã€‚
    """

    @staticmethod
    def create_agents(
        model: Any,
        tool_list: List[ToolInfoJson],
        system_prompt: str = ""
    ) -> List[CompiledGraph]:
        """åˆ›å»ºæ‰€æœ‰æ™ºèƒ½ä½“

        Args:
            model: è¯­è¨€æ¨¡å‹å®ä¾‹
            registered_tools: å·²æ³¨å†Œçš„å·¥å…·åç§°åˆ—è¡¨
            system_prompt: ç³»ç»Ÿæç¤ºè¯

        Returns:
            List[Any]: åˆ›å»ºå¥½çš„æ™ºèƒ½ä½“åˆ—è¡¨
        """
        # ä¸ºä¸åŒç±»å‹çš„æ™ºèƒ½ä½“è¿‡æ»¤åˆé€‚çš„å·¥å…·
        image_tools =  [tool for tool in tool_list if tool.get('type') == 'image']
        video_tools = [tool for tool in tool_list if tool.get('type') == 'video']

        print(f"ğŸ“¸ å›¾åƒå·¥å…·: {image_tools}")
        print(f"ğŸ¬ è§†é¢‘å·¥å…·: {video_tools}")

        planner_config = PlannerAgentConfig()
        planner_agent = AgentManager._create_langgraph_agent(
            model, planner_config)

        # image_designer_config = ImageDesignerAgentConfig(
        #     image_tools, system_prompt)
        # print('ğŸ‘‡image_designer_config tools', image_designer_config.tools)
        # print('ğŸ‘‡image_designer_config system_prompt', image_designer_config.system_prompt)
        # image_designer_agent = AgentManager._create_langgraph_agent(
        #     model, image_designer_config)

        # video_designer_config = VideoDesignerAgentConfig(
        #     video_tools)
        # video_designer_agent = AgentManager._create_langgraph_agent(
        #     model, video_designer_config)

        image_video_creator_config = ImageVideoCreatorAgentConfig(tool_list)
        image_video_creator_agent = AgentManager._create_langgraph_agent(
            model, image_video_creator_config)

        return [planner_agent, image_video_creator_agent]

    @staticmethod
    def _create_langgraph_agent(
        model: Any,
        config: BaseAgentConfig
    ) -> CompiledGraph:
        """æ ¹æ®é…ç½®åˆ›å»ºå•ä¸ª LangGraph æ™ºèƒ½ä½“

        Args:
            model: è¯­è¨€æ¨¡å‹å®ä¾‹
            config: æ™ºèƒ½ä½“é…ç½®å­—å…¸

        Returns:
            Any: åˆ›å»ºå¥½çš„ LangGraph æ™ºèƒ½ä½“å®ä¾‹
        """
        # åˆ›å»ºæ™ºèƒ½ä½“é—´åˆ‡æ¢å·¥å…·
        handoff_tools: List[BaseTool] = []
        for handoff in config.handoffs:
            handoff_tool = create_handoff_tool(
                agent_name=handoff['agent_name'],
                description=handoff['description'],
            )
            if handoff_tool:
                handoff_tools.append(handoff_tool)

        # è·å–ä¸šåŠ¡å·¥å…·
        business_tools: List[BaseTool] = []
        for tool_json in config.tools:
            tool = tool_service.get_tool(tool_json['id'])
            if tool:
                business_tools.append(tool)

        # åˆ›å»ºå¹¶è¿”å› LangGraph æ™ºèƒ½ä½“
        return create_react_agent(
            name=config.name,
            model=model,
            tools=[*business_tools, *handoff_tools],
            prompt=config.system_prompt
        )

    @staticmethod
    def get_last_active_agent(
        messages: List[Dict[str, Any]],
        agent_names: List[str]
    ) -> Optional[str]:
        """è·å–æœ€åæ´»è·ƒçš„æ™ºèƒ½ä½“

        Args:
            messages: æ¶ˆæ¯å†å²
            agent_names: æ™ºèƒ½ä½“åç§°åˆ—è¡¨

        Returns:
            Optional[str]: æœ€åæ´»è·ƒçš„æ™ºèƒ½ä½“åç§°ï¼Œå¦‚æœæ²¡æœ‰åˆ™è¿”å› None
        """
        for message in reversed(messages):
            if message.get('role') == 'assistant':
                message_name = message.get('name')
                if message_name and message_name in agent_names:
                    return message_name
        return None



================================================
FILE: server/services/langgraph_service/agent_service.py
================================================
from models.tool_model import ToolInfoJson
from services.db_service import db_service
from .StreamProcessor import StreamProcessor
from .agent_manager import AgentManager
import traceback
from utils.http_client import HttpClient
from langgraph_swarm import create_swarm  # type: ignore
from langchain_openai import ChatOpenAI
from langchain_ollama import ChatOllama
from services.websocket_service import send_to_websocket  # type: ignore
from services.config_service import config_service
from typing import Optional, List, Dict, Any, cast, Set, TypedDict
from models.config_model import ModelInfo


class ContextInfo(TypedDict):
    """Context information passed to tools"""
    canvas_id: str
    session_id: str
    model_info: Dict[str, List[ModelInfo]]


def _fix_chat_history(messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """ä¿®å¤èŠå¤©å†å²ä¸­ä¸å®Œæ•´çš„å·¥å…·è°ƒç”¨

    æ ¹æ®LangGraphæ–‡æ¡£å»ºè®®ï¼Œç§»é™¤æ²¡æœ‰å¯¹åº”ToolMessageçš„tool_calls
    å‚è€ƒ: https://langchain-ai.github.io/langgraph/troubleshooting/errors/INVALID_CHAT_HISTORY/
    """
    if not messages:
        return messages

    fixed_messages: List[Dict[str, Any]] = []
    tool_call_ids: Set[str] = set()

    # ç¬¬ä¸€éï¼šæ”¶é›†æ‰€æœ‰ToolMessageçš„tool_call_id
    for msg in messages:
        if msg.get('role') == 'tool' and msg.get('tool_call_id'):
            tool_call_id = msg.get('tool_call_id')
            if tool_call_id:
                tool_call_ids.add(tool_call_id)

    # ç¬¬äºŒéï¼šä¿®å¤AIMessageä¸­çš„tool_calls
    for msg in messages:
        if msg.get('role') == 'assistant' and msg.get('tool_calls'):
            # è¿‡æ»¤æ‰æ²¡æœ‰å¯¹åº”ToolMessageçš„tool_calls
            valid_tool_calls: List[Dict[str, Any]] = []
            removed_calls: List[str] = []

            for tool_call in msg.get('tool_calls', []):
                tool_call_id = tool_call.get('id')
                if tool_call_id in tool_call_ids:
                    valid_tool_calls.append(tool_call)
                elif tool_call_id:
                    removed_calls.append(tool_call_id)

            # è®°å½•ä¿®å¤ä¿¡æ¯
            if removed_calls:
                print(
                    f"ğŸ”§ ä¿®å¤æ¶ˆæ¯å†å²ï¼šç§»é™¤äº† {len(removed_calls)} ä¸ªä¸å®Œæ•´çš„å·¥å…·è°ƒç”¨: {removed_calls}")

            # æ›´æ–°æ¶ˆæ¯
            if valid_tool_calls:
                msg_copy = msg.copy()
                msg_copy['tool_calls'] = valid_tool_calls
                fixed_messages.append(msg_copy)
            elif msg.get('content'):  # å¦‚æœæ²¡æœ‰æœ‰æ•ˆçš„tool_callsä½†æœ‰contentï¼Œä¿ç•™æ¶ˆæ¯
                msg_copy = msg.copy()
                msg_copy.pop('tool_calls', None)  # ç§»é™¤ç©ºçš„tool_calls
                fixed_messages.append(msg_copy)
            # å¦‚æœæ—¢æ²¡æœ‰æœ‰æ•ˆtool_callsä¹Ÿæ²¡æœ‰contentï¼Œè·³è¿‡è¿™æ¡æ¶ˆæ¯
        else:
            # éassistantæ¶ˆæ¯æˆ–æ²¡æœ‰tool_callsçš„æ¶ˆæ¯ç›´æ¥ä¿ç•™
            fixed_messages.append(msg)

    return fixed_messages


async def langgraph_multi_agent(
    messages: List[Dict[str, Any]],
    canvas_id: str,
    session_id: str,
    text_model: ModelInfo,
    tool_list: List[ToolInfoJson],
    system_prompt: Optional[str] = None
) -> None:
    """å¤šæ™ºèƒ½ä½“å¤„ç†å‡½æ•°

    Args:
        messages: æ¶ˆæ¯å†å²
        canvas_id: ç”»å¸ƒID
        session_id: ä¼šè¯ID
        text_model: æ–‡æœ¬æ¨¡å‹é…ç½®
        tool_list: å·¥å…·æ¨¡å‹é…ç½®åˆ—è¡¨ï¼ˆå›¾åƒæˆ–è§†é¢‘æ¨¡å‹ï¼‰
        system_prompt: ç³»ç»Ÿæç¤ºè¯
    """
    try:
        # 0. ä¿®å¤æ¶ˆæ¯å†å²
        fixed_messages = _fix_chat_history(messages)

        # 2. æ–‡æœ¬æ¨¡å‹
        text_model_instance = _create_text_model(text_model)

        # 3. åˆ›å»ºæ™ºèƒ½ä½“
        agents = AgentManager.create_agents(
            text_model_instance,
            tool_list,  # ä¼ å…¥æ‰€æœ‰æ³¨å†Œçš„å·¥å…·
            system_prompt or ""
        )
        agent_names = [agent.name for agent in agents]
        print('ğŸ‘‡agent_names', agent_names)
        last_agent = AgentManager.get_last_active_agent(
            fixed_messages, agent_names)

        print('ğŸ‘‡last_agent', last_agent)

        # 4. åˆ›å»ºæ™ºèƒ½ä½“ç¾¤ç»„
        swarm = create_swarm(
            agents=agents,  # type: ignore
            default_active_agent=last_agent if last_agent else agent_names[0]
        )

        # 5. åˆ›å»ºä¸Šä¸‹æ–‡
        context = {
            'canvas_id': canvas_id,
            'session_id': session_id,
            'tool_list': tool_list,
        }

        # 6. æµå¤„ç†
        processor = StreamProcessor(
            session_id, db_service, send_to_websocket)  # type: ignore
        await processor.process_stream(swarm, fixed_messages, context)

    except Exception as e:
        await _handle_error(e, session_id)


def _create_text_model(text_model: ModelInfo) -> Any:
    """åˆ›å»ºè¯­è¨€æ¨¡å‹å®ä¾‹"""
    model = text_model.get('model')
    provider = text_model.get('provider')
    url = text_model.get('url')
    api_key = config_service.app_config.get(  # type: ignore
        provider, {}).get("api_key", "")

    # TODO: Verify if max token is working
    # max_tokens = text_model.get('max_tokens', 8148)

    if provider == 'ollama':
        return ChatOllama(
            model=model,
            base_url=url,
        )
    else:
        # Create httpx client with SSL configuration for ChatOpenAI
        http_client = HttpClient.create_sync_client()
        http_async_client = HttpClient.create_async_client()
        return ChatOpenAI(
            model=model,
            api_key=api_key,  # type: ignore
            timeout=300,
            base_url=url,
            temperature=0,
            # max_tokens=max_tokens, # TODO: æš‚æ—¶æ³¨é‡Šæ‰æœ‰é—®é¢˜çš„å‚æ•°
            http_client=http_client,
            http_async_client=http_async_client
        )


async def _handle_error(error: Exception, session_id: str) -> None:
    """å¤„ç†é”™è¯¯"""
    print('Error in langgraph_agent', error)
    tb_str = traceback.format_exc()
    print(f"Full traceback:\n{tb_str}")
    traceback.print_exc()

    await send_to_websocket(session_id, cast(Dict[str, Any], {
        'type': 'error',
        'error': str(error)
    }))



================================================
FILE: server/services/langgraph_service/StreamProcessor.py
================================================
# type: ignore[import]
import traceback
from typing import Optional, List, Dict, Any, Callable, Awaitable
from langchain_core.messages import AIMessageChunk, ToolCall, convert_to_openai_messages, ToolMessage
from langgraph.graph import StateGraph
import json


class StreamProcessor:
    """æµå¼å¤„ç†å™¨ - è´Ÿè´£å¤„ç†æ™ºèƒ½ä½“çš„æµå¼è¾“å‡º"""

    def __init__(self, session_id: str, db_service: Any, websocket_service: Callable[[str, Dict[str, Any]], Awaitable[None]]):
        self.session_id = session_id
        self.db_service = db_service
        self.websocket_service = websocket_service
        self.tool_calls: List[ToolCall] = []
        self.last_saved_message_index = 0
        self.last_streaming_tool_call_id: Optional[str] = None

    async def process_stream(self, swarm: StateGraph, messages: List[Dict[str, Any]], context: Dict[str, Any]) -> None:
        """å¤„ç†æ•´ä¸ªæµå¼å“åº”

        Args:
            swarm: æ™ºèƒ½ä½“ç¾¤ç»„
            messages: æ¶ˆæ¯åˆ—è¡¨
            context: ä¸Šä¸‹æ–‡ä¿¡æ¯
        """
        self.last_saved_message_index = len(messages) - 1

        compiled_swarm = swarm.compile()

        async for chunk in compiled_swarm.astream(
            {"messages": messages},
            config=context,
            stream_mode=["messages", "custom", 'values']
        ):
            await self._handle_chunk(chunk)

        # å‘é€å®Œæˆäº‹ä»¶
        await self.websocket_service(self.session_id, {
            'type': 'done'
        })

    async def _handle_chunk(self, chunk: Any) -> None:
        # print('ğŸ‘‡chunk', chunk)
        """å¤„ç†å•ä¸ªchunk"""
        chunk_type = chunk[0]

        if chunk_type == 'values':
            await self._handle_values_chunk(chunk[1])
        else:
            await self._handle_message_chunk(chunk[1][0])

    async def _handle_values_chunk(self, chunk_data: Dict[str, Any]) -> None:
        """å¤„ç† values ç±»å‹çš„ chunk"""
        all_messages = chunk_data.get('messages', [])
        oai_messages = convert_to_openai_messages(all_messages)
        # ç¡®ä¿ oai_messages æ˜¯åˆ—è¡¨ç±»å‹
        if not isinstance(oai_messages, list):
            oai_messages = [oai_messages] if oai_messages else []

        # å‘é€æ‰€æœ‰æ¶ˆæ¯åˆ°å‰ç«¯
        await self.websocket_service(self.session_id, {
            'type': 'all_messages',
            'messages': oai_messages
        })

        # ä¿å­˜æ–°æ¶ˆæ¯åˆ°æ•°æ®åº“
        for i in range(self.last_saved_message_index + 1, len(oai_messages)):
            new_message = oai_messages[i]
            if len(oai_messages) > 0:  # ç¡®ä¿æœ‰æ¶ˆæ¯æ‰ä¿å­˜
                await self.db_service.create_message(
                    self.session_id,
                    new_message.get('role', 'user'),
                    json.dumps(new_message)
                )
            self.last_saved_message_index = i

    async def _handle_message_chunk(self, ai_message_chunk: AIMessageChunk) -> None:
        """å¤„ç†æ¶ˆæ¯ç±»å‹çš„ chunk"""
        # print('ğŸ‘‡ai_message_chunk', ai_message_chunk)
        try:
            content = ai_message_chunk.content

            if isinstance(ai_message_chunk, ToolMessage):
                # å·¥å…·è°ƒç”¨ç»“æœä¹‹åä¼šåœ¨ values ç±»å‹ä¸­å‘é€åˆ°å‰ç«¯ï¼Œè¿™é‡Œä¼šæ›´å¿«å‡ºç°ä¸€äº›
                oai_message = convert_to_openai_messages([ai_message_chunk])[0]
                print('ğŸ‘‡toolcall res oai_message', oai_message)
                await self.websocket_service(self.session_id, {
                    'type': 'tool_call_result',
                    'id': ai_message_chunk.tool_call_id,
                    'message': oai_message
                })
            elif content:
                # å‘é€æ–‡æœ¬å†…å®¹
                await self.websocket_service(self.session_id, {
                    'type': 'delta',
                    'text': content
                })
            elif hasattr(ai_message_chunk, 'tool_calls') and ai_message_chunk.tool_calls and ai_message_chunk.tool_calls[0].get('name'):
                # å¤„ç†å·¥å…·è°ƒç”¨
                await self._handle_tool_calls(ai_message_chunk.tool_calls)

            # å¤„ç†å·¥å…·è°ƒç”¨å‚æ•°æµ
            if hasattr(ai_message_chunk, 'tool_call_chunks'):
                await self._handle_tool_call_chunks(ai_message_chunk.tool_call_chunks)
        except Exception as e:
            print('ğŸŸ error', e)
            traceback.print_stack()

    async def _handle_tool_calls(self, tool_calls: List[ToolCall]) -> None:
        """å¤„ç†å·¥å…·è°ƒç”¨"""
        self.tool_calls = [tc for tc in tool_calls if tc.get('name')]
        print('ğŸ˜˜tool_call event', tool_calls)

        # éœ€è¦ç¡®è®¤çš„å·¥å…·åˆ—è¡¨
        TOOLS_REQUIRING_CONFIRMATION = {
            # 'generate_video_by_kling_v2_jaaz',
            # 'generate_video_by_seedance_v1_pro_volces',
            # 'generate_video_by_seedance_v1_lite_i2v',
            # 'generate_video_by_seedance_v1_lite_t2v',
            # 'generate_video_by_seedance_v1_jaaz',
            # 'generate_video_by_hailuo_02_jaaz',
            'generate_video_by_veo3_fast_jaaz',
        }

        for tool_call in self.tool_calls:
            tool_name = tool_call.get('name')

            # æ£€æŸ¥æ˜¯å¦éœ€è¦ç¡®è®¤
            if tool_name in TOOLS_REQUIRING_CONFIRMATION:
                # å¯¹äºéœ€è¦ç¡®è®¤çš„å·¥å…·ï¼Œä¸åœ¨è¿™é‡Œå‘é€äº‹ä»¶ï¼Œè®©å·¥å…·å‡½æ•°è‡ªå·±å¤„ç†
                print(
                    f'ğŸ”„ Tool {tool_name} requires confirmation, skipping StreamProcessor event')
                continue
            else:
                await self.websocket_service(self.session_id, {
                    'type': 'tool_call',
                    'id': tool_call.get('id'),
                    'name': tool_name,
                    'arguments': '{}'
                })

    async def _handle_tool_call_chunks(self, tool_call_chunks: List[Any]) -> None:
        """å¤„ç†å·¥å…·è°ƒç”¨å‚æ•°æµ"""
        for tool_call_chunk in tool_call_chunks:
            if tool_call_chunk.get('id'):
                # æ ‡è®°æ–°çš„æµå¼å·¥å…·è°ƒç”¨å‚æ•°å¼€å§‹
                self.last_streaming_tool_call_id = tool_call_chunk.get('id')
            else:
                if self.last_streaming_tool_call_id:
                    await self.websocket_service(self.session_id, {
                        'type': 'tool_call_arguments',
                        'id': self.last_streaming_tool_call_id,
                        'text': tool_call_chunk.get('args')
                    })
                else:
                    print('ğŸŸ no last_streaming_tool_call_id', tool_call_chunk)



================================================
FILE: server/services/langgraph_service/configs/__init__.py
================================================
"""æ™ºèƒ½ä½“é…ç½®æ¨¡å—

æ­¤æ¨¡å—åŒ…å«æ‰€æœ‰æ™ºèƒ½ä½“çš„é…ç½®å®šä¹‰ã€‚è¿™äº›é…ç½®ç±»ç”¨äºå®šä¹‰æ™ºèƒ½ä½“çš„è¡Œä¸ºã€å·¥å…·å’Œç³»ç»Ÿæç¤ºè¯ï¼Œ
å®é™…çš„æ™ºèƒ½ä½“å®ä¾‹å°†ç”± AgentManager æ ¹æ®è¿™äº›é…ç½®åˆ›å»ºã€‚
"""

from .base_config import BaseAgentConfig, create_handoff_tool, ToolConfig
from .planner_config import PlannerAgentConfig
from .image_designer_config import ImageDesignerAgentConfig
from .video_designer_config import VideoDesignerAgentConfig

__all__ = [
    'BaseAgentConfig',
    'ToolConfig',
    'create_handoff_tool',
    'PlannerAgentConfig',
    'ImageDesignerAgentConfig',
    'VideoDesignerAgentConfig',
]



================================================
FILE: server/services/langgraph_service/configs/base_config.py
================================================
from typing import Annotated, Optional, Dict, Any, Sequence, List, TypedDict
from langgraph.types import Command
from langgraph.prebuilt import InjectedState
from langchain_core.messages import ToolMessage
from langchain_core.tools import BaseTool, InjectedToolCallId, tool  # type: ignore
from langgraph_swarm.handoff import METADATA_KEY_HANDOFF_DESTINATION
from models.tool_model import ToolInfoJson


class ToolConfig(TypedDict):
    """å·¥å…·é…ç½®"""
    tool: str


def _normalize_agent_name(name: str) -> str:
    """Normalize agent name to be compatible with tool names."""
    return name.lower().replace(" ", "_").replace("-", "_")


def create_handoff_tool(
    *, agent_name: str, name: Optional[str] = None, description: Optional[str] = None
) -> BaseTool:
    """Create a tool that can handoff control to the requested agent.

    Args:
        agent_name: The name of the agent to handoff control to, i.e.
            the name of the agent node in the multi-agent graph.
            Agent names should be simple, clear and unique, preferably in snake_case,
            although you are only limited to the names accepted by LangGraph
            nodes as well as the tool names accepted by LLM providers
            (the tool name will look like this: `transfer_to_<agent_name>`).
        name: Optional name of the tool to use for the handoff.
            If not provided, the tool name will be `transfer_to_<agent_name>`.
        description: Optional description for the handoff tool.
            If not provided, the tool description will be `Ask agent <agent_name> for help`.
    """
    if name is None:
        name = f"transfer_to_{_normalize_agent_name(agent_name)}"

    if description is None:
        description = f"Ask agent '{agent_name}' for help"

    @tool(name, description=description+"""
    \nIMPORTANT RULES:
            1. You MUST complete the other tool calls and wait for their result BEFORE attempting to transfer to another agent
            2. Do NOT call this handoff tool with other tools simultaneously
            3. Always wait for the result of other tool calls before making this handoff call
    """)
    def handoff_to_agent(
        state: Annotated[Dict[str, Any], InjectedState],
        tool_call_id: Annotated[str, InjectedToolCallId],
    ) -> Command[Any]:
        tool_message = ToolMessage(
            content=f"<hide_in_user_ui> Successfully transferred to {agent_name}",
            name=name,
            tool_call_id=tool_call_id,
        )
        return Command(
            goto=agent_name,
            graph=Command.PARENT,
            update={"messages": state["messages"] +
                    [tool_message], "active_agent": agent_name},
        )

    setattr(handoff_to_agent, 'metadata', {
            METADATA_KEY_HANDOFF_DESTINATION: agent_name})

    return handoff_to_agent


class HandoffConfig(TypedDict):
    """åˆ‡æ¢æ™ºèƒ½ä½“é…ç½®"""
    agent_name: str
    description: str


class BaseAgentConfig:
    """æ™ºèƒ½ä½“é…ç½®åŸºç±»

    æ­¤ç±»ç”¨äºå­˜å‚¨æ™ºèƒ½ä½“é…ç½®ä¿¡æ¯çš„é…ç½®ç±»ï¼Œä¸æ˜¯å®é™…çš„æ™ºèƒ½ä½“ã€‚
    å®é™…çš„æ™ºèƒ½ä½“å°†é€šè¿‡ LangGraph çš„ create_react_agent å‡½æ•°åˆ›å»ºã€‚
    """

    def __init__(
        self,
        name: str,
        tools: Sequence[ToolInfoJson],
        system_prompt: str,
        handoffs: Optional[List[HandoffConfig]] = None
    ) -> None:
        self.name = name
        self.tools = tools
        self.system_prompt = system_prompt
        self.handoffs: List[HandoffConfig] = handoffs or []


================================================
FILE: server/services/langgraph_service/configs/image_designer_config.py
================================================
from typing import List

from models.tool_model import ToolInfoJson
from .base_config import BaseAgentConfig, HandoffConfig

class ImageDesignerAgentConfig(BaseAgentConfig):
    """å›¾åƒè®¾è®¡æ™ºèƒ½ä½“ - ä¸“é—¨è´Ÿè´£å›¾åƒç”Ÿæˆ
    """

    def __init__(self, tool_list: List[ToolInfoJson], system_prompt: str = "") -> None:
        batch_generation_prompt = """

BATCH GENERATION RULES:
- If user needs >10 images: Generate in batches of max 10 images each
- Complete each batch before starting next batch
- Example for 20 images: Batch 1 (1-10) â†’ "Batch 1 done!" â†’ Batch 2 (11-20) â†’ "All 20 images completed!"

"""

        error_handling_prompt = """

ERROR HANDLING INSTRUCTIONS:
When image generation fails, you MUST:
1. Acknowledge the failure and explain the specific reason to the user
2. If the error mentions "sensitive content" or "flagged content", advise the user to:
   - Use more appropriate and less sensitive descriptions
   - Avoid potentially controversial, violent, or inappropriate content
   - Try rephrasing with more neutral language
3. If it's an API error (HTTP 500, etc.), suggest:
   - Trying again in a moment
   - Using different wording in the prompt
   - Checking if the service is temporarily unavailable
4. Always provide helpful suggestions for alternative approaches
5. Maintain a supportive and professional tone

IMPORTANT: Never ignore tool errors. Always respond to failed tool calls with helpful guidance for the user.
"""

        full_system_prompt = system_prompt + \
            batch_generation_prompt + error_handling_prompt

        # å›¾åƒè®¾è®¡æ™ºèƒ½ä½“ä¸éœ€è¦åˆ‡æ¢åˆ°å…¶ä»–æ™ºèƒ½ä½“
        handoffs: List[HandoffConfig] = [
            {
                'agent_name': 'video_designer',
                'description': """
                        Transfer user to the video_designer. If user wants to generate video, transfer to video_designer.
                        """
            }
        ]

        super().__init__(
            name='image_designer',
            tools=tool_list,
            system_prompt=full_system_prompt,
            handoffs=handoffs
        )



================================================
FILE: server/services/langgraph_service/configs/image_vide_creator_config.py
================================================
from typing import List

from models.tool_model import ToolInfoJson
from .base_config import BaseAgentConfig, HandoffConfig

system_prompt = """
You are a image video creator. You can create image or video from text prompt or image.
You can write very professional image prompts to generate aesthetically pleasing images that best fulfilling and matching the user's request.

1. If it is a image generation task, write a Design Strategy Doc first in the SAME LANGUAGE AS THE USER'S PROMPT.

Example Design Strategy Doc:
Design Proposal for â€œMUSE MODULAR â€“ Future of Identityâ€ Cover
â€¢ Recommended resolution: 1024 Ã— 1536 px (portrait) â€“ optimal for a standard magazine trim while preserving detail for holographic accents.

â€¢ Style & Mood
â€“ High-contrast grayscale base evoking timeless editorial sophistication.
â€“ Holographic iridescence selectively applied (cyan â†’ violet â†’ lime) for mask edges, title glyphs and micro-glitches, signalling futurism and fluid identity.
â€“ Atmosphere: enigmatic, cerebral, slightly unsettling yet glamorous.

â€¢ Key Visual Element
â€“ Central androgynous model, shoulders-up, lit with soft frontal key and twin rim lights.
â€“ A translucent polygonal AR mask overlays the face; within it, three offset â€œghostâ€ facial layers (different eyes, nose, mouth) hint at multiple personas.
â€“ Subtle pixel sorting/glitch streaks emanate from mask edges, blending into background grid.

â€¢ Composition & Layout

Masthead â€œMUSE MODULARâ€ across the top, extra-condensed modular sans serif; characters constructed from repeating geometric units. Spot UV + holo foil.
Tagline â€œWho are you today?â€ centered beneath masthead in ultra-light italic.
Subjectâ€™s gaze directly engages reader; head breaks the baseline of the masthead for depth.
Bottom left kicker â€œFuture of Identity Issueâ€ in tiny monospaced capitals.
Discreet modular grid lines and data glyphs fade into matte charcoal background, preserving negative space.
â€¢ Color Palette
#000000, #1a1a1a, #4d4d4d, #d9d9d9 + holographic gradient (#00eaff, #c400ff, #38ffab).

â€¢ Typography
â€“ Masthead: custom variable sans with removable modules.
â€“ Tagline: thin italic grotesque.
â€“ Secondary copy: 10 pt monospaced to reference code.

2. Call generate_image tool to generate the image based on the plan immediately, use a detailed and professional image prompt according to your design strategy plan, no need to ask for user's approval.

3. If it is a video generation task, use video generation tools to generate the video. You can choose to generate the necessary images first, and then use the images to generate the video, or directly generate the video using text prompt.
"""

class ImageVideoCreatorAgentConfig(BaseAgentConfig):
    def __init__(self, tool_list: List[ToolInfoJson]) -> None:
        image_input_detection_prompt = """

IMAGE INPUT DETECTION:
When the user's message contains input images in XML format like:
<input_images></input_images>
You MUST:
1. Parse the XML to extract file_id attributes from <image> tags
2. Use tools that support input_images parameter when images are present
3. Pass the extracted file_id(s) in the input_images parameter as a list
4. If input_images count > 1 , only use generate_image_by_gpt_image_1_jaaz (supports multiple images)
5. For video generation â†’ use video tools with input_images if images are present
"""

        batch_generation_prompt = """

BATCH GENERATION RULES:
- If user needs >10 images: Generate in batches of max 10 images each
- Complete each batch before starting next batch
- Example for 20 images: Batch 1 (1-10) â†’ "Batch 1 done!" â†’ Batch 2 (11-20) â†’ "All 20 images completed!"

"""

        error_handling_prompt = """

ERROR HANDLING INSTRUCTIONS:
When image generation fails, you MUST:
1. Acknowledge the failure and explain the specific reason to the user
2. If the error mentions "sensitive content" or "flagged content", advise the user to:
   - Use more appropriate and less sensitive descriptions
   - Avoid potentially controversial, violent, or inappropriate content
   - Try rephrasing with more neutral language
3. If it's an API error (HTTP 500, etc.), suggest:
   - Trying again in a moment
   - Using different wording in the prompt
   - Checking if the service is temporarily unavailable
4. Always provide helpful suggestions for alternative approaches
5. Maintain a supportive and professional tone

IMPORTANT: Never ignore tool errors. Always respond to failed tool calls with helpful guidance for the user.
"""

        full_system_prompt = system_prompt + \
            image_input_detection_prompt + \
            batch_generation_prompt + \
            error_handling_prompt

        # å›¾åƒè®¾è®¡æ™ºèƒ½ä½“ä¸éœ€è¦åˆ‡æ¢åˆ°å…¶ä»–æ™ºèƒ½ä½“
        handoffs: List[HandoffConfig] = []

        super().__init__(
            name='image_video_creator',
            tools=tool_list,
            system_prompt=full_system_prompt,
            handoffs=handoffs
        )



================================================
FILE: server/services/langgraph_service/configs/planner_config.py
================================================
from typing import List
from .base_config import BaseAgentConfig, HandoffConfig


class PlannerAgentConfig(BaseAgentConfig):
    """è§„åˆ’æ™ºèƒ½ä½“ - è´Ÿè´£åˆ¶å®šæ‰§è¡Œè®¡åˆ’
    """

    def __init__(self) -> None:
        system_prompt = """
            You are a design planning writing agent. Answer and write plan in the SAME LANGUAGE as the user's prompt. You should do:
            - Step 1. If it is a complex task requiring multiple steps, write a execution plan for the user's request using the SAME LANGUAGE AS THE USER'S PROMPT. You should breakdown the task into high level steps for the other agents to execute.
            - Step 2. If it is a image/video generation or editing task, transfer the task to image_video_creator agent to generate the image based on the plan IMMEDIATELY, no need to ask for user's approval.

            IMPORTANT RULES:
            1. You MUST complete the write_plan tool call and wait for its result BEFORE attempting to transfer to another agent
            2. Do NOT call multiple tools simultaneously
            3. Always wait for the result of one tool call before making another

            ALWAYS PAY ATTENTION TO IMAGE QUANTITY!
            - If user specifies a number (like "20 images", "generate 15 pictures"), you MUST include this exact number in your plan
            - When transferring to image_video_creator, clearly communicate the required quantity
            - NEVER ignore or change the user's specified quantity
            - If no quantity is specified, assume 1 image

            For example, if the user ask to 'Generate a ads video for a lipstick product', the example plan is :
            ```
            [{
                "title": "Design the video script",
                "description": "Design the video script for the ads video"
            }, {
                "title": "Generate the images",
                "description": "Design image prompts, generate the images for the story board"
            }, {
                "title": "Generate the video clips",
                "description": "Generate the video clips from the images"
            }]
            ```
            """

        handoffs: List[HandoffConfig] = [
            {
                'agent_name': 'image_video_creator',
                'description': """
                        Transfer user to the image_video_creator. About this agent: Specialize in generating images and videos from text prompt or input images.
                        """
            }
        ]

        super().__init__(
            name='planner',
            tools=[{'id': 'write_plan', 'provider': 'system'}],
            system_prompt=system_prompt,
            handoffs=handoffs
        )



================================================
FILE: server/services/langgraph_service/configs/video_designer_config.py
================================================
from typing import List
from models.tool_model import ToolInfoJson
from .base_config import BaseAgentConfig, HandoffConfig


class VideoDesignerAgentConfig(BaseAgentConfig):
    """è§†é¢‘è®¾è®¡æ™ºèƒ½ä½“ - ä¸“é—¨è´Ÿè´£è§†é¢‘ç”Ÿæˆ
    """

    def __init__(self, tool_list: List[ToolInfoJson]) -> None:
        video_generation_prompt = """
You are a video designer. You are responsible for generating videos based on user request. You can generate video from text prompt and images.

VIDEO GENERATION RULES:
- Generate high-quality videos based on user prompts
- Use detailed, cinematic descriptions for better results
- Consider aspect ratio, duration, and resolution requirements
- Provide clear feedback on video generation progress
- If user provides an image, use it as the first frame when possible

"""

        error_handling_prompt = """

ERROR HANDLING INSTRUCTIONS:
When video generation fails, you MUST:
1. Acknowledge the failure and explain the specific reason to the user
2. If the error mentions "sensitive content" or "flagged content", advise the user to:
   - Use more appropriate and less sensitive descriptions
   - Avoid potentially controversial, violent, or inappropriate content
   - Try rephrasing with more neutral language
3. If it's an API error (HTTP 500, etc.), suggest:
   - Trying again in a moment
   - Using different wording in the prompt
   - Checking if the service is temporarily unavailable
4. Always provide helpful suggestions for alternative approaches
5. Maintain a supportive and professional tone

IMPORTANT: Never ignore tool errors. Always respond to failed tool calls with helpful guidance for the user.
"""

        full_system_prompt = video_generation_prompt + error_handling_prompt

        # è§†é¢‘è®¾è®¡æ™ºèƒ½ä½“ä¸éœ€è¦åˆ‡æ¢åˆ°å…¶ä»–æ™ºèƒ½ä½“
        handoffs: List[HandoffConfig] = [
            {
                'agent_name': 'image_designer',
                'description': """
                        Transfer user to the image_designer. About this agent: Specialize in generating images.
                        """
            },
        ]

        super().__init__(
            name='video_designer',
            tools=tool_list,
            system_prompt=full_system_prompt,
            handoffs=handoffs
        )



================================================
FILE: server/services/migrations/__init__.py
================================================
from typing import Protocol
import sqlite3

class Migration(Protocol):
    """Migration protocol"""
    version: int
    description: str

    def up(self, conn: sqlite3.Connection) -> None:
        """Apply the migration"""
        ...

    def down(self, conn: sqlite3.Connection) -> None:
        """Rollback the migration"""
        ... 


================================================
FILE: server/services/migrations/manager.py
================================================
from typing import List, Type
import sqlite3
from services.migrations.v1_initial_schema import V1InitialSchema
from services.migrations.v2_add_canvases import V2AddCanvases
from services.migrations.v3_add_comfy_workflow import V3AddComfyWorkflow
from . import Migration

# Database version
CURRENT_VERSION = 3

ALL_MIGRATIONS = [
    {
        'version': 1,
        'migration': V1InitialSchema,
    },
    {
        'version': 2,
        'migration': V2AddCanvases,
    },
    {
        'version': 3,
        'migration': V3AddComfyWorkflow,
    },
]
class MigrationManager:
    def get_migrations_to_apply(self, current_version: int, target_version: int) -> List[Type[Migration]]:
        """Get list of migrations to apply"""
        return [m for m in ALL_MIGRATIONS
                if m['version'] > current_version and m['version'] <= target_version]

    def get_migrations_to_rollback(self, current_version: int, target_version: int) -> List[Type[Migration]]:
        """Get list of migrations to rollback"""
        return [m for m in reversed(ALL_MIGRATIONS)
                if m['version'] <= current_version and m['version'] > target_version]

    def migrate(self, conn: sqlite3.Connection, from_version: int, to_version: int) -> None:
        """Apply or rollback migrations to reach target version"""
        if from_version < to_version:
            # Apply migrations forward
            print('ğŸ¦„ Applying migrations forward', from_version, '->', to_version)
            migrations_to_apply = self.get_migrations_to_apply(from_version, to_version)
            print('ğŸ¦„ Migrations to apply', migrations_to_apply)
            for migration in migrations_to_apply:
                migration_class = migration['migration']
                migration = migration_class()
                print(f"Applying migration {migration.version}: {migration.description}")
                migration.up(conn)
                conn.execute("UPDATE db_version SET version = ?", (migration.version,))
        # Do not do rollback migrations
        # else:
        #     # Rollback migrations
        #     print('ğŸ¦„ Rolling back migrations', from_version, '->', to_version)
        #     migrations_to_rollback = self.get_migrations_to_rollback(from_version, to_version)
        #     print('ğŸ¦„ Migrations to rollback', migrations_to_rollback)
        #     for migration_class in migrations_to_rollback:
        #         migration = migration_class()
        #         print(f"Rolling back migration {migration.version}: {migration.description}")
        #         migration.down(conn)
        #         conn.execute("UPDATE db_version SET version = ?", (migration.version - 1,)) 


================================================
FILE: server/services/migrations/v1_initial_schema.py
================================================
from . import Migration
import sqlite3

class V1InitialSchema(Migration):
    version = 1
    description = "Initial schema"

    def up(self, conn: sqlite3.Connection) -> None:
        # Create chat_sessions table
        conn.execute("""
            CREATE TABLE IF NOT EXISTS chat_sessions (
                id TEXT PRIMARY KEY,
                canvas_id TEXT,
                created_at TEXT DEFAULT (STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now')),
                updated_at TEXT DEFAULT (STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now')),
                title TEXT,
                model TEXT,
                provider TEXT,
                FOREIGN KEY (canvas_id) REFERENCES canvases(id)
            )
        """)

        conn.execute("""
            CREATE INDEX IF NOT EXISTS idx_chat_sessions_updated_at ON chat_sessions(updated_at DESC, id DESC)
        """)

        # Create chat_messages table
        conn.execute("""
            CREATE TABLE IF NOT EXISTS chat_messages (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                session_id TEXT,
                role TEXT,
                message TEXT,
                created_at TEXT DEFAULT (STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now')),
                updated_at TEXT DEFAULT (STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now')),
                FOREIGN KEY (session_id) REFERENCES chat_sessions(id)
            )
        """)

        conn.execute("""
            CREATE INDEX IF NOT EXISTS idx_chat_messages_session_id_id ON chat_messages(session_id, id);
        """)

    def down(self, conn: sqlite3.Connection) -> None:
        conn.execute("DROP TABLE IF EXISTS chat_messages")
        conn.execute("DROP TABLE IF EXISTS chat_sessions") 


================================================
FILE: server/services/migrations/v2_add_canvases.py
================================================
from . import Migration
import sqlite3


class V2AddCanvases(Migration):
    version = 2
    description = "Add canvases"

    def up(self, conn: sqlite3.Connection) -> None:
        # Create canvases table
        conn.execute("""
            CREATE TABLE IF NOT EXISTS canvases (
                id TEXT PRIMARY KEY,
                name TEXT NOT NULL,
                data TEXT,
                description TEXT DEFAULT '',
                thumbnail TEXT DEFAULT '',
                created_at TEXT DEFAULT (STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now')),
                updated_at TEXT DEFAULT (STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now'))
            )
        """)

        conn.execute("""
            CREATE INDEX IF NOT EXISTS idx_canvases_updated_at ON canvases(updated_at DESC, id DESC)
        """)

        # Check if canvas_id column already exists in chat_sessions
        cursor = conn.execute("PRAGMA table_info(chat_sessions)")
        columns = [column[1] for column in cursor.fetchall()]

        if 'canvas_id' not in columns:
            # Add canvas_id column to chat_sessions only if it doesn't exist
            conn.execute(
                "ALTER TABLE chat_sessions ADD COLUMN canvas_id TEXT REFERENCES canvases(id)")

        # Create default canvas
        conn.execute("""
            INSERT OR IGNORE INTO canvases (id, name)
            VALUES ('default', 'Default Canvas')
        """)

        # Associate all existing sessions with default canvas
        conn.execute("""
            UPDATE chat_sessions
            SET canvas_id = 'default'
            WHERE canvas_id IS NULL
        """)

    def down(self, conn: sqlite3.Connection) -> None:
        # Remove canvas_id column from chat_sessions
        conn.execute("""
            CREATE TABLE chat_sessions_new (
                id TEXT PRIMARY KEY,
                created_at TEXT DEFAULT (STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now')),
                updated_at TEXT DEFAULT (STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now')),
                title TEXT,
                model TEXT,
                provider TEXT
            )
        """)

        conn.execute("""
            INSERT INTO chat_sessions_new (id, created_at, updated_at, title, model, provider)
            SELECT id, created_at, updated_at, title, model, provider FROM chat_sessions
        """)

        conn.execute("DROP TABLE chat_sessions")
        conn.execute("ALTER TABLE chat_sessions_new RENAME TO chat_sessions")

        conn.execute("DROP TABLE IF EXISTS canvases")



================================================
FILE: server/services/migrations/v3_add_comfy_workflow.py
================================================
from . import Migration
import sqlite3


class V3AddComfyWorkflow(Migration):
    version = 3
    description = "Add comfy workflow"

    def up(self, conn: sqlite3.Connection) -> None:
        # Create comfy workflow table
        conn.execute("""
            CREATE TABLE IF NOT EXISTS comfy_workflows (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                api_json TEXT,
                description TEXT DEFAULT '',
                inputs TEXT,
                outputs TEXT,
                created_at TEXT DEFAULT (STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now')),
                updated_at TEXT DEFAULT (STRFTIME('%Y-%m-%dT%H:%M:%fZ', 'now'))
            )
        """)

        conn.execute("""
            CREATE INDEX IF NOT EXISTS idx_comfy_workflows_updated_at ON comfy_workflows(updated_at DESC, id DESC)
        """)



    def down(self, conn: sqlite3.Connection) -> None:
        pass


================================================
FILE: server/services/OpenAIAgents_service/__init__.py
================================================
# services/OpenAIAgents_service/__init__.py

from .jaaz_magic_agent import create_jaaz_response

__all__ = ['create_jaaz_response']



================================================
FILE: server/services/OpenAIAgents_service/jaaz_magic_agent.py
================================================
# services/OpenAIAgents_service/jaaz_agent.py

from typing import Dict, Any, List
import asyncio
import os
from nanoid import generate
from tools.utils.image_canvas_utils import save_image_to_canvas
from tools.utils.image_utils import get_image_info_and_save
from services.config_service import FILES_DIR
from common import DEFAULT_PORT
from ..jaaz_service import JaazService


async def create_jaaz_response(messages: List[Dict[str, Any]], session_id: str = "", canvas_id: str = "") -> Dict[str, Any]:
    """
    åŸºäºäº‘ç«¯æœåŠ¡çš„å›¾åƒç”Ÿæˆå“åº”å‡½æ•°
    å®ç°å’Œ magic_agent ç›¸åŒçš„åŠŸèƒ½
    """
    try:
        # è·å–å›¾ç‰‡å†…å®¹
        user_message: Dict[str, Any] = messages[-1]
        image_content: str = ""

        if isinstance(user_message.get('content'), list):
            for content_item in user_message['content']:
                if content_item.get('type') == 'image_url':
                    image_content = content_item.get(
                        'image_url', {}).get('url', "")
                    break

        if not image_content:
            return {
                'role': 'assistant',
                'content': [
                    {
                        'type': 'text',
                        'text': 'âœ¨ not found input image'
                    }
                ]
            }

        # åˆ›å»º Jaaz æœåŠ¡å®ä¾‹
        try:
            jaaz_service = JaazService()
        except ValueError as e:
            print(f"âŒ Jaaz service configuration error: {e}")
            return {
                'role': 'assistant',
                'content': [
                    {
                        'type': 'text',
                        'text': 'âœ¨ Cloud API Key not configured'
                    }
                ]
            }

        # è°ƒç”¨ Jaaz æœåŠ¡ç”Ÿæˆé­”æ³•å›¾åƒ
        result = await jaaz_service.generate_magic_image(image_content)
        if not result:
            return {
                'role': 'assistant',
                'content': [
                    {
                        'type': 'text',
                        'text': 'âœ¨ Magic generation failed'
                    }
                ]
            }

        # æ£€æŸ¥æ˜¯å¦æœ‰é”™è¯¯
        if result.get('error'):
            error_msg = result['error']
            print(f"âŒ Magic generation error: {error_msg}")
            return {
                'role': 'assistant',
                'content': [
                    {
                        'type': 'text',
                        'text': f'âœ¨ Magic Generation Error: {error_msg}'
                    }
                ]
            }

        # æ£€æŸ¥æ˜¯å¦æœ‰ç»“æœ URL
        if not result.get('result_url'):
            return {
                'role': 'assistant',
                'content': [
                    {
                        'type': 'text',
                        'text': 'âœ¨ Magic generation failed: No result URL'
                    }
                ]
            }

        # åˆå§‹åŒ–å˜é‡
        filename = ""
        result_url = result['result_url']
        image_url = result_url

        # ä¿å­˜å›¾ç‰‡åˆ°ç”»å¸ƒ
        if session_id and canvas_id:
            try:
                # ç”Ÿæˆå”¯ä¸€æ–‡ä»¶å
                file_id = generate(size=10)
                file_path_without_extension = os.path.join(FILES_DIR, file_id)

                # ä¸‹è½½å¹¶ä¿å­˜å›¾ç‰‡
                mime_type, width, height, extension = await get_image_info_and_save(
                    image_url, file_path_without_extension, is_b64=False
                )

                width = max(1, int(width / 2))
                height = max(1, int(height / 2))

                # ç”Ÿæˆæ–‡ä»¶å
                filename = f'{file_id}.{extension}'

                # ä¿å­˜å›¾ç‰‡åˆ°ç”»å¸ƒ
                image_url = await save_image_to_canvas(session_id, canvas_id, filename, mime_type, width, height)
                print(f"âœ¨ å›¾ç‰‡å·²ä¿å­˜åˆ°ç”»å¸ƒ: {filename}")
            except Exception as e:
                print(f"âŒ ä¿å­˜å›¾ç‰‡åˆ°ç”»å¸ƒå¤±è´¥: {e}")

        return {
            'role': 'assistant',
            'content': f'âœ¨ Magic Success!!!\n\nResult url: {result_url}\n\n![image_id: {filename}](http://localhost:{DEFAULT_PORT}{image_url})'
        }

    except (asyncio.TimeoutError, Exception) as e:
        # æ£€æŸ¥æ˜¯å¦æ˜¯è¶…æ—¶ç›¸å…³çš„é”™è¯¯
        error_msg = str(e).lower()
        if 'timeout' in error_msg or 'timed out' in error_msg:
            return {
                'role': 'assistant',
                'content': [
                    {
                        'type': 'text',
                        'text': 'âœ¨ time out'
                    }
                ]
            }
        else:
            print(f"âŒ åˆ›å»ºé­”æ³•å›å¤æ—¶å‡ºé”™: {e}")
            return {
                'role': 'assistant',
                'content': [
                    {
                        'type': 'text',
                        'text': f'âœ¨ Magic Generation Error: {str(e)}'
                    }
                ]
            }

if __name__ == "__main__":
    asyncio.run(create_jaaz_response([]))



================================================
FILE: server/services/OpenAIAgents_service/test.py
================================================
from agents import Agent, Runner, set_tracing_disabled, set_default_openai_key
import asyncio
from services.config_service import config_service
config = config_service.get_config()

set_tracing_disabled(True)
api_key = config.get('openai', {}).get('api_key', '')
set_default_openai_key(str(api_key))



async def create_magic_response():
    intent_agent = Agent(
        name="Intent Agent",
        instructions="You are a helpful assistant that can analyze images and provide a summary of the content.",
        model="gpt-4.1-mini",
    )
    result = await Runner.run(intent_agent, input='Hi')
    print(result.final_output)



if __name__ == "__main__":
    asyncio.run(create_magic_response())









================================================
FILE: server/tools/comfy_dynamic.py
================================================
"""
Dynamic registration of ComfyUI workflows as LangChain tools.

Importing this module will:
1. Query the local database for all stored ComfyUI workflows.
2. For each workflow, generate:
   â€¢ A Pydantic input schema reflecting its `inputs` definition.
   â€¢ An async LangChain `@tool` function that forwards the call to
     `db_service.run_comfy_workflow(...)`.
3. Expose all generated tool callables in `DYNAMIC_COMFY_TOOLS`
   so the agent can do:

       from server.tools.comfy_dynamic import DYNAMIC_COMFY_TOOLS
       tools = [..., *DYNAMIC_COMFY_TOOLS]

If `run_comfy_workflow` is not yet implemented it will still work
(actually return a stub dict) so callers won't crash.
"""

from __future__ import annotations

import json
import os
import random
import time
import traceback
from io import BytesIO
from typing import Annotated, Any, Dict, List, Optional
from common import DEFAULT_PORT
from .utils.image_canvas_utils import (
    generate_file_id,
    generate_new_image_element,
)
from langchain_core.runnables import RunnableConfig
from langchain_core.tools import InjectedToolCallId, tool, BaseTool
from pydantic import BaseModel, Field, create_model
from routers.comfyui_execution import upload_image
from services.config_service import FILES_DIR, config_service, IMAGE_FORMATS
from services.db_service import db_service
from services.websocket_service import broadcast_session_update, send_to_websocket

from .utils.comfyui import ComfyUIWorkflowRunner
from tools.video_generation.video_canvas_utils import generate_new_video_element


def _python_type(param_type: str, default: Any):
    """Map simple param types to Python types."""
    if param_type == "number":
        # choose int vs float based on default value presence
        if isinstance(default, int):
            return int
        return float
    if param_type == "boolean" or param_type == "bool":
        return bool
    # Treat unknown / string / image / file / path all as str
    return str


def _build_input_schema(wf: Dict[str, Any]) -> type[BaseModel]:
    """
    Build a Pydantic model named '<WorkflowName>Input' from workflow['inputs'].
    The `inputs` column is stored in DB as JSON text -> parse first.
    """
    try:
        input_defs: List[Dict[str, Any]] = (
            wf["inputs"] if isinstance(wf["inputs"], list) else json.loads(wf["inputs"])
        )
    except Exception:
        # fall back to empty model if bad schema
        input_defs = []

    fields: Dict[str, tuple] = {}
    for param in input_defs:
        name = param.get("name")
        if not name:
            continue
        py_t = _python_type(param.get("type"), param.get("default_value"))
        default_val = param.get("default_value")
        desc = param.get("description", "")
        is_required = param.get("required", False)

        if is_required:
            desc = f"Required. {desc}"
            fields[name] = (py_t, Field(description=desc))
        else:
            desc = f"Optional. {desc}"
            fields[name] = (
                Optional[py_t],
                Field(default=default_val, description=desc),
            )
    # add a tool_call_id - fix the field definition format
    fields["tool_call_id"] = (
        Annotated[str, InjectedToolCallId],
        Field(description="Tool call identifier"),
    )

    model_name = f"{wf['name'].title().replace(' ', '')}InputSchema"
    return create_model(model_name, __base__=BaseModel, **fields)


def build_tool(wf: Dict[str, Any]) -> BaseTool:
    """Return an @tool function for the given workflow record."""
    input_schema = _build_input_schema(wf)

    @tool(
        wf["name"],
        description=wf.get("description") or f"Run ComfyUI workflow {wf['id']}",
        args_schema=input_schema,
    )
    async def _run(
        config: RunnableConfig,
        tool_call_id: Annotated[str, InjectedToolCallId],
        **kwargs,
    ) -> str:
        """
        code to call comfyui generating image.
        """
        print("ğŸ› ï¸ tool_call_id", tool_call_id)
        ctx = config.get("configurable", {})
        canvas_id = ctx.get("canvas_id", "")
        session_id = ctx.get("session_id", "")
        print("ğŸ› ï¸canvas_id", canvas_id, "session_id", session_id)
        # Inject the tool call id into the context
        ctx["tool_call_id"] = tool_call_id
        api_url = str(
            config_service.app_config.get("comfyui", {}).get("url", "")
        ).rstrip("/")

        # if there's image, upload it!
        # First, let's filter all values endswith .jpg .png etc

        required_data = dict(kwargs)
        for key, value in required_data.items():
            if isinstance(value, str) and value.lower().endswith(IMAGE_FORMATS):
                # Image!
                # Extract filename from potential API path like "/api/file/filename.png"
                if "/" in value:
                    filename = value.split("/")[
                        -1
                    ]  # Get the last part after the last "/"
                else:
                    filename = value
                image_path = os.path.join(FILES_DIR, filename)
                if not os.path.exists(image_path):
                    continue
                with open(image_path, "rb") as image_file:
                    image_bytes = image_file.read()
                image_stream = BytesIO(image_bytes)
                image_name = await upload_image(image_stream, api_url, filename)
                required_data[key] = image_name

        workflow_dict = await db_service.get_comfy_workflow(wf["id"])

        try:
            input_defs: List[Dict[str, Any]] = (
                wf["inputs"]
                if isinstance(wf["inputs"], list)
                else json.loads(wf["inputs"])
            )
        except Exception:
            input_defs = []

        for param in input_defs:
            param_name = param.get("name")
            node_id = param.get("node_id")
            node_input_name = param.get("node_input_name")

            if not (param_name and node_id and node_input_name):
                continue

            if param_name in required_data:
                value = required_data[param_name]
                if node_id in workflow_dict:
                    node_inputs = workflow_dict[node_id].get("inputs", {})
                    if node_input_name in node_inputs:
                        node_inputs[node_input_name] = value

        # Process seed if has seed
        # æ”¹ä¸ºç›´æ¥éå†èŠ‚ç‚¹è¾“å…¥æ£€æµ‹seedå­—æ®µï¼Œæ›¿ä»£å­—ç¬¦ä¸²åŒ¹é…
        seed_nodes = []
        for node_id, node in workflow_dict.items():
            if "seed" in node.get("inputs", {}):  # ç›´æ¥æ£€æŸ¥èŠ‚ç‚¹è¾“å…¥æ˜¯å¦æœ‰seedå­—æ®µ
                seed_nodes.append(node_id)  # æ”¶é›†æ‰€æœ‰å«seedçš„èŠ‚ç‚¹ï¼Œä¸ç§»é™¤break

        if len(seed_nodes) > 0:  # ä»…åœ¨å­˜åœ¨ç§å­èŠ‚ç‚¹æ—¶æ‰§è¡Œ
            for node_id in seed_nodes:
                # ä½¿ç”¨æ›´å¤§çš„éšæœºèŒƒå›´ï¼ˆ0åˆ°2^32-1æ›´ç¬¦åˆå¸¸è§ç§å­èŒƒå›´ï¼‰
                workflow_dict[node_id]["inputs"]["seed"] = random.randint(
                    1, (1 << 32) - 1
                )

        try:
            generator = ComfyUIWorkflowRunner(workflow_dict, api_url)
            extra_kwargs = {}
            extra_kwargs["ctx"] = ctx

            outputs = await generator.generate(**extra_kwargs)
            # if outputs is not a list of list, make it a list of list
            if not isinstance(outputs, list) or (
                outputs and not isinstance(outputs[0], (list, tuple))
            ):
                outputs = [outputs]

            # update the canvas data, add the new image element
            canvas_data = await db_service.get_canvas_data(canvas_id)
            if "data" not in canvas_data:
                canvas_data["data"] = {}
            if "elements" not in canvas_data["data"]:
                canvas_data["data"]["elements"] = []
            if "files" not in canvas_data["data"]:
                canvas_data["data"]["files"] = {}

            generated_files_info = []

            for output in outputs:
                mime_type, width, height, filename = output
                file_id = generate_file_id()

                url = f"/api/file/{filename}"

                file_data = {
                    "mimeType": mime_type,
                    "id": file_id,
                    "dataURL": url,
                    "created": int(time.time() * 1000),
                }

                # Pass the current canvas_data to the element generation function
                if mime_type.startswith("image"):
                    new_element = await generate_new_image_element(
                        canvas_id,
                        file_id,
                        {
                            "width": width,
                            "height": height,
                        },
                        canvas_data=canvas_data.get("data", {}),
                    )
                else:
                    new_element = await generate_new_video_element(
                        canvas_id,
                        file_id,
                        {
                            "width": width,
                            "height": height,
                        },
                        canvas_data=canvas_data.get("data", {}),
                    )

                canvas_data["data"]["elements"].append(new_element)
                canvas_data["data"]["files"][file_id] = file_data

                image_url = f"http://localhost:{DEFAULT_PORT}/api/file/{filename}"

                generated_files_info.append(
                    {
                        "element": new_element,
                        "file": file_data,
                        "url": image_url,
                        "mime_type": mime_type,
                        "filename": filename,
                    }
                )

            await db_service.save_canvas_data(
                canvas_id, json.dumps(canvas_data["data"])
            )

            for file_info in generated_files_info:
                if file_info["mime_type"].startswith("image"):
                    await broadcast_session_update(
                        session_id,
                        canvas_id,
                        {
                            "type": "image_generated",
                            "element": file_info["element"],
                            "file": file_info["file"],
                            "image_url": file_info["url"],
                        },
                    )
                else:
                    await broadcast_session_update(
                        session_id,
                        canvas_id,
                        {
                            "type": "video_generated",
                            "element": file_info["element"],
                            "file": file_info["file"],
                            "video_url": file_info["url"],
                        },
                    )

            # Create a markdown string for all the generated files
            markdown_images = []
            for file_info in generated_files_info:
                markdown_images.append(
                    f"![id: {file_info['filename']}]({file_info['url']})"
                )

            return f"workflow executed successfully {', '.join(markdown_images)}"

        except Exception as e:
            print(f"Error generating image: {str(e)}")
            traceback.print_exc()
            await send_to_websocket(session_id, {"type": "error", "error": str(e)})
            return f"image generation failed: {str(e)}"

    return _run



================================================
FILE: server/tools/generate_image_by_doubao_seededit_3_volces.py
================================================
from typing import Annotated
from pydantic import BaseModel, Field
from langchain_core.tools import tool, InjectedToolCallId  # type: ignore
from langchain_core.runnables import RunnableConfig
from tools.utils.image_generation_core import generate_image_with_provider


class EditImageByDoubaoSeedream3InputSchema(BaseModel):
    prompt: str = Field(
        description="Required. The prompt for image edit. Please describe what you want to edit in the prompt."
    )
    image: list[str] = Field(
        description="Required. The image for image generation. Pass a list of image_id here (Only 1 image supported. If you want to generate multiple images. Call another), e.g. ['im_hfuiut78.png']. Best for image editing cases like: Editing specific parts of the image, Removing specific objects, Maintaining visual elements across scenes (character/object consistency), Generating new content in the style of the reference (style transfer), etc."
    )
    tool_call_id: Annotated[str, InjectedToolCallId]


@tool(
    "edit_image_by_doubao_seededit_3_volces",
    description="Edit an image by Doubao Seedream 3 model using text prompt and an image. Use this model for high-quality image modification with Doubao's advanced AI.",
    args_schema=EditImageByDoubaoSeedream3InputSchema,
)
async def edit_image_by_doubao_seededit_3_volces(
    prompt: str,
    image: list[str],
    config: RunnableConfig,
    tool_call_id: Annotated[str, InjectedToolCallId],
) -> str:
    """
    Generate an image using Doubao Seedream 3 model via the provider framework
    """
    ctx = config.get("configurable", {})
    canvas_id = ctx.get("canvas_id", "")
    session_id = ctx.get("session_id", "")

    return await generate_image_with_provider(
        canvas_id=canvas_id,
        session_id=session_id,
        provider="volces",
        model="doubao-seededit-3-0-i2i-250628",
        prompt=prompt,
        input_images=image,
    )


# Export the tool for easy import
__all__ = ["edit_image_by_doubao_seededit_3_volces"]



================================================
FILE: server/tools/generate_image_by_doubao_seedream_3_jaaz.py
================================================
from typing import Annotated
from pydantic import BaseModel, Field
from langchain_core.tools import tool, InjectedToolCallId  # type: ignore
from langchain_core.runnables import RunnableConfig
from tools.utils.image_generation_core import generate_image_with_provider


class GenerateImageByDoubaoSeedream3InputSchema(BaseModel):
    prompt: str = Field(
        description="Required. The prompt for image generation. If you want to edit an image, please describe what you want to edit in the prompt."
    )
    aspect_ratio: str = Field(
        description="Required. Aspect ratio of the image, only these values are allowed: 1:1, 16:9, 4:3, 3:4, 9:16. Choose the best fitting aspect ratio according to the prompt. Best ratio for posters is 3:4"
    )
    tool_call_id: Annotated[str, InjectedToolCallId]


@tool("generate_image_by_doubao_seedream_3_jaaz",
      description="Generate an image by Doubao Seedream 3 model using text prompt. This model does NOT support input images for reference or editing. Use this model for high-quality image generation with Doubao's advanced AI. Supports multiple providers with automatic fallback.",
      args_schema=GenerateImageByDoubaoSeedream3InputSchema)
async def generate_image_by_doubao_seedream_3_jaaz(
    prompt: str,
    aspect_ratio: str,
    config: RunnableConfig,
    tool_call_id: Annotated[str, InjectedToolCallId],
) -> str:
    """
    Generate an image using Doubao Seedream 3 model via the provider framework
    """
    ctx = config.get('configurable', {})
    canvas_id = ctx.get('canvas_id', '')
    session_id = ctx.get('session_id', '')

    return await generate_image_with_provider(
        canvas_id=canvas_id,
        session_id=session_id,
        provider='jaaz',
        model="doubao/doubao-seedream-3-0-t2i-250415",
        prompt=prompt,
        aspect_ratio=aspect_ratio,
        input_images=None,
    )


# Export the tool for easy import
__all__ = ["generate_image_by_doubao_seedream_3_jaaz"]



================================================
FILE: server/tools/generate_image_by_doubao_seedream_3_volces.py
================================================
from typing import Annotated
from pydantic import BaseModel, Field
from langchain_core.tools import tool, InjectedToolCallId  # type: ignore
from langchain_core.runnables import RunnableConfig
from tools.utils.image_generation_core import generate_image_with_provider


class GenerateImageByDoubaoSeedream3InputSchema(BaseModel):
    prompt: str = Field(
        description="Required. The prompt for image generation. If you want to edit an image, please describe what you want to edit in the prompt."
    )
    aspect_ratio: str = Field(
        description="Required. Aspect ratio of the image, only these values are allowed: 1:1, 16:9, 4:3, 3:4, 9:16. Choose the best fitting aspect ratio according to the prompt. Best ratio for posters is 3:4"
    )
    tool_call_id: Annotated[str, InjectedToolCallId]


@tool("generate_image_by_doubao_seedream_3_volces",
      description="Generate an image by Doubao Seedream 3 model using text prompt. This model does NOT support input images for reference or editing. Use this model for high-quality image generation with Doubao's advanced AI. Supports multiple providers with automatic fallback.",
      args_schema=GenerateImageByDoubaoSeedream3InputSchema)
async def generate_image_by_doubao_seedream_3_volces(
    prompt: str,
    aspect_ratio: str,
    config: RunnableConfig,
    tool_call_id: Annotated[str, InjectedToolCallId],
) -> str:
    """
    Generate an image using Doubao Seedream 3 model via the provider framework
    """
    ctx = config.get('configurable', {})
    canvas_id = ctx.get('canvas_id', '')
    session_id = ctx.get('session_id', '')

    return await generate_image_with_provider(
        canvas_id=canvas_id,
        session_id=session_id,
        provider='volces',
        model="volces/doubao-seedream-3-0-t2i-250415",
        prompt=prompt,
        aspect_ratio=aspect_ratio,
        input_images=None,
    )


# Export the tool for easy import
__all__ = ["generate_image_by_doubao_seedream_3_volces"]



================================================
FILE: server/tools/generate_image_by_flux_1_1_pro_jaaz.py
================================================
from typing import Annotated
from pydantic import BaseModel, Field
from langchain_core.tools import tool, InjectedToolCallId  # type: ignore
from langchain_core.runnables import RunnableConfig
from tools.utils.image_generation_core import generate_image_with_provider


class GenerateImageByFlux11ProInputSchema(BaseModel):
    prompt: str = Field(
        description="Required. The prompt for image generation. If you want to edit an image, please describe what you want to edit in the prompt."
    )
    aspect_ratio: str = Field(
        description="Required. Aspect ratio of the image, only these values are allowed: 1:1, 16:9, 4:3, 3:4, 9:16. Choose the best fitting aspect ratio according to the prompt. Best ratio for posters is 3:4"
    )
    tool_call_id: Annotated[str, InjectedToolCallId]


@tool("generate_image_by_flux_1_1_pro",
      description="Generate an image by Flux 1.1 Pro model using text prompt. This model does NOT support input images for reference or editing. Use this model for high-quality image generation with Flux's advanced AI. Supports multiple providers with automatic fallback.",
      args_schema=GenerateImageByFlux11ProInputSchema)
async def generate_image_by_flux_1_1_pro(
    prompt: str,
    aspect_ratio: str,
    config: RunnableConfig,
    tool_call_id: Annotated[str, InjectedToolCallId],
) -> str:
    """
    Generate an image using Flux 1.1 Pro model via the provider framework
    """
    ctx = config.get('configurable', {})
    canvas_id = ctx.get('canvas_id', '')
    session_id = ctx.get('session_id', '')

    return await generate_image_with_provider(
        canvas_id=canvas_id,
        session_id=session_id,
        provider='jaaz',
        prompt=prompt,
        aspect_ratio=aspect_ratio,
        model="black-forest-labs/flux-1.1-pro",
        input_images=None,
    )


# Export the tool for easy import
__all__ = ["generate_image_by_flux_1_1_pro"]



================================================
FILE: server/tools/generate_image_by_flux_kontext_max_jaaz.py
================================================
from typing import Annotated
from pydantic import BaseModel, Field
from langchain_core.tools import tool, InjectedToolCallId  # type: ignore
from langchain_core.runnables import RunnableConfig
from tools.utils.image_generation_core import generate_image_with_provider

class GenerateImageByFluxKontextMaxInputSchema(BaseModel):
    prompt: str = Field(
        description="Required. The prompt for image generation. If you want to edit an image, please describe what you want to edit in the prompt."
    )
    aspect_ratio: str = Field(
        description="Required. Aspect ratio of the image, only these values are allowed: 1:1, 16:9, 4:3, 3:4, 9:16. Choose the best fitting aspect ratio according to the prompt. Best ratio for posters is 3:4"
    )
    input_images: list[str]| None = Field(
        default=None,
        description="Optional; Image to use as reference. Only one image is allowed, e.g. ['im_jurheut7.png']. Best for image editing cases like: Editing specific parts of the image, Removing specific objects, Maintaining visual elements across scenes (character/object consistency), Generating new content in the style of the reference (style transfer), etc."
    )
    tool_call_id: Annotated[str, InjectedToolCallId]


@tool("generate_image_by_flux_kontext_max",
      description="Generate an image by Flux Kontext Max model using text prompt or optionally pass an image for reference or editing. Use this model for high-quality image generation with Flux's advanced AI. Supports multiple providers with automatic fallback.",
      args_schema=GenerateImageByFluxKontextMaxInputSchema)
async def generate_image_by_flux_kontext_max(
    prompt: str,
    aspect_ratio: str,
    config: RunnableConfig,
    tool_call_id: Annotated[str, InjectedToolCallId],
    input_images: list[str] | None = None,
) -> str:
    """
    Generate an image using Flux Kontext Max model via the provider framework
    """
    ctx = config.get('configurable', {})
    canvas_id = ctx.get('canvas_id', '')
    session_id = ctx.get('session_id', '')

    return await generate_image_with_provider(
        canvas_id=canvas_id,
        session_id=session_id,
        provider='jaaz',
        model="black-forest-labs/flux-kontext-max",
        prompt=prompt,
        aspect_ratio=aspect_ratio,
        input_images=input_images,
    )

# Export the tool for easy import
__all__ = ["generate_image_by_flux_kontext_max"]



================================================
FILE: server/tools/generate_image_by_flux_kontext_max_replicate.py
================================================
from typing import Annotated
from langchain_core.tools import tool, InjectedToolCallId  # type: ignore
from langchain_core.runnables import RunnableConfig
from tools.utils.image_generation_core import generate_image_with_provider
from tools.generate_image_by_flux_kontext_max_jaaz import GenerateImageByFluxKontextMaxInputSchema


@tool("generate_image_by_flux_kontext_max_replicate",
      description="Generate an image by Flux Kontext Max model using text prompt or optionally pass an image for reference or editing. Use this model for high-quality image generation with Flux's advanced AI.",
      args_schema=GenerateImageByFluxKontextMaxInputSchema)
async def generate_image_by_flux_kontext_max_replicate(
    prompt: str,
    aspect_ratio: str,
    config: RunnableConfig,
    tool_call_id: Annotated[str, InjectedToolCallId],
    input_image: str | None = None,
) -> str:
    """
    Generate an image using Flux Kontext Max model via the Replicate provider framework
    """
    ctx = config.get('configurable', {})
    canvas_id = ctx.get('canvas_id', '')
    session_id = ctx.get('session_id', '')

    return await generate_image_with_provider(
        canvas_id=canvas_id,
        session_id=session_id,
        provider='replicate',
        model="black-forest-labs/flux-kontext-max",
        prompt=prompt,
        aspect_ratio=aspect_ratio,
        input_images=[input_image] if input_image else None,
    )

# Export the tool for easy import
__all__ = ["generate_image_by_flux_kontext_max_replicate"]



================================================
FILE: server/tools/generate_image_by_flux_kontext_pro_jaaz.py
================================================
from typing import Annotated
from pydantic import BaseModel, Field
from langchain_core.tools import tool, InjectedToolCallId  # type: ignore
from langchain_core.runnables import RunnableConfig
from tools.utils.image_generation_core import generate_image_with_provider


class GenerateImageByFluxKontextProInputSchema(BaseModel):
    prompt: str = Field(
        description="Required. The prompt for image generation. If you want to edit an image, please describe what you want to edit in the prompt."
    )
    aspect_ratio: str = Field(
        description="Required. Aspect ratio of the image, only these values are allowed: 1:1, 16:9, 4:3, 3:4, 9:16. Choose the best fitting aspect ratio according to the prompt. Best ratio for posters is 3:4"
    )
    input_images: list[str]| None = Field(
        default=None,
        description="Optional; Image to use as reference. Only one image is allowed, e.g. ['im_jurheut7.png']. Best for image editing cases like: Editing specific parts of the image, Removing specific objects, Maintaining visual elements across scenes (character/object consistency), Generating new content in the style of the reference (style transfer), etc."
    )
    tool_call_id: Annotated[str, InjectedToolCallId]


@tool("generate_image_by_flux_kontext_pro_jaaz",
      description="Generate an image by Flux Kontext Pro model using text prompt or optionally pass an image for reference or editing. Good for object removal, image editing, etc. Only one input image is allowed.",
      args_schema=GenerateImageByFluxKontextProInputSchema)
async def generate_image_by_flux_kontext_pro_jaaz(
    prompt: str,
    aspect_ratio: str,
    config: RunnableConfig,
    tool_call_id: Annotated[str, InjectedToolCallId],
    input_images: list[str] | None = None,
) -> str:
    ctx = config.get('configurable', {})
    canvas_id = ctx.get('canvas_id', '')
    session_id = ctx.get('session_id', '')
    return await generate_image_with_provider(
        canvas_id=canvas_id,
        session_id=session_id,
        provider='jaaz',
        model='black-forest-labs/flux-kontext-pro',
        prompt=prompt,
        aspect_ratio=aspect_ratio,
        input_images=input_images,
    )

# Export the tool for easy import
__all__ = ["generate_image_by_flux_kontext_pro_jaaz"]



================================================
FILE: server/tools/generate_image_by_flux_kontext_pro_replicate.py
================================================
from typing import Annotated
from langchain_core.tools import tool, InjectedToolCallId  # type: ignore
from langchain_core.runnables import RunnableConfig
from tools.utils.image_generation_core import generate_image_with_provider
from tools.generate_image_by_flux_kontext_pro_jaaz import GenerateImageByFluxKontextProInputSchema


@tool("generate_image_by_flux_kontext_pro_replicate",
      description="Generate an image by Flux Kontext Pro model using text prompt or optionally pass an image for reference or editing. Good for object removal, image editing, etc. Only one input image is allowed.",
      args_schema=GenerateImageByFluxKontextProInputSchema)
async def generate_image_by_flux_kontext_pro_replicate(
    prompt: str,
    aspect_ratio: str,
    config: RunnableConfig,
    tool_call_id: Annotated[str, InjectedToolCallId],
    input_image: str | None = None,
) -> str:
    ctx = config.get('configurable', {})
    canvas_id = ctx.get('canvas_id', '')
    session_id = ctx.get('session_id', '')
    return await generate_image_with_provider(
        canvas_id=canvas_id,
        session_id=session_id,
        provider='replicate',
        model='black-forest-labs/flux-kontext-pro',
        prompt=prompt,
        aspect_ratio=aspect_ratio,
        input_images=[input_image] if input_image else None,
    )

# Export the tool for easy import
__all__ = ["generate_image_by_flux_kontext_pro_replicate"]



================================================
FILE: server/tools/generate_image_by_gpt_image_1_jaaz.py
================================================
from typing import Annotated
from pydantic import BaseModel, Field
from langchain_core.tools import tool, InjectedToolCallId  # type: ignore
from langchain_core.runnables import RunnableConfig
from tools.utils.image_generation_core import generate_image_with_provider


class GenerateImageByGptImage1InputSchema(BaseModel):
    prompt: str = Field(
        description="Required. The prompt for image generation. If you want to edit an image, please describe what you want to edit in the prompt."
    )
    aspect_ratio: str = Field(
        description="Required. Aspect ratio of the image, only these values are allowed: 1:1, 16:9, 4:3, 3:4, 9:16. Choose the best fitting aspect ratio according to the prompt. Best ratio for posters is 3:4"
    )
    input_images: list[str] | None = Field(
        default=None,
        description="Optional; One or multiple images to use as reference. Pass a list of image_id here, e.g. ['im_jurheut7.png', 'im_hfuiut78.png']. Best for image editing cases like: Editing specific parts of the image, Removing specific objects, Maintaining visual elements across scenes (character/object consistency), Generating new content in the style of the reference (style transfer), etc."
    )
    tool_call_id: Annotated[str, InjectedToolCallId]


@tool("generate_image_by_gpt_image_1_jaaz",
      description="Generate an image by gpt image model using text prompt or optionally pass images for reference or for editing. Use this model if you need to use multiple input images as reference. Supports multiple providers with automatic fallback.",
      args_schema=GenerateImageByGptImage1InputSchema)
async def generate_image_by_gpt_image_1_jaaz(
    prompt: str,
    aspect_ratio: str,
    config: RunnableConfig,
    tool_call_id: Annotated[str, InjectedToolCallId],
    input_images: list[str] | None = None,
) -> str:
    ctx = config.get('configurable', {})
    canvas_id = ctx.get('canvas_id', '')
    session_id = ctx.get('session_id', '')
    return await generate_image_with_provider(
        canvas_id=canvas_id,
        session_id=session_id,
        provider='jaaz',
        model='openai/gpt-image-1',
        prompt=prompt,
        aspect_ratio=aspect_ratio,
        input_images=input_images,
    )


# Export the tool for easy import
__all__ = ["generate_image_by_gpt_image_1_jaaz"]



================================================
FILE: server/tools/generate_image_by_ideogram3_bal_jaaz.py
================================================
from typing import Annotated
from pydantic import BaseModel, Field
from langchain_core.tools import tool, InjectedToolCallId  # type: ignore
from langchain_core.runnables import RunnableConfig
from tools.utils.image_generation_core import generate_image_with_provider


class GenerateImageByIdeogram3InputSchema(BaseModel):
    prompt: str = Field(
        description="Required. The prompt for image generation. If you want to edit an image, please describe what you want to edit in the prompt."
    )
    aspect_ratio: str = Field(
        description="Required. Aspect ratio of the image, only these values are allowed: 1:1, 16:9, 4:3, 3:4, 9:16. Choose the best fitting aspect ratio according to the prompt. Best ratio for posters is 3:4"
    )
    tool_call_id: Annotated[str, InjectedToolCallId]


@tool("generate_image_by_ideogram3_bal_jaaz",
      description="Generate an image by Ideogram 3 balanced model using text prompt. A good backup model for image generation if other models are not available. This model does NOT support input images for reference or editing.",
      args_schema=GenerateImageByIdeogram3InputSchema)
async def generate_image_by_ideogram3_bal_jaaz(
    prompt: str,
    aspect_ratio: str,
    config: RunnableConfig,
    tool_call_id: Annotated[str, InjectedToolCallId],
) -> str:
    ctx = config.get('configurable', {})
    canvas_id = ctx.get('canvas_id', '')
    session_id = ctx.get('session_id', '')

    return await generate_image_with_provider(
        canvas_id=canvas_id,
        session_id=session_id,
        provider='jaaz',
        prompt=prompt,
        aspect_ratio=aspect_ratio,
        model="ideogram-ai/ideogram-v3-balanced",
        input_images=None,
    )


# Export the tool for easy import
__all__ = ["generate_image_by_ideogram3_bal_jaaz"]



================================================
FILE: server/tools/generate_image_by_imagen_4_jaaz.py
================================================
from typing import Annotated
from pydantic import BaseModel, Field
from langchain_core.tools import tool, InjectedToolCallId  # type: ignore
from langchain_core.runnables import RunnableConfig
from tools.utils.image_generation_core import generate_image_with_provider

class GenerateImageByImagen4InputSchema(BaseModel):
    prompt: str = Field(
        description="Required. The prompt for image generation. If you want to edit an image, please describe what you want to edit in the prompt."
    )
    aspect_ratio: str = Field(
        description="Required. Aspect ratio of the image, only these values are allowed: 1:1, 16:9, 4:3, 3:4, 9:16. Choose the best fitting aspect ratio according to the prompt. Best ratio for posters is 3:4"
    )
    tool_call_id: Annotated[str, InjectedToolCallId]



@tool("generate_image_by_imagen_4_jaaz",
      description="Generate an image by Google Imagen-4 model using text prompt. This model does NOT support input images for reference or editing. Use this model for high-quality image generation with Google's advanced AI. Supports multiple providers with automatic fallback.",
      args_schema=GenerateImageByImagen4InputSchema)
async def generate_image_by_imagen_4_jaaz(
    prompt: str,
    aspect_ratio: str,
    config: RunnableConfig,
    tool_call_id: Annotated[str, InjectedToolCallId],
) -> str:
    ctx = config.get('configurable', {})
    canvas_id = ctx.get('canvas_id', '')
    session_id = ctx.get('session_id', '')
    print(f'ğŸ› ï¸ canvas_id {canvas_id} session_id {session_id}')
    return await generate_image_with_provider(
        canvas_id=canvas_id,
        session_id=session_id,
        provider='jaaz',
        model='google/imagen-4',
        prompt=prompt,
        aspect_ratio=aspect_ratio,
    )


# Export the tool for easy import
__all__ = ["generate_image_by_imagen_4_jaaz"]



================================================
FILE: server/tools/generate_image_by_imagen_4_replicate.py
================================================
from typing import Annotated
from langchain_core.tools import tool, InjectedToolCallId  # type: ignore
from langchain_core.runnables import RunnableConfig
from tools.utils.image_generation_core import generate_image_with_provider
from tools.generate_image_by_imagen_4_jaaz import GenerateImageByImagen4InputSchema


@tool("generate_image_by_imagen_4_replicate",
      description="Generate an image by Google Imagen-4 model using text prompt. This model does NOT support input images for reference or editing. Use this model for high-quality image generation with Google's advanced AI through Replicate platform.",
      args_schema=GenerateImageByImagen4InputSchema)
async def generate_image_by_imagen_4_replicate(
    prompt: str,
    aspect_ratio: str,
    config: RunnableConfig,
    tool_call_id: Annotated[str, InjectedToolCallId],
) -> str:
    ctx = config.get('configurable', {})
    canvas_id = ctx.get('canvas_id', '')
    session_id = ctx.get('session_id', '')
    print(f'ğŸ› ï¸ canvas_id {canvas_id} session_id {session_id}')
    return await generate_image_with_provider(
        canvas_id=canvas_id,
        session_id=session_id,
        provider='replicate',
        model='google/imagen-4',
        prompt=prompt,
        aspect_ratio=aspect_ratio,
    )


# Export the tool for easy import
__all__ = ["generate_image_by_imagen_4_replicate"]



================================================
FILE: server/tools/generate_image_by_midjourney_jaaz.py
================================================
from typing import Annotated, List, Dict, Any
from pydantic import BaseModel, Field
from langchain_core.tools import tool, InjectedToolCallId  # type: ignore
from langchain_core.runnables import RunnableConfig
from services.jaaz_service import JaazService
from tools.utils.image_canvas_utils import save_image_to_canvas, send_image_start_notification, send_image_error_notification
from common import DEFAULT_PORT
import os
from tools.utils.image_utils import get_image_info_and_save, generate_image_id, process_input_image
from services.config_service import FILES_DIR


class GenerateImageByMidjourneyInputSchema(BaseModel):
    prompt: str = Field(
        description="Required. The prompt for image generation. Describe what you want to see in the image."
    )
    input_images: List[str] | None = Field(
        default=None,
        description="Optional. A list of image URLs to use as input for the image generation. If provided, the images will be used as input for the image generation."
    )
    tool_call_id: Annotated[str, InjectedToolCallId]


@tool("generate_image_by_midjourney_jaaz",
      description="Generate high-quality images using Midjourney model. Returns multiple images and saves them to canvas. Use this for artistic and creative image generation.",
      args_schema=GenerateImageByMidjourneyInputSchema)
async def generate_image_by_midjourney_jaaz(
    prompt: str,
    config: RunnableConfig,
    tool_call_id: Annotated[str, InjectedToolCallId],
    input_images: List[str] | None = None,
) -> str:
    """
    Generate images using Midjourney model via Jaaz service
    """
    print(f'ğŸ¨ Midjourney Image Generation tool_call_id: {tool_call_id}')
    ctx = config.get('configurable', {})
    canvas_id = ctx.get('canvas_id', '')
    session_id = ctx.get('session_id', '')
    print(f'ğŸ¨ canvas_id {canvas_id} session_id {session_id}')

    # Inject the tool call id into the context
    ctx['tool_call_id'] = tool_call_id

    try:
        # Send start notification
        await send_image_start_notification(
            session_id,
            f"Starting Midjourney image generation..."
        )

        # Process input images if provided (only use the first one)
        processed_input_images = None
        if input_images and len(input_images) > 0:
            # Only process the first image
            first_image = input_images[0]
            processed_image = await process_input_image(first_image)
            if processed_image:
                processed_input_images = [processed_image]
                print(f"Using input image for video generation: {first_image}")
            else:
                raise ValueError(
                    f"Failed to process input image: {first_image}. Please check if the image exists and is valid.")

        # Create Jaaz service and generate image
        jaaz_service = JaazService()
        result = await jaaz_service.generate_image_by_midjourney(
            prompt=prompt,
            model="midjourney",
            input_images=processed_input_images,
        )

        if not result:
            raise Exception("No result returned from Midjourney generation")

        # Process multiple images from the result
        images = result.get('images', [])
        if not images or len(images) == 0:
            raise Exception("No images found in Midjourney result")

        print(f"ğŸ¨ Midjourney generated {len(images)} images")

        # Save all images to canvas and collect results
        saved_images: List[Dict[str, Any]] = []
        for i, image_data in enumerate(images):
            try:
                image_url = image_data.get('url')
                if not image_url:
                    print(f"Warning: No URL found for image {i}")
                    continue

                # Download and save the image
                image_id = generate_image_id()
                mime_type, width, height, extension = await get_image_info_and_save(
                    image_url,
                    os.path.join(FILES_DIR, f'{image_id}'),
                    metadata={
                        "prompt": prompt,
                        "model": "midjourney",
                        "image_index": i,
                        "total_images": len(images),
                        "original_url": image_url,
                        "file_size": image_data.get('file_size'),
                        "content_type": image_data.get('content_type'),
                    }
                )

                filename = f'{image_id}.{extension}'

                # Save to canvas
                canvas_image_url = await save_image_to_canvas(
                    session_id, canvas_id, filename, mime_type, width, height
                )

                # Add to saved images list
                saved_images.append({
                    "image_id": filename,
                    "url": canvas_image_url,
                    "index": i,
                    "original_data": image_data
                })

                print(f"ğŸ¨ Saved image {i+1}/{len(images)}: {filename}")

            except Exception as e:
                print(f"Error saving image {i}: {e}")
                # Continue with other images even if one fails
                continue

        if not saved_images:
            raise Exception("Failed to save any images from Midjourney generation")

        # Create result message with all saved images
        image_links: List[str] = []
        for saved_image in saved_images:
            image_links.append(
                f"![image_{saved_image['index']+1}: {saved_image['image_id']}](http://localhost:{DEFAULT_PORT}{saved_image['url']})"
            )

        result_message = f"Midjourney generated {len(saved_images)} images successfully:\n\n" + "\n\n".join(image_links)

        print(f"ğŸ¨ Midjourney generation completed: {len(saved_images)} images saved")
        return result_message

    except Exception as e:
        error_message = f"Error in Midjourney image generation: {str(e)}"
        print(f"ğŸ¨ {error_message}")

        # Send error notification
        await send_image_error_notification(session_id, error_message)

        raise e


# Export the tool for easy import
__all__ = ["generate_image_by_midjourney_jaaz"]



================================================
FILE: server/tools/generate_image_by_recraft_v3_jaaz.py
================================================
from typing import Annotated
from pydantic import BaseModel, Field
from langchain_core.tools import tool, InjectedToolCallId  # type: ignore
from langchain_core.runnables import RunnableConfig
from tools.utils.image_generation_core import generate_image_with_provider

class GenerateImageByRecraftV3InputSchema(BaseModel):
    prompt: str = Field(
        description="Required. The prompt for image generation. If you want to edit an image, please describe what you want to edit in the prompt."
    )
    aspect_ratio: str = Field(
        description="Required. Aspect ratio of the image, only these values are allowed: 1:1, 16:9, 4:3, 3:4, 9:16. Choose the best fitting aspect ratio according to the prompt. Best ratio for posters is 3:4"
    )
    tool_call_id: Annotated[str, InjectedToolCallId]


@tool("generate_image_by_recraft_v3_jaaz",
      description="Generate an image by Recraft V3 model using text prompt. This model does NOT support input images for reference or editing. Use this model for high-quality image generation with Recraft's advanced AI. Supports multiple providers with automatic fallback.",
      args_schema=GenerateImageByRecraftV3InputSchema)
async def generate_image_by_recraft_v3_jaaz(
    prompt: str,
    aspect_ratio: str,
    config: RunnableConfig,
    tool_call_id: Annotated[str, InjectedToolCallId],
) -> str:
    """
    Generate an image using Recraft V3 model via the provider framework
    """
    ctx = config.get('configurable', {})
    canvas_id = ctx.get('canvas_id', '')
    session_id = ctx.get('session_id', '')
    return await generate_image_with_provider(        
        canvas_id=canvas_id,
        session_id=session_id,
        provider='jaaz',
        model="recraft-ai/recraft-v3",
        prompt=prompt,
        aspect_ratio=aspect_ratio,
        input_images=None,
    )


# Export the tool for easy import
__all__ = ["generate_image_by_recraft_v3_jaaz"]



================================================
FILE: server/tools/generate_image_by_recraft_v3_replicate.py
================================================
from typing import Annotated
from langchain_core.tools import tool, InjectedToolCallId  # type: ignore
from langchain_core.runnables import RunnableConfig
from tools.utils.image_generation_core import generate_image_with_provider
from tools.generate_image_by_recraft_v3_jaaz import GenerateImageByRecraftV3InputSchema


@tool("generate_image_by_recraft_v3_replicate",
      description="Generate an image by Recraft V3 model using text prompt. This model does NOT support input images for reference or editing. Use this model for high-quality image generation with Recraft's advanced AI. Supports multiple providers with automatic fallback.",
      args_schema=GenerateImageByRecraftV3InputSchema)
async def generate_image_by_recraft_v3_replicate(
    prompt: str,
    aspect_ratio: str,
    config: RunnableConfig,
    tool_call_id: Annotated[str, InjectedToolCallId],
) -> str:
    """
    Generate an image using Recraft V3 model via the Replicate provider framework
    """
    ctx = config.get('configurable', {})
    canvas_id = ctx.get('canvas_id', '')
    session_id = ctx.get('session_id', '')
    return await generate_image_with_provider(
        canvas_id=canvas_id,
        session_id=session_id,
        provider='replicate',
        model="recraft-ai/recraft-v3",
        prompt=prompt,
        aspect_ratio=aspect_ratio,
        input_images=None,
    )


# Export the tool for easy import
__all__ = ["generate_image_by_recraft_v3_replicate"]



================================================
FILE: server/tools/generate_video_by_hailuo_02_jaaz.py
================================================
from typing import Annotated
from pydantic import BaseModel, Field
from langchain_core.tools import tool, InjectedToolCallId  # type: ignore
from langchain_core.runnables import RunnableConfig
from services.jaaz_service import JaazService
from tools.video_generation.video_canvas_utils import send_video_start_notification, process_video_result
from .utils.image_utils import process_input_image


class GenerateVideoByHailuoInputSchema(BaseModel):
    prompt: str = Field(
        description="Required. The prompt for video generation. Describe what you want to see in the video."
    )
    prompt_enhancer: bool = Field(
        default=False,
        description="Optional. Whether to enhance the prompt automatically. Use False by default."
    )
    resolution: str = Field(
        default="768p",
        description="Optional. The resolution of the video. Use 768p by default. Allowed values: 768p, 1080p."
    )
    duration: int = Field(
        default=6,
        description="Optional. The duration of the video in seconds. Use 6 by default. Allowed values: 6, 10."
    )
    input_images: list[str] | None = Field(
        default=None,
        description="Optional. Images to use as reference or starting frame. Pass a list of image_id here, e.g. ['im_jurheut7.png']. Only the first image will be used as start_image."
    )
    tool_call_id: Annotated[str, InjectedToolCallId]


@tool("generate_video_by_hailuo_02_jaaz",
      description="Generate high-quality videos using Hailuo 02 model. Supports text-to-video generation with prompt enhancement. Fixed 6-second duration and 1080p resolution.",
      args_schema=GenerateVideoByHailuoInputSchema)
async def generate_video_by_hailuo_02_jaaz(
    prompt: str,
    config: RunnableConfig,
    tool_call_id: Annotated[str, InjectedToolCallId],
    prompt_enhancer: bool = False,
    resolution: str = "768p",
    duration: int = 6,
    input_images: list[str] | None = None,
) -> str:
    """
    Generate a video using Hailuo 02 model via Jaaz service
    """
    print(f'ğŸ› ï¸ Hailuo Video Generation tool_call_id: {tool_call_id}')
    ctx = config.get('configurable', {})
    canvas_id = ctx.get('canvas_id', '')
    session_id = ctx.get('session_id', '')
    print(f'ğŸ› ï¸ canvas_id {canvas_id} session_id {session_id}')

    # Inject the tool call id into the context
    ctx['tool_call_id'] = tool_call_id

    try:
        # Send start notification
        await send_video_start_notification(
            session_id,
            f"Starting Hailuo video generation..."
        )

        # Process input images if provided (only use the first one)
        processed_input_images = None
        if input_images and len(input_images) > 0:
            # Only process the first image
            first_image = input_images[0]
            processed_image = await process_input_image(first_image)
            if processed_image:
                processed_input_images = [processed_image]
                print(f"Using input image for video generation: {first_image}")
            else:
                raise ValueError(
                    f"Failed to process input image: {first_image}. Please check if the image exists and is valid.")

        # Create Jaaz service and generate video
        jaaz_service = JaazService()
        result = await jaaz_service.generate_video(
            prompt=prompt,
            model="hailuo-02",
            resolution=resolution,
            duration=duration,
            input_images=processed_input_images,
            prompt_enhancer=prompt_enhancer,
        )

        video_url = result.get('result_url')
        if not video_url:
            raise Exception("No video URL returned from generation")

        # Process video result (save, update canvas, notify)
        return await process_video_result(
            video_url=video_url,
            session_id=session_id,
            canvas_id=canvas_id,
            provider_name="jaaz_hailuo",
        )

    except Exception as e:
        print(f"Error in Hailuo video generation: {e}")
        raise e


# Export the tool for easy import
__all__ = ["generate_video_by_hailuo_02_jaaz"]



================================================
FILE: server/tools/generate_video_by_kling_v2_jaaz.py
================================================
from typing import Annotated
from pydantic import BaseModel, Field
from langchain_core.tools import tool, InjectedToolCallId  # type: ignore
from langchain_core.runnables import RunnableConfig
from services.jaaz_service import JaazService
from tools.video_generation.video_canvas_utils import send_video_start_notification, process_video_result
from .utils.image_utils import process_input_image


class GenerateVideoByKlingV2InputSchema(BaseModel):
    prompt: str = Field(
        description="Required. The prompt for video generation. Describe what you want to see in the video."
    )
    negative_prompt: str = Field(
        default="",
        description="Optional. Negative prompt to specify what you don't want in the video."
    )
    guidance_scale: float = Field(
        default=0.5,
        description="Optional. Guidance scale for generation (0.0 to 1.0). Higher values follow the prompt more closely."
    )
    aspect_ratio: str = Field(
        default="16:9",
        description="Optional. The aspect ratio of the video. Allowed values: 1:1, 16:9, 4:3, 21:9"
    )
    duration: int = Field(
        default=5,
        description="Optional. The duration of the video in seconds. Use 5 by default. Allowed values: 5, 10."
    )
    input_images: list[str] = Field(
        description="Required. Images to use as reference or starting frame. Pass a list of image_id here, e.g. ['im_jurheut7.png']. Only the first image will be used as start_image."
    )
    tool_call_id: Annotated[str, InjectedToolCallId]


@tool("generate_video_by_kling_v2_jaaz",
      description="Generate high-quality videos using Kling V2.1 model. Supports image-to-video generation with advanced controls like negative prompts and guidance scale.",
      args_schema=GenerateVideoByKlingV2InputSchema)
async def generate_video_by_kling_v2_jaaz(
    prompt: str,
    input_images: list[str],
    config: RunnableConfig,
    tool_call_id: Annotated[str, InjectedToolCallId],
    negative_prompt: str = "",
    guidance_scale: float = 0.5,
    aspect_ratio: str = "16:9",
    duration: int = 5,
) -> str:
    """
    Generate a video using Kling V2.1 model via Jaaz service
    """
    print(f'ğŸ› ï¸ Kling Video Generation tool_call_id: {tool_call_id}')
    ctx = config.get('configurable', {})
    canvas_id = ctx.get('canvas_id', '')
    session_id = ctx.get('session_id', '')
    print(f'ğŸ› ï¸ canvas_id {canvas_id} session_id {session_id}')

    # Inject the tool call id into the context
    ctx['tool_call_id'] = tool_call_id

    try:
        # Validate input_images is provided and not empty
        if not input_images or len(input_images) == 0:
            raise ValueError(
                "input_images is required and cannot be empty. Please provide at least one image.")

        # Send start notification
        await send_video_start_notification(
            session_id,
            f"Starting Kling video generation..."
        )

        # Process input images (use first image as start_image)
        first_image = input_images[0]
        processed_image = await process_input_image(first_image)
        if not processed_image:
            raise ValueError(
                f"Failed to process input image: {first_image}. Please check if the image exists and is valid.")

        print(
            f"Using first input image as start image for Kling video generation: {first_image}")

        # Create Jaaz service and generate video
        jaaz_service = JaazService()
        result = await jaaz_service.generate_video(
            prompt=prompt,
            model="kling-v2.1-standard",
            duration=duration,
            aspect_ratio=aspect_ratio,
            input_images=[processed_image],
            negative_prompt=negative_prompt,
            guidance_scale=guidance_scale,
        )

        video_url = result.get('result_url')
        if not video_url:
            raise Exception("No video URL returned from generation")

        # Process video result (save, update canvas, notify)
        return await process_video_result(
            video_url=video_url,
            session_id=session_id,
            canvas_id=canvas_id,
            provider_name="jaaz_kling",
        )

    except Exception as e:
        print(f"Error in Kling video generation: {e}")
        raise e


# Export the tool for easy import
__all__ = ["generate_video_by_kling_v2_jaaz"]



================================================
FILE: server/tools/generate_video_by_seedance_v1_jaaz.py
================================================
from typing import Annotated
from pydantic import BaseModel, Field
from langchain_core.tools import tool, InjectedToolCallId  # type: ignore
from langchain_core.runnables import RunnableConfig
from services.jaaz_service import JaazService
from tools.video_generation.video_canvas_utils import send_video_start_notification, process_video_result
from .utils.image_utils import process_input_image


class GenerateVideoBySeedanceV1InputSchema(BaseModel):
    prompt: str = Field(
        description="Required. The prompt for video generation. Describe what you want to see in the video."
    )
    resolution: str = Field(
        default="480p",
        description="Optional. The resolution of the video. Use 480p if not explicitly specified by user. Allowed values: 480p, 1080p."
    )
    duration: int = Field(
        default=5,
        description="Optional. The duration of the video in seconds. Use 5 by default. Allowed values: 5, 10."
    )
    aspect_ratio: str = Field(
        default="16:9",
        description="Optional. The aspect ratio of the video. Allowed values: 1:1, 16:9, 4:3, 21:9"
    )
    input_images: list[str] | None = Field(
        default=None,
        description="Optional. Images to use as reference or first frame. Pass a list of image_id here, e.g. ['im_jurheut7.png']."
    )
    camera_fixed: bool = Field(
        default=True,
        description="Optional. Whether to keep the camera fixed (no camera movement)."
    )
    tool_call_id: Annotated[str, InjectedToolCallId]


@tool("generate_video_by_seedance_v1_jaaz",
      description="Generate high-quality videos using Seedance V1 model. Supports multiple providers and text-to-video/image-to-video generation.",
      args_schema=GenerateVideoBySeedanceV1InputSchema)
async def generate_video_by_seedance_v1_jaaz(
    prompt: str,
    config: RunnableConfig,
    tool_call_id: Annotated[str, InjectedToolCallId],
    resolution: str = "480p",
    duration: int = 5,
    aspect_ratio: str = "16:9",
    input_images: list[str] | None = None,
    camera_fixed: bool = True,
) -> str:
    """
    Generate a video using Seedance V1 model via Jaaz service
    """
    print(f'ğŸ› ï¸ Seedance Video Generation tool_call_id: {tool_call_id}')
    ctx = config.get('configurable', {})
    canvas_id = ctx.get('canvas_id', '')
    session_id = ctx.get('session_id', '')
    print(f'ğŸ› ï¸ canvas_id {canvas_id} session_id {session_id}')

    # Inject the tool call id into the context
    ctx['tool_call_id'] = tool_call_id

    try:
        # Send start notification
        await send_video_start_notification(
            session_id,
            f"Starting Seedance video generation..."
        )

        # Process input images if provided (only use the first one)
        processed_input_images = None
        if input_images and len(input_images) > 0:
            # Only process the first image
            first_image = input_images[0]
            processed_image = await process_input_image(first_image)
            if processed_image:
                processed_input_images = [processed_image]
                print(f"Using input image for video generation: {first_image}")
            else:
                raise ValueError(
                    f"Failed to process input image: {first_image}. Please check if the image exists and is valid.")

        # Create Jaaz service and generate video
        jaaz_service = JaazService()
        result = await jaaz_service.generate_video_by_seedance(
            prompt=prompt,
            model="seedance-1.0-pro",
            resolution=resolution,
            duration=duration,
            aspect_ratio=aspect_ratio,
            input_images=processed_input_images,
            camera_fixed=camera_fixed,
        )

        video_url = result.get('result_url')
        if not video_url:
            raise Exception("No video URL returned from generation")

        # Process video result (save, update canvas, notify)
        return await process_video_result(
            video_url=video_url,
            session_id=session_id,
            canvas_id=canvas_id,
            provider_name="jaaz_seedance",
        )

    except Exception as e:
        print(f"Error in Seedance video generation: {e}")
        raise e


# Export the tool for easy import
__all__ = ["generate_video_by_seedance_v1_jaaz"]



================================================
FILE: server/tools/generate_video_by_seedance_v1_lite_volces.py
================================================
from typing import Annotated
from pydantic import BaseModel, Field
from langchain_core.tools import tool, InjectedToolCallId  # type: ignore
from langchain_core.runnables import RunnableConfig
from .video_generation import generate_video_with_provider
from .utils.image_utils import process_input_image


class GenerateVideoBySeedanceV1LiteInputI2VSchema(BaseModel):
    prompt: str = Field(
        description="Required. The prompt for video generation. Describe what you want to see in the video."
    )
    resolution: str = Field(
        default="480p",
        description="Optional. The resolution of the video. Use 480p if not explicitly specified by user. Allowed values: 480p, 720p."
    )
    duration: int = Field(
        default=5,
        description="Optional. The duration of the video in seconds. Use 5 by default. Allowed values: 5, 10."
    )
    aspect_ratio: str = Field(
        default="16:9",
        description="Optional. The aspect ratio of the video. Allowed values: 1:1, 16:9, 4:3, 21:9"
    )
    input_images: list[str] | None = Field(
        default=None,
        description="Optional. Images to use as reference or first frame and last frame. Pass a list of image_id here **in order**, e.g. ['im_jurheut7.png']."
    )
    camera_fixed: bool = Field(
        default=True,
        description="Optional. Whether to keep the camera fixed (no camera movement)."
    )
    tool_call_id: Annotated[str, InjectedToolCallId]


class GenerateVideoBySeedanceV1LiteInputT2VSchema(BaseModel):
    prompt: str = Field(
        description="Required. The prompt for video generation. Describe what you want to see in the video."
    )
    resolution: str = Field(
        default="480p",
        description="Optional. The resolution of the video. Use 480p if not explicitly specified by user. Allowed values: 480p, 720p."
    )
    duration: int = Field(
        default=5,
        description="Optional. The duration of the video in seconds. Use 5 by default. Allowed values: 5, 10."
    )
    aspect_ratio: str = Field(
        default="16:9",
        description="Optional. The aspect ratio of the video. Allowed values: 1:1, 16:9, 4:3, 21:9"
    )
    camera_fixed: bool = Field(
        default=True,
        description="Optional. Whether to keep the camera fixed (no camera movement)."
    )
    tool_call_id: Annotated[str, InjectedToolCallId]


@tool("generate_video_by_seedance_v1_lite_i2v",
      description="Generate high-quality videos using Seedance V1 Lite model. Supports image-to-video/first-last-frame-video generation.",
      args_schema=GenerateVideoBySeedanceV1LiteInputI2VSchema)
async def generate_video_by_seedance_v1_lite_i2v(
    prompt: str,
    config: RunnableConfig,
    tool_call_id: Annotated[str, InjectedToolCallId],
    resolution: str = "480p",
    duration: int = 5,
    aspect_ratio: str = "16:9",
    input_images: list[str] | None = None,
    camera_fixed: bool = True,
) -> str:
    """
    Generate a video using Seedance V1 model via configured provider
    """
    if input_images is None:
        raise ValueError(
            "Input images must be provided for image-to-video generation.")

    # Process input images if provided (only use the first one)
    processed_input_images = None
    if len(input_images) > 1:
        # first-last-frame-to-video
        first_image = input_images[0]
        last_frame = input_images[-1]
        processed_first_image = await process_input_image(first_image)
        processed_last_frame = await process_input_image(last_frame)
        if processed_first_image and processed_last_frame:
            processed_input_images = [
                processed_first_image, processed_last_frame]
            print(
                f"Using input images for video generation: {first_image}, {last_frame}")
        else:
            raise ValueError(
                f"Failed to process input image: {first_image}. Please check if the image exists and is valid.")
    else:
        # image-to-video
        processed_image = await process_input_image(input_images[0])
        if processed_image:
            processed_input_images = [processed_image]
            print(f"Using input image for video generation: {input_images[0]}")
        else:
            raise ValueError(
                f"Failed to process input image: {input_images[0]}. Please check if the image exists and is valid.")

    return await generate_video_with_provider(
        prompt=prompt,
        resolution=resolution,
        duration=duration,
        aspect_ratio=aspect_ratio,
        model="doubao-seedance-1-0-lite-i2v-250428",
        tool_call_id=tool_call_id,
        config=config,
        input_images=processed_input_images,
        camera_fixed=camera_fixed,
    )


@tool("generate_video_by_seedance_v1_lite_t2v",
      description="Generate high-quality videos using Seedance V1 Lite model. Supports text-to-video generation.",
      args_schema=GenerateVideoBySeedanceV1LiteInputT2VSchema)
async def generate_video_by_seedance_v1_lite_t2v(
    prompt: str,
    config: RunnableConfig,
    tool_call_id: Annotated[str, InjectedToolCallId],
    resolution: str = "480p",
    duration: int = 5,
    aspect_ratio: str = "16:9",
    camera_fixed: bool = True,
) -> str:
    """
    Generate a video using Seedance V1 model via configured provider
    """

    return await generate_video_with_provider(
        prompt=prompt,
        resolution=resolution,
        duration=duration,
        aspect_ratio=aspect_ratio,
        model="doubao-seedance-1-0-lite-t2v-250428",
        tool_call_id=tool_call_id,
        config=config,
        camera_fixed=camera_fixed,
    )


# Export the tool for easy import
__all__ = ["generate_video_by_seedance_v1_lite_i2v",
           "generate_video_by_seedance_v1_lite_t2v"]



================================================
FILE: server/tools/generate_video_by_seedance_v1_pro_volces.py
================================================
from typing import Annotated
from pydantic import BaseModel, Field
from langchain_core.tools import tool, InjectedToolCallId  # type: ignore
from langchain_core.runnables import RunnableConfig
from tools.video_generation.video_generation_core import generate_video_with_provider
from .utils.image_utils import process_input_image


class GenerateVideoBySeedanceV1InputSchema(BaseModel):
    prompt: str = Field(
        description="Required. The prompt for video generation. Describe what you want to see in the video."
    )
    resolution: str = Field(
        default="480p",
        description="Optional. The resolution of the video. Use 480p if not explicitly specified by user. Allowed values: 480p, 1080p."
    )
    duration: int = Field(
        default=5,
        description="Optional. The duration of the video in seconds. Use 5 by default. Allowed values: 5, 10."
    )
    aspect_ratio: str = Field(
        default="16:9",
        description="Optional. The aspect ratio of the video. Allowed values: 1:1, 16:9, 4:3, 21:9"
    )
    input_images: list[str] | None = Field(
        default=None,
        description="Optional. Images to use as reference or first frame. Pass a list of image_id here, e.g. ['im_jurheut7.png']."
    )
    camera_fixed: bool = Field(
        default=True,
        description="Optional. Whether to keep the camera fixed (no camera movement)."
    )
    tool_call_id: Annotated[str, InjectedToolCallId]


@tool("generate_video_by_seedance_v1_pro_volces",
      description="Generate high-quality videos using Seedance V1 model. Supports multiple providers and text-to-video/image-to-video generation.",
      args_schema=GenerateVideoBySeedanceV1InputSchema)
async def generate_video_by_seedance_v1_pro_volces(
    prompt: str,
    config: RunnableConfig,
    tool_call_id: Annotated[str, InjectedToolCallId],
    resolution: str = "480p",
    duration: int = 5,
    aspect_ratio: str = "16:9",
    input_images: list[str] | None = None,
    camera_fixed: bool = True,
) -> str:
    """
    Generate a video using Seedance V1 model via configured provider
    """

    # Process input images if provided (only use the first one)
    processed_input_images = None
    if input_images and len(input_images) > 0:
        # Only process the first image
        first_image = input_images[0]
        processed_image = await process_input_image(first_image)
        if processed_image:
            processed_input_images = [processed_image]
            print(f"Using input image for video generation: {first_image}")
        else:
            raise ValueError(
                f"Failed to process input image: {first_image}. Please check if the image exists and is valid.")

    return await generate_video_with_provider(
        prompt=prompt,
        resolution=resolution,
        duration=duration,
        aspect_ratio=aspect_ratio,
        model="doubao-seedance-1-0-pro-250528",
        tool_call_id=tool_call_id,
        config=config,
        input_images=processed_input_images,
        camera_fixed=camera_fixed,
    )


# Export the tool for easy import
__all__ = ["generate_video_by_seedance_v1_pro_volces"]



================================================
FILE: server/tools/generate_video_by_veo3_fast_jaaz.py
================================================
from typing import Annotated
from pydantic import BaseModel, Field
from langchain_core.tools import tool, InjectedToolCallId  # type: ignore
from langchain_core.runnables import RunnableConfig
from services.jaaz_service import JaazService
from tools.video_generation.video_canvas_utils import send_video_start_notification, process_video_result
from services.tool_confirmation_manager import tool_confirmation_manager
from services.websocket_service import send_to_websocket
import json

class GenerateVideoByVeo3FastInputSchema(BaseModel):
    prompt: str = Field(
        description="Required. The prompt for video generation. Describe what you want to see in the video."
    )
    tool_call_id: Annotated[str, InjectedToolCallId]


@tool("generate_video_by_veo3_fast_jaaz",
      description="Generate high-quality videos using Veo3 Fast model. Fast text-to-video generation with optimized performance.",
      args_schema=GenerateVideoByVeo3FastInputSchema)
async def generate_video_by_veo3_fast_jaaz(
    prompt: str,
    config: RunnableConfig,
    tool_call_id: Annotated[str, InjectedToolCallId],
) -> str:
    """
    Generate a video using Veo3 Fast model via Jaaz service
    """
    print(f'ğŸ› ï¸ Veo3 Fast Video Generation tool_call_id: {tool_call_id}')
    ctx = config.get('configurable', {})
    canvas_id = ctx.get('canvas_id', '')
    session_id = ctx.get('session_id', '')
    print(f'ğŸ› ï¸ canvas_id {canvas_id} session_id {session_id}')

        # æ£€æŸ¥æ˜¯å¦éœ€è¦ç¡®è®¤
    arguments = {
        'prompt': prompt,
    }

    # å‘é€ç¡®è®¤è¯·æ±‚
    await send_to_websocket(session_id, {
        'type': 'tool_call_pending_confirmation',
        'id': tool_call_id,
        'name': 'generate_video_by_veo3_fast_jaaz',
        'arguments': json.dumps(arguments)
    })

    # ç­‰å¾…ç¡®è®¤
    confirmed = await tool_confirmation_manager.request_confirmation(
        tool_call_id, session_id, 'generate_video_by_veo3_fast_jaaz', arguments
    )

    if not confirmed:
        return "Video generation cancelled by user."

    # Inject the tool call id into the context
    ctx['tool_call_id'] = tool_call_id

    try:
        # Send start notification
        await send_video_start_notification(
            session_id,
            f"Starting Veo3 Fast video generation..."
        )

        # Create Jaaz service and generate video
        jaaz_service = JaazService()
        result = await jaaz_service.generate_video(
            prompt=prompt,
            model="veo3-fast",
        )

        video_url = result.get('result_url')
        if not video_url:
            raise Exception("No video URL returned from generation")

        # Process video result (save, update canvas, notify)
        return await process_video_result(
            video_url=video_url,
            session_id=session_id,
            canvas_id=canvas_id,
            provider_name="jaaz_veo3_fast",
        )

    except Exception as e:
        print(f"Error in Veo3 Fast video generation: {e}")
        raise e


# Export the tool for easy import
__all__ = ["generate_video_by_veo3_fast_jaaz"]



================================================
FILE: server/tools/video_generation_utils.py
================================================
# from engineio import payload
from utils.http_client import HttpClient

import aiofiles
import io
import os
import base64
from PIL import Image

from nanoid import generate
from mimetypes import guess_type
# import httpx
import mimetypes
from pymediainfo import MediaInfo
from PIL import Image


from services.config_service import FILES_DIR


def generate_video_file_id():
    return "vi_" + generate(size=8)


async def get_video_info_and_save(
    url: str, file_path_without_extension: str
) -> tuple[str, int, int, str]:
    # Fetch the video asynchronously
    async with HttpClient.create_aiohttp() as session:
        async with session.get(url) as response:
            video_content = await response.read()

    # Save to temporary mp4 file first
    temp_path = f"{file_path_without_extension}.mp4"
    async with aiofiles.open(temp_path, "wb") as out_file:
        await out_file.write(video_content)
    print("ğŸ¥ Video saved to", temp_path)

    try:
        media_info = MediaInfo.parse(temp_path)
        for track in media_info.tracks:  # type: ignore
            if track.track_type == "Video":
                width = track.width
                height = track.height
                print(f"Width: {width}, Height: {height}")

        extension = "mp4"  # é»˜è®¤ä½¿ç”¨ mp4ï¼Œå®é™…æƒ…å†µå¯ä»¥æ ¹æ® codec_name çµæ´»åˆ¤æ–­

        # Get mime type
        mime_type = mimetypes.types_map.get(".mp4", "video/mp4")

        print(
            f"ğŸ¥ Video info - width: {width}, height: {height}, mime_type: {mime_type}, extension: {extension}"
        )

        return mime_type, width, height, extension
    except Exception as e:
        print(f"Error probing video file {temp_path}: {str(e)}")
        raise e


def get_image_base64(image_name: str):
    # Process image
    image_path = os.path.join(FILES_DIR, f"{image_name}")
    image = Image.open(image_path)

    # å¯çˆ±çš„è±†åŒ…ï¼Œé²æ£’æ€§å¤ªæ‹‰äº†ï¼Œæ‹‰çš„æƒ³éª‚äºº(å›¾ç‰‡æ”¯æ”¯æŒ0.4-2.5æ¯”ä¾‹çš„)
    # Kawaii Doubao video model has a fxxking bad robustness,
    # it can only handle images with aspect ratio between 0.4 and 2.5.

    width, height = image.size
    ratio = width / height
    if ratio > 2.5 or ratio < 0.4:
        # å®½é«˜æ¯”å¤§äº2.5æˆ–è€…å°äº0.4çš„å›¾ç‰‡ï¼Œç°åœ¨åªèƒ½æš´åŠ›è£æ‰
        if ratio < 1:
            # ç«–ç‰ˆå›¾ç‰‡
            new_height = int(width * 2.4)
            new_width = width
            image = image.resize(  # type:ignore
                (new_width, new_height), Image.Resampling.LANCZOS
            )
        elif ratio > 1:
            new_width = int(height * 2.4)
            new_height = height
            image = image.resize(
                (new_width, new_height), Image.Resampling.LANCZOS
            )
    else:
        new_width, new_height = image.size

    # è®¡ç®—ç¼©æ”¾å› å­ï¼Œç¡®ä¿ç±»å‹ä¸ºfloat
    scale_factor: float = float(
        (float(1048576) / float(new_width * new_height)) ** 0.5
    )

    preview_image_width = int(new_width * scale_factor)
    preview_image_height = int(new_height * scale_factor)

    img = image.resize(
        (preview_image_width, preview_image_height), Image.Resampling.LANCZOS
    )
    img_byte_arr = io.BytesIO()
    img.save(img_byte_arr, format="PNG")

    b64 = base64.b64encode(img_byte_arr.getvalue()).decode("utf-8")
    mime_type, _ = guess_type(image_path)
    if not mime_type:
        mime_type = "image/png"
    return f"data:{mime_type};base64,{b64}"



================================================
FILE: server/tools/write_plan.py
================================================
from asyncio import sleep
import asyncio
from pydantic import BaseModel, Field
from typing import Optional, Annotated
from langchain_core.tools import tool
from langchain_core.runnables import RunnableConfig
from langchain_core.tools import InjectedToolCallId
from typing import List

class Step(BaseModel):
    title: str
    description: Optional[str] = Field(
        default="",
        description="Description of the step",
    )

class StepsInput(BaseModel):
    steps: List[Step] = Field(
        default_factory=list,
        description="The list of steps, in the order of execution",
    )
    tool_call_id: Annotated[str, InjectedToolCallId]


@tool("write_plan", 
description="""
Write a plan to complete the current task in the order of execution, including the steps and the description of each step. 
The plan should be friendly to showcase to the user.
""",
args_schema=StepsInput)
def write_plan_tool(
    steps: List[Step],
    config: RunnableConfig,
    tool_call_id: Annotated[str, InjectedToolCallId],
) -> str:
    print("write_plan_tool")
    return "<hide_in_user_ui> Plan made. Now you can start executing the plan, or handoff the task to the suitable agent who specializes in the steps of the plan.</hide_from_user>"


================================================
FILE: server/tools/image_providers/__init__.py
================================================
# Image generation providers



================================================
FILE: server/tools/image_providers/comfyui_provider.py
================================================
import os
import random
import json
import sys
import copy
import traceback
from typing import Optional, Any
from pydantic import BaseModel
from .image_base_provider import ImageProviderBase
from ..utils.image_utils import get_image_info_and_save, generate_image_id
from services.config_service import FILES_DIR, config_service
from routers.comfyui_execution import execute


class ComfyUIResponse(BaseModel):
    """ComfyUI API response format"""
    outputs: list[str]
    status: str


def get_asset_path(filename: str) -> str:
    """
    To get the correct path for pyinstaller bundled application
    """
    if getattr(sys, "frozen", False):
        # If the application is run as a bundle, the path is relative to the executable
        base_path = getattr(sys, "_MEIPASS", "")
    else:
        # If the application is run in a normal Python environment
        base_path = os.path.dirname(
            os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
        )

    return os.path.join(str(base_path), "asset", filename)


class ComfyUIProvider(ImageProviderBase, provider_name="comfyui"):
    """ComfyUI image generation provider implementation"""

    def __init__(self):
        # Load workflows
        asset_dir = get_asset_path("flux_comfy_workflow.json")
        basic_comfy_t2i_workflow = get_asset_path(
            "default_comfy_t2i_workflow.json")

        self.flux_comfy_workflow = None
        self.basic_comfy_t2i_workflow = None

        try:
            self.flux_comfy_workflow = json.load(open(asset_dir, "r"))
            self.basic_comfy_t2i_workflow = json.load(
                open(basic_comfy_t2i_workflow, "r")
            )
        except Exception:
            traceback.print_exc()

    def _calculate_dimensions(self, aspect_ratio: str, model: str) -> tuple[int, int]:
        """Calculate width and height based on aspect ratio and model"""
        if "flux" in model:
            # Flux generate images around 1M pixel (1024x1024)
            pixel_count = 1024**2
        else:
            # sd 1.5, basic is 512, but accept 768 for better quality
            pixel_count = 768**2

        w_ratio, h_ratio = map(int, aspect_ratio.split(":"))
        factor = (pixel_count / (w_ratio * h_ratio)) ** 0.5

        width = int((factor * w_ratio) / 64) * 64
        height = int((factor * h_ratio) / 64) * 64

        return width, height

    def _build_workflow(self, prompt: str, model: str, width: int, height: int) -> dict[str, Any]:
        """Build workflow based on model type"""
        if "flux" in model:
            if not self.flux_comfy_workflow:
                raise FileNotFoundError("Flux workflow json not found")

            workflow = copy.deepcopy(self.flux_comfy_workflow)
            workflow["6"]["inputs"]["text"] = prompt
            workflow["30"]["inputs"]["ckpt_name"] = model
            workflow["27"]["inputs"]["width"] = width
            workflow["27"]["inputs"]["height"] = height
            workflow["31"]["inputs"]["seed"] = random.randint(1, 2**32)
        else:
            if not self.basic_comfy_t2i_workflow:
                raise FileNotFoundError(
                    "Basic ComfyUI workflow json not found")

            workflow = copy.deepcopy(self.basic_comfy_t2i_workflow)
            workflow["6"]["inputs"]["text"] = prompt
            workflow["4"]["inputs"]["ckpt_name"] = model
            workflow["5"]["inputs"]["width"] = width
            workflow["5"]["inputs"]["height"] = height
            workflow["3"]["inputs"]["seed"] = random.randint(1, 2**32)

        return workflow

    async def generate(
        self,
        prompt: str,
        model: str,
        aspect_ratio: str = "1:1",
        input_images: Optional[list[str]] = None,
        **kwargs: Any
    ) -> tuple[str, int, int, str]:
        """
        Generate image using ComfyUI API service

        Args:
            prompt: Image generation prompt
            model: Model name to use for generation
            aspect_ratio: Image aspect ratio (1:1, 16:9, 4:3, 3:4, 9:16)
            input_images: Optional input images for reference or editing
            **kwargs: Additional provider-specific parameters

        Returns:
            tuple[str, int, int, str]: (mime_type, width, height, filename)
        """
        try:
            # Get context from kwargs
            ctx = kwargs.get("ctx", {})

            api_url = str(
                config_service.app_config.get("comfyui", {}).get("url", "")
            ).rstrip("/")

            # Calculate dimensions
            width, height = self._calculate_dimensions(aspect_ratio, model)

            # Build workflow
            workflow = self._build_workflow(prompt, model, width, height)

            # Execute workflow
            execution = await execute(workflow, api_url, ctx=ctx)
            print("ğŸ¦„image execution outputs", execution.outputs)
            url = execution.outputs[0]

            # Save the image
            image_id = generate_image_id()
            mime_type, width, height, extension = await get_image_info_and_save(
                url, os.path.join(FILES_DIR, f"{image_id}")
            )
            filename = f"{image_id}.{extension}"
            return mime_type, width, height, filename

        except Exception as e:
            print('Error generating image with ComfyUI:', e)
            traceback.print_exc()
            raise e


class ComfyUIWorkflowProvider(ImageProviderBase, provider_name="comfyui_workflow"):
    """ComfyUI workflow runner provider implementation"""

    def __init__(self, workflow_dict: dict[str, Any], base_url: str):
        self.workflow = workflow_dict
        self.base_url = base_url

    async def generate(
        self,
        prompt: str,
        model: str,
        aspect_ratio: str = "1:1",
        input_images: Optional[list[str]] = None,
        **kwargs: Any
    ) -> tuple[str, int, int, str]:
        """
        Run a workflow by calling official ComfyUI Client

        Args:
            prompt: Image generation prompt (not used in workflow mode)
            model: Model name (not used in workflow mode)
            aspect_ratio: Image aspect ratio (not used in workflow mode)
            input_images: Optional input images (not used in workflow mode)
            **kwargs: Additional provider-specific parameters

        Returns:
            tuple[str, int, int, str]: (mime_type, width, height, filename)
        """
        try:
            # Get context from kwargs
            ctx = kwargs.get("ctx", {})

            execution = await execute(
                self.workflow, self.base_url, local_paths=True, ctx=ctx
            )
            print("ğŸ¦„workflow execution outputs", execution.outputs)

            url = execution.outputs[0]

            # Save the image
            image_id = generate_image_id()
            mime_type, width, height, extension = await get_image_info_and_save(
                url, os.path.join(FILES_DIR, f"{image_id}")
            )

            filename = f"{image_id}.{extension}"
            return mime_type, width, height, filename

        except Exception as e:
            print('Error generating image with ComfyUI Workflow:', e)
            traceback.print_exc()
            raise e



================================================
FILE: server/tools/image_providers/image_base_provider.py
================================================
from abc import ABC, abstractmethod
from typing import Optional, Any, Tuple


class ImageProviderBase(ABC):
    @abstractmethod
    async def generate(
        self,
        prompt: str,
        model: str,
        aspect_ratio: str = "1:1",
        input_images: Optional[list[str]] = None,
        metadata: Optional[dict[str, Any]] = None,
        **kwargs: Any
    ) -> Tuple[str, int, int, str]:
        """
        Generate image and return image details

        Args:
            prompt: Image generation prompt
            model: Model name to use for generation
            aspect_ratio: Image aspect ratio (1:1, 16:9, 4:3, 3:4, 9:16)
            input_images: Optional input images for reference or editing
            metadata: Optional metadata to be saved in PNG info
            **kwargs: Additional provider-specific parameters

        Returns:
            Tuple[str, int, int, str]: (mime_type, width, height, filename)
        """
        pass


================================================
FILE: server/tools/image_providers/jaaz_provider.py
================================================
import os
import traceback
import asyncio
from typing import Optional, List, Any, Dict
from pydantic import BaseModel
from openai.types import Image
from .image_base_provider import ImageProviderBase
from ..utils.image_utils import get_image_info_and_save, generate_image_id
from services.config_service import FILES_DIR
from utils.http_client import HttpClient
from services.config_service import config_service


class JaazImagesResponse(BaseModel):
    """Image response class, Jaaz API return format, consistent with OpenAI"""
    created: int
    """The Unix timestamp (in seconds) of when the image was created."""

    data: Optional[List[Image]] = None
    """The list of generated images."""


class TaskSearchResponse(BaseModel):
    """Task search response model"""
    success: bool
    data: Dict[str, Any]


class JaazImageProvider(ImageProviderBase):
    """Jaaz Cloud image generation provider implementation"""

    def _build_url(self) -> str:
        """Build request URL"""
        config = config_service.app_config.get('jaaz', {})
        api_url = str(config.get("url", "")).rstrip("/")
        api_token = str(config.get("api_key", ""))

        if not api_url:
            raise ValueError("Jaaz API URL is not configured")
        if not api_token:
            raise ValueError("Jaaz API token is not configured")
        if api_url.rstrip('/').endswith('/api/v1'):
            return f"{api_url.rstrip('/')}/image/generations"
        else:
            return f"{api_url.rstrip('/')}/api/v1/image/generations"

    def _build_search_url(self) -> str:
        """Build task search URL"""
        config = config_service.app_config.get('jaaz', {})
        api_url = str(config.get("url", "")).rstrip("/")

        if api_url.rstrip('/').endswith('/api/v1'):
            return f"{api_url.rstrip('/')}/task/search"
        else:
            return f"{api_url.rstrip('/')}/api/v1/task/search"

    def _build_headers(self) -> Dict[str, str]:
        config = config_service.app_config.get('jaaz', {})
        api_token = str(config.get("api_key", ""))

        """Build request headers"""
        return {
            "Authorization": f"Bearer {api_token}",
            "Content-Type": "application/json"
        }

    async def _search_cloud_task(self, prompt: str) -> Optional[Dict[str, Any]]:
        """
        Search for existing cloud task

        Args:
            prompt: The generation prompt

        Returns:
            Task data if found and succeeded, None otherwise
        """
        try:
            url = self._build_search_url()
            headers = self._build_headers()

            search_data = {
                "prompt": prompt,
                "type": 'image',
            }

            async with HttpClient.create_aiohttp() as session:
                async with session.post(url, headers=headers, json=search_data) as response:
                    if response.status != 200:
                        print(f'ğŸ¦„ Task search failed: HTTP {response.status}')
                        return None

                    json_data = await response.json()
                    if json_data.get('success') and json_data.get('data', {}).get('found'):
                        task = json_data['data']['task']
                        print(
                            f'ğŸ¦„ Found cloud task: {task.get("id")}, status: {task.get("status")}')
                        return task

                    return None

        except Exception as e:
            print(f'ğŸ¦„ Error searching cloud task: {e}')
            return None

    async def _wait_for_task_completion(self, prompt: str, max_wait_time: int = 300) -> Optional[Dict[str, Any]]:
        """
        Wait for cloud task to complete

        Args:
            prompt: The generation prompt
            model: The model used
            max_wait_time: Maximum wait time in seconds

        Returns:
            Task data if succeeded, None otherwise
        """
        start_time = asyncio.get_event_loop().time()
        no_task_retry_count = 0
        max_no_task_retries = 5

        while True:
            task = await self._search_cloud_task(prompt)

            if not task:
                no_task_retry_count += 1
                if no_task_retry_count <= max_no_task_retries:
                    print(
                        f'ğŸ¦„ No cloud task found, retrying ({no_task_retry_count}/{max_no_task_retries})...')
                    await asyncio.sleep(3)
                    continue
                else:
                    print('ğŸ¦„ No cloud task found after 5 retries')
                    return None

            # Reset retry count when task is found
            no_task_retry_count = 0

            status = task.get('status')
            print(f'ğŸ¦„ Cloud task status: {status}')

            if status == 'succeeded':
                print('ğŸ¦„ Cloud task completed successfully')
                return task
            elif status == 'failed':
                print('ğŸ¦„ Cloud task failed')
                return None
            elif status == 'processing':
                # Check if we've exceeded max wait time
                elapsed = asyncio.get_event_loop().time() - start_time
                if elapsed > max_wait_time:
                    print(
                        f'ğŸ¦„ Timeout waiting for cloud task completion ({max_wait_time}s)')
                    return None

                print('ğŸ¦„ Cloud task still processing, waiting 2 seconds...')
                await asyncio.sleep(2)
            else:
                print(f'ğŸ¦„ Unknown cloud task status: {status}')
                return None

    async def _process_cloud_task_result(self, task: Dict[str, Any], metadata: Optional[Dict[str, Any]] = None) -> tuple[str, int, int, str]:
        """
        Process cloud task result and download image

        Args:
            task: Task data from cloud
            metadata: Optional metadata

        Returns:
            tuple[str, int, int, str]: (mime_type, width, height, filename)
        """
        result_url = task.get('result_url')
        if not result_url:
            raise Exception('No result_url found in cloud task')

        print(f'ğŸ¦„ Using cloud task result: {result_url}')

        # Download and save the image from cloud result
        image_id = generate_image_id()
        mime_type, width, height, extension = await get_image_info_and_save(
            str(result_url),
            os.path.join(FILES_DIR, f'{image_id}'),
            metadata=metadata
        )

        filename = f'{image_id}.{extension}'
        return mime_type, width, height, filename

    async def _make_request(self, url: str, headers: Dict[str, str], data: Dict[str, Any]) -> JaazImagesResponse:
        """
        Send HTTP request and handle response

        Returns:
            JaazImagesResponse: Jaaz compatible image response object
        """
        async with HttpClient.create_aiohttp() as session:
            print(
                f'ğŸ¦„ Jaaz API request: {url}, model: {data["model"]}, prompt: {data["prompt"]}')

            async with session.post(url, headers=headers, json=data) as response:
                if response.status != 200:
                    error_text = await response.text()
                    error_msg = f"HTTP {response.status}: {error_text}"
                    print(f'ğŸ¦„ Jaaz API error: {error_msg}')
                    raise Exception(f'Image generation failed: {error_msg}')

                # Parse JSON data
                json_data = await response.json()
                print('ğŸ¦„ Jaaz API response', json_data)

                return JaazImagesResponse(**json_data)

    async def _process_response(
        self,
        res: JaazImagesResponse,
        error_prefix: str = "Jaaz",
        metadata: Optional[Dict[str, Any]] = None
    ) -> tuple[str, int, int, str]:
        """
        Process ImagesResponse and save image

        Args:
            res: OpenAI ImagesResponse object
            error_prefix: Error message prefix

        Returns:
            tuple[str, int, int, str]: (mime_type, width, height, filename)
        """
        if res.data and len(res.data) > 0:
            image_data = res.data[0]
            if hasattr(image_data, 'url') and image_data.url:
                image_url = image_data.url
                image_id = generate_image_id()
                mime_type, width, height, extension = await get_image_info_and_save(
                    image_url,
                    os.path.join(FILES_DIR, f'{image_id}'),
                    metadata=metadata
                )

                filename = f'{image_id}.{extension}'
                return mime_type, width, height, filename

        # If no valid image data found
        raise Exception(
            f'{error_prefix} image generation failed: No valid image data in response')

    async def generate(
        self,
        prompt: str,
        model: str,
        aspect_ratio: str = "1:1",
        input_images: Optional[list[str]] = None,
        metadata: Optional[Dict[str, Any]] = None,
        **kwargs: Any
    ) -> tuple[str, int, int, str]:
        """
        Generate image using Jaaz API service
        Supports both Replicate format and OpenAI format models

        Returns:
            tuple[str, int, int, str]: (mime_type, width, height, filename)
        """
        # Check if it's an OpenAI model
        if model.startswith('openai/'):
            return await self._generate_openai_image(
                prompt=prompt,
                model=model,
                input_images=input_images,
                aspect_ratio=aspect_ratio,
                metadata=metadata,
                **kwargs
            )

        # Replicate compatible logic
        return await self._generate_replicate_image(
            prompt=prompt,
            model=model,
            aspect_ratio=aspect_ratio,
            input_images=input_images,
            metadata=metadata,
            **kwargs
        )

    async def _generate_replicate_image(
        self,
        prompt: str,
        model: str,
        aspect_ratio: str = "1:1",
        input_images: Optional[list[str]] = None,
        metadata: Optional[Dict[str, Any]] = None,
        **kwargs: Any
    ) -> tuple[str, int, int, str]:
        """Generate Replicate format image"""
        try:
            url = self._build_url()
            headers = self._build_headers()

            # Build request data, consistent with Replicate format
            data = {
                "prompt": prompt,
                "model": model,
                "aspect_ratio": aspect_ratio,
            }

            # Add input images if provided
            if input_images:
                # For Replicate format, we take the first image as input_image
                data['input_image'] = input_images[0]
                if len(input_images) > 1:
                    print(
                        "Warning: Replicate format only supports single image input. Using first image.")

            res = await self._make_request(url, headers, data)
            return await self._process_response(res, "Jaaz", metadata)

        except Exception as e:
            print(f'Error generating image with Jaaz: {e}')
            traceback.print_exc()

            # Always attempt cloud task fallback on any error
            print('ğŸ¦„ Attempting cloud task fallback...')
            try:
                task = await self._wait_for_task_completion(prompt)
                if task:
                    print('ğŸ¦„ Successfully recovered using cloud task')
                    return await self._process_cloud_task_result(task, metadata)
                else:
                    print('ğŸ¦„ No cloud task available for recovery')
            except Exception as fallback_error:
                print(f'ğŸ¦„ Cloud task fallback failed: {fallback_error}')

            # If fallback fails, raise original error
            raise e

    async def _generate_openai_image(
        self,
        prompt: str,
        model: str,
        input_images: Optional[list[str]] = None,
        aspect_ratio: str = "1:1",
        metadata: Optional[Dict[str, Any]] = None,
        **kwargs: Any
    ) -> tuple[str, int, int, str]:
        """
        Generate image using Jaaz API service calling OpenAI model
        Compatible with OpenAI image generation API

        Returns:
            tuple[str, int, int, str]: (mime_type, width, height, filename)
        """
        try:
            url = self._build_url()
            headers = self._build_headers()

            # Build request data
            enhanced_prompt = f"{prompt} Aspect ratio: {aspect_ratio}"

            data = {
                "model": model,
                "prompt": enhanced_prompt,
                "n": kwargs.get("num_images", 1),
                "size": 'auto',
                "mask": None,  # Add mask here if needed
            }

            # Add input images if provided
            if input_images:
                data["input_images"] = input_images
                print(f"Using {len(input_images)} input images for generation")

            res = await self._make_request(url, headers, data)
            return await self._process_response(res, "Jaaz OpenAI", metadata)

        except Exception as e:
            print(f'Error generating image with Jaaz OpenAI: {e}')
            traceback.print_exc()

            # Always attempt cloud task fallback on any error
            print('ğŸ¦„ Attempting cloud task fallback...')
            try:
                # For OpenAI models, use the original prompt
                enhanced_prompt = f"{prompt} Aspect ratio: {aspect_ratio}"
                task = await self._wait_for_task_completion(enhanced_prompt)
                if task:
                    print('ğŸ¦„ Successfully recovered using cloud task')
                    return await self._process_cloud_task_result(task, metadata)
                else:
                    print('ğŸ¦„ No cloud task available for recovery')
            except Exception as fallback_error:
                print(f'ğŸ¦„ Cloud task fallback failed: {fallback_error}')

            # If fallback fails, raise original error
            raise e



================================================
FILE: server/tools/image_providers/openai_provider.py
================================================
import os
import traceback
from typing import Optional, Any
from openai import OpenAI
from .image_base_provider import ImageProviderBase
from ..utils.image_utils import get_image_info_and_save, generate_image_id
from services.config_service import FILES_DIR
from services.config_service import config_service


class OpenAIImageProvider(ImageProviderBase):
    """OpenAI image generation provider implementation"""

    async def generate(
        self,
        prompt: str,
        model: str,
        aspect_ratio: str = "1:1",
        input_images: Optional[list[str]] = None,
        **kwargs: Any
    ) -> tuple[str, int, int, str]:
        """
        Generate image using OpenAI API

        Returns:
            tuple[str, int, int, str]: (mime_type, width, height, filename)
        """

        config = config_service.app_config.get('openai', {})
        self.api_key = str(config.get("api_key", ""))
        self.base_url = str(config.get("url", ""))  # å¯é€‰

        if not self.api_key:
            raise ValueError("OpenAI API key is not configured")

        # Create OpenAI client
        self.client = OpenAI(api_key=self.api_key,
                             base_url=self.base_url or None)
        try:
            # Remove openai/ prefix if present
            model = model.replace('openai/', '')

            # Determine if this is an edit operation or generation
            if input_images and len(input_images) > 0:
                # Image editing mode
                input_image_path = input_images[0]
                # For OpenAI, input_image should be the file path
                full_path = os.path.join(FILES_DIR, input_image_path)

                with open(full_path, 'rb') as image_file:
                    result = self.client.images.edit(
                        model=model,
                        image=image_file,
                        prompt=prompt,
                        n=kwargs.get("num_images", 1)
                    )
            else:
                # Image generation mode
                # Map aspect ratio to size
                size_map = {
                    "1:1": "1024x1024",
                    "16:9": "1792x1024",
                    "9:16": "1024x1792",
                    "4:3": "1024x768",
                    "3:4": "768x1024"
                }
                size = size_map.get(aspect_ratio, "1024x1024")

                result = self.client.images.generate(
                    model=model,
                    prompt=prompt,
                    n=kwargs.get("num_images", 1),
                    size=size,
                )

            # Process the result
            if not result.data or len(result.data) == 0:
                raise Exception("No image data returned from OpenAI API")

            image_data = result.data[0]

            # Handle different response formats
            if hasattr(image_data, 'b64_json') and image_data.b64_json:
                # Base64 response
                image_b64 = image_data.b64_json
                image_id = generate_image_id()
                mime_type, width, height, extension = await get_image_info_and_save(
                    image_b64, os.path.join(FILES_DIR, f'{image_id}'), is_b64=True
                )
            elif hasattr(image_data, 'url') and image_data.url:
                # URL response
                image_url = image_data.url
                image_id = generate_image_id()
                mime_type, width, height, extension = await get_image_info_and_save(
                    image_url, os.path.join(FILES_DIR, f'{image_id}')
                )
            else:
                raise Exception("Invalid response format from OpenAI API")

            # Ensure mime_type is not None
            if mime_type is None:
                raise Exception('Failed to determine image MIME type')

            filename = f'{image_id}.{extension}'
            return mime_type, width, height, filename

        except Exception as e:
            print('Error generating image with OpenAI:', e)
            traceback.print_exc()
            raise e



================================================
FILE: server/tools/image_providers/replicate_provider.py
================================================
import os
import traceback
from typing import Optional, Any
from .image_base_provider import ImageProviderBase
from ..utils.image_utils import get_image_info_and_save, generate_image_id
from services.config_service import FILES_DIR
from utils.http_client import HttpClient
from services.config_service import config_service


class ReplicateImageProvider(ImageProviderBase):
    """Replicate image generation provider implementation"""

    def _build_url(self, model: str) -> str:
        """Build request URL for Replicate API"""
        return f"https://api.replicate.com/v1/models/{model}/predictions"

    def _build_headers(self) -> dict[str, str]:
        """Build request headers"""
        config = config_service.app_config.get('replicate', {})
        api_key = config.get("api_key", "")

        if not api_key:
            raise ValueError("Replicate API key is not configured")
        return {
            "Authorization": f"Bearer {api_key}",
            "Content-Type": "application/json",
            "Prefer": "wait"
        }

    async def _make_request(self, url: str, headers: dict[str, str], data: dict[str, Any]) -> dict[str, Any]:
        """
        Send HTTP request and handle response

        Returns:
            dict[str, Any]: Response data from Replicate API
        """
        async with HttpClient.create_aiohttp() as session:
            print(
                f'ğŸ¦„ Replicate API request: {url}, model: {data["input"]["prompt"]}')
            async with session.post(url, headers=headers, json=data) as response:
                # Parse JSON data
                json_data = await response.json()
                print('ğŸ¦„ Replicate API response', json_data)

                return json_data

    async def _process_response(self, res: dict[str, Any]) -> tuple[str, int, int, str]:
        """
        Process Replicate API response and save image

        Args:
            res: Response data from Replicate API

        Returns:
            tuple[str, int, int, str]: (mime_type, width, height, filename)
        """
        output = res.get('output', '')
        if output == '':
            if res.get('detail', '') != '':
                raise Exception(
                    f'Replicate image generation failed: {res.get("detail", "")}')
            else:
                raise Exception(
                    'Replicate image generation failed: no output url found')

        image_id = generate_image_id()
        print('ğŸ¦„ image generation image_id', image_id)

        # Get image dimensions and save
        mime_type, width, height, extension = await get_image_info_and_save(
            output, os.path.join(FILES_DIR, f'{image_id}')
        )

        filename = f'{image_id}.{extension}'
        return mime_type, width, height, filename

    async def generate(
        self,
        prompt: str,
        model: str,
        aspect_ratio: str = "1:1",
        input_images: Optional[list[str]] = None,
        **kwargs: Any
    ) -> tuple[str, int, int, str]:
        """
        Generate image using Replicate API

        Args:
            prompt: Image generation prompt
            model: Model name to use for generation
            aspect_ratio: Image aspect ratio (1:1, 16:9, 4:3, 3:4, 9:16)
            input_images: Optional input images for reference or editing
            **kwargs: Additional provider-specific parameters

        Returns:
            tuple[str, int, int, str]: (mime_type, width, height, filename)
        """
        try:
            url = self._build_url(model)
            headers = self._build_headers()

            # Build request data
            data = {
                "input": {
                    "prompt": prompt,
                    "aspect_ratio": aspect_ratio,
                }
            }

            if input_images:
                # For Replicate format, we take the first image as input_image
                data['input']['input_image'] = input_images[0]
                if len(input_images) > 1:
                    print(
                        "Warning: Replicate format only supports single image input. Using first image.")

            # Make request
            res = await self._make_request(url, headers, data)

            # Process response and return result
            return await self._process_response(res)

        except Exception as e:
            print('Error generating image with Replicate:', e)
            traceback.print_exc()
            raise e



================================================
FILE: server/tools/image_providers/volces_provider.py
================================================
import os
import random
import traceback
from types import NoneType
from typing import Optional, List, Any
from pydantic import BaseModel
from openai.types import Image
from openai import OpenAI, OpenAIError
from .image_base_provider import ImageProviderBase
from ..utils.image_utils import get_image_info_and_save, generate_image_id
from tools.video_generation_utils import get_image_base64
from services.config_service import FILES_DIR, config_service
from utils.http_client import HttpClient


class VolcesImagesResponse(BaseModel):
    """Image response class, Volces API return format, consistent with OpenAI"""

    created: int
    """The Unix timestamp (in seconds) of when the image was created."""

    data: Optional[List[Image]] = None
    """The list of generated images."""


class VolcesProvider(ImageProviderBase):
    """Volces image generation provider implementation"""

    def _create_client(self) -> OpenAI:
        """Create OpenAI client for Volces API"""
        config = config_service.app_config.get("volces", {})
        api_key = str(config.get("api_key", ""))
        api_url = str(config.get("url", ""))

        if not api_key:
            raise ValueError("Volces API key is not configured")
        if not api_url:
            raise ValueError("Volces API URL is not configured")

        return OpenAI(api_key=api_key, base_url=api_url)

    def _calculate_dimensions(self, aspect_ratio: str) -> tuple[int, int]:
        """Calculate width and height based on aspect ratio"""
        w_ratio, h_ratio = map(int, aspect_ratio.split(":"))
        factor = (1024**2 / (w_ratio * h_ratio)) ** 0.5

        width = int((factor * w_ratio) / 64) * 64
        height = int((factor * h_ratio) / 64) * 64

        return width, height

    async def _process_response(
        self, result: Any, error_prefix: str = "Volces"
    ) -> tuple[str, int, int, str]:
        """
        Process OpenAI response and save image

        Args:
            result: OpenAI response object
            error_prefix: Error message prefix

        Returns:
            tuple[str, int, int, str]: (mime_type, width, height, filename)
        """
        if hasattr(result, "data"):
            if len(result.data) > 0:
                image_data = result.data[0]
                if hasattr(image_data, "url") and image_data.url:
                    image_url = image_data.url
        elif isinstance(result, str):
            image_url = result
        # If no valid image data found
        else:
            raise Exception(
                f"{error_prefix} image generation failed: No valid image data in response"
            )
        image_id = generate_image_id()
        mime_type, width, height, extension = await get_image_info_and_save(
            image_url, os.path.join(FILES_DIR, f"{image_id}"), is_b64=False
        )

        filename = f"{image_id}.{extension}"
        return mime_type, width, height, filename

    async def generate(
        self,
        prompt: str,
        model: str,
        aspect_ratio: str = "1:1",
        input_images: list[str] | NoneType = None,
        **kwargs: Any,
    ) -> tuple[str, int, int, str]:
        """
        Generate image using Volces API service

        Args:
            prompt: Image generation prompt
            model: Model name to use for generation
            aspect_ratio: Image aspect ratio (1:1, 16:9, 4:3, 3:4, 9:16)
            input_images: Optional input images for reference or editing
            **kwargs: Additional provider-specific parameters

        Returns:
            tuple[str, int, int, str]: (mime_type, width, height, filename)
        """
        try:
            # Remove provider prefix from model name
            model = model.replace("volces/", "")

            client = self._create_client()
            width, height = self._calculate_dimensions(aspect_ratio)

            if input_images:
                # input_image should be the file path
                # volces does not support openai client to edit image. But no pool required QVQ
                config = config_service.app_config.get("volces", {})
                api_url = str(
                    config.get("url", "https://ark.cn-beijing.volces.com/api/v3")
                )
                headers = {
                    "Content-Type": "application/json",
                    "Authorization": f"Bearer {str(config.get('api_key', ''))}",
                }

                payload = {
                    "model": model,
                    "prompt": prompt,
                    "image": input_images[0],
                    "response_format": "url",
                    "size": "adaptive",
                    "seed": random.randint(1, 9999),
                    "guidance_scale": 5.5,
                    "watermark": False,
                }

                url = str(api_url).strip("/") + "/images/generations"

                async with HttpClient.create_aiohttp() as session:
                    async with session.post(
                        url, headers=headers, json=payload
                    ) as response:
                        if response.status != 200:
                            try:
                                error_data = await response.json()
                                error_message = error_data.get(
                                    "error", f"HTTP {response.status}"
                                )
                            except Exception:
                                error_message = f"HTTP {response.status}"
                            raise Exception(
                                f"Volces task creation failed: {error_message}"
                            )

                        result_dict = await response.json()
                        result = result_dict["data"][0]["url"]
                        print(f"ğŸ‘‡SeedEdit Url: {result}")

            else:
                result = client.images.generate(
                    model=model,
                    prompt=prompt,
                    size=kwargs.get("size", f"{width}x{height}"),
                    extra_body={"watermark": False},
                )

            return await self._process_response(result, "Volces")

        except OpenAIError as e:
            print("Error generating image with Volces:", e)
            traceback.print_exc()
            raise e
        except Exception as e:
            print("Error generating image with Volces:", e)
            traceback.print_exc()
            raise e



================================================
FILE: server/tools/image_providers/wavespeed_provider.py
================================================
import os
import asyncio
import traceback
from typing import Optional, Any
from pydantic import BaseModel
from .image_base_provider import ImageProviderBase
from ..utils.image_utils import get_image_info_and_save, generate_image_id
from services.config_service import FILES_DIR, config_service
from utils.http_client import HttpClient


class WavespeedResponse(BaseModel):
    """WaveSpeed API response format"""
    code: int
    data: dict[str, Any]
    message: Optional[str] = None


class WavespeedProvider(ImageProviderBase):
    """WaveSpeed image generation provider implementation"""

    def _build_headers(self) -> dict[str, str]:
        """Build request headers"""
        config = config_service.app_config.get('wavespeed', {})
        api_key = str(config.get("api_key", ""))
        api_url = str(config.get("url", ""))
        channel = os.environ.get('WAVESPEED_CHANNEL', 'jaaz_main')

        if not api_key:
            raise ValueError("WaveSpeed API key is not configured")
        if not api_url:
            raise ValueError("WaveSpeed API URL is not configured")
        return {
            'Authorization': f'Bearer {api_key}',
            'Content-Type': 'application/json',
            'channel': channel,
        }

    def _build_payload(self, prompt: str, input_images: Optional[list[str]] = None, **kwargs: Any) -> dict[str, Any]:
        """Build request payload based on whether input images are provided"""
        if input_images and len(input_images) > 0:
            # Image editing mode
            return {
                "prompt": prompt,
                "images": input_images,
                "guidance_scale": kwargs.get("guidance_scale", 3.5),
                "num_images": kwargs.get("num_images", 1),
                "safety_tolerance": str(kwargs.get("safety_tolerance", "2"))
            }
        else:
            # Text-to-image mode
            return {
                "enable_base64_output": False,
                "enable_safety_checker": False,
                "guidance_scale": kwargs.get("guidance_scale", 3.5),
                "num_images": kwargs.get("num_images", 1),
                "num_inference_steps": kwargs.get("num_inference_steps", 28),
                "prompt": prompt,
                "seed": -1,
                "size": kwargs.get("size", "1024*1024"),
                "strength": kwargs.get("strength", 0.8),
            }

    def _get_model_for_request(self, model: str, input_images: Optional[list[str]] = None) -> str:
        """Get the appropriate model for the request"""
        if input_images and len(input_images) > 0:
            return 'wavespeed-ai/flux-kontext-pro/multi'
        return model

    async def _poll_for_result(self, result_url: str, headers: dict[str, str]) -> str:
        """Poll for image generation result"""
        async with HttpClient.create_aiohttp() as session:
            for _ in range(60):  # æœ€å¤šç­‰60ç§’
                await asyncio.sleep(1)
                async with session.get(result_url, headers=headers) as result_resp:
                    result_data = await result_resp.json()
                    print("WaveSpeed polling result:", result_data)

                    data = result_data.get("data", {})
                    outputs = data.get("outputs", [])
                    status = data.get("status")

                    if status in ("succeeded", "completed") and outputs:
                        return outputs[0]

                    if status == "failed":
                        raise Exception(
                            f"WaveSpeed generation failed: {result_data}")

            raise Exception("WaveSpeed image generation timeout")

    async def generate(
        self,
        prompt: str,
        model: str,
        aspect_ratio: str = "1:1",
        input_images: Optional[list[str]] = None,
        **kwargs: Any
    ) -> tuple[str, int, int, str]:
        """
        Generate image using WaveSpeed API service

        Args:
            prompt: Image generation prompt
            model: Model name to use for generation
            aspect_ratio: Image aspect ratio (1:1, 16:9, 4:3, 3:4, 9:16)
            input_images: Optional input images for reference or editing
            **kwargs: Additional provider-specific parameters

        Returns:
            tuple[str, int, int, str]: (mime_type, width, height, filename)
        """
        try:
            headers = self._build_headers()
            payload = self._build_payload(prompt, input_images, **kwargs)
            request_model = self._get_model_for_request(model, input_images)

            endpoint = f"{self.api_url.rstrip('/')}/{request_model}"

            async with HttpClient.create_aiohttp() as session:
                async with session.post(endpoint, json=payload, headers=headers) as response:
                    response_json = await response.json()

                    if response.status != 200 or response_json.get("code") != 200:
                        raise Exception(
                            f"WaveSpeed API error: {response_json}")

                    result_url = response_json["data"]["urls"]["get"]

                # Poll for the result
                image_url = await self._poll_for_result(result_url, headers)

                # Save the image
                image_id = generate_image_id()
                mime_type, width, height, extension = await get_image_info_and_save(
                    image_url,
                    os.path.join(FILES_DIR, f'{image_id}')
                )
                filename = f'{image_id}.{extension}'
                return mime_type, width, height, filename

        except Exception as e:
            print('Error generating image with WaveSpeed:', e)
            traceback.print_exc()
            raise e



================================================
FILE: server/tools/utils/__init__.py
================================================
# Image generation utilities module



================================================
FILE: server/tools/utils/comfyui.py
================================================
from typing import Optional
import os
import random
import json
import sys
import copy
import traceback
from utils.http_client import HttpClient
from .image_utils import get_image_info_and_save, generate_image_id
from services.config_service import (
    config_service,
    FILES_DIR,
    IMAGE_FORMATS,
    VIDEO_FORMATS,
)
from routers.comfyui_execution import execute
from tools.video_generation.video_canvas_utils import get_video_info_and_save


async def detect_file_type_comprehensive(url):
    """ç»¼åˆåˆ¤æ–­æ–‡ä»¶ç±»å‹"""
    try:
        # é¦–å…ˆå°è¯•é€šè¿‡HTTPå¤´éƒ¨åˆ¤æ–­
        async with HttpClient.create() as client:
            response = await client.head(url)
            content_type = response.headers.get("content-type", "").lower()

            if content_type.startswith("image/"):
                return "image"
            elif content_type.startswith("video/"):
                return "video"

        # å¦‚æœContent-Typeä¸æ˜ç¡®ï¼Œæ£€æŸ¥URLæ‰©å±•å
        if any(fmt in url.lower() for fmt in IMAGE_FORMATS):
            return "image"
        elif any(fmt in url.lower() for fmt in VIDEO_FORMATS):
            return "video"

        # é»˜è®¤è¿”å›image
        return "image"

    except Exception:
        # å‡ºé”™æ—¶å›é€€åˆ°æ‰©å±•åæ£€æŸ¥
        return "image" if any(fmt in url.lower() for fmt in IMAGE_FORMATS) else "video"


def get_asset_path(filename):
    """
    To get the correct path for pyinstaller bundled application
    """
    if getattr(sys, "frozen", False):
        # If the application is run as a bundle, the path is relative to the executable
        base_path = sys._MEIPASS
    else:
        # If the application is run in a normal Python environment
        base_path = os.path.dirname(
            os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
        )

    return os.path.join(base_path, "asset", filename)


class ComfyUIGenerator():
    """ComfyUI image generator implementation"""

    def __init__(self):
        # Load workflows
        asset_dir = get_asset_path("flux_comfy_workflow.json")
        basic_comfy_t2i_workflow = get_asset_path("default_comfy_t2i_workflow.json")

        self.flux_comfy_workflow = None
        self.basic_comfy_t2i_workflow = None
        self.comfy_websocket_client = None

        try:
            self.flux_comfy_workflow = json.load(open(asset_dir, "r"))
            self.basic_comfy_t2i_workflow = json.load(
                open(basic_comfy_t2i_workflow, "r")
            )
        except Exception:
            traceback.print_exc()

    async def generate(
        self,
        prompt: str,
        model: str,
        aspect_ratio: str = "1:1",
        input_image: Optional[str] = None,
        **kwargs,
    ) -> tuple[str, int, int, str]:
        """
        Generate an image by calling offical ComfyUI Client
        """
        if not self.flux_comfy_workflow:
            raise FileNotFoundError("Flux workflow json not found")

        # Get context from kwargs
        ctx = kwargs.get("ctx", {})

        api_url = str(
            config_service.app_config.get("comfyui", {}).get("url", "")
        ).rstrip("/")

        # Process ratio
        if "flux" in model:
            # Flux generate images around 1M pixel (1024x1024)
            pixel_count = 1024**2
        else:
            # sd 1.5, basic is 512, but acceopt 768 for better quality
            pixel_count = 768**2

        w_ratio, h_ratio = map(int, aspect_ratio.split(":"))
        factor = (pixel_count / (w_ratio * h_ratio)) ** 0.5

        width = int((factor * w_ratio) / 64) * 64
        height = int((factor * h_ratio) / 64) * 64

        if "flux" in model:
            workflow = copy.deepcopy(self.flux_comfy_workflow)
            workflow["6"]["inputs"]["text"] = prompt
            workflow["30"]["inputs"]["ckpt_name"] = model
            workflow["27"]["inputs"]["width"] = width
            workflow["27"]["inputs"]["height"] = height
            workflow["31"]["inputs"]["seed"] = random.randint(1, 2**32)
        else:
            workflow = copy.deepcopy(self.basic_comfy_t2i_workflow)
            workflow["6"]["inputs"]["text"] = prompt
            workflow["4"]["inputs"]["ckpt_name"] = model
            workflow["5"]["inputs"]["width"] = width
            workflow["5"]["inputs"]["height"] = height
            workflow["3"]["inputs"]["seed"] = random.randint(1, 2**32)

        execution = await execute(workflow, api_url, ctx=ctx)
        print("ğŸ¦„image execution outputs", execution.outputs)
        url = execution.outputs[0]

        # get image dimensions
        image_id = generate_image_id()
        mime_type, width, height, extension = await get_image_info_and_save(
            url, os.path.join(FILES_DIR, f"{image_id}")
        )
        filename = f"{image_id}.{extension}"
        return mime_type, width, height, filename


class ComfyUIWorkflowRunner():
    """ComfyUI image generator implementation"""

    def __init__(self, workflow_dict, base_url):
        # Load workflows
        self.workflow = workflow_dict
        self.base_url = base_url

    async def generate(
        self,
        **kwargs,
    ) -> tuple[str, int, int, str]:
        """
        Run a workflow by calling official ComfyUI Client
        """
        # Get context from kwargs
        ctx = kwargs.get("ctx", {})

        execution = await execute(
            self.workflow, self.base_url, local_paths=True, ctx=ctx
        )
        print("ğŸ¦„workflow execution outputs", execution.outputs)

        results = []
        for url in execution.outputs:
            # get image id
            image_id = generate_image_id()

            # check is video or image.
            file_type = await detect_file_type_comprehensive(url)
            get_info_func = (
                get_video_info_and_save
                if file_type == "video"
                else get_image_info_and_save
            )

            mime_type, width, height, extension = await get_info_func(
                url, os.path.join(FILES_DIR, f"{image_id}")
            )

            filename = f"{image_id}.{extension}"
            results.append((mime_type, width, height, filename))

        return results


================================================
FILE: server/tools/utils/image_canvas_utils.py
================================================
"""
Canvas-related utilities for image generation
Handles canvas operations, locking, and notifications
"""

import asyncio
import random
import time
import json
from contextlib import asynccontextmanager
from typing import Dict, List, Any, Optional, Union, cast
from nanoid import generate
from services.db_service import db_service
from services.websocket_service import broadcast_session_update
from services.websocket_service import send_to_websocket
from utils.canvas import find_next_best_element_position

def generate_file_id() -> str:
    """Generate unique file ID"""
    return 'im_' + generate(size=8)


class CanvasLockManager:
    """Canvas lock manager to prevent concurrent operations causing position overlap"""

    def __init__(self) -> None:
        self._locks: Dict[str, asyncio.Lock] = {}

    @asynccontextmanager
    async def lock_canvas(self, canvas_id: str):
        if canvas_id not in self._locks:
            self._locks[canvas_id] = asyncio.Lock()

        async with self._locks[canvas_id]:
            yield


# Global lock manager instance
canvas_lock_manager = CanvasLockManager()



async def generate_new_image_element(
    canvas_id: str,
    fileid: str,
    image_data: Dict[str, Any],
    canvas_data: Optional[Dict[str, Any]] = None,
) -> Dict[str, Any]:
    """Generate new image element for canvas"""
    if canvas_data is None:
        canvas = await db_service.get_canvas_data(canvas_id)
        if canvas is None:
            canvas = {"data": {}}
        canvas_data = canvas.get("data", {})



    new_x, new_y = await find_next_best_element_position(canvas_data)

    return {
        "type": "image",
        "id": fileid,
        "x": new_x,
        "y": new_y,
        "width": image_data.get("width", 0),
        "height": image_data.get("height", 0),
        "angle": 0,
        "fileId": fileid,
        "strokeColor": "#000000",
        "fillStyle": "solid",
        "strokeStyle": "solid",
        "boundElements": None,
        "roundness": None,
        "frameId": None,
        "backgroundColor": "transparent",
        "strokeWidth": 1,
        "roughness": 0,
        "opacity": 100,
        "groupIds": [],
        "seed": int(random.random() * 1000000),
        "version": 1,
        "versionNonce": int(random.random() * 1000000),
        "isDeleted": False,
        "index": None,
        "updated": 0,
        "link": None,
        "locked": False,
        "status": "saved",
        "scale": [1, 1],
        "crop": None,
    }


async def save_image_to_canvas(session_id: str, canvas_id: str, filename: str, mime_type: str, width: int, height: int) -> str:
    """Save image to canvas with proper locking and positioning"""
    # Use lock to ensure atomicity of the save process
    async with canvas_lock_manager.lock_canvas(canvas_id):
        # Fetch canvas data once inside the lock
        canvas: Optional[Dict[str, Any]] = await db_service.get_canvas_data(canvas_id)
        if canvas is None:
            canvas = {'data': {}}
        canvas_data: Dict[str, Any] = canvas.get('data', {})

        # Ensure 'elements' and 'files' keys exist
        if 'elements' not in canvas_data:
            canvas_data['elements'] = []
        if 'files' not in canvas_data:
            canvas_data['files'] = {}

        file_id = generate_file_id()
        url = f'/api/file/{filename}'

        file_data: Dict[str, Any] = {
            'mimeType': mime_type,
            'id': file_id,
            'dataURL': url,
            'created': int(time.time() * 1000),
        }

        new_image_element: Dict[str, Any] = await generate_new_image_element(
            canvas_id,
            file_id,
            {
                'width': width,
                'height': height,
            },
            canvas_data
        )

        # Update the canvas data with the new element and file info
        elements_list = cast(List[Dict[str, Any]], canvas_data['elements'])
        elements_list.append(new_image_element)
        canvas_data['files'][file_id] = file_data

        image_url = f"/api/file/{filename}"

        # Save the updated canvas data back to the database
        await db_service.save_canvas_data(canvas_id, json.dumps(canvas_data))

        # Broadcast image generation message to frontend
        await broadcast_session_update(session_id, canvas_id, {
            'type': 'image_generated',
            'element': new_image_element,
            'file': file_data,
            'image_url': image_url,
        })

        return image_url


async def send_image_start_notification(session_id: str, message: str) -> None:
    """Send image generation start notification"""
    await send_to_websocket(session_id, {
        'type': 'image_generation_start',
        'message': message
    })


async def send_image_error_notification(session_id: str, error_message: str) -> None:
    """Send image generation error notification"""
    await send_to_websocket(session_id, {
        'type': 'error',
        'error': error_message
    })



================================================
FILE: server/tools/utils/image_generation_core.py
================================================
"""
Image generation core module
Contains the main orchestration logic for image generation across different providers
"""

from typing import Optional, Dict, Any
from common import DEFAULT_PORT
from tools.utils.image_utils import process_input_image
from ..image_providers.image_base_provider import ImageProviderBase

# å¯¼å…¥æ‰€æœ‰æä¾›å•†ä»¥ç¡®ä¿è‡ªåŠ¨æ³¨å†Œ (ä¸è¦åˆ é™¤è¿™äº›å¯¼å…¥)
from ..image_providers.jaaz_provider import JaazImageProvider
from ..image_providers.openai_provider import OpenAIImageProvider
from ..image_providers.replicate_provider import ReplicateImageProvider
from ..image_providers.volces_provider import VolcesProvider
from ..image_providers.wavespeed_provider import WavespeedProvider

# from ..image_providers.comfyui_provider import ComfyUIProvider
from .image_canvas_utils import (
    save_image_to_canvas,
)
import time

IMAGE_PROVIDERS: dict[str, ImageProviderBase] = {
    "jaaz": JaazImageProvider(),
    "openai": OpenAIImageProvider(),
    "replicate": ReplicateImageProvider(),
    "volces": VolcesProvider(),
    "wavespeed": WavespeedProvider(),
}


async def generate_image_with_provider(
    canvas_id: str,
    session_id: str,
    provider: str,
    model: str,
    # image generator args
    prompt: str,
    aspect_ratio: str = "1:1",
    input_images: Optional[list[str]] = None,
) -> str:
    """
    é€šç”¨å›¾åƒç”Ÿæˆå‡½æ•°ï¼Œæ”¯æŒä¸åŒçš„æ¨¡å‹å’Œæä¾›å•†

    Args:
        prompt: å›¾åƒç”Ÿæˆæç¤ºè¯
        aspect_ratio: å›¾åƒé•¿å®½æ¯”
        model_name: å†…éƒ¨æ¨¡å‹åç§° (å¦‚ 'gpt-image-1', 'imagen-4')
        model: æ¨¡å‹æ ‡è¯†ç¬¦ (å¦‚ 'openai/gpt-image-1', 'google/imagen-4')
        tool_call_id: å·¥å…·è°ƒç”¨ID
        config: ä¸Šä¸‹æ–‡è¿è¡Œé…ç½®ï¼ŒåŒ…å«canvas_idï¼Œsession_idï¼Œmodel_infoï¼Œç”±langgraphæ³¨å…¥
        input_images: å¯é€‰çš„è¾“å…¥å‚è€ƒå›¾åƒåˆ—è¡¨

    Returns:
        str: ç”Ÿæˆç»“æœæ¶ˆæ¯
    """

    provider_instance = IMAGE_PROVIDERS.get(provider)
    if not provider_instance:
        raise ValueError(f"Unknown provider: {provider}")

    # Process input images for the provider
    processed_input_images: list[str] | None = None
    if input_images:
        processed_input_images = []
        for image_path in input_images:
            processed_image = await process_input_image(image_path)
            if processed_image:
                processed_input_images.append(processed_image)

        print(f"Using {len(processed_input_images)} input images for generation")

    # Prepare metadata with all generation parameters
    metadata: Dict[str, Any] = {
        "prompt": prompt,
        "model": model,
        "provider": provider,
        "aspect_ratio": aspect_ratio,
        "input_images": input_images or [],
    }

    # Generate image using the selected provider
    mime_type, width, height, filename = await provider_instance.generate(
        prompt=prompt,
        model=model,
        aspect_ratio=aspect_ratio,
        input_images=processed_input_images,
        metadata=metadata,
    )

    # Save image to canvas
    image_url = await save_image_to_canvas(
        session_id, canvas_id, filename, mime_type, width, height
    )

    return f"image generated successfully ![image_id: {filename}](http://localhost:{DEFAULT_PORT}{image_url})"



================================================
FILE: server/tools/utils/image_utils.py
================================================
import os
import traceback
from PIL import Image, PngImagePlugin
from io import BytesIO
import base64
import json
from typing import Any, Optional, Tuple
from nanoid import generate
from utils.http_client import HttpClient
from services.config_service import FILES_DIR


def generate_image_id() -> str:
    """Generate unique image ID"""
    return generate(size=10)


async def get_image_info_and_save(
    url: str,
    file_path_without_extension: str,
    is_b64: bool = False,
    metadata: Optional[dict[str, Any]] = None
) -> Tuple[str, int, int, str]:
    """
    Download image from URL or decode base64, convert to PNG and save with metadata

    Args:
        url: Image URL or base64 string
        file_path_without_extension: File path without extension
        is_b64: Whether the url is a base64 string
        metadata: Optional metadata to be saved in PNG info

    Returns:
        tuple[str, int, int, str]: (mime_type, width, height, extension) - always PNG
    """
    try:
        if is_b64:
            image_data = base64.b64decode(url)
        else:
            # Fetch the image asynchronously
            async with HttpClient.create_aiohttp() as session:
                async with session.get(url) as response:
                    # Read the image content as bytes
                    image_data = await response.read()

        # Open image to get info
        image = Image.open(BytesIO(image_data))
        width, height = image.size
        
        # Store original format for debugging
        original_format = image.format or 'Unknown'
        print(f"Converting {original_format} image to PNG: {width}x{height}")

        # Handle different color modes properly for PNG conversion
        if image.mode == 'P':
            # Palette mode - convert to RGBA to preserve potential transparency
            if 'transparency' in image.info:
                image = image.convert('RGBA')
            else:
                image = image.convert('RGB')
        elif image.mode == 'LA':
            # Grayscale with alpha - convert to RGBA
            image = image.convert('RGBA')
        elif image.mode == 'L':
            # Grayscale - can stay as L or convert to RGB
            # PNG supports grayscale, so we can keep it
            pass
        elif image.mode == 'CMYK':
            # CMYK mode - convert to RGB
            image = image.convert('RGB')
        elif image.mode in ('RGB', 'RGBA'):
            # Already compatible with PNG
            pass
        else:
            # For any other modes, convert to RGB as a safe fallback
            print(f"Warning: Unusual color mode {image.mode}, converting to RGB")
            image = image.convert('RGB')

        # Unified format: always PNG
        extension = 'png'
        mime_type = 'image/png'

        # Prepare PNG info for metadata
        pnginfo = PngImagePlugin.PngInfo()
        
        # Add original format info
        pnginfo.add_text("original_format", original_format)
        
        if metadata:
            for key, value in metadata.items():
                try:
                    # Handle different value types
                    if isinstance(value, (dict, list)):
                        # Serialize complex types as JSON
                        text_value = json.dumps(value, ensure_ascii=False)
                    elif value is None:
                        text_value = "null"
                    else:
                        # Convert to string
                        text_value = str(value)
                    
                    pnginfo.add_text(str(key), text_value)
                except Exception as e:
                    print(f"Warning: Failed to add metadata key '{key}': {e}")
                    traceback.print_stack()

        # Save as PNG with metadata
        file_path = f"{file_path_without_extension}.{extension}"
        
        # Save with optimizations and metadata
        if metadata or original_format != 'PNG':
            image.save(file_path, format='PNG', optimize=True, pnginfo=pnginfo)
        else:
            image.save(file_path, format='PNG', optimize=True)
        
        print(f"Successfully saved as PNG: {file_path}")
        return mime_type, width, height, extension

    except Exception as e:
        print(f"Error processing image: {e}")
        raise e


# Canvas-related utilities have been moved to tools/image_generation/image_canvas_utils.py


# Canvas element generation moved to tools/image_generation/image_canvas_utils.py


# Canvas saving functionality moved to tools/image_generation/image_canvas_utils.py


# Image generation orchestration moved to tools/image_generation/image_generation_core.py
# Notification functions moved to tools/image_generation/image_canvas_utils.py


async def process_input_image(input_image: str | None) -> str | None:
    """
    Process input image and convert to base64 format

    Args:
        input_image: Image file path

    Returns:
        Base64 encoded image with data URL, or None if no image
    """
    if not input_image:
        return None

    try:
        full_path = os.path.join(FILES_DIR, input_image)
        if not os.path.exists(full_path):
            print(f"Warning: Image file not found: {full_path}")
            return None

        image = Image.open(full_path)
        ext = os.path.splitext(input_image)[1].lower()
        mime_type_map = {
            '.png': 'image/png',
            '.jpg': 'image/jpeg',
            '.jpeg': 'image/jpeg',
            '.webp': 'image/webp'
        }
        mime_type = mime_type_map.get(ext, 'image/jpeg')

        with BytesIO() as output:
            image.save(output, format=str(mime_type.split('/')[1]).upper())
            compressed_data = output.getvalue()
            b64_data = base64.b64encode(compressed_data).decode('utf-8')

        data_url = f"data:{mime_type};base64,{b64_data}"
        return data_url

    except Exception as e:
        print(f"Error processing image {input_image}: {e}")
        return None



================================================
FILE: server/tools/video_generation/__init__.py
================================================
from .video_generation_core import generate_video_with_provider
from .video_canvas_utils import (
    save_video_to_canvas,
    generate_new_video_element,
    send_video_start_notification,
    send_video_error_notification,
    process_video_result,
)

__all__ = [
    "generate_video_with_provider",
    "save_video_to_canvas",
    "generate_new_video_element",
    "send_video_start_notification",
    "send_video_error_notification",
    "process_video_result",
]



================================================
FILE: server/tools/video_generation/video_canvas_utils.py
================================================
"""
Video canvas utilities module
Contains functions for video processing, canvas operations, and notifications
"""

import json
import time
import os
import asyncio
from contextlib import asynccontextmanager
from typing import Dict, List, Any, Tuple, Optional, Union
from services.config_service import FILES_DIR
from services.db_service import db_service
from services.websocket_service import send_to_websocket, broadcast_session_update  # type: ignore
from common import DEFAULT_PORT
from utils.http_client import HttpClient
import aiofiles
import mimetypes
from pymediainfo import MediaInfo
from nanoid import generate
import random
from utils.canvas import find_next_best_element_position


class CanvasLockManager:
    """Canvas lock manager to prevent concurrent operations causing position overlap"""

    def __init__(self) -> None:
        self._locks: Dict[str, asyncio.Lock] = {}

    @asynccontextmanager
    async def lock_canvas(self, canvas_id: str):
        if canvas_id not in self._locks:
            self._locks[canvas_id] = asyncio.Lock()

        async with self._locks[canvas_id]:
            yield


# Global lock manager instance
canvas_lock_manager = CanvasLockManager()


async def save_video_to_canvas(
    session_id: str,
    canvas_id: str,
    video_url: str
) -> Tuple[str, Dict[str, Any], Dict[str, Any]]:
    """
    Download video, save to files, create canvas element and return data

    Args:
        session_id: Session ID for notifications
        canvas_id: Canvas ID to add video element
        video_url: URL to download video from

    Returns:
        Tuple of (filename, file_data, new_video_element)
    """
    # Use lock to ensure atomicity of the save process
    async with canvas_lock_manager.lock_canvas(canvas_id):
        # Generate unique video ID
        video_id = generate_video_file_id()

        # Download and save video
        print(f"ğŸ¥ Downloading video from: {video_url}")
        mime_type, width, height, extension = await get_video_info_and_save(
            video_url, os.path.join(FILES_DIR, f"{video_id}")
        )
        filename = f"{video_id}.{extension}"

        print(f"ğŸ¥ Video saved as: {filename}, dimensions: {width}x{height}")

        # Create file data
        file_id = generate_video_file_id()
        file_url = f"/api/file/{filename}"

        file_data: Dict[str, Any] = {
            "mimeType": mime_type,
            "id": file_id,
            "dataURL": file_url,
            "created": int(time.time() * 1000),
        }

        # Create new video element for canvas
        new_video_element: Dict[str, Any] = await generate_new_video_element(
            canvas_id,
            file_id,
            {
                "width": width,
                "height": height,
            },
        )

        # Update canvas data
        canvas_data: Optional[Dict[str, Any]] = await db_service.get_canvas_data(canvas_id)
        if canvas_data is None:
            canvas_data = {}
        if "data" not in canvas_data:
            canvas_data["data"] = {}
        if "elements" not in canvas_data["data"]:
            canvas_data["data"]["elements"] = []
        if "files" not in canvas_data["data"]:
            canvas_data["data"]["files"] = {}

        canvas_data["data"]["elements"].append(
            new_video_element)  # type: ignore
        canvas_data["data"]["files"][file_id] = file_data

        # Save updated canvas data
        await db_service.save_canvas_data(canvas_id, json.dumps(canvas_data["data"]))

        return filename, file_data, new_video_element


async def send_video_start_notification(session_id: str, message: str) -> None:
    """Send WebSocket notification about video generation start"""
    await send_to_websocket(session_id, {
        "type": "video_generation_started",
        "message": message
    })


async def send_video_completion_notification(
    session_id: str,
    canvas_id: str,
    new_video_element: Dict[str, Any],
    file_data: Dict[str, Any],
    video_url: str
) -> None:
    """Send WebSocket notification about video generation completion"""
    await broadcast_session_update(
        session_id,
        canvas_id,
        {
            "type": "video_generated",
            "element": new_video_element,
            "file": file_data,
            "video_url": video_url,
        },
    )


async def send_video_error_notification(session_id: str, error_message: str) -> None:
    """Send WebSocket notification about video generation error"""
    print(f"ğŸ¥ Video generation error: {error_message}")
    await send_to_websocket(session_id, {
        "type": "error",
        "error": error_message
    })


def format_video_success_message(filename: str) -> str:
    """Format success message for video generation"""
    return f"video generated successfully ![video_id: {filename}](http://localhost:{DEFAULT_PORT}/api/file/{filename})"


async def process_video_result(
    video_url: str,
    session_id: str,
    canvas_id: str,
    provider_name: str = ""
) -> str:
    """
    Complete video processing pipeline: save, update canvas, notify

    Args:
        video_url: URL of the generated video
        session_id: Session ID for notifications
        canvas_id: Canvas ID to add video element
        provider_name: Name of the provider (for logging)

    Returns:
        Success message with video link
    """
    try:
        # Save video to canvas and get file info
        filename, file_data, new_video_element = await save_video_to_canvas(
            session_id=session_id,
            canvas_id=canvas_id,
            video_url=video_url
        )

        # Send completion notification
        await send_video_completion_notification(
            session_id=session_id,
            canvas_id=canvas_id,
            new_video_element=new_video_element,
            file_data=file_data,
            video_url=file_data["dataURL"]
        )

        provider_info = f" using {provider_name}" if provider_name else ""
        print(f"ğŸ¥ Video generation completed{provider_info}: {filename}")
        return format_video_success_message(filename)

    except Exception as e:
        error_message = str(e)
        await send_video_error_notification(session_id, error_message)
        raise e


def generate_video_file_id() -> str:
    return "vi_" + generate(size=8)


async def get_video_info_and_save(
    url: str, file_path_without_extension: str
) -> Tuple[str, int, int, str]:
    # Fetch the video asynchronously
    async with HttpClient.create_aiohttp() as session:
        async with session.get(url) as response:
            video_content = await response.read()

    # Save to temporary mp4 file first
    temp_path = f"{file_path_without_extension}.mp4"
    async with aiofiles.open(temp_path, "wb") as out_file:
        await out_file.write(video_content)
    print("ğŸ¥ Video saved to", temp_path)

    try:
        media_info = MediaInfo.parse(temp_path)  # type: ignore
        width: int = 0
        height: int = 0

        for track in media_info.tracks:  # type: ignore
            if track.track_type == "Video":  # type: ignore
                width = int(track.width or 0)  # type: ignore
                height = int(track.height or 0)  # type: ignore
                print(f"Width: {width}, Height: {height}")
                break

        extension = "mp4"  # Default to mp4, can be flexible based on codec_name

        # Get mime type
        mime_type = mimetypes.types_map.get(".mp4", "video/mp4")

        print(
            f"ğŸ¥ Video info - width: {width}, height: {height}, mime_type: {mime_type}, extension: {extension}"
        )

        return mime_type, width, height, extension
    except Exception as e:
        print(f"Error probing video file {temp_path}: {str(e)}")
        raise e


async def generate_new_video_element(
    canvas_id: str,
    fileid: str,
    video_data: Dict[str, Any],
    canvas_data: Optional[Dict[str, Any]] = None,
) -> Dict[str, Any]:
    """Generate new video element for canvas"""
    if canvas_data is None:
        canvas = await db_service.get_canvas_data(canvas_id)
        if canvas is None:
            canvas = {"data": {}}
        canvas_data = canvas.get("data", {})

    new_x, new_y = await find_next_best_element_position(canvas_data)

    return {
        "type": "video",
        "id": fileid,
        "x": new_x,
        "y": new_y,
        "width": video_data.get("width", 0),
        "height": video_data.get("height", 0),
        "angle": 0,
        "fileId": fileid,
        "strokeColor": "#000000",
        "fillStyle": "solid",
        "strokeStyle": "solid",
        "boundElements": None,
        "roundness": None,
        "frameId": None,
        "backgroundColor": "transparent",
        "strokeWidth": 1,
        "roughness": 0,
        "opacity": 100,
        "groupIds": [],
        "seed": int(random.random() * 1000000),
        "version": 1,
        "versionNonce": int(random.random() * 1000000),
        "isDeleted": False,
        "index": None,
        "updated": 0,
        "link": None,
        "locked": False,
        "status": "saved",
        "scale": [1, 1],
        "crop": None,
    }



================================================
FILE: server/tools/video_generation/video_generation_core.py
================================================
"""
Video generation core module
Contains the main orchestration logic for video generation across different providers
"""

import traceback
from typing import List, cast, Optional, Any
from models.config_model import ModelInfo
from ..video_providers.video_base_provider import get_default_provider, VideoProviderBase
# Import all providers to ensure automatic registration (don't delete these imports)
from ..video_providers.volces_provider import VolcesVideoProvider  # type: ignore
from .video_canvas_utils import (
    send_video_start_notification,
    send_video_error_notification,
    process_video_result,
)


async def generate_video_with_provider(
    prompt: str,
    resolution: str,
    duration: int,
    aspect_ratio: str,
    model: str,
    tool_call_id: str,
    config: Any,
    input_images: Optional[list[str]] = None,
    camera_fixed: bool = True,
    **kwargs: Any
) -> str:
    """
    Universal video generation function supporting different models and providers

    Args:
        prompt: Video generation prompt
        resolution: Video resolution (480p, 1080p)
        duration: Video duration in seconds (5, 10)
        aspect_ratio: Video aspect ratio (1:1, 16:9, 4:3, 21:9)
        model: Model identifier (e.g., 'doubao-seedance-1-0-pro')
        tool_call_id: Tool call ID
        config: Context runtime configuration containing canvas_id, session_id, model_info, injected by langgraph
        input_images: Optional input reference images list
        camera_fixed: Whether to keep camera fixed

    Returns:
        str: Generation result message
    """
    model_name = model.split(
        # Some model names contain "/", like "openai/gpt-image-1", need to handle
        '/')[-1]
    print(f'ğŸ› ï¸ Video Generation {model_name} tool_call_id', tool_call_id)
    ctx = config.get('configurable', {})
    canvas_id = ctx.get('canvas_id', '')
    session_id = ctx.get('session_id', '')
    print(f'ğŸ› ï¸ canvas_id {canvas_id} session_id {session_id}')

    # Inject the tool call id into the context
    ctx['tool_call_id'] = tool_call_id

    try:
        # Determine provider selection
        model_info_list: List[ModelInfo] = cast(
            List[ModelInfo], ctx.get('model_info', {}).get(model_name, []))

        if model_info_list == []:
            # video registed as tool
            model_info_list: List[ModelInfo] = cast(
                List[ModelInfo], ctx.get('tool_list', {}))

        # Use get_default_provider which already handles Jaaz prioritization
        provider_name = get_default_provider(model_info_list)

        print(f"ğŸ¥ Using provider: {provider_name} for {model_name}")

        # Create provider instance
        provider_instance = VideoProviderBase.create_provider(provider_name)

        # Send start notification
        await send_video_start_notification(
            session_id,
            f"Starting video generation using {model_name} via {provider_name}..."
        )

        # Process input images for the provider
        processed_input_images = None
        if input_images:
            # For some providers, we might need to process input images differently
            # For now, just pass them as is
            processed_input_images = input_images

        # Generate video using the selected provider
        video_url = await provider_instance.generate(
            prompt=prompt,
            model=model,
            resolution=resolution,
            duration=duration,
            aspect_ratio=aspect_ratio,
            input_images=processed_input_images,
            camera_fixed=camera_fixed,
            **kwargs
        )

        # Process video result (save, update canvas, notify)
        return await process_video_result(
            video_url=video_url,
            session_id=session_id,
            canvas_id=canvas_id,
            provider_name=f"{model_name} ({provider_name})"
        )

    except Exception as e:
        error_message = str(e)
        print(f"ğŸ¥ Error generating video with {model_name}: {error_message}")
        traceback.print_exc()

        # Send error notification
        await send_video_error_notification(session_id, error_message)

        # Re-raise the exception for proper error handling
        raise Exception(
            f"{model_name} video generation failed: {error_message}")



================================================
FILE: server/tools/video_providers/__init__.py
================================================
# Video providers package



================================================
FILE: server/tools/video_providers/video_base_provider.py
================================================
from abc import ABC, abstractmethod
from typing import Optional, Dict, Any, List, Type
from models.config_model import ModelInfo


class VideoProviderBase(ABC):
    """Video generation provider base class"""

    # Class attribute: provider registry
    _providers: Dict[str, Type['VideoProviderBase']] = {}

    def __init_subclass__(cls, provider_name: Optional[str] = None, **kwargs: Any):
        """Auto-register provider"""
        super().__init_subclass__(**kwargs)
        if provider_name:
            cls._providers[provider_name] = cls

    @classmethod
    def create_provider(cls, provider_name: str) -> 'VideoProviderBase':
        """Factory method: create provider instance"""
        if provider_name not in cls._providers:
            raise ValueError(f"Unknown provider: {provider_name}")

        provider_class = cls._providers[provider_name]
        return provider_class()  # Let each provider handle its own configuration

    @classmethod
    def get_available_providers(cls) -> List[str]:
        """Get all available providers"""
        return list(cls._providers.keys())

    @abstractmethod
    async def generate(
        self,
        prompt: str,
        model: str,
        resolution: str = "480p",
        duration: int = 5,
        aspect_ratio: str = "16:9",
        input_images: Optional[list[str]] = None,
        camera_fixed: bool = True,
        **kwargs: Any
    ) -> str:
        """
        Generate video and return video URL

        Args:
            prompt: Video generation prompt
            model: Model name to use for generation
            resolution: Video resolution (480p, 1080p)
            duration: Video duration in seconds (5, 10)
            aspect_ratio: Video aspect ratio (1:1, 16:9, 4:3, 21:9)
            input_images: Optional input images for reference
            camera_fixed: Whether to keep camera fixed
            **kwargs: Additional provider-specific parameters

        Returns:
            str: Video URL for download
        """
        pass


def get_default_provider(model_info_list: Optional[List[ModelInfo]] = None) -> str:
    """Get default provider for video generation

    Args:
        model_info_list: List of model info dictionaries. If provided,
                        will prioritize jaaz provider if available, otherwise use first one.
                        If not provided, returns 'jaaz' as default.

    Returns:
        str: Provider name
    """
    if model_info_list:
        # Prioritize Jaaz provider if available
        for model_info in model_info_list:
            if model_info.get('provider') == 'jaaz':
                return 'jaaz'

        # If no jaaz provider, use the first available one
        if model_info_list:
            return model_info_list[0].get('provider', 'jaaz')

    # Default fallback
    return "jaaz"



================================================
FILE: server/tools/video_providers/volces_provider.py
================================================
import json
import traceback
import asyncio
from typing import Optional, Dict, Any, List

from .video_base_provider import VideoProviderBase
from utils.http_client import HttpClient
from services.config_service import config_service


class VolcesVideoProvider(VideoProviderBase, provider_name="volces"):
    """Volces Cloud video generation provider implementation"""

    def __init__(self):
        config = config_service.app_config.get('volces', {})
        self.api_key = config.get("api_key", "")
        self.base_url = config.get("url", "").rstrip("/")
        self.model_name = config.get("model_name", "doubao-seedance-1-0-pro")

        if not self.api_key:
            raise ValueError("Volces API key is not configured")
        if not self.base_url:
            raise ValueError("Volces URL is not configured")

    def _build_api_url(self) -> str:
        """Build API URL for Volces Cloud"""
        return f"{self.base_url}/contents/generations/tasks"

    def _build_headers(self) -> Dict[str, str]:
        """Build request headers"""
        return {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json",
        }

    def _build_request_payload(
        self,
        prompt: str,
        model: str | None = None,
        resolution: str = "480p",
        duration: int = 5,
        aspect_ratio: str = "16:9",
        camera_fixed: bool = True,
        input_image_data: Optional[str] | None = None,
        **kwargs: Any
    ) -> Dict[str, Any]:
        """Build request payload for Volces API"""
        # Build command string
        command = (
            f"--resolution {resolution} "
            f"--dur {duration} "
            f"--camerafixed {str(camera_fixed).lower()} "
            f"--wm false"
        )

        # Add aspect ratio if no input image
        if not input_image_data:
            command += f" --rt {aspect_ratio}"

        # Build content
        content: List[Dict[str, Any]] = [
            {"type": "text", "text": prompt + " " + command}]

        if isinstance(input_image_data, list) and len(input_image_data) == 1:
            # image-to-video
            content.append({
                "type": "image_url",
                "image_url": {"url": input_image_data[0]}
            })
        elif isinstance(input_image_data, list) and len(input_image_data) == 2:
            # first-last-frame-to-video
            content.append({
                "type": "image_url",
                "image_url": {"url": input_image_data[0]},
                "role": "first_frame"
            })
            content.append({
                "type": "image_url",
                "image_url": {"url": input_image_data[1]},
                "role": "last_frame"
            })

        payload = {
            "model": str(self.model_name.split("by")[0]).rstrip("_") if model is None else model,
            "content": content,
        }

        return payload

    async def _poll_task_status(self, task_id: str, headers: Dict[str, str]) -> str:
        """Poll task status until completion"""
        polling_url = f"{self.base_url}/contents/generations/tasks/{task_id}"
        status = "submitted"

        async with HttpClient.create_aiohttp() as session:
            while status not in ("succeeded", "failed", "cancelled"):
                print(
                    f"ğŸ¥ Polling Volces generation {task_id}, current status: {status} ...")
                await asyncio.sleep(3)  # Wait 3 seconds between polls

                async with session.get(polling_url, headers=headers) as poll_response:
                    poll_res = await poll_response.json()
                    status = poll_res.get("status", None)

                    if status == "succeeded":
                        output = poll_res.get(
                            "content", {}).get("video_url", None)
                        if output and isinstance(output, str):
                            return output
                        else:
                            raise Exception(
                                "No video URL found in successful response")
                    elif status in ("failed", "cancelled"):
                        detail_error = poll_res.get(
                            "detail", f"Task failed with status: {status}")
                        raise Exception(
                            f"Volces video generation failed: {detail_error}")

        raise Exception(f"Task polling failed with final status: {status}")

    async def generate(
        self,
        prompt: str,
        model: str,
        resolution: str = "480p",
        duration: int = 5,
        aspect_ratio: str = "16:9",
        input_images: Optional[List[str]] = None,
        camera_fixed: bool = True,
        **kwargs: Any
    ) -> str:
        """
        Generate video using Volces API

        Returns:
            str: Video URL for download
        """
        try:
            api_url = self._build_api_url()
            headers = self._build_headers()

            # Use the first input image if provided (already processed as base64)
            input_image_data = input_images if input_images and len(
                input_images) > 0 else None

            # Build request payload
            payload = self._build_request_payload(
                prompt=prompt,
                model=model,
                resolution=resolution,
                duration=duration,
                aspect_ratio=aspect_ratio,
                camera_fixed=camera_fixed,
                input_image_data=input_image_data,
                **kwargs
            )

            print(
                f"ğŸ¥ Starting Volces video generation")

            # Make API request to create task
            async with HttpClient.create_aiohttp() as session:
                async with session.post(api_url, headers=headers, json=payload) as response:
                    if response.status != 200:
                        try:
                            error_data = await response.json()
                            error_message = error_data.get(
                                "error", f"HTTP {response.status}")
                        except Exception:
                            error_message = f"HTTP {response.status}"
                        raise Exception(
                            f"Volces task creation failed: {error_message}")

                    result = await response.json()
                    task_id = result.get("id", None)

                if not task_id:
                    print("ğŸ¥ Failed to create Volces video generation task:", result)
                    raise Exception(
                        "Volces video generation task creation failed")

                print(
                    f"ğŸ¥ Volces video generation task created, task_id: {task_id}")

            # Poll for task completion
            video_url = await self._poll_task_status(task_id, headers)
            print(
                f"ğŸ¥ Volces video generation completed, video URL: {video_url}")

            return video_url

        except Exception as e:
            print(f"ğŸ¥ Error generating video with Volces: {str(e)}")
            traceback.print_exc()
            raise e



================================================
FILE: server/utils/canvas.py
================================================
from typing import Optional, Dict, Any, Union
from services.db_service import db_service

async def find_next_best_element_position(canvas_data, max_num_per_row=4, spacing=20):
    """
    Calculates the next best position for a new element on the canvas.
    This final version uses a robust row detection algorithm to handle complex layouts.
    """
    elements = canvas_data.get("elements", [])
    
    media_elements = [
        e for e in elements 
        if e.get("type") in ["image", "embeddable", "video"] and not e.get("isDeleted")
    ]

    if not media_elements:
        return 0, 0

    # Sort elements by their top-left corner
    media_elements.sort(key=lambda e: (e.get("y", 0), e.get("x", 0)))

    # Group elements into rows based on vertical overlap
    rows = []
    for element in media_elements:
        y, height = element.get("y", 0), element.get("height", 0)
        placed = False
        for row in rows:
            # Check if the element vertically overlaps with any element in the row
            if any(max(y, r.get("y", 0)) < min(y + height, r.get("y", 0) + r.get("height", 0)) for r in row):
                row.append(element)
                placed = True
                break
        if not placed:
            rows.append([element])

    # Sort rows by their average y-coordinate
    rows.sort(key=lambda row: sum(e.get("y", 0) for e in row) / len(row))

    if not rows:
        return 0, 0

    last_row = rows[-1]
    last_row.sort(key=lambda e: e.get("x", 0))

    if len(last_row) < max_num_per_row:
        # Add to the last row
        rightmost_element = last_row[-1]
        new_x = rightmost_element.get("x", 0) + rightmost_element.get("width", 0) + spacing
        # Align with the top of the last row for consistency
        new_y = min(e.get("y", 0) for e in last_row)
    else:
        # Start a new row
        new_x = 0
        # Position below the entire last row
        bottom_of_last_row = max(e.get("y", 0) + e.get("height", 0) for e in last_row)
        new_y = bottom_of_last_row + spacing

    return new_x, new_y


================================================
FILE: server/utils/http_client.py
================================================
"""
HTTP å®¢æˆ·ç«¯å·¥å‚å’Œç®¡ç†å™¨

æœ¬æ¨¡å—æä¾›äº†ç»Ÿä¸€çš„ HTTP å®¢æˆ·ç«¯åˆ›å»ºå’Œç®¡ç†åŠŸèƒ½ï¼Œæ”¯æŒ httpx å’Œ aiohttp åº“ï¼š
- è‡ªåŠ¨ SSL è¯ä¹¦éªŒè¯
- è¿æ¥æ± ç®¡ç†å’Œè¶…æ—¶æ§åˆ¶
- åŒæ­¥å’Œå¼‚æ­¥å®¢æˆ·ç«¯æ”¯æŒ
- æ”¯æŒä»£ç†ç¯å¢ƒå˜é‡ (trust_env=True)

ä½¿ç”¨æŒ‡å—ï¼š
1. httpx å®¢æˆ·ç«¯ï¼š
   async with HttpClient.create() as client:
       response = await client.get("https://api.example.com/data")

2. aiohttp å®¢æˆ·ç«¯ï¼š
   async with HttpClient.create_aiohttp() as session:
       async with session.get("https://api.example.com/data") as response:
           data = await response.json()

3. åŒæ­¥è¯·æ±‚ï¼šä½¿ç”¨ HttpClient.create_sync()
   with HttpClient.create_sync() as client:
       response = client.get("https://api.example.com/data")
"""

import ssl
import certifi
import httpx
from typing import Optional, Dict, Any, AsyncGenerator, Generator
from contextlib import asynccontextmanager, contextmanager
import aiohttp


class HttpClient:
    """HTTP å®¢æˆ·ç«¯å·¥å‚å’Œç®¡ç†å™¨"""

    _ssl_context: Optional[ssl.SSLContext] = None

    @classmethod
    def _get_ssl_context(cls) -> ssl.SSLContext:
        """è·å–ç¼“å­˜çš„ SSL ä¸Šä¸‹æ–‡"""
        if cls._ssl_context is None:
            try:
                cls._ssl_context = ssl.create_default_context(cafile=certifi.where())
            except Exception as e:
                print(f"âš ï¸ Failed to create SSL context with certifi: {e}")
                cls._ssl_context = ssl.create_default_context()
        return cls._ssl_context

    @classmethod
    def _get_client_config(cls, **kwargs: Any) -> Dict[str, Any]:
        """è·å– httpx å®¢æˆ·ç«¯é…ç½®"""

        config = {
            'verify': cls._get_ssl_context(),
            'timeout': 300,
            'follow_redirects': True,
            'limits': httpx.Limits(
                max_keepalive_connections=0, max_connections=200, keepalive_expiry=30
            ),
            **kwargs,
        }

        return config

    @classmethod
    def _get_aiohttp_config(
        cls, trust_env: bool = True, **kwargs: Any
    ) -> Dict[str, Any]:
        """è·å– aiohttp å®¢æˆ·ç«¯é…ç½®"""
        config = {
            'connector': aiohttp.TCPConnector(
                ssl=cls._get_ssl_context(),
                limit=200,
                limit_per_host=50,
                keepalive_timeout=0,
            ),
            'timeout': aiohttp.ClientTimeout(total=300),
            'trust_env': trust_env,  # å¯ç”¨ç¯å¢ƒå˜é‡ä»£ç†æ”¯æŒ
            **kwargs,
        }

        return config

    # ========== å·¥å‚æ–¹æ³• ==========

    @classmethod
    @asynccontextmanager
    async def create(
        cls, url: Optional[str] = None, **kwargs: Any
    ) -> AsyncGenerator[httpx.AsyncClient, None]:
        """åˆ›å»ºå¼‚æ­¥å®¢æˆ·ç«¯ä¸Šä¸‹æ–‡ç®¡ç†å™¨"""
        config = cls._get_client_config(**kwargs)
        client = httpx.AsyncClient(**config)
        try:
            yield client
        finally:
            await client.aclose()

    @classmethod
    @contextmanager
    def create_sync(
        cls, url: Optional[str] = None, **kwargs: Any
    ) -> Generator[httpx.Client, None, None]:
        """åˆ›å»ºåŒæ­¥å®¢æˆ·ç«¯ä¸Šä¸‹æ–‡ç®¡ç†å™¨"""
        config = cls._get_client_config(**kwargs)
        client = httpx.Client(**config)
        try:
            yield client
        finally:
            client.close()

    @classmethod
    def create_async_client(cls, **kwargs: Any) -> httpx.AsyncClient:
        """ç›´æ¥åˆ›å»ºå¼‚æ­¥å®¢æˆ·ç«¯ï¼ˆéœ€è¦æ‰‹åŠ¨å…³é—­ï¼‰"""
        config = cls._get_client_config(**kwargs)
        return httpx.AsyncClient(**config)

    @classmethod
    def create_sync_client(cls, **kwargs: Any) -> httpx.Client:
        """ç›´æ¥åˆ›å»ºåŒæ­¥å®¢æˆ·ç«¯ï¼ˆéœ€è¦æ‰‹åŠ¨å…³é—­ï¼‰"""
        config = cls._get_client_config(**kwargs)
        return httpx.Client(**config)

    # ========== aiohttp å·¥å‚æ–¹æ³• ==========
    @classmethod
    @asynccontextmanager
    async def create_aiohttp(
        cls, trust_env: bool = True, **kwargs: Any
    ) -> AsyncGenerator['aiohttp.ClientSession', None]:
        """åˆ›å»º aiohttp å®¢æˆ·ç«¯ä¸Šä¸‹æ–‡ç®¡ç†å™¨

        Args:
            trust_env: æ˜¯å¦ä¿¡ä»»ç¯å¢ƒå˜é‡ä»£ç†è®¾ç½® (HTTP_PROXY, HTTPS_PROXY, etc.)
            **kwargs: å…¶ä»– aiohttp.ClientSession å‚æ•°
        """
        config = cls._get_aiohttp_config(trust_env=trust_env, **kwargs)
        session = aiohttp.ClientSession(**config)
        try:
            yield session
        finally:
            await session.close()

    @classmethod
    def create_aiohttp_client(
        cls, trust_env: bool = True, **kwargs: Any
    ) -> 'aiohttp.ClientSession':
        """ç›´æ¥åˆ›å»º aiohttp å®¢æˆ·ç«¯ï¼ˆéœ€è¦æ‰‹åŠ¨å…³é—­ï¼‰

        Args:
            trust_env: æ˜¯å¦ä¿¡ä»»ç¯å¢ƒå˜é‡ä»£ç†è®¾ç½® (HTTP_PROXY, HTTPS_PROXY, etc.)
            **kwargs: å…¶ä»– aiohttp.ClientSession å‚æ•°
        """
        config = cls._get_aiohttp_config(trust_env=trust_env, **kwargs)
        return aiohttp.ClientSession(**config)



================================================
FILE: .github/workflows/build.yml
================================================
# .github/workflows/build.yml
name: Build and Package Desktop App

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [macos-latest, windows-latest]
        arch: [x64, arm64]

    steps:
      - uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.12'

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'

      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          cd server
          pip install -r requirements.txt

      - name: Install Node.js dependencies
        run: |
          npm install --force
          cd react
          npm install --force

      - name: Build Python app
        run: |
          cd server
          pyinstaller main.spec

      - name: Build React app
        env:
          VITE_UMAMI_WEBSITE_ID: ${{ secrets.UMAMI_WEBSITE_ID }}
          VITE_PUBLIC_POSTHOG_KEY: ${{ secrets.VITE_PUBLIC_POSTHOG_KEY }}
          VITE_PUBLIC_POSTHOG_HOST: ${{ secrets.VITE_PUBLIC_POSTHOG_HOST }}
        run: |
          cd react
          npx vite build

      - name: Install Apple certificate
        if: matrix.os == 'macos-latest'
        run: |
          echo "$CERTIFICATE_P12" | base64 --decode > certificate.p12
          security create-keychain -p "" build.keychain
          security default-keychain -s build.keychain
          security unlock-keychain -p "" build.keychain
          security import certificate.p12 -k build.keychain -P "$CERTIFICATE_PASSWORD" -T /usr/bin/codesign
          security set-key-partition-list -S apple-tool:,apple: -s -k "" build.keychain
        env:
          CERTIFICATE_P12: ${{ secrets.CERTIFICATE_P12 }}
          CERTIFICATE_PASSWORD: ${{ secrets.CERTIFICATE_PASSWORD }}

      - name: Set env for mac signing
        if: matrix.os == 'macos-latest'
        run: echo "CSC_LINK=certificate.p12" >> $GITHUB_ENV && echo "CSC_KEY_PASSWORD=${{ secrets.CERTIFICATE_PASSWORD }}" >> $GITHUB_ENV

      - name: Build and Package Electron app
        run: |
          npx electron-builder --${{ matrix.os == 'macos-latest' && 'mac' || 'win' }} --publish always
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_PASSWORD: ${{ secrets.APPLE_APP_PASSWORD }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_PASSWORD }} # Map the existing password
          TEAM_ID: ${{ secrets.TEAM_ID }}

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: desktop-app-${{ matrix.os }}-${{ matrix.arch }}-${{ github.run_id }}
          path: dist/
          overwrite: true


