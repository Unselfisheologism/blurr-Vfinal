Directory structure:
â””â”€â”€ hexdocom-lemonai/
    â”œâ”€â”€ README.md
    â”œâ”€â”€ API_README.md
    â”œâ”€â”€ CODE_OF_CONDUCT.md
    â”œâ”€â”€ CONTRIBUTING.md
    â”œâ”€â”€ CONTRIBUTING_CN.md
    â”œâ”€â”€ docker-compose.yml
    â”œâ”€â”€ dockerSetupService.js
    â”œâ”€â”€ entitlements.plist
    â”œâ”€â”€ forge.config.js
    â”œâ”€â”€ jsconfig.json
    â”œâ”€â”€ LICENSE
    â”œâ”€â”€ main.js
    â”œâ”€â”€ Makefile
    â”œâ”€â”€ nodemon.json
    â”œâ”€â”€ package.json
    â”œâ”€â”€ preload.js
    â”œâ”€â”€ README_CN.md
    â”œâ”€â”€ setup-renderer.js
    â”œâ”€â”€ setup.html
    â”œâ”€â”€ vite.main.config.js
    â”œâ”€â”€ vite.preload.config.js
    â”œâ”€â”€ WEB_README.md
    â”œâ”€â”€ .env.example
    â”œâ”€â”€ browser_server/
    â”‚   â”œâ”€â”€ readme.md
    â”‚   â”œâ”€â”€ pyproject.toml
    â”‚   â”œâ”€â”€ report.md
    â”‚   â”œâ”€â”€ requirements.txt
    â”‚   â”œâ”€â”€ browser_use/
    â”‚   â”‚   â”œâ”€â”€ server.py
    â”‚   â”‚   â”œâ”€â”€ agent/
    â”‚   â”‚   â”‚   â”œâ”€â”€ agent.py
    â”‚   â”‚   â”‚   â””â”€â”€ prompt/
    â”‚   â”‚   â”‚       â”œâ”€â”€ base_system_prompt.md
    â”‚   â”‚   â”‚       â””â”€â”€ extend/
    â”‚   â”‚   â”‚           â”œâ”€â”€ extend_prompt_v1.md
    â”‚   â”‚   â”‚           â””â”€â”€ extend_prompt_v2.md
    â”‚   â”‚   â”œâ”€â”€ browser/
    â”‚   â”‚   â”‚   â””â”€â”€ browser.py
    â”‚   â”‚   â”œâ”€â”€ config/
    â”‚   â”‚   â”‚   â”œâ”€â”€ config.yaml
    â”‚   â”‚   â”‚   â””â”€â”€ load_config.py
    â”‚   â”‚   â”œâ”€â”€ service/
    â”‚   â”‚   â”‚   â””â”€â”€ browser_agent.py
    â”‚   â”‚   â””â”€â”€ utils/
    â”‚   â”‚       â”œâ”€â”€ request_util.py
    â”‚   â”‚       â””â”€â”€ response_util.py
    â”‚   â””â”€â”€ test/
    â”‚       â””â”€â”€ chat_open_ai.py
    â”œâ”€â”€ containers/
    â”‚   â”œâ”€â”€ app/
    â”‚   â”‚   â”œâ”€â”€ Dockerfile
    â”‚   â”‚   â””â”€â”€ VERSION
    â”‚   â””â”€â”€ runtime/
    â”‚       â”œâ”€â”€ Dockerfile
    â”‚       â””â”€â”€ VERSION
    â”œâ”€â”€ frontend/
    â”‚   â”œâ”€â”€ README.md
    â”‚   â”œâ”€â”€ deploy.sh
    â”‚   â”œâ”€â”€ index.html
    â”‚   â”œâ”€â”€ jsconfig.json
    â”‚   â”œâ”€â”€ package.json
    â”‚   â”œâ”€â”€ vite.config.js
    â”‚   â”œâ”€â”€ .env.example
    â”‚   â”œâ”€â”€ .env.production
    â”‚   â””â”€â”€ src/
    â”‚       â”œâ”€â”€ App.vue
    â”‚       â”œâ”€â”€ main.js
    â”‚       â”œâ”€â”€ style.scss
    â”‚       â”œâ”€â”€ components/
    â”‚       â”‚   â”œâ”€â”€ logo.vue
    â”‚       â”‚   â”œâ”€â”€ Navbar.vue
    â”‚       â”‚   â”œâ”€â”€ browser/
    â”‚       â”‚   â”‚   â”œâ”€â”€ image.vue
    â”‚       â”‚   â”‚   â”œâ”€â”€ searchResults.vue
    â”‚       â”‚   â”‚   â””â”€â”€ video.vue
    â”‚       â”‚   â”œâ”€â”€ defaultModel/
    â”‚       â”‚   â”‚   â”œâ”€â”€ assistantSetting.vue
    â”‚       â”‚   â”‚   â”œâ”€â”€ index.vue
    â”‚       â”‚   â”‚   â”œâ”€â”€ selectModel.vue
    â”‚       â”‚   â”‚   â”œâ”€â”€ TopicNaming.vue
    â”‚       â”‚   â”‚   â””â”€â”€ translation.vue
    â”‚       â”‚   â”œâ”€â”€ DiffViewer/
    â”‚       â”‚   â”‚   â””â”€â”€ index.vue
    â”‚       â”‚   â”œâ”€â”€ file/
    â”‚       â”‚   â”‚   â”œâ”€â”€ imgModal.vue
    â”‚       â”‚   â”‚   â”œâ”€â”€ index.vue
    â”‚       â”‚   â”‚   â””â”€â”€ officePreview.vue
    â”‚       â”‚   â”œâ”€â”€ fileClass/
    â”‚       â”‚   â”‚   â””â”€â”€ fileSvg.vue
    â”‚       â”‚   â”œâ”€â”€ lang/
    â”‚       â”‚   â”‚   â””â”€â”€ index.vue
    â”‚       â”‚   â”œâ”€â”€ markdown/
    â”‚       â”‚   â”‚   â”œâ”€â”€ index.vue
    â”‚       â”‚   â”‚   â”œâ”€â”€ markdown-it-markmap.js
    â”‚       â”‚   â”‚   â”œâ”€â”€ markdown-it-mermaid.js
    â”‚       â”‚   â”‚   â”œâ”€â”€ markdown-it-prism.js
    â”‚       â”‚   â”‚   â””â”€â”€ markdown-it-think.js
    â”‚       â”‚   â”œâ”€â”€ mcpServer/
    â”‚       â”‚   â”‚   â”œâ”€â”€ index.vue
    â”‚       â”‚   â”‚   â”œâ”€â”€ ServerList.vue
    â”‚       â”‚   â”‚   â””â”€â”€ ServerSettings.vue
    â”‚       â”‚   â”œâ”€â”€ menu/
    â”‚       â”‚   â”‚   â”œâ”€â”€ LeftRight.vue
    â”‚       â”‚   â”‚   â”œâ”€â”€ TaskIcon.vue
    â”‚       â”‚   â”‚   â””â”€â”€ User.vue
    â”‚       â”‚   â”œâ”€â”€ MessageFileList/
    â”‚       â”‚   â”‚   â””â”€â”€ index.vue
    â”‚       â”‚   â”œâ”€â”€ office/
    â”‚       â”‚   â”‚   â”œâ”€â”€ docxPreview.vue
    â”‚       â”‚   â”‚   â”œâ”€â”€ pdfPreview.vue
    â”‚       â”‚   â”‚   â””â”€â”€ xlsxPreview.vue
    â”‚       â”‚   â”œâ”€â”€ platforms/
    â”‚       â”‚   â”‚   â”œâ”€â”€ addPlatform.vue
    â”‚       â”‚   â”‚   â”œâ”€â”€ modelinfo.vue
    â”‚       â”‚   â”‚   â”œâ”€â”€ modelsList.vue
    â”‚       â”‚   â”‚   â””â”€â”€ settingPlatform.vue
    â”‚       â”‚   â”œâ”€â”€ preview/
    â”‚       â”‚   â”‚   â”œâ”€â”€ fileClass.vue
    â”‚       â”‚   â”‚   â”œâ”€â”€ fullPreview.vue
    â”‚       â”‚   â”‚   â”œâ”€â”€ index.vue
    â”‚       â”‚   â”‚   â””â”€â”€ office.vue
    â”‚       â”‚   â”œâ”€â”€ searchEngine/
    â”‚       â”‚   â”‚   â””â”€â”€ index.vue
    â”‚       â”‚   â”œâ”€â”€ terminal/
    â”‚       â”‚   â”‚   â”œâ”€â”€ index.vue
    â”‚       â”‚   â”‚   â””â”€â”€ siderTerminal.vue
    â”‚       â”‚   â””â”€â”€ vscode/
    â”‚       â”‚       â”œâ”€â”€ fileTree.vue
    â”‚       â”‚       â””â”€â”€ index.vue
    â”‚       â”œâ”€â”€ locals/
    â”‚       â”‚   â”œâ”€â”€ index.js
    â”‚       â”‚   â”œâ”€â”€ lang/
    â”‚       â”‚   â”‚   â”œâ”€â”€ de.js
    â”‚       â”‚   â”‚   â”œâ”€â”€ en.js
    â”‚       â”‚   â”‚   â”œâ”€â”€ es.js
    â”‚       â”‚   â”‚   â”œâ”€â”€ fr.js
    â”‚       â”‚   â”‚   â”œâ”€â”€ ja.js
    â”‚       â”‚   â”‚   â”œâ”€â”€ kr.js
    â”‚       â”‚   â”‚   â”œâ”€â”€ pt.js
    â”‚       â”‚   â”‚   â”œâ”€â”€ tr.js
    â”‚       â”‚   â”‚   â”œâ”€â”€ tw.js
    â”‚       â”‚   â”‚   â”œâ”€â”€ vi.js
    â”‚       â”‚   â”‚   â””â”€â”€ zh.js
    â”‚       â”‚   â””â”€â”€ utils/
    â”‚       â”‚       â””â”€â”€ index.js
    â”‚       â”œâ”€â”€ router/
    â”‚       â”‚   â””â”€â”€ index.js
    â”‚       â”œâ”€â”€ services/
    â”‚       â”‚   â”œâ”€â”€ agent.js
    â”‚       â”‚   â”œâ”€â”€ auth.js
    â”‚       â”‚   â”œâ”€â”€ chat.js
    â”‚       â”‚   â”œâ”€â”€ default-model-setting.js
    â”‚       â”‚   â”œâ”€â”€ editor.js
    â”‚       â”‚   â”œâ”€â”€ experience.js
    â”‚       â”‚   â”œâ”€â”€ files.js
    â”‚       â”‚   â”œâ”€â”€ knowledge.js
    â”‚       â”‚   â”œâ”€â”€ mcp.js
    â”‚       â”‚   â”œâ”€â”€ membership.js
    â”‚       â”‚   â”œâ”€â”€ message.js
    â”‚       â”‚   â”œâ”€â”€ platforms.js
    â”‚       â”‚   â”œâ”€â”€ resume.js
    â”‚       â”‚   â”œâ”€â”€ search-engine.js
    â”‚       â”‚   â”œâ”€â”€ see-agent.js
    â”‚       â”‚   â”œâ”€â”€ setting.js
    â”‚       â”‚   â”œâ”€â”€ sse-coding.js
    â”‚       â”‚   â”œâ”€â”€ sse.js
    â”‚       â”‚   â”œâ”€â”€ version.js
    â”‚       â”‚   â”œâ”€â”€ workspace.js
    â”‚       â”‚   â””â”€â”€ wx-client.js
    â”‚       â”œâ”€â”€ store/
    â”‚       â”‚   â”œâ”€â”€ index.js
    â”‚       â”‚   â””â”€â”€ modules/
    â”‚       â”‚       â”œâ”€â”€ chat.js
    â”‚       â”‚       â”œâ”€â”€ demo.js
    â”‚       â”‚       â”œâ”€â”€ editor.js
    â”‚       â”‚       â”œâ”€â”€ server.js
    â”‚       â”‚       â””â”€â”€ user.js
    â”‚       â”œâ”€â”€ utils/
    â”‚       â”‚   â”œâ”€â”€ base64.js
    â”‚       â”‚   â”œâ”€â”€ chat.js
    â”‚       â”‚   â”œâ”€â”€ emitter.js
    â”‚       â”‚   â”œâ”€â”€ file.js
    â”‚       â”‚   â”œâ”€â”€ http.js
    â”‚       â”‚   â”œâ”€â”€ markdown.js
    â”‚       â”‚   â”œâ”€â”€ time.js
    â”‚       â”‚   â””â”€â”€ viewList.js
    â”‚       â””â”€â”€ view/
    â”‚           â”œâ”€â”€ agents/
    â”‚           â”‚   â”œâ”€â”€ index.vue
    â”‚           â”‚   â””â”€â”€ components/
    â”‚           â”‚       â”œâ”€â”€ agentsEdit.vue
    â”‚           â”‚       â””â”€â”€ KnowledgeModal.vue
    â”‚           â”œâ”€â”€ auth/
    â”‚           â”‚   â”œâ”€â”€ GoogleCallback.vue
    â”‚           â”‚   â”œâ”€â”€ index.vue
    â”‚           â”‚   â”œâ”€â”€ Login.vue
    â”‚           â”‚   â”œâ”€â”€ usage.vue
    â”‚           â”‚   â”œâ”€â”€ UserProfile.vue
    â”‚           â”‚   â””â”€â”€ components/
    â”‚           â”‚       â”œâ”€â”€ forgot.vue
    â”‚           â”‚       â”œâ”€â”€ login.vue
    â”‚           â”‚       â”œâ”€â”€ register.vue
    â”‚           â”‚       â”œâ”€â”€ sms-login.vue
    â”‚           â”‚       â””â”€â”€ user-profile.vue
    â”‚           â”œâ”€â”€ demo/
    â”‚           â”‚   â”œâ”€â”€ HelloWorld.vue
    â”‚           â”‚   â””â”€â”€ index.vue
    â”‚           â”œâ”€â”€ desktop/
    â”‚           â”‚   â””â”€â”€ redirect.vue
    â”‚           â”œâ”€â”€ editor/
    â”‚           â”‚   â”œâ”€â”€ index.vue
    â”‚           â”‚   â”œâ”€â”€ components/
    â”‚           â”‚   â”‚   â”œâ”€â”€ AIEditDialog.vue
    â”‚           â”‚   â”‚   â”œâ”€â”€ CodePanel.vue
    â”‚           â”‚   â”‚   â”œâ”€â”€ FileUploadArea.vue
    â”‚           â”‚   â”‚   â”œâ”€â”€ InlineEditModal.vue
    â”‚           â”‚   â”‚   â”œâ”€â”€ MediaEditDialog.vue
    â”‚           â”‚   â”‚   â”œâ”€â”€ PreviewArea.vue
    â”‚           â”‚   â”‚   â”œâ”€â”€ RichTextEditor.vue
    â”‚           â”‚   â”‚   â”œâ”€â”€ SidePanel.vue
    â”‚           â”‚   â”‚   â”œâ”€â”€ ToolBar.vue
    â”‚           â”‚   â”‚   â”œâ”€â”€ UploadStatus.vue
    â”‚           â”‚   â”‚   â”œâ”€â”€ VersionActions.vue
    â”‚           â”‚   â”‚   â”œâ”€â”€ VersionHistoryPanel.vue
    â”‚           â”‚   â”‚   â””â”€â”€ media/
    â”‚           â”‚   â”‚       â”œâ”€â”€ AIGeneratePanel.vue
    â”‚           â”‚   â”‚       â”œâ”€â”€ ImageSearchPanel.vue
    â”‚           â”‚   â”‚       â””â”€â”€ LocalReplacePanel.vue
    â”‚           â”‚   â”œâ”€â”€ composables/
    â”‚           â”‚   â”‚   â”œâ”€â”€ useAIPrompts.js
    â”‚           â”‚   â”‚   â”œâ”€â”€ useDragDrop.js
    â”‚           â”‚   â”‚   â”œâ”€â”€ useEditorCore.js
    â”‚           â”‚   â”‚   â”œâ”€â”€ useFileManager.js
    â”‚           â”‚   â”‚   â”œâ”€â”€ useFileUpload.js
    â”‚           â”‚   â”‚   â”œâ”€â”€ useNotification.js
    â”‚           â”‚   â”‚   â””â”€â”€ useVersionManager.js
    â”‚           â”‚   â””â”€â”€ render/
    â”‚           â”‚       â”œâ”€â”€ index.vue
    â”‚           â”‚       â”œâ”€â”€ components/
    â”‚           â”‚       â”‚   â”œâ”€â”€ EditInput.vue
    â”‚           â”‚       â”‚   â”œâ”€â”€ InteractionLayer.vue
    â”‚           â”‚       â”‚   â”œâ”€â”€ RenderCodeEditor.vue
    â”‚           â”‚       â”‚   â”œâ”€â”€ RenderPreview.vue
    â”‚           â”‚       â”‚   â””â”€â”€ RenderToolBar.vue
    â”‚           â”‚       â””â”€â”€ utils/
    â”‚           â”‚           â”œâ”€â”€ contentCleaner.js
    â”‚           â”‚           â”œâ”€â”€ iframeManager.js
    â”‚           â”‚           â””â”€â”€ previewTemplates.js
    â”‚           â”œâ”€â”€ lemon/
    â”‚           â”‚   â”œâ”€â”€ index.vue
    â”‚           â”‚   â”œâ”€â”€ components/
    â”‚           â”‚   â”‚   â”œâ”€â”€ ChatHeader.vue
    â”‚           â”‚   â”‚   â”œâ”€â”€ ChatInput.vue
    â”‚           â”‚   â”‚   â”œâ”€â”€ ChatInputFileList.vue
    â”‚           â”‚   â”‚   â”œâ”€â”€ ChatInputUpload.vue
    â”‚           â”‚   â”‚   â”œâ”€â”€ ChatMessages.vue
    â”‚           â”‚   â”‚   â”œâ”€â”€ ChatPanel.vue
    â”‚           â”‚   â”‚   â”œâ”€â”€ ChatReference.vue
    â”‚           â”‚   â”‚   â”œâ”€â”€ ChatTree.vue
    â”‚           â”‚   â”‚   â”œâ”€â”€ ConfirmPrompt.vue
    â”‚           â”‚   â”‚   â”œâ”€â”€ ConversationList.vue
    â”‚           â”‚   â”‚   â”œâ”€â”€ LoadingDots.vue
    â”‚           â”‚   â”‚   â”œâ”€â”€ ModelSelect.vue
    â”‚           â”‚   â”‚   â”œâ”€â”€ ModeSelector.vue
    â”‚           â”‚   â”‚   â”œâ”€â”€ Sample.vue
    â”‚           â”‚   â”‚   â”œâ”€â”€ SelectionPreview.vue
    â”‚           â”‚   â”‚   â”œâ”€â”€ Sidebar.vue
    â”‚           â”‚   â”‚   â”œâ”€â”€ Suggestion.vue
    â”‚           â”‚   â”‚   â””â”€â”€ SuggestionCard.vue
    â”‚           â”‚   â””â”€â”€ message/
    â”‚           â”‚       â”œâ”€â”€ Action.vue
    â”‚           â”‚       â”œâ”€â”€ CodingMessage.vue
    â”‚           â”‚       â”œâ”€â”€ index.vue
    â”‚           â”‚       â”œâ”€â”€ Message.vue
    â”‚           â”‚       â”œâ”€â”€ Observation.vue
    â”‚           â”‚       â””â”€â”€ Planing.vue
    â”‚           â”œâ”€â”€ menu/
    â”‚           â”‚   â”œâ”€â”€ FooterSocial.vue
    â”‚           â”‚   â”œâ”€â”€ index.vue
    â”‚           â”‚   â”œâ”€â”€ secondMenu.vue
    â”‚           â”‚   â””â”€â”€ UserVersion.vue
    â”‚           â”œâ”€â”€ pay/
    â”‚           â”‚   â”œâ”€â”€ paySuccess.vue
    â”‚           â”‚   â”œâ”€â”€ pricing.vue
    â”‚           â”‚   â””â”€â”€ components/
    â”‚           â”‚       â””â”€â”€ rechargeProducts.vue
    â”‚           â”œâ”€â”€ setting/
    â”‚           â”‚   â”œâ”€â”€ about.vue
    â”‚           â”‚   â”œâ”€â”€ basic.vue
    â”‚           â”‚   â”œâ”€â”€ ContentSide.vue
    â”‚           â”‚   â”œâ”€â”€ default-model.vue
    â”‚           â”‚   â”œâ”€â”€ defaultModelSetting.vue
    â”‚           â”‚   â”œâ”€â”€ experience.vue
    â”‚           â”‚   â”œâ”€â”€ index.vue
    â”‚           â”‚   â”œâ”€â”€ mcp.vue
    â”‚           â”‚   â”œâ”€â”€ MenuSide.vue
    â”‚           â”‚   â”œâ”€â”€ model.vue
    â”‚           â”‚   â””â”€â”€ search.vue
    â”‚           â”œâ”€â”€ share/
    â”‚           â”‚   â””â”€â”€ index.vue
    â”‚           â””â”€â”€ welcome/
    â”‚               â”œâ”€â”€ WelcomeView.vue
    â”‚               â”œâ”€â”€ components/
    â”‚               â”‚   â””â”€â”€ WelcomeLayout.vue
    â”‚               â””â”€â”€ composables/
    â”‚                   â””â”€â”€ useWelcomeCommon.js
    â”œâ”€â”€ public/
    â”‚   â””â”€â”€ schemas/
    â”‚       â”œâ”€â”€ conversation.json
    â”‚       â”œâ”€â”€ default_model_setting.json
    â”‚       â”œâ”€â”€ experience.json
    â”‚       â”œâ”€â”€ file.json
    â”‚       â”œâ”€â”€ model.json
    â”‚       â”œâ”€â”€ model_enable.json
    â”‚       â”œâ”€â”€ platform.json
    â”‚       â”œâ”€â”€ provider.json
    â”‚       â””â”€â”€ provider_setting_result.json
    â”œâ”€â”€ resources/
    â”‚   â””â”€â”€ browser/
    â”‚       â””â”€â”€ install.md
    â”œâ”€â”€ src/
    â”‚   â”œâ”€â”€ app.js
    â”‚   â”œâ”€â”€ globals.js
    â”‚   â”œâ”€â”€ agent/
    â”‚   â”‚   â”œâ”€â”€ AgenticAgent.js
    â”‚   â”‚   â”œâ”€â”€ AgenticAgent.run.js
    â”‚   â”‚   â”œâ”€â”€ conversationHistoryUtils.js
    â”‚   â”‚   â”œâ”€â”€ fileUtils.js
    â”‚   â”‚   â”œâ”€â”€ TaskManager.js
    â”‚   â”‚   â”œâ”€â”€ auto-reply/
    â”‚   â”‚   â”‚   â”œâ”€â”€ chat.reply.js
    â”‚   â”‚   â”‚   â””â”€â”€ index.js
    â”‚   â”‚   â”œâ”€â”€ chat-completion/
    â”‚   â”‚   â”‚   â””â”€â”€ index.js
    â”‚   â”‚   â”œâ”€â”€ chatbot/
    â”‚   â”‚   â”‚   â””â”€â”€ index.js
    â”‚   â”‚   â”œâ”€â”€ code-act/
    â”‚   â”‚   â”‚   â”œâ”€â”€ code-act.common.js
    â”‚   â”‚   â”‚   â”œâ”€â”€ code-act.js
    â”‚   â”‚   â”‚   â”œâ”€â”€ context-cache.llm.message.js
    â”‚   â”‚   â”‚   â”œâ”€â”€ context-cache.thinking.js
    â”‚   â”‚   â”‚   â”œâ”€â”€ evaluate.prompt.js
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.js
    â”‚   â”‚   â”‚   â”œâ”€â”€ message.js
    â”‚   â”‚   â”‚   â”œâ”€â”€ message.test.js
    â”‚   â”‚   â”‚   â”œâ”€â”€ thinking.js
    â”‚   â”‚   â”‚   â”œâ”€â”€ thinking.prompt.js
    â”‚   â”‚   â”‚   â””â”€â”€ thinking.util.js
    â”‚   â”‚   â”œâ”€â”€ generate-agent/
    â”‚   â”‚   â”‚   â”œâ”€â”€ generate_system_role.js
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.js
    â”‚   â”‚   â”‚   â””â”€â”€ knowledge.js
    â”‚   â”‚   â”œâ”€â”€ generate-title/
    â”‚   â”‚   â”‚   â””â”€â”€ index.js
    â”‚   â”‚   â”œâ”€â”€ intent-detection/
    â”‚   â”‚   â”‚   â””â”€â”€ index.js
    â”‚   â”‚   â”œâ”€â”€ memory/
    â”‚   â”‚   â”‚   â”œâ”€â”€ BaseMemory.js
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.js
    â”‚   â”‚   â”‚   â””â”€â”€ LocalMemory.js
    â”‚   â”‚   â”œâ”€â”€ planning/
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.js
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.test.js
    â”‚   â”‚   â”‚   â”œâ”€â”€ plan.run.js
    â”‚   â”‚   â”‚   â””â”€â”€ retry_with_format_fix.js
    â”‚   â”‚   â”œâ”€â”€ prompt/
    â”‚   â”‚   â”‚   â”œâ”€â”€ auto_reply.js
    â”‚   â”‚   â”‚   â”œâ”€â”€ chat.js
    â”‚   â”‚   â”‚   â”œâ”€â”€ chatbot-intent.js
    â”‚   â”‚   â”‚   â”œâ”€â”€ choose_agent.js
    â”‚   â”‚   â”‚   â”œâ”€â”€ choose_agent_question.js
    â”‚   â”‚   â”‚   â”œâ”€â”€ generate_agent.js
    â”‚   â”‚   â”‚   â”œâ”€â”€ generate_knowledge.js
    â”‚   â”‚   â”‚   â”œâ”€â”€ generate_result.js
    â”‚   â”‚   â”‚   â”œâ”€â”€ generate_title.js
    â”‚   â”‚   â”‚   â”œâ”€â”€ generate_todo.js
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.js
    â”‚   â”‚   â”‚   â”œâ”€â”€ intent_detection.js
    â”‚   â”‚   â”‚   â”œâ”€â”€ plan.js
    â”‚   â”‚   â”‚   â”œâ”€â”€ plan.test.js
    â”‚   â”‚   â”‚   â”œâ”€â”€ system.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ tool.js
    â”‚   â”‚   â”‚   â””â”€â”€ tool.test.js
    â”‚   â”‚   â”œâ”€â”€ reflection/
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.js
    â”‚   â”‚   â”‚   â””â”€â”€ llm.evaluate.js
    â”‚   â”‚   â”œâ”€â”€ summary/
    â”‚   â”‚   â”‚   â””â”€â”€ index.js
    â”‚   â”‚   â””â”€â”€ tools/
    â”‚   â”‚       â”œâ”€â”€ browser_use.js
    â”‚   â”‚       â””â”€â”€ index.js
    â”‚   â”œâ”€â”€ completion/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ calc.token.js
    â”‚   â”‚   â”œâ”€â”€ configs.js
    â”‚   â”‚   â”œâ”€â”€ handle.error.js
    â”‚   â”‚   â”œâ”€â”€ index.js
    â”‚   â”‚   â”œâ”€â”€ llm.azure.openai.js
    â”‚   â”‚   â”œâ”€â”€ llm.base.js
    â”‚   â”‚   â”œâ”€â”€ llm.config.js
    â”‚   â”‚   â”œâ”€â”€ llm.gemini.js
    â”‚   â”‚   â”œâ”€â”€ llm.one.js
    â”‚   â”‚   â”œâ”€â”€ log.record.js
    â”‚   â”‚   â””â”€â”€ resolveServiceConfig.js
    â”‚   â”œâ”€â”€ editor/
    â”‚   â”‚   â”œâ”€â”€ coding.continue.js
    â”‚   â”‚   â”œâ”€â”€ coding.js
    â”‚   â”‚   â”œâ”€â”€ content.txt
    â”‚   â”‚   â”œâ”€â”€ execute.js
    â”‚   â”‚   â”œâ”€â”€ resolve.js
    â”‚   â”‚   â”œâ”€â”€ template.txt
    â”‚   â”‚   â””â”€â”€ withRetry.js
    â”‚   â”œâ”€â”€ knowledge/
    â”‚   â”‚   â”œâ”€â”€ feedback.js
    â”‚   â”‚   â”œâ”€â”€ FileStorage.js
    â”‚   â”‚   â”œâ”€â”€ index.js
    â”‚   â”‚   â”œâ”€â”€ knowledge.util.js
    â”‚   â”‚   â””â”€â”€ MemoryStorage.js
    â”‚   â”œâ”€â”€ logger/
    â”‚   â”‚   â”œâ”€â”€ index.js
    â”‚   â”‚   â””â”€â”€ winston.js
    â”‚   â”œâ”€â”€ logging/
    â”‚   â”‚   â”œâ”€â”€ index.js
    â”‚   â”‚   â””â”€â”€ logger.js
    â”‚   â”œâ”€â”€ mcp/
    â”‚   â”‚   â”œâ”€â”€ action.js
    â”‚   â”‚   â”œâ”€â”€ binary.js
    â”‚   â”‚   â”œâ”€â”€ cache.js
    â”‚   â”‚   â”œâ”€â”€ client.js
    â”‚   â”‚   â”œâ”€â”€ prompt.js
    â”‚   â”‚   â”œâ”€â”€ server.js
    â”‚   â”‚   â”œâ”€â”€ tool.js
    â”‚   â”‚   â””â”€â”€ transport.js
    â”‚   â”œâ”€â”€ middlewares/
    â”‚   â”‚   â”œâ”€â”€ auth.js
    â”‚   â”‚   â”œâ”€â”€ setGlobalToken.js
    â”‚   â”‚   â””â”€â”€ wrap.context.js
    â”‚   â”œâ”€â”€ models/
    â”‚   â”‚   â”œâ”€â”€ Agent.js
    â”‚   â”‚   â”œâ”€â”€ BaseModel.js
    â”‚   â”‚   â”œâ”€â”€ Conversation.js
    â”‚   â”‚   â”œâ”€â”€ DefaultModelSetting.js
    â”‚   â”‚   â”œâ”€â”€ File.js
    â”‚   â”‚   â”œâ”€â”€ FileVersion.js
    â”‚   â”‚   â”œâ”€â”€ index.js
    â”‚   â”‚   â”œâ”€â”€ Knowledge.js
    â”‚   â”‚   â”œâ”€â”€ LLMLogs.js
    â”‚   â”‚   â”œâ”€â”€ McpServer.js
    â”‚   â”‚   â”œâ”€â”€ Message.js
    â”‚   â”‚   â”œâ”€â”€ Model.js
    â”‚   â”‚   â”œâ”€â”€ Platform.js
    â”‚   â”‚   â”œâ”€â”€ SearchProvider.js
    â”‚   â”‚   â”œâ”€â”€ sync.js
    â”‚   â”‚   â”œâ”€â”€ Task.js
    â”‚   â”‚   â”œâ”€â”€ User.js
    â”‚   â”‚   â”œâ”€â”€ UserProviderConfig.js
    â”‚   â”‚   â””â”€â”€ UserSearchSetting.js
    â”‚   â”œâ”€â”€ routers/
    â”‚   â”‚   â”œâ”€â”€ index.js
    â”‚   â”‚   â”œâ”€â”€ agent/
    â”‚   â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ agent.js
    â”‚   â”‚   â”‚   â”œâ”€â”€ chat.js
    â”‚   â”‚   â”‚   â”œâ”€â”€ coding.js
    â”‚   â”‚   â”‚   â”œâ”€â”€ coding.sse.js
    â”‚   â”‚   â”‚   â”œâ”€â”€ format.mock.js
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.js
    â”‚   â”‚   â”‚   â”œâ”€â”€ proxy.js
    â”‚   â”‚   â”‚   â”œâ”€â”€ run.js
    â”‚   â”‚   â”‚   â”œâ”€â”€ xml.txt
    â”‚   â”‚   â”‚   â””â”€â”€ utils/
    â”‚   â”‚   â”‚       â”œâ”€â”€ coding-agent.js
    â”‚   â”‚   â”‚       â”œâ”€â”€ coding-api.js
    â”‚   â”‚   â”‚       â”œâ”€â”€ coding-cleanup.js
    â”‚   â”‚   â”‚       â”œâ”€â”€ coding-executor.js
    â”‚   â”‚   â”‚       â”œâ”€â”€ coding-helpers.js
    â”‚   â”‚   â”‚       â”œâ”€â”€ coding-intent.js
    â”‚   â”‚   â”‚       â”œâ”€â”€ coding-messages.js
    â”‚   â”‚   â”‚       â””â”€â”€ coding-setup.js
    â”‚   â”‚   â”œâ”€â”€ agent_store/
    â”‚   â”‚   â”‚   â”œâ”€â”€ agent_remix.js
    â”‚   â”‚   â”‚   â”œâ”€â”€ agent_store.js
    â”‚   â”‚   â”‚   â””â”€â”€ index.js
    â”‚   â”‚   â”œâ”€â”€ conversation/
    â”‚   â”‚   â”‚   â”œâ”€â”€ conversation.js
    â”‚   â”‚   â”‚   â”œâ”€â”€ favorite.js
    â”‚   â”‚   â”‚   â””â”€â”€ index.js
    â”‚   â”‚   â”œâ”€â”€ conversation_case/
    â”‚   â”‚   â”‚   â”œâ”€â”€ conversation_case.js
    â”‚   â”‚   â”‚   â””â”€â”€ index.js
    â”‚   â”‚   â”œâ”€â”€ default_model_setting/
    â”‚   â”‚   â”‚   â”œâ”€â”€ default_model_setting.js
    â”‚   â”‚   â”‚   â””â”€â”€ index.js
    â”‚   â”‚   â”œâ”€â”€ file/
    â”‚   â”‚   â”‚   â”œâ”€â”€ editor.js
    â”‚   â”‚   â”‚   â”œâ”€â”€ file.js
    â”‚   â”‚   â”‚   â””â”€â”€ index.js
    â”‚   â”‚   â”œâ”€â”€ knowledge/
    â”‚   â”‚   â”‚   â”œâ”€â”€ category.js
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.js
    â”‚   â”‚   â”‚   â””â”€â”€ knowledge.js
    â”‚   â”‚   â”œâ”€â”€ mcp_server/
    â”‚   â”‚   â”‚   â”œâ”€â”€ connect.js
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.js
    â”‚   â”‚   â”‚   â””â”€â”€ mcp_server.js
    â”‚   â”‚   â”œâ”€â”€ membership_plan/
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.js
    â”‚   â”‚   â”‚   â””â”€â”€ membership_plan.js
    â”‚   â”‚   â”œâ”€â”€ message/
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.js
    â”‚   â”‚   â”‚   â””â”€â”€ message.js
    â”‚   â”‚   â”œâ”€â”€ model/
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.js
    â”‚   â”‚   â”‚   â””â”€â”€ model.js
    â”‚   â”‚   â”œâ”€â”€ order/
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.js
    â”‚   â”‚   â”‚   â””â”€â”€ order.js
    â”‚   â”‚   â”œâ”€â”€ payment/
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.js
    â”‚   â”‚   â”‚   â””â”€â”€ payment.js
    â”‚   â”‚   â”œâ”€â”€ platform/
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.js
    â”‚   â”‚   â”‚   â””â”€â”€ platform.js
    â”‚   â”‚   â”œâ”€â”€ points_transaction/
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.js
    â”‚   â”‚   â”‚   â””â”€â”€ points_transaction.js
    â”‚   â”‚   â”œâ”€â”€ recharge_product/
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.js
    â”‚   â”‚   â”‚   â””â”€â”€ recharge_product.js
    â”‚   â”‚   â”œâ”€â”€ runtime/
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.js
    â”‚   â”‚   â”‚   â””â”€â”€ runtime.js
    â”‚   â”‚   â”œâ”€â”€ search_provider_setting/
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.js
    â”‚   â”‚   â”‚   â””â”€â”€ setting.js
    â”‚   â”‚   â”œâ”€â”€ user/
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.js
    â”‚   â”‚   â”‚   â””â”€â”€ users.js
    â”‚   â”‚   â””â”€â”€ version/
    â”‚   â”‚       â”œâ”€â”€ index.js
    â”‚   â”‚       â””â”€â”€ version.js
    â”‚   â”œâ”€â”€ runtime/
    â”‚   â”‚   â”œâ”€â”€ action_execution_server.js
    â”‚   â”‚   â”œâ”€â”€ browser.js
    â”‚   â”‚   â”œâ”€â”€ DockerRuntime.d.ts
    â”‚   â”‚   â”œâ”€â”€ DockerRuntime.js
    â”‚   â”‚   â”œâ”€â”€ DockerRuntime.local.js
    â”‚   â”‚   â”œâ”€â”€ LocalRuntime.js
    â”‚   â”‚   â”œâ”€â”€ LocalRuntime.test.js
    â”‚   â”‚   â”œâ”€â”€ read_file.js
    â”‚   â”‚   â”œâ”€â”€ read_xlsx_optimized.js
    â”‚   â”‚   â”œâ”€â”€ runtime.util.js
    â”‚   â”‚   â”œâ”€â”€ terminal_run.js
    â”‚   â”‚   â”œâ”€â”€ plugins/
    â”‚   â”‚   â”‚   â”œâ”€â”€ browser/
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ index.js
    â”‚   â”‚   â”‚   â””â”€â”€ vscode/
    â”‚   â”‚   â”‚       â”œâ”€â”€ index.js
    â”‚   â”‚   â”‚       â””â”€â”€ settings.json
    â”‚   â”‚   â””â”€â”€ utils/
    â”‚   â”‚       â”œâ”€â”€ electron.js
    â”‚   â”‚       â”œâ”€â”€ system.js
    â”‚   â”‚       â””â”€â”€ tools.js
    â”‚   â”œâ”€â”€ swagger/
    â”‚   â”‚   â””â”€â”€ swagger.js
    â”‚   â”œâ”€â”€ template/
    â”‚   â”‚   â”œâ”€â”€ core_principle.dynamic.txt
    â”‚   â”‚   â”œâ”€â”€ core_principle.static.txt
    â”‚   â”‚   â”œâ”€â”€ knowledge.cn.txt
    â”‚   â”‚   â”œâ”€â”€ knowledge.txt
    â”‚   â”‚   â”œâ”€â”€ planning.search.cn.txt
    â”‚   â”‚   â”œâ”€â”€ planning.search.txt
    â”‚   â”‚   â”œâ”€â”€ planning.txt
    â”‚   â”‚   â”œâ”€â”€ search.template.txt
    â”‚   â”‚   â””â”€â”€ thinking.txt
    â”‚   â”œâ”€â”€ tools/
    â”‚   â”‚   â”œâ”€â”€ browser.js
    â”‚   â”‚   â”œâ”€â”€ index.js
    â”‚   â”‚   â”œâ”€â”€ read_file.js
    â”‚   â”‚   â”œâ”€â”€ terminal_run.js
    â”‚   â”‚   â”œâ”€â”€ WebSearch.js
    â”‚   â”‚   â”œâ”€â”€ write_code.js
    â”‚   â”‚   â””â”€â”€ impl/
    â”‚   â”‚       â””â”€â”€ web_search/
    â”‚   â”‚           â”œâ”€â”€ CloudswaySearch.js
    â”‚   â”‚           â”œâ”€â”€ GoogleSearch.js
    â”‚   â”‚           â”œâ”€â”€ GoogleSearch.run.js
    â”‚   â”‚           â”œâ”€â”€ LocalSearch.js
    â”‚   â”‚           â”œâ”€â”€ LocalSearch.run.js
    â”‚   â”‚           â”œâ”€â”€ TalivySearch.js
    â”‚   â”‚           â””â”€â”€ TalivySearch.run.js
    â”‚   â”œâ”€â”€ utils/
    â”‚   â”‚   â”œâ”€â”€ check_llm_api_availability.js
    â”‚   â”‚   â”œâ”€â”€ debug.js
    â”‚   â”‚   â”œâ”€â”€ default_model.js
    â”‚   â”‚   â”œâ”€â”€ electron.js
    â”‚   â”‚   â”œâ”€â”€ errors.js
    â”‚   â”‚   â”œâ”€â”€ file_type_response.js
    â”‚   â”‚   â”œâ”€â”€ filePathHelper.js
    â”‚   â”‚   â”œâ”€â”€ format.js
    â”‚   â”‚   â”œâ”€â”€ function.call.js
    â”‚   â”‚   â”œâ”€â”€ get_sub_server_token_usage.js
    â”‚   â”‚   â”œâ”€â”€ img_upload.js
    â”‚   â”‚   â”œâ”€â”€ json.js
    â”‚   â”‚   â”œâ”€â”€ jwt.js
    â”‚   â”‚   â”œâ”€â”€ llm.js
    â”‚   â”‚   â”œâ”€â”€ markdown.js
    â”‚   â”‚   â”œâ”€â”€ message.js
    â”‚   â”‚   â”œâ”€â”€ network.js
    â”‚   â”‚   â”œâ”€â”€ planning.js
    â”‚   â”‚   â”œâ”€â”€ resolve.js
    â”‚   â”‚   â”œâ”€â”€ screen_shot.js
    â”‚   â”‚   â”œâ”€â”€ stream.util.js
    â”‚   â”‚   â”œâ”€â”€ sub_server_forward_request.js
    â”‚   â”‚   â”œâ”€â”€ sub_server_request.js
    â”‚   â”‚   â”œâ”€â”€ template.js
    â”‚   â”‚   â”œâ”€â”€ text_to_image.js
    â”‚   â”‚   â”œâ”€â”€ thinking.js
    â”‚   â”‚   â”œâ”€â”€ validate.js
    â”‚   â”‚   â””â”€â”€ versionManager.js
    â”‚   â””â”€â”€ xml/
    â”‚       â”œâ”€â”€ index.js
    â”‚       â””â”€â”€ resolve.xml.optimize.js
    â”œâ”€â”€ test/
    â”‚   â””â”€â”€ api/
    â”‚       â””â”€â”€ platform/
    â”‚           â””â”€â”€ platform.test.js
    â”œâ”€â”€ types/
    â”‚   â”œâ”€â”€ LocalRuntime.d.ts
    â”‚   â””â”€â”€ Tool.d.ts
    â”œâ”€â”€ .github/
    â”‚   â””â”€â”€ workflows/
    â”‚       â””â”€â”€ app_docker_build_push.yml
    â””â”€â”€ .trae/
        â””â”€â”€ rules/
            â””â”€â”€ project_rules.md

================================================
FILE: README.md
================================================

# Lemon AIâ€‹ is the first Full-stack Open-source Self-Evolving General AI Agent, offering a â€‹fully local alternativeâ€‹ to Agentic platforms like Manus & Genspark AI. It features an integrated Code Interpreter VM sandbox for safe execution.â€‹â€‹
<br><br>
<div align=center>
  <img src="./public/img/LemonAI_Evolving.png" width="500">
</div>
<br><br>
<p align="center">
  <a href="https://lemon-11.gitbook.io/lemonai">Get to know Lemon AI quickly</a> Â·
  <a href="https://lemon-11.gitbook.io/lemonai/development-deployment-guidelines/docker-quick-deployment">Docker Quick Deployment</a> Â·
  <a href="https://lemon-11.gitbook.io/lemonai/">Documentation</a> Â·
  <a href="https://lemonai.cc/">Visit the official website</a> Â·
  <a href="https://deepwiki.com/hexdocom/lemonai">DeepWiki</a> 
</p>

<p align="center">
  <a href="./README.md"><img alt="README in English" src="https://img.shields.io/badge/English-d9d9d9"></a>
  <a href="./README_CN.md"><img alt="ç®€ä½“ä¸­æ–‡ç‰ˆè‡ªè¿°æ–‡ä»¶" src="https://img.shields.io/badge/ç®€ä½“ä¸­æ–‡-d9d9d9"></a>
</p>


**Lemon AIâ€‹** is the first **â€‹Full-stack Open-source Self-Evolving General AI Agent**, offering a **â€‹fully local alternativeâ€‹** to Agentic platforms like **Manus & Genspark AI. It features an integrated Code Interpreter VM sandbox for safe execution**.â€‹â€‹

**â€‹Lemon AI empowers deep research, web browsing, viable coding, and data analysis â€“ running entirely on your local hardware.â€‹â€‹** It supports â€‹**planning, action, reflection, and memoryâ€‹** functionalities using **â€‹local LLMs**â€‹ (like DeepSeek,Kimiï¼ŒQwen, Llama, Gemma,GPTOSS) via **Ollama,VLLM**, ensuring **â€‹complete privacy and zero cloud dependency.**

For enhanced security, Lemon AI operates within a â€‹**local Virtual Machine (VM) sandbox by Docker.** This sandbox **â€‹protects your machine's files and operating systemâ€‹** by safely handling all code writing, execution, and editing tasks.

Additionally, Lemon AI provides the **â€‹flexibility to configure enhanced results**â€‹ using APIs from leading cloud models like **â€‹Claude, GPT, Gemini, and Grok.**

<a href="https://youtu.be/OmU_4rrZUHE?si=iseqOl5TV2n2kovy">
  <figure>
    <img src="./public/img/githubvideo.png" alt="">
  </figure>
</a>

### function and characteristic
The world's first Full-stack Open-source Self Evolving General AI Agent framework with comprehensive capabilities
#### Multi: Infinite possibilities
General AI Agent capabilities supporting unlimited task scenarios, including:
- Deep search & research reports
- Code generation & data analysis
- Content creation & document processing
Supports experience repository for self-learning and extending enterprise-specific customizations.

#### Self-Evolving
Make a personal memory for every conversation. Which make the Agent be more clever more used.

#### AI Agent HTML Editor
You could click the HTML element and change it by AI Agent. No need to re-generate all the HTML files every time. 
Change it over and over again until satisfied.


**Deployment options:** Open source code, Container, Client application, Online subscription - compatible with cloud/local/all-in-one systems

#### Fast: Rapid Deploy
One-click deployment for immediate usage with minimal technical requirements:
- Simplified installation process for all deployment options
- Quick setup without complex configurations
- Ready-to-use system within minutes

Supporting various deployment environments from personal computers to enterprise servers, with comprehensive documentation for smooth implementation.

#### Good: Powerful & Flexibility
Feature-rich framework with extensive capabilities:
- Virtual machine integration
- Code generation & execution
- Browser operations & web search
- Multi-tool integration

Highly adaptable architecture allows for custom modifications and extensions to fit specific business requirements and integration with existing systems.

#### Economic: Same qualityï¼Œ10x cheaper
Dramatically reduced operational costs:
- Task execution costs 1/10 - 1/100 of other agent products
- Open source subscription model
- Based on open source DeepSeekV3 model

Significant cost savings without compromising on quality or performance, making advanced AI capabilities accessible to organizations of all sizes.

### Lemon AI Editor

**The worldâ€™s first General AI Agent Editor---Lemon AI Editor**

#### Why do we need a General AI Agent Editor? 

When you use an Agent to creating a research report, Vibe coding, or generating a data analysis chart, the results often are not perfect. And when you try to fix one part, the rest may get messed up . What we really need is seamless collaboration between humans and AI. Lemon AI Editor empowers you to refine all this results as many times as needed ,until youâ€™re completely satisfied. You can Edit it Over and over and over again. 

#### function and characteristic

Lemon AI Editor lets you continuously edit, modify, and refine your generated HTML pages. What you see is what you get, and you can change anything just by clicking on it.

1.AI Editing Modeï¼š

 - Let AI modify any section content on the page.

 - Let AI insert new paragraphs or content.

- Let AI reformat the entire page.

2.Advanced Edit Modeï¼šDirect editing for quick manual text adjustments.

<a href="https://youtu.be/XaU4Vnt1lTI?si=iQJRSAaiUcqaN45k">
  <figure>
    <img src="./public/img/githubEditor2.png" alt="">
  </figure>
</a>


### Using Lemon AI

* Quickly get Lemon AI running in your environment with this starter guide. Use our [documentation](https://document.lemonai.cc/) for further references and more in-depth instructions.

### System Requirements[â€‹](https://docs.all-hands.dev/modules/usage/installation#system-requirements) <a href="#system-requirements" id="system-requirements"></a>

* MacOS with [Docker Desktop support](https://docs.docker.com/desktop/setup/install/mac-install/#system-requirements)
* Linux
* Windows with [WSL](https://learn.microsoft.com/en-us/windows/wsl/install) and [Docker Desktop support](https://docs.docker.com/desktop/setup/install/windows-install/#system-requirements)

A system with a modern processor and a minimum of **4GB RAM** is recommended to run Lemon AI.

### Prerequisites <a href="#prerequisites" id="prerequisites"></a>

#### MacOS

**Docker Desktop**

1. [Install Docker Desktop on Mac](https://docs.docker.com/desktop/setup/install/mac-install).
2. Open Docker Desktop, go to `Settings > Advanced` and ensure `Allow the default Docker socket to be used` is enabled.

#### Linux

Tested with Ubuntu 22.04.

**Docker Desktop**

1. [Install Docker Desktop on Linux](https://docs.docker.com/desktop/setup/install/linux/).

#### Windows

**WSL**

1. [Install WSL](https://learn.microsoft.com/en-us/windows/wsl/install).
2. Run `wsl --version` in powershell and confirm `Default Version: 2`.

**Docker Desktop**

1. [Install Docker Desktop on Windows](https://docs.docker.com/desktop/setup/install/windows-install).
2. Open Docker Desktop, go to `Settings` and confirm the following:

* General: `Use the WSL 2 based engine` is enabled.
* Resources > WSL Integration: `Enable integration with my default WSL distro` is enabled.

**note**

The docker command below to start the app must be run inside the WSL terminal.

### Start the App <a href="#start-the-app" id="start-the-app"></a>

The easiest way to run Lemon AI is in Docker.

```bash
docker pull hexdolemonai/lemon-runtime-sandbox:latest

docker run -it --rm --pull=always \
  --name lemon-app \
  --env DOCKER_HOST_ADDR=host.docker.internal \
  --env ACTUAL_HOST_WORKSPACE_PATH=${WORKSPACE_BASE:-$PWD/workspace} \
  --publish 5005:5005 \
  --add-host host.docker.internal:host-gateway \
  --volume /var/run/docker.sock:/var/run/docker.sock \
  --volume ~/.cache:/.cache \
  --volume ${WORKSPACE_BASE:-$PWD/workspace}:/workspace \
  --volume ${WORKSPACE_BASE:-$PWD/data}:/app/data \
  --interactive \
  --tty \
  hexdolemonai/lemon:latest make run
```

### Contributing

For those who'd like to contribute code, see our [Contribution Guide](https://github.com/hexdocom/lemon/blob/main/CONTRIBUTING.md). At the same time, please consider supporting Lemon AI by sharing it on social media and at events and conferences.

#### contributors

<a href="https://github.com/hexdocom/lemonai/graphs/contributors">
  <img src="https://contrib.rocks/image?repo=hexdocom/lemonai" />
</a>

### Community & contact

We welcome your contribution to lemon AI to help improve lemon AI. Include: submit code, questions, new ideas, or share interesting and useful AI applications you have created based on lemon AI. We also welcome you to share lemon AI at different events, conferences and social media.

* [GitHub Discussion](https://github.com/hexdocom/lemonai/discussions). Best for: sharing feedback and asking questions.
* [GitHub Issues](https://github.com/hexdocom/Lemon/issues).Best for: bugs you encounter using Lemon.AI, and feature proposals. See our [Contribution Guide](https://github.com/hexdocom/lemon/blob/main/CONTRIBUTING.md).
* [X(Twitter)](https://x.com/LemonAI_cc). Best for: sharing your applications and hanging out with the community.
* [Discord](https://discord.com/invite/gjEXg4UBR4). Best for: sharing your applications and hanging out with the community.
* commercial licenseï¼ˆ[feedback@lemonai.cc](mailto:feedback@lemonai.cc)ï¼‰. Business consulting on commercial use licensing lemon AI.

### Star History

[![Star History Chart](https://api.star-history.com/svg?repos=hexdocom/lemonai&type=Date)](https://www.star-history.com/#hexdocom/lemonai&Date)

### Security disclosure

To protect your privacy, please avoid posting security issues on GitHub. Instead, send your questions to [feedback@lemonai.cc](mailto:feedback@lemonai.cc) and we will provide you with a more detailed answer.

### License

This repository is available under the [Lemon AI Open Source License](https://github.com/hexdocom/lemon/blob/main/LICENSE), which is essentially Apache 2.0 with a few additional restrictions.



================================================
FILE: API_README.md
================================================

### Backend Configuration File

The backend configuration file is located at the root of the project.envFile. You can refer.env.exampleFile to learn about the available configuration items and their examples.

#### Configuration Item Description

* **STORAGE\_PATH**
  * Description: Defines where SQLite database files are stored.
  * Default:data/database.sqlite
  * Example:

STORAGE\_PATH=data/database.sqlite\


*
  * Note: If not configured, the system will use the defaultdata/database.sqliteAs the storage path for the database file.
* **WORKSPACE\_DIR**
  * Description: Defines the mapping path of the workspace on the local host.
  * Example:

WORKSPACE\_DIR=workspace\


* **RUNTIME\_TYPE**
  * Description: Defines how to start the backend service.
  * Default:docker(Sandbox Environment required)
  * Optional values:
    * docker: The default value, which means running in the Docker sandbox environment.
    * local: For developers to use when debugging locally.
  * Example:

RUNTIME\_TYPE=docker\



================================================
FILE: CODE_OF_CONDUCT.md
================================================
---
icon: file-lines
---

# CODE\_OF\_CONDUCT

## Our Pledge

In the interest of fostering an open and welcoming environment, we as
\
contributors and maintainers pledge to make participation in our project and
\
our community a harassment-free experience for everyone, regardless of age, body
\
size, disability, ethnicity, sex characteristics, gender identity, expression,
\
level of experience, education, socio-economic status, nationality, personal
\
appearance, race, religion, or sexual identity and orientation.

## Our Standards

Examples of behavior that contributes to creating a positive environment
\
include:

* Using welcoming and inclusive language
* Being respectful of differing viewpoints and experiences
* Gracefully accepting constructive criticism
* Focusing on what is best for the community
* Showing empathy towards other community members

Examples of unacceptable behavior by participants include:

* The use of sexualized language or imagery and unwelcome sexual attention or
  \
  advances
* Trolling, insulting/derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or electronic
  \
  address, without explicit permission
* Other conduct which could reasonably be considered inappropriate in a
  \
  professional setting

## Our Responsibilities

Project maintainers are responsible for clarifying the standards of acceptable
\
behavior and are expected to take appropriate and fair corrective action in
\
response to any instances of unacceptable behavior.

Project maintainers have the right and responsibility to remove, edit, or
\
reject comments, commits, code, wiki edits, issues, and other contributions
\
that are not aligned to this Code of Conduct, or to ban temporarily or
\
permanently any contributor for other behaviors that they deem inappropriate,
\
threatening, offensive, or harmful.

## Scope

This Code of Conduct applies both within project spaces and in public spaces
\
when an individual is representing the project or its community. Examples of
\
representing a project or community include using an official project e-mail
\
address, posting via an official social media account, or acting as an appointed
\
representative at an online or offline event. Representation of a project may be
\
further defined and clarified by project maintainers.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
\
reported by contacting the project team at service@hexdo.com. All
\
complaints will be reviewed and investigated and will result in a response that
\
is deemed necessary and appropriate to the circumstances. The project team is
\
obligated to maintain confidentiality with regard to the reporter of an incident.
\
Further details of specific enforcement policies may be posted separately.

Project maintainers who do not follow or enforce the Code of Conduct in good
\
faith may face temporary or permanent repercussions as determined by other
\
members of the project's leadership.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant](https://www.contributor-covenant.org), version 1.4,
\
available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html

For answers to common questions about this code of conduct, see
\
https://www.contributor-covenant.org/faq



================================================
FILE: CONTRIBUTING.md
================================================
---
icon: file-lines
---

# CONTRIBUTING

So you're looking to contribute to Lemon - that's awesome, we can't wait to see what you do. As a startup with limited headcount and funding, we have grand ambitions to design the most intuitive workflow for building and managing LLM applications. Any help from the community counts, truly.

We need to be nimble and ship fast given where we are, but we also want to make sure that contributors like you get as smooth an experience at contributing as possible. We've assembled this contribution guide for that purpose, aiming at getting you familiarized with the codebase & how we work with contributors, so you could quickly jump to the fun part.

This guide, like Lemon itself, is a constant work in progress. We highly appreciate your understanding if at times it lags behind the actual project, and welcome any feedback for us to improve.

In terms of licensing, please take a minute to read our short License and Contributor Agreement. The community also adheres to the [code of conduct](https://github.com/hexdocom/lemon/blob/main/CODE_OF_CONDUCT.md).

### Bug reports

> \[!IMPORTANT]
> \
> Please make sure to include the following information when submitting a bug report:

* A clear and descriptive title
* A detailed description of the bug, including any error messages
* Steps to reproduce the bug
* Expected behavior
* **Logs**, if available, for backend issues, this is really important, you can find them in docker-compose logs
* Screenshots or videos, if applicable

### Feature requests

> \[!NOTE]
> \
> Please make sure to include the following information when submitting a feature request:

* A clear and descriptive title
* A detailed description of the feature
* A use case for the feature
* Any other context or screenshots about the feature request


## Submitting your PR

### Pull Request Process

1. Fork the repository
2. Before you draft a PR, please create an issue to discuss the changes you want to make
3. Create a new branch for your changes
4. Please add tests for your changes accordingly
5. Ensure your code passes the existing tests
6. Please link the issue in the PR description, `fixes #<issue_number>`
7. Get merged!

### Setup the project

#### Frontend

For setting up the frontend service, please refer to our comprehensive [guide](https://github.com/hexdocom/lemon/blob/main/frontend/WEB_README.md) in the `frontend/README.md` file. This document provides detailed instructions to help you set up the frontend environment properly.

#### Backend

For setting up the backend service, kindly refer to our detailed [instructions](https://github.com/hexdocom/lemon/blob/main/API_README.md) in the `api/README.md` file. This document contains step-by-step guidance to help you get the backend up and running smoothly.

#### Other things to note

We recommend reviewing this document carefully before proceeding with the setup, as it contains essential information about:

* Prerequisites and dependencies
* Installation steps
* Configuration details
* Common troubleshooting tips

Feel free to reach out if you encounter any issues during the setup process.

## Getting Help

If you ever get stuck or get a burning question while contributing, simply shoot your queries our way via the related GitHub issue for a quick chat.



================================================
FILE: CONTRIBUTING_CN.md
================================================
---
icon: file-lines
---

# CONTRIBUTING\_CN

éå¸¸æ„Ÿè°¢ä½ è€ƒè™‘ä¸º Lemon åšå‡ºè´¡çŒ®ï¼ä½œä¸ºä¸€å®¶èµ„æºæœ‰é™çš„åˆ›ä¸šå…¬å¸ï¼Œç¤¾åŒºçš„æ¯ä¸€ä»½è´¡çŒ®å¯¹æˆ‘ä»¬æ¥è¯´éƒ½å¼¥è¶³çè´µã€‚

æˆ‘ä»¬éœ€è¦ä¿æŒæ•æ·å’Œå¿«é€Ÿè¿­ä»£ï¼ŒåŒæ—¶ä¹Ÿå¸Œæœ›ç¡®ä¿è´¡çŒ®è€…èƒ½è·å¾—å°½å¯èƒ½æµç•…çš„å‚ä¸ä½“éªŒã€‚è¿™ä»½è´¡çŒ®æŒ‡å—æ—¨åœ¨å¸®åŠ©ä½ ç†Ÿæ‚‰ä»£ç åº“å’Œæˆ‘ä»¬çš„å·¥ä½œæ–¹å¼ï¼Œè®©ä½ å¯ä»¥å°½å¿«è¿›å…¥æœ‰è¶£çš„å¼€å‘ç¯èŠ‚ã€‚

æœ¬æŒ‡å—å’Œ Lemon ä¸€æ ·åœ¨ä¸æ–­å®Œå–„ä¸­ã€‚å¦‚æœæœ‰ä»»ä½•æ»åäºé¡¹ç›®å®é™…æƒ…å†µçš„åœ°æ–¹ï¼Œæ³è¯·è°…è§£ï¼Œæˆ‘ä»¬ä¹Ÿæ¬¢è¿ä»»ä½•æ”¹è¿›å»ºè®®ã€‚

å…³äºè®¸å¯è¯ï¼Œè¯·èŠ±ä¸€åˆ†é’Ÿé˜…è¯»æˆ‘ä»¬ç®€çŸ­çš„è®¸å¯å’Œè´¡çŒ®è€…åè®®ã€‚ç¤¾åŒºåŒæ—¶ä¹Ÿéµå¾ª[è¡Œä¸ºå‡†åˆ™](https://github.com/hexdocom/lemon/blob/main/CODE_OF_CONDUCT.md)ã€‚

åŠ å…¥æˆ‘ä»¬ï¼Œä¸€èµ·è´¡çŒ®ï¼Œå…±åŒæ‰“é€ ç²¾å½©é¡¹ç›®ï¼ğŸ’¡âœ¨

è¯·è®°å¾—åœ¨ PR æè¿°ä¸­å…³è”ç°æœ‰ issue æˆ–åˆ›å»ºæ–°çš„ issueã€‚

### Bug æŠ¥å‘Š

> \[!IMPORTANT]
> \
> æäº¤ bug æŠ¥å‘Šæ—¶è¯·åŠ¡å¿…åŒ…å«ä»¥ä¸‹ä¿¡æ¯ï¼š

* æ¸…æ™°æè¿°æ€§çš„æ ‡é¢˜
* è¯¦ç»†çš„ bug æè¿°ï¼ŒåŒ…æ‹¬ä»»ä½•é”™è¯¯ä¿¡æ¯
* å¤ç°æ­¥éª¤
* é¢„æœŸè¡Œä¸º
* æˆªå›¾æˆ–è§†é¢‘ï¼ˆå¦‚æœé€‚ç”¨ï¼‰

ä¼˜å…ˆçº§åˆ’åˆ†ï¼š

| é—®é¢˜ç±»å‹                           | ä¼˜å…ˆçº§   |
| ------------------------------ | ----- |
| æ ¸å¿ƒåŠŸèƒ½ bugï¼ˆäº‘æœåŠ¡ã€ç™»å½•å¤±è´¥ã€åº”ç”¨æ— æ³•ä½¿ç”¨ã€å®‰å…¨æ¼æ´ï¼‰ | ç´§æ€¥    |
| éå…³é”® bugã€æ€§èƒ½ä¼˜åŒ–                   | ä¸­ç­‰ä¼˜å…ˆçº§ |
| å°ä¿®å¤ï¼ˆæ‹¼å†™é”™è¯¯ã€ç•Œé¢æ··ä¹±ä½†å¯ç”¨ï¼‰              | ä½ä¼˜å…ˆçº§  |

### åŠŸèƒ½è¯·æ±‚

> \[!NOTE]
> \
> æäº¤åŠŸèƒ½è¯·æ±‚æ—¶è¯·åŠ¡å¿…åŒ…å«ä»¥ä¸‹ä¿¡æ¯ï¼š

* æ¸…æ™°æè¿°æ€§çš„æ ‡é¢˜
* è¯¦ç»†çš„åŠŸèƒ½æè¿°
* åŠŸèƒ½ä½¿ç”¨åœºæ™¯
* å…¶ä»–ç›¸å…³ä¸Šä¸‹æ–‡æˆ–æˆªå›¾

## æäº¤ PR

### é¡¹ç›®è®¾ç½®

### PR æäº¤æµç¨‹

1. Fork æœ¬ä»“åº“
2. åœ¨æäº¤ PR ä¹‹å‰ï¼Œè¯·å…ˆåˆ›å»º issue è®¨è®ºä½ æƒ³è¦åšçš„ä¿®æ”¹
3. ä¸ºä½ çš„ä¿®æ”¹åˆ›å»ºä¸€ä¸ªæ–°çš„åˆ†æ”¯
4. è¯·ä¸ºä½ çš„ä¿®æ”¹æ·»åŠ ç›¸åº”çš„æµ‹è¯•
5. ç¡®ä¿ä½ çš„ä»£ç èƒ½é€šè¿‡ç°æœ‰çš„æµ‹è¯•
6. è¯·åœ¨ PR æè¿°ä¸­å…³è”ç›¸å…³ issueï¼Œæ ¼å¼ä¸º `fixes #<issueç¼–å·>`
7. ç­‰å¾…åˆå¹¶ï¼

#### å‰ç«¯

å…³äºå‰ç«¯æœåŠ¡çš„è®¾ç½®ï¼Œè¯·å‚è€ƒ `frontend/README.md` æ–‡ä»¶ä¸­çš„[è¯¦ç»†æŒ‡å—](https://github.com/hexdocom/lemon/blob/main/frontend/WEB_README.md)ã€‚è¯¥æ–‡æ¡£æä¾›äº†å¸®åŠ©ä½ æ­£ç¡®é…ç½®å‰ç«¯ç¯å¢ƒçš„è¯¦ç»†è¯´æ˜ã€‚

#### åç«¯

å…³äºåç«¯æœåŠ¡çš„è®¾ç½®ï¼Œè¯·å‚è€ƒ `API_README.md` æ–‡ä»¶ä¸­çš„[è¯¦ç»†è¯´æ˜](https://github.com/hexdocom/lemon/blob/main/API_README.md)ã€‚è¯¥æ–‡æ¡£åŒ…å«äº†å¸®åŠ©ä½ é¡ºåˆ©è¿è¡Œåç«¯çš„æ­¥éª¤è¯´æ˜ã€‚

#### å…¶ä»–æ³¨æ„äº‹é¡¹

æˆ‘ä»¬å»ºè®®åœ¨å¼€å§‹è®¾ç½®ä¹‹å‰ä»”ç»†é˜…è¯»æœ¬æ–‡æ¡£ï¼Œå› ä¸ºå®ƒåŒ…å«ä»¥ä¸‹é‡è¦ä¿¡æ¯ï¼š

* å‰ç½®æ¡ä»¶å’Œä¾èµ–é¡¹
* å®‰è£…æ­¥éª¤
* é…ç½®ç»†èŠ‚
* å¸¸è§é—®é¢˜è§£å†³æ–¹æ¡ˆ

å¦‚æœåœ¨è®¾ç½®è¿‡ç¨‹ä¸­é‡åˆ°ä»»ä½•é—®é¢˜ï¼Œè¯·éšæ—¶è”ç³»æˆ‘ä»¬ã€‚

## è·å–å¸®åŠ©

å¦‚æœä½ åœ¨è´¡çŒ®è¿‡ç¨‹ä¸­é‡åˆ°å›°éš¾æˆ–æœ‰ç´§æ€¥é—®é¢˜ï¼Œå¯ä»¥é€šè¿‡ç›¸å…³ GitHub issue å‘æˆ‘ä»¬æé—®ï¼Œè¿›è¡Œå¿«é€Ÿäº¤æµã€‚



================================================
FILE: docker-compose.yml
================================================

services:
  lemon:
    image: hexdolemonai/lemon:latest
    container_name: lemon-app
    environment:
      - DOCKER_HOST_ADDR=host.docker.internal
      - ACTUAL_HOST_WORKSPACE_PATH=${WORKSPACE_BASE:-$PWD/workspace}
    ports:
      - "5005:5005"
    extra_hosts:
      - "host.docker.internal:host-gateway"
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - ~/.cache:/.cache
      - ${WORKSPACE_BASE:-$PWD/workspace}:/app/workspace
      - ${WORKSPACE_BASE:-$PWD/data}:/app/data
    stdin_open: true
    tty: true
    command: make run



================================================
FILE: dockerSetupService.js
================================================
// src/dockerSetupService.js

const { app, ipcMain, BrowserWindow } = require('electron');
const { exec, spawn } = require('child_process');
const fs = require('fs');
const path = require('path');
const https = require('https');

// --- Configuration Constants ---
const DOCKER_SETUP_DONE_KEY = 'dockerSetupDone';

// Complete image name and tag
const REQUIRED_DOCKER_IMAGE = 'hexdolemonai/lemon-runtime-sandbox:latest';

// Complete image package download address (you need to provide the actual download URL)
// Please replace with the actual network address where your lemon_runtime_sandbox.tar file is stored
const DOCKER_IMAGE_TAR_URL = '';

// Complete locally saved image package file name
const DOWNLOADED_IMAGE_FILE_NAME = 'lemon_runtime_sandbox.tar';

// --- Internal State (Set during initialization) ---
let store;
let userDataPath;


//è·å–dockerimagefilename  ä¸åŒçš„ç³»ç»Ÿæ¶æ„ä¸ä¸€æ ·
function getDockerImageFileName() {
    let arch = process.arch;
    if (arch === 'x64' ) {
        return 'lemon_runtime_sandbox-x64.tar';
    } else if (arch === 'arm64') {
        return 'lemon_runtime_sandbox-arm64.tar';
    } else {
        return 'lemon_runtime_sandbox-x64.tar';
    }
}

// --- Initialization Function ---
function initDockerSetupService(options) {
    ({ store, userDataPath } = options);

    // --- IPC Handlers ---
    ipcMain.handle('check-docker-setup', async () => {
        const setupDone = store.get(DOCKER_SETUP_DONE_KEY, false);
        return setupDone;
    });

    ipcMain.handle('start-docker-setup', async (event) => {
        console.log('Triggering start-docker-setup');
        const mainWindow = BrowserWindow.fromWebContents(event.sender);
        checkAndRunDockerSetup(mainWindow)
       
    });
}

// --- Helper Functions (Async) ---

/**
 * Checks if Docker is installed and running
 */
const process = require('process');

/**
 * Checks Docker availability
 */
async function checkDockerAvailability(webContents) {
    try {
        await executeDockerInfo();
        return  true;
    } catch (error) {
        // Installation failed, install docker
        webContents.send('setup-status', { 
            step: 'installing-docker',
            message: 'Docker is not installed or not installing.'
        });
        // let res = await installDocker(webContents);
        // console.log('Docker installation result:', res);
        return  false;
    }
}


// Install Docker
//http://lemon-ai.oss-cn-beijing.aliyuncs.com/docker/Docker-windows.exe
async function installDocker(webContents) {
    try {
        // Step 1: Detect system
        const os = await checkSystem(); 
        console.log("System type", os);
        let download_file_name = "";

        switch (os) {
            case 'win64':
                download_file_name = 'Docker-windows.exe';
                break;
            case 'macos-apple':
                download_file_name = 'Docker-apple.dmg';
                break;
            case 'macos-intel':
                download_file_name = 'Docker-intel.dmg';
                break;
            default:
                return false; // If OS is not supported, return false directly
        }

        if (download_file_name !== "") {
            // const download_url = `https://lemon-ai.oss-cn-beijing.aliyuncs.com/docker/${download_file_name}`;
            // const downloadedFilePath = path.join(userDataPath, download_file_name);
            
            // // Download file
            // await downloadFile(download_url, downloadedFilePath, (progress) => {
            //     webContents.send('setup-status', { step: 'downloading', message: `Downloading installer package ${download_file_name}...`, progress: progress });
            // });
            // webContents.send('setup-status', { step: 'downloaded', message: `${download_file_name} download complete` });

            // // Execute installation
            // await executeInstaller(downloadedFilePath);
            // webContents.send('setup-status', { step: 'installed', message: `Waiting for installation to complete` });

            // // Check if Docker is installed successfully after a 3-second delay
            // await new Promise(resolve => setTimeout(resolve, 3000));
            // await checkDockerInstallation();
            // console.log('Docker installation completed.');
            // return true; // Return true if installation is successful
        } else {
            return false; // If the correct installer package is not selected, also return false
        }
    } catch (error) {
        console.error('Error during Docker installation:', error);
        webContents.send('setup-status', { step: 'error', message: `Installation error: ${error.message || error}` });
        return false; // Return false on error
    }
}

// Timer to check if Docker installation is complete
function checkDockerInstallation(interval = 3000) {
    return new Promise((resolve, reject) => {
        const timer = setInterval(() => {
            exec('docker --version', (error, stdout, stderr) => {
                if (!error && !stderr && stdout.toString().includes('Docker version')) {
                    console.log('âœ… Docker installed successfully');
                    clearInterval(timer);
                    resolve(); // Installation complete, Promise resolves successfully
                }else{
                    console.log('âŒ Docker not installed successfully');
                }
                // If Docker is not found, continue to next check
            });
        }, interval);
    });
}

// Execute Docker installer
async function executeInstaller(filePath) {
    return new Promise((resolve, reject) => {
        let command;
        switch (process.platform) {
            case 'win32':
                command = `"${filePath}"`;
                break;
            case 'darwin':
                command = `open "${filePath}"`; // macOS will open DMG files in Finder by default
                break;
            default:
                reject(new Error(`Unsupported platform for installation: ${process.platform}`));
                return;
        }

        console.log(`Executing installation command: ${command}`);
        exec(command, (error, stdout, stderr) => {
            if (error) {
                console.error(`Error during installation: ${error.message}`);
                reject(error);
                return;
            }
            if (stderr) {
                console.warn(`Installation warning/info output:\n${stderr}`);
            }
            console.log(`Successful installation output:\n${stdout}`);
            resolve(stdout);
        });
    });
}

function checkSystem() {
    return new Promise((resolve, reject) => {
        if (process.platform === 'win32') {
            // Check if it's a 64-bit system
            resolve("win64")
        } else if (process.platform === 'darwin') {
            // Check if it's Apple Silicon
            if (isAppleSilicon()) {
                resolve("macos-apple")
            }else{
                resolve("macos-intel")
            }
        }
    })
}
function isAppleSilicon() {
    if (process.platform !== 'darwin') return false;
    try {
      // Run command to check hardware model in system report
      const model = exec('sysctl -n machdep.cpu.brand_string').toString();
      // Apple Silicon will have a specific identifier, e.g., "Apple M1"
      return model.includes('Apple');
    } catch (e) {
      console.error('Unable to determine processor type:', e);
      return false;
    }
  }



/**
 * Executes docker info command
 */
function executeDockerInfo() {
    return new Promise((resolve, reject) => {
        console.log('Current PATH:', process.env.PATH);
        exec('docker --version', (error, stdout, stderr) => {
            if (error) {
                console.error(`Docker check failed: ${error}`);
                console.error(`Stderr: ${stderr}`);
                return reject({ error, stderr });
            }
            resolve(stdout);
        });
    });
}

//åˆ¤æ–­docker æœ‰æ²¡æœ‰è¿è¡Œ ä½¿ç”¨ docker ps åˆ¤æ–­
function checkDockerRunning() {
    return new Promise((resolve, reject) => {
        exec('docker ps', (error, stdout, stderr) => {
            if (error) {
                console.log('Docker is not running');
                console.error(`Docker check failed: ${error}`);
                console.error(`Stderr: ${stderr}`);
                return reject({ error, stderr });
            }
            if (stdout.includes('CONTAINER ID')) {
                console.log('Docker is running');
            } else {
                console.log('Docker is not running');
            }
            resolve(stdout);
        });
    });
}



/**
 * Handles Docker error messages
 */
function handleDockerError({ error, stderr }) {
    console.error(`Handling Docker error: ${stderr}`);

    if (isDockerNotInstalled(stderr)) {
        return handleError(new Error('Docker command not found. Please ensure Docker is installed and added to your system PATH.'));
    }

    if (isDockerNotRunning(stderr)) {
        console.error('Docker service is not running. Attempting to start Docker Desktop/Daemon...');
        attemptStartDocker()
            .then(() => console.log('Docker started successfully'))
            .catch(startError => handleError(startError));
        return;
    }

    if (isConnectionError(stderr)) {
        console.warn('Detected inability to connect to Docker engine. Attempting automatic repair...');
        attemptStartDocker()
            .then(() => console.log('Docker reconnected'))
            .catch(startError => handleError(startError));
        return;
    }

    handleError(new Error(`Unable to check Docker status: ${stderr}`));
}

/**
 * Checks if Docker is not installed
 */
function isDockerNotInstalled(stderr) {
    return stderr.includes('command not found') || stderr.includes("'docker' is not recognized");
}

/**
 * Checks if Docker is not running
 */
function isDockerNotRunning(stderr) {
    return stderr.includes('Is the docker daemon running?');
}

/**
 * Checks for connection error (e.g., Docker is running but cannot connect)
 */
function isConnectionError(stderr) {
    return stderr.includes('error during connect: Get');
}

/**
 * Attempts to start Docker based on the operating system
 */
function attemptStartDocker() {
    return new Promise((resolve, reject) => {
        const platform = process.platform;

        let command;
        if (platform === 'win32') {
            // Windows
            command = 'start "" "C:\\Program Files\\Docker\\Docker\\Docker Desktop.exe"';
        } else if (platform === 'darwin') {
            // macOS
            command = 'open -a Docker';
        } else {
            return reject('Unsupported operating system. Please start Docker manually.');
        }

        exec(command, (startError, startStdout, startStderr) => {
            if (startError) {
                console.error(`Failed to start Docker: ${startStderr}`);
                return reject(`Unable to start Docker Desktop: ${startStderr}`);
            }

            return  resolve("Docker Desktop started. Waiting a few seconds for Docker to run normally...");
        });
    });
}

/**
 * Unified error handling
 */
function handleError(err) {
    console.error(`Final error: ${err.message}`);
    throw err;
}
/**
 * Checks if the required Docker image exists
 */
async function checkDockerEnvironmentReady() {
     return new Promise((resolve, reject) => {
         // Use the refined image name for checking
         exec(`docker images -q ${REQUIRED_DOCKER_IMAGE}`, (error, stdout, stderr) => {
            if (error) {
                 console.warn(`Docker images check failed: ${stderr}`);
                 resolve(false);
            } else {
                resolve(stdout.trim().length > 0);
            }
        });
     });
}

/**
 * Downloads a file
 */
async function downloadFile(url, destinationPath, progressCallback) {
    console.log(`Downloading file from ${url} to ${destinationPath}`);
    // ... (download function remains unchanged)
     return new Promise((resolve, reject) => {
        const file = fs.createWriteStream(destinationPath);
        const request = https.get(url, (response) => {
            if (response.statusCode !== 200) {
                fs.unlink(destinationPath, () => {});
                return reject(new Error(`Download failed, HTTP status code: ${response.statusCode}`));
            }

            const totalLength = parseInt(response.headers['content-length'], 10);
            let downloadedLength = 0;

            response.on('data', (chunk) => {
                downloadedLength += chunk.length;
                if (totalLength) {
                    const progress = downloadedLength / totalLength;
                    if (progressCallback) progressCallback(progress);
                }
            });

            response.pipe(file);

            file.on('finish', () => {
                file.close(resolve);
            });

            file.on('error', (err) => {
                fs.unlink(destinationPath, () => {});
                reject(err);
            });
        });

        request.on('error', (err) => {
            fs.unlink(destinationPath, () => {});
            reject(err);
        });
    });
}

/**
 * Imports a Docker image (.tar)
 */
async function importDockerImage(imagePath) {
    return new Promise((resolve, reject) => {
        const dockerProcess = spawn('docker', ['load', '-i', imagePath]);

        dockerProcess.stdout.on('data', (data) => {
            console.log(`docker load stdout: ${data}`);
        });

        dockerProcess.stderr.on('data', (data) => {
            console.error(`docker load stderr: ${data}`);
        });

        dockerProcess.on('error', (error) => {
            console.error(`Failed to start docker load process: ${error}`);
            reject(new Error(`Unable to execute 'docker load' command: ${error.message}`));
        });

        dockerProcess.on('close', (code) => {
            if (code === 0) {
                resolve();
            } else {
                reject(new Error(`'docker load' command failed, exit code: ${code}`));
            }
        });
    });
}


// --- Function to check and run setup flow ---
async function checkAndRunDockerSetup(mainWindow) {
    mainWindow.loadFile('setup.html');
    console.log("Triggering checkAndRunDockerSetup")
    const initialSetupDone = store.get(DOCKER_SETUP_DONE_KEY, false);
    let dockerEnvironmentIsActuallyReady = false;
    let errorMessage = null;

    try {
        console.log('Verifying current Docker environment state...');
        // --- Execute actual Docker environment check here ---

        // 1. Check if Docker is installed
        let res = await checkDockerAvailability(mainWindow);
        console.log('Docker availability check result:', res);
        if (!res) {
            throw new Error('Docker is not available.');
        }
        mainWindow.send('setup-status', { 
            step: 'startDocker',
            message: 'Checking if Docker is running...'
        });
        //åˆ¤æ–­daokeræ˜¯å¦è¿è¡Œ
        try {
            console.log('Checking if Docker is running...');
            await checkDockerRunning();

            console.log('Checking if Docker is running...2');
            mainWindow.send('setup-status', { 
                step: 'startDocker',
                message: 'Docker is running.'
            });
        } catch (error) {
            // Installation failed, install docker
            mainWindow.send('setup-status', { 
                step: 'startDocker',
                message: 'Docker is not running.'
            });
            // let res = await installDocker(webContents);
            // console.log('Docker installation result:', res);
            throw new Error('Docker is not started.');
        }
        //2. Run docker 
        // mainWindow.webContents.send('setup-status', { step: 'startDocker', message: `Starting Docker` });
        // res = await attemptStartDocker()
        // Delay for 3 seconds
        // await new Promise(resolve => setTimeout(resolve, 10000));
        mainWindow.webContents.send('setup-status', { step: 'checkDockerImages', message: `Checking required Docker images` });
        dockerEnvironmentIsActuallyReady = await checkDockerEnvironmentReady();
        console.log('Required Docker image ready:', dockerEnvironmentIsActuallyReady);

        // If both checks pass, the environment is ready
        if (dockerEnvironmentIsActuallyReady) {
             console.log('Docker environment is ready.');
             mainWindow.webContents.send('setup-status', { step: 'complete', message: `Docker image ${REQUIRED_DOCKER_IMAGE} is ready.` });
        } else {
            console.log('Docker environment is not ready');
            // Image not detected, start image download and installation
            // Full path to the locally saved image package

            // const downloadedFilePath = path.join(userDataPath, getDockerImageFileName());

            // 3. Download Docker image file
            // mainWindow.webContents.send('setup-status', { step: 'downloading', message: `Downloading image package ${getDockerImageFileName()}...`, progress: 0 });
            // Use the refined URL
            // await downloadFile(DOCKER_IMAGE_TAR_URL, downloadedFilePath, (progress) => {
            //         console.log(`Download progress: ${progress}%`);
            //         mainWindow.webContents.send('setup-status', { step: 'downloading', message: `Downloading image package ${getDockerImageFileName()}...`, progress: progress });
            // });
            // 4. Import Docker image
            // mainWindow.webContents.send('setup-status', { step: 'checkDockerImages', message: `Importing Docker image ${REQUIRED_DOCKER_IMAGE}...` });
            // await importDockerImage(downloadedFilePath);
            // 5. Mark setup as complete
            mainWindow.webContents.send('setup-status', { step: 'complete', message: `Docker image ${REQUIRED_DOCKER_IMAGE} is not ready.` });

            store.set(DOCKER_SETUP_DONE_KEY, false);
            dockerEnvironmentIsActuallyReady = false;
        }


    } catch (error) {
        // Catch any errors that occur during the check (e.g., Docker not running, Docker command not found, etc.)
        console.error('Docker environment verification failed:', error);
        errorMessage = `Docker environment check failed: ${error.message || error}`;
        dockerEnvironmentIsActuallyReady = false; // Check failed, environment not ready
    }

    // --- Decide which page to load based on the actual check result ---
    if (dockerEnvironmentIsActuallyReady) {
        console.log('Loading main window as Docker environment is ready.');
        // If the actual environment is ready, ensure the state in the store is also true
        if (!initialSetupDone) { // Only write if store is false to avoid unnecessary writes
             store.set(DOCKER_SETUP_DONE_KEY, true);
             console.log('Updated store: DOCKER_SETUP_DONE_KEY set to true.');
        }

        if (process.env.NODE_ENV === 'development') {
            mainWindow.loadURL('http://localhost:5005');
        } else {
            mainWindow.loadFile(path.join(__dirname, 'renderer/main_window/index.html'));
        }
    } else {
        console.log('Loading setup page as Docker environment is NOT ready.');
        // If the actual environment is not ready, ensure the state in the store is false
        if (initialSetupDone) { // Only write if store is true
             store.set(DOCKER_SETUP_DONE_KEY, false);
             console.log('Updated store: DOCKER_SETUP_DONE_KEY set to false.');
        }
    }
}



// --- Export the functions needed by main.js ---
export {
    initDockerSetupService,
    checkAndRunDockerSetup,
    DOCKER_SETUP_DONE_KEY
};


================================================
FILE: entitlements.plist
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>com.apple.security.network.client</key>
    <true/>
    <key>com.apple.security.cs.allow-jit</key>
    <true/>
    <key>com.apple.security.cs.allow-unsigned-executable-memory</key>
    <true/>
    <key>com.apple.security.cs.disable-library-validation</key>
    <true/>
    <key>com.apple.security.device.audio-input</key>
    <true/>
</dict>
</plist>


================================================
FILE: forge.config.js
================================================
require('dotenv').config();
const { FusesPlugin } = require('@electron-forge/plugin-fuses');
const { FuseV1Options, FuseVersion } = require('@electron/fuses');
const { config } = require('dotenv');
const path = require('path');

module.exports = {
  packagerConfig: {
    prune: true,
    asar: true,
    icon: path.resolve(__dirname, 'frontend/src/assets/icon'),
    // {
    //   unpackDir: "bin" // è§£å‹ bin ç›®å½•åˆ° app.asar.unpacked
    // },
    ignore: [
      /^\/node_modules\/\.bin/,
      /^\/tests/,
      /^\/docs/,
      /README\.md/,
      /\.(log|tmp|bak)$/, // å¿½ç•¥æ—¥å¿—ã€ä¸´æ—¶æ–‡ä»¶
      /\.(cache|ds_store)$/, // å¿½ç•¥ macOS ç¼“å­˜æ–‡ä»¶
      /^\/\.git/, // å¿½ç•¥ Git ç›®å½•
      /^\/out/, // å¿½ç•¥æ„å»ºç›®å½•
      /^\/dist/, // å¿½ç•¥å…¶ä»–æ„å»ºç›®å½•
      /^\/frontend\/node_modules\/.*/, // å¿½ç•¥å‰ç«¯çš„ node_modules
      /^\/frontend\/src\/.*/, // å¿½ç•¥å‰ç«¯æºç 
    ],
    extraResource: [
      "./data",
      "./cache",
      "./workspace",
      "./.env",
      "./resources/browser" // copy browser to resources
    ],
    osxSign: {
      identity: "Developer ID Application: Beijing Yichuang Technology Co.,Ltd. (6P6VT3LT4F)",
      "hardenedRuntime": true,
      'entitlements': './entitlements.plist',
      "entitlementsInherit": "./entitlements.plist",
      "gatekeeper-assess": false,
      optionsForFile: (filePath) => {
        return { entitlements: './entitlements.plist' };
      }
    },
    osxNotarize: {
      tool: "notarytool",
      appleId: process.env.APPLE_ID,
      appleIdPassword: process.env.APPLE_PASSWORD,
      teamId: process.env.APPLE_TEAM_ID
    }
  },
  rebuildConfig: {},
  makers: [
    {
      name: '@electron-forge/maker-dmg',
      platforms: ['darwin'],
    },
    {
      name: '@electron-forge/maker-squirrel',
      config: {},
    },
    {
      name: '@electron-forge/maker-zip',
      platforms: ['darwin'],
      // platforms: ['win32'],
    },
    {
      name: '@electron-forge/maker-deb',
      config: {},
    },
    {
      name: '@electron-forge/maker-rpm',
      config: {},
    },
  ],
  plugins: [
    {
      name: '@electron-forge/plugin-vite',
      config: {
        // ä¸»è¿›ç¨‹é…ç½®
        build: [
          {
            entry: 'main.js', // ä¸»è¿›ç¨‹å…¥å£ï¼ˆåç«¯ä»£ç ï¼‰
            config: 'vite.main.config.js', // ä¸»è¿›ç¨‹ Vite é…ç½®æ–‡ä»¶
          },
          {
            entry: 'preload.js', // é¢„åŠ è½½è„šæœ¬å…¥å£
            config: 'vite.preload.config.js', // é¢„åŠ è½½ Vite é…ç½®æ–‡ä»¶
          },
        ],
        // æ¸²æŸ“è¿›ç¨‹é…ç½®
        renderer: [
          {
            name: 'main_window',
            config: 'frontend/vite.config.js', // å‰ç«¯ Vite é…ç½®æ–‡ä»¶
          },
        ],
      },
    },
    new FusesPlugin({
      version: FuseVersion.V1,
      [FuseV1Options.RunAsNode]: false,
      [FuseV1Options.EnableCookieEncryption]: true,
      [FuseV1Options.EnableNodeOptionsEnvironmentVariable]: false,
      [FuseV1Options.EnableNodeCliInspectArguments]: false,
    }),
  ],
};



================================================
FILE: jsconfig.json
================================================
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@src/*": [
        "src/*"
      ],
      // Optional: set alias for type folders
      "@types/*": [
        "types/*"
      ],
    },
    "checkJs": true,
    "target": "es2020",
    "module": "commonjs",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "allowSyntheticDefaultImports": true,
  },
  "include": [
    "**/*.js",
    "**/*.d.ts",
    "src/**/*.d.ts"
  ],
  "exclude": [
    "node_modules",
    "dist"
  ]
}


================================================
FILE: LICENSE
================================================
# Open Source License

Lemon is licensed under a modified version of the Apache License 2.0, with the following additional conditions:

1. Lemon may be utilized commercially, including as a backend service for other applications or as an application development platform for enterprises. Should the conditions below be met, a commercial license must be obtained from the producer:

a. Multi-tenant service: Unless explicitly authorized by Lemon in writing, you may not use the Lemon source code to operate a multi-tenant environment.
    - Tenant Definition: Within the context of Lemon, one tenant corresponds to one workspace. The workspace provides a separated area for each tenant's data and configurations.

b. LOGO and copyright information: In the process of using Lemon's frontend, you may not remove or moLemon the LOGO or copyright information in the Lemon console or applications. This restriction is inapplicable to uses of Lemon that do not involve its frontend.
    - Frontend Definition: For the purposes of this license, the "frontend" of Lemon includes all components located in the `web/` directory when running Lemon from the raw source code, or the "web" image when running Lemon with Docker.

2. As a contributor, you should agree that:

a. The producer can adjust the open-source agreement to be more strict or relaxed as deemed necessary.
b. Your contributed code may be used for commercial purposes, including but not limited to its cloud business operations.

Apart from the specific conditions mentioned above, all other rights and restrictions follow the Apache License 2.0. Detailed information about the Apache License 2.0 can be found at http://www.apache.org/licenses/LICENSE-2.0.

The interactive design of this product is protected by appearance patent.

Â© 2025 Lemon, Inc.


================================================
FILE: main.js
================================================
// main.js

const { app, BrowserWindow,ipcMain,shell } = require('electron');
const path = require('path');
const http = require('http');
const { URL } = require('url'); // Node.js çš„ URL ç±»
const { exec, spawn } = require('child_process');
import { initDockerSetupService, checkAndRunDockerSetup, DOCKER_SETUP_DONE_KEY } from './dockerSetupService.js';

let mainWindow;
let backendProcess; // ä½ çš„åç«¯è¿›ç¨‹å˜é‡

// Store å®ä¾‹å°†åœ¨å¼‚æ­¥åŠ è½½ååˆ›å»º
let store;

const dotenv = require('dotenv');
const fs = require('fs');

const isDev = !app.isPackaged; // æ˜¯å¦ä¸ºå¼€å‘ç¯å¢ƒ

// åˆ¤æ–­ç¯å¢ƒæ¥è®¾å®š .env æ–‡ä»¶è·¯å¾„
const envPath = isDev
Â  ? path.resolve(process.cwd(), '.env') // å¼€å‘ç¯å¢ƒ
Â  : path.resolve(process.resourcesPath, '.env'); // æ‰“åŒ…å

// å®‰å…¨åœ°åŠ è½½ .env
if (fs.existsSync(envPath)) {
Â  dotenv.config({ path: envPath });
Â  console.log('âœ… .env åŠ è½½æˆåŠŸ:', process.env);
} else {
Â  console.error('âŒ .env æ–‡ä»¶ä¸å­˜åœ¨:', envPath);
}

if (app && app.getPath) {
Â  const dataUserPath = app.getPath("userData");
Â  console.log("ELECTRON.APP.USER.PATH", dataUserPath);
Â  process.env.LEMON_AI_PATH = dataUserPath;
}


// é˜²æ­¢å¤šå®ä¾‹
const gotTheLock = app.requestSingleInstanceLock();
if (!gotTheLock) {
Â  console.log('Another instance is running, quitting...');
Â  app.quit();
} else {
Â  app.on('second-instance', () => {
Â  Â  console.log('Second instance detected');
Â  Â  if (mainWindow) {
Â  Â  Â  if (mainWindow.isMinimized()) mainWindow.restore();
Â  Â  Â  mainWindow.focus();
Â  Â  }
Â  });

Â  function executeDockerInfo() {
Â  Â  return new Promise((resolve, reject) => {
Â  Â  Â  const cmd = process.platform === 'win32'
Â  Â  Â  Â  ? 'powershell -Command "Get-Command docker | Select-Object -ExpandProperty Source"'
Â  Â  Â  Â  : 'which docker';
Â  
Â  Â  Â  exec(cmd, (error, stdout, stderr) => {
Â  Â  Â  Â  if (error) {
Â  Â  Â  Â  Â  console.error('âŒ Docker æ£€æµ‹å¤±è´¥:', error.message);
Â  Â  Â  Â  Â  return reject({ error, stderr });
Â  Â  Â  Â  }
Â  
Â  Â  Â  Â  const dockerPath = stdout.trim();
Â  Â  Â  Â  if (!dockerPath) return reject({ error: 'Docker è·¯å¾„ä¸ºç©º', stderr });
Â  
Â  Â  Â  Â  console.log('âœ… æ£€æµ‹åˆ° Docker è·¯å¾„:', dockerPath);
Â  
Â  Â  Â  Â  // æå–è·¯å¾„ç›®å½•éƒ¨åˆ†ï¼ˆä¸åŒ…æ‹¬ docker æœ¬èº«ï¼‰
Â  Â  Â  Â  const dockerDir = path.dirname(dockerPath);
Â  Â  Â  Â  resolve(dockerDir);
Â  Â  Â  });
Â  Â  });
Â  }

Â  function addToEnvPath(dir) {
Â  Â  const delimiter = process.platform === 'win32' ? ';' : ':';
Â  Â  const pathSet = new Set(process.env.PATH.split(delimiter));
Â  Â  pathSet.add(dir);
Â  Â  process.env.PATH = Array.from(pathSet).join(delimiter);
Â  }
Â  
Â  // åˆå§‹ PATH è®¾ç½®ï¼ˆç”¨äºå‰ç½®æŸ¥æ‰¾ï¼‰
Â  function setupInitialDockerPathEnv() {
Â  Â  const platform = process.platform;
Â  Â  const customPaths = new Set();
Â  
Â  Â  if (platform === 'darwin') {
Â  Â  Â  customPaths.add('/usr/bin');
Â  Â  Â  customPaths.add('/bin');
Â  Â  Â  customPaths.add('/usr/sbin');
Â  Â  Â  customPaths.add('/sbin');
Â  Â  Â  customPaths.add('/Applications/Docker.app/Contents/Resources/bin');
Â  Â  Â  customPaths.add('/opt/homebrew/bin');
Â  Â  } else if (platform === 'win32') {
Â  Â  Â  customPaths.add('C:\\Program Files\\Docker\\Docker\\resources\\bin');
Â  Â  }
Â  
Â  Â  const delimiter = platform === 'win32' ? ';' : ':';
Â  Â  const originalPaths = process.env.PATH.split(delimiter);
Â  Â  originalPaths.forEach(p => customPaths.add(p));
Â  
Â  Â  process.env.PATH = Array.from(customPaths).join(delimiter);
Â  }


Â  function Â createWindow() {
Â  Â  console.log('Creating new window at:', new Date().toISOString());
Â  Â  console.log('preload path',path.join(__dirname, '../preload.js'), );
Â  Â  mainWindow = new BrowserWindow({
Â  Â  Â  width: 1000,
Â  Â  Â  height: 800,
Â  Â  Â  webPreferences: {
Â  Â  Â  Â  nodeIntegration: false, // ä¿æŒ falseï¼Œä½¿ç”¨ preload
Â  Â  Â  Â  contextIsolation: true, // ä¿æŒ trueï¼Œä½¿ç”¨ preload
Â  Â  Â  Â  preload: path.join(__dirname, '../preload.js'), // ä½¿ç”¨ä½ çš„ preload è„šæœ¬
Â  Â  Â  },
Â  Â  Â  // è¿™é‡Œä¸å†åŠ è½½é¡µé¢ï¼ŒåŠ è½½å“ªä¸ªé¡µé¢ç”± checkAndRunDockerSetup å†³å®š
Â  Â  });

Â  Â  mainWindow.on('closed', () => {
Â  Â  Â  console.log('Window closed');
Â  Â  Â  mainWindow = null;
Â  Â  });

Â  Â  // è¿”å›çª—å£å®ä¾‹
Â  Â  return mainWindow;
Â  }

Â  ipcMain.on('setup-complete-load-main', (event) => {
Â  Â  // è·å–å‘é€æ¶ˆæ¯çš„çª—å£
Â  Â  // æˆ–è€…ç›´æ¥ä½¿ç”¨å¤–éƒ¨ä½œç”¨åŸŸçš„ mainWindow å˜é‡
Â  Â  const win = BrowserWindow.fromWebContents(event.sender);
Â  Â  if (!win) {
Â  Â  Â  Â  console.error('ä¸»è¿›ç¨‹æ”¶åˆ°åŠ è½½ä¸»é¡µé¢è¯·æ±‚ï¼Œä½†æ‰¾ä¸åˆ°å¯¹åº”çš„çª—å£');
Â  Â  Â  Â  return;
Â  Â  }

Â  Â  console.log('ä¸»è¿›ç¨‹æ”¶åˆ°æ¸²æŸ“è¿›ç¨‹çš„åŠ è½½ä¸»é¡µé¢è¯·æ±‚ï¼Œå¼€å§‹æ‰§è¡ŒåŠ è½½ä¸»é¡µé¢é€»è¾‘...');

Â  Â  // æ‰§è¡ŒåŠ è½½ä¸»é¡µé¢çš„é€»è¾‘
Â  Â  if (process.env.NODE_ENV === 'development') {
Â  Â  Â  Â  win.loadURL('http://localhost:5005');
Â  Â  } else {
Â  Â  Â  Â  win.loadFile(path.join(__dirname, 'renderer/main_window/index.html'));
Â  Â  }
Â  });

Â  let deeplinkUrl = '';

Â  const isMac = process.platform === 'darwin';
Â  const isWin = process.platform === 'win32';

Â  // æ³¨å†Œåè®®ï¼ˆWindows è¦æŒ‡å®š exeï¼‰
Â  if (!app.isDefaultProtocolClient('lemonai')) {
Â  Â  if (isWin) {
Â  Â  Â  app.setAsDefaultProtocolClient('lemonai', process.execPath, []);
Â  Â  } else {
Â  Â  Â  app.setAsDefaultProtocolClient('lemonai');
Â  Â  }
Â  }



Â  function handleDeepLink(url) {
Â  Â  Â  try {
Â  Â  Â  Â  const parsedUrl = new URL(url);
Â  Â  Â  Â  const pathname = parsedUrl.pathname;
Â  Â  Â  Â  const host = parsedUrl.hostname;
Â  Â  Â  Â  const target = host || pathname.replace(/^\//, '');
Â  Â  
Â  Â  Â  Â  const sendToRenderer = (channel, data) => {
Â  Â  Â  Â  Â  if (mainWindow) {
Â  Â  Â  Â  Â  Â  mainWindow.webContents.send(channel, data);
Â  Â  Â  Â  Â  Â  mainWindow.focus();
Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  // App è¿˜æ²¡ readyï¼Œç¼“å­˜æ¶ˆæ¯
Â  Â  Â  Â  Â  Â  deeplinkUrl = JSON.stringify({ channel, data });
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  };
Â  Â  
Â  Â  Â  Â  switch (target) {
Â  Â  Â  Â  Â  case 'auth': {
Â  Â  Â  Â  Â  Â  const code = parsedUrl.searchParams.get('code');
Â  Â  Â  Â  Â  Â  const state = parsedUrl.searchParams.get('state');
Â  Â  Â  Â  Â  Â  sendToRenderer('oauth-login-success', { code, state });
Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  Â  }
Â  Â  
Â  Â  Â  Â  Â  case 'pay-result': {
Â  Â  Â  Â  Â  Â  const orderId = parsedUrl.searchParams.get('orderId');
Â  Â  Â  Â  Â  Â  const amount = parsedUrl.searchParams.get('amount');
Â  Â  Â  Â  Â  Â  const currency = parsedUrl.searchParams.get('currency');
Â  Â  Â  Â  Â  Â  const status = parsedUrl.searchParams.get('status');
Â  Â  Â  Â  Â  Â  sendToRenderer('stripe-payment-success', { orderId, amount, currency, status });
Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  Â  }
Â  Â  
Â  Â  Â  Â  Â  case 'payment-cancelled': {
Â  Â  Â  Â  Â  Â  sendToRenderer('stripe-payment-cancel', {});
Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  Â  }
Â  Â  
Â  Â  Â  Â  Â  default: {
Â  Â  Â  Â  Â  Â  console.warn('âš ï¸ Unknown deep link target:', target);
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  } catch (err) {
Â  Â  Â  Â  console.error('Failed to handle deep link:', err);
Â  Â  Â  }
Â  Â  }
Â  Â  

Â  // å•å®ä¾‹é”
const gotLock = app.requestSingleInstanceLock();

if (!gotLock) {
Â  app.quit();
} else {
Â  if (isWin) {
Â  Â  // Windowsï¼šé€šè¿‡ argv è·å–åè®®å‚æ•°
Â  Â  app.on('second-instance', (event, argv) => {
Â  Â  Â  console.log("argv ======",argv);
Â  Â  Â  const urlArg = argv.find(arg => arg.startsWith('lemonai://'));
Â  Â  Â  if (urlArg) {
Â  Â  Â  Â  console.log("urlArg ==== ",urlArg);
Â  Â  Â  Â  deeplinkUrl = urlArg;
Â  Â  Â  Â  handleDeepLink(urlArg);
Â  Â  Â  }
Â  Â  });
Â  }

Â  if (isMac) {
Â  Â  // macOSï¼šä½¿ç”¨ open-url äº‹ä»¶
Â  Â  // å¤„ç† macOS çš„åè®®æ‰“å¼€äº‹ä»¶
Â  Â  app.on('open-url', (event, url) => {
Â  Â  Â  event.preventDefault();
Â  Â  Â  console.log('ğŸ‹ Received lemonai:// URL:', url);
Â  Â  Â  handleDeepLink(url);
Â  Â  })
Â  }
}



Â  // å°†æ•´ä¸ª then å›è°ƒå‡½æ•°æ ‡è®°ä¸º async
Â  app.whenReady().then(async () => {
Â  Â  console.log('Electron Main: App ready.');
Â  Â  console.log('å½“å‰ç³»ç»Ÿå¹³å°ï¼š', process.platform);
Â  Â  // é¢„ç½®å¸¸è§è·¯å¾„ï¼Œé¿å…æ‰¾ä¸åˆ° docker
Â  Â  setupInitialDockerPathEnv();
Â  Â  try {
Â  Â  Â  const dockerDir = await executeDockerInfo();
Â  Â  Â  addToEnvPath(dockerDir);
Â  Â  Â  console.log('ğŸ¯ Docker æ‰€åœ¨ç›®å½•æ·»åŠ åˆ° PATHï¼š', dockerDir);
Â  Â  } catch (err) {
Â  Â  Â  console.error('ğŸš« è·å– Docker è·¯å¾„å¤±è´¥:', err);
Â  Â  }


Â  Â  // --- ä½¿ç”¨åŠ¨æ€ import å¼‚æ­¥åŠ è½½ electron-store ---
Â  Â  let StoreModule;
Â  Â  try {
Â  Â  Â  // ä½¿ç”¨ await ç­‰å¾… electron-store æ¨¡å—åŠ è½½å®Œæˆ
Â  Â  Â  StoreModule = await import('electron-store');
Â  Â  Â  console.log('electron-store module imported dynamically.');
Â  Â  } catch (err) {
Â  Â  Â  console.error('Failed to dynamically import electron-store:', err);
Â  Â  Â  // å¦‚æœ electron-store åŠ è½½å¤±è´¥ï¼Œè¿™æ˜¯ä¸ªä¸¥é‡é”™è¯¯ï¼Œå¯èƒ½éœ€è¦é€€å‡ºåº”ç”¨æˆ–æç¤ºç”¨æˆ·
Â  Â  Â  app.quit(); // é€‰æ‹©é€€å‡ºåº”ç”¨
Â  Â  Â  return; // åœæ­¢åç»­æ‰§è¡Œ
Â  Â  }

Â  Â  // ä»åŠ¨æ€å¯¼å…¥çš„æ¨¡å—ä¸­è·å– Store æ„é€ å‡½æ•° (é€šå¸¸åœ¨ .default å±æ€§ä¸Š)
Â  Â  const Store = StoreModule.default;

Â  Â  // åˆ›å»º Store å®ä¾‹ (ç°åœ¨ç¡®ä¿åœ¨ electron-store åŠ è½½å¹¶è·å–æ„é€ å‡½æ•°ä¹‹å)
Â  Â  store = new Store();
Â  Â  console.log('electron-store instance created.');
Â  Â  console.log('=== userData ====',app.getPath('userData'));

Â  Â  // --- ç°åœ¨å¯ä»¥ç»§ç»­æ‰§è¡Œä¾èµ– store å®ä¾‹çš„é€»è¾‘ ---

Â  Â  // åˆå§‹åŒ– Docker è®¾ç½®æœåŠ¡ï¼Œä¼ å…¥ store å’Œç”¨æˆ·æ•°æ®è·¯å¾„
Â  Â  // initDockerSetupService è´Ÿè´£è®¾ç½® IPC ç›‘å¬å™¨
Â  Â  initDockerSetupService({
Â  Â  Â  Â  store: store, // å°† Store å®ä¾‹ä¼ é€’è¿›å»
Â  Â  Â  Â  userDataPath: app.getPath('userData'), // å°†ç”¨æˆ·æ•°æ®è·¯å¾„ä¼ é€’è¿›å»
Â  Â  });
Â  Â  console.log('Docker setup service initialized.');


Â  Â  //æ•°æ®åº“åˆå§‹åŒ– sqllite3 
Â  Â  //node src/models/sync.js
Â  Â  require(path.join(__dirname, '../src/models/sync.js'));
Â  Â  console.log('Database initialized.');
Â  Â  
Â  Â  // å¯åŠ¨åç«¯è¿›ç¨‹ (æ—¶æœºå¯èƒ½éœ€è¦è°ƒæ•´ï¼Œç¡®ä¿åç«¯åœ¨ Docker å°±ç»ªåæ‰èƒ½æ­£å¸¸å·¥ä½œ)
Â  Â  console.log('Spawning backend process...');
Â  Â  try {
Â  Â  Â  // @ts-ignore
Â  Â  Â  // ç¡®ä¿ä½ çš„ '../bin/www' æ–‡ä»¶èƒ½å¤Ÿé€šè¿‡ require æ­£å¸¸å¯åŠ¨åç«¯æœåŠ¡
Â  Â  Â  require(path.join(__dirname, '../bin/www'));
Â  Â  Â  console.log('Backend process started.');
Â  Â  } catch (err) {
Â  Â  Â  console.error('Failed to start backend service:', err);
Â  Â  Â  // è€ƒè™‘åœ¨è¿™é‡Œå¤„ç†åç«¯å¯åŠ¨å¤±è´¥çš„æƒ…å†µ
Â  Â  }


Â  Â  // åˆ›å»ºä¸»çª—å£
Â  Â  const createdWindow = createWindow(); // è·å–åˆ›å»ºçš„çª—å£å®ä¾‹
Â  Â  console.log('Main window created.');



Â  Â  // è¿è¡Œ Docker è®¾ç½®æ£€æŸ¥å’Œæµç¨‹
Â  Â  checkAndRunDockerSetup(createdWindow);
Â  Â  console.log('Docker setup check initiated.');

Â  Â  // å…¶ä»– app ready åç»­é€»è¾‘...

Â  Â  Â  Â  function isAllowedRedirectUrl(url) {
Â  Â  Â  Â  Â  Â  Â  const whitelist = [
Â  Â  Â  // Â  Â  Â  Â  Â  'https://accounts.google.com/o/oauth2',
Â  Â  Â  // Â  Â  Â  Â  Â  'https://accounts.google.com/',
Â  Â  Â  // Â  Â  Â  Â  Â  'https://www.google.com/accounts',
Â  Â  Â  // Â  Â  Â  Â  Â  'https://checkout.stripe.com'
Â  Â  Â  Â  Â  Â  Â  ];
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  return whitelist.some(allowed => url.startsWith(allowed));
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  
Â  Â  
Â  Â  // æ‹¦æˆªæ–°çª—å£æ‰“å¼€
Â  Â  createdWindow.webContents.setWindowOpenHandler(({ url }) => {
Â  Â  Â  if (isAllowedRedirectUrl(url)) {
Â  Â  Â  Â  // å¯¹äºè°·æ­Œç™»å½•é“¾æ¥ï¼Œå…è®¸åœ¨åº”ç”¨å†…æ‰“å¼€ï¼ˆaction: 'allow'ï¼‰
Â  Â  Â  Â  return { action: 'allow' };
Â  Â  Â  }
Â  Â  
Â  Â  Â  // å…¶ä»– http/https é“¾æ¥éƒ½ç”¨ç³»ç»Ÿæµè§ˆå™¨æ‰“å¼€
Â  Â  Â  if (url.startsWith('http')) {
Â  Â  Â  Â  shell.openExternal(url);
Â  Â  Â  Â  return { action: 'deny' };
Â  Â  Â  }
Â  Â  
Â  Â  Â  return { action: 'allow' };
Â  Â  });
Â  Â  
Â  Â  // æ‹¦æˆªé¡µé¢å†…è·³è½¬
Â  Â  createdWindow.webContents.on('will-navigate', (event, url) => {
Â  Â  Â  if (isAllowedRedirectUrl(url)) {
Â  Â  Â  Â  // å¯¹äºè°·æ­Œç™»å½•ç›¸å…³çš„ URLï¼Œå…è®¸è·³è½¬ï¼Œä»€ä¹ˆéƒ½ä¸åš
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  
Â  Â  Â  // éè°·æ­Œç™»å½•ä¸”ä¸ºæ–°çš„ http/https è·³è½¬ï¼Œé˜»æ­¢å¹¶ç”¨ç³»ç»Ÿæµè§ˆå™¨æ‰“å¼€
Â  Â  Â  if (url.startsWith('http') && url !== createdWindow.webContents.getURL()) {
Â  Â  Â  Â  event.preventDefault();
Â  Â  Â  Â  shell.openExternal(url);
Â  Â  Â  }
Â  Â  });
Â  });


Â  app.on('before-quit', () => {
Â  Â  console.log('App quitting, killing backend process...');
Â  Â  // å¦‚æœä½ çš„åç«¯æ˜¯é€šè¿‡ spawn å¯åŠ¨çš„ï¼Œåœ¨è¿™é‡Œæ€æ­»è¿›ç¨‹
Â  Â  // if (backendProcess && !backendProcess.killed) {
Â  Â  // Â  Â  backendProcess.kill();
Â  Â  // }
Â  });

Â  app.on('activate', () => {
Â  Â  // å½“åº”ç”¨æ¿€æ´»ä½†æ²¡æœ‰å¯è§çª—å£æ—¶
Â  Â  if (mainWindow === null) {
Â  Â  Â  const createdWindow = createWindow();
Â  Â  Â  // å¦‚æœæ˜¯æ–°åˆ›å»ºçš„çª—å£ï¼ŒåŒæ ·éœ€è¦è¿è¡Œæ£€æŸ¥
Â  Â  Â  // è¿™é‡Œçš„é€»è¾‘ä¾èµ– store å·²ç»åˆ›å»ºå’ŒæœåŠ¡å·²ç»åˆå§‹åŒ–ï¼Œ
Â  Â  Â  // è€ƒè™‘åˆ°è¿™æ˜¯ activate äº‹ä»¶ï¼Œé€šå¸¸ app.whenReady å·²ç»æ‰§è¡Œè¿‡äº†ï¼Œæ‰€ä»¥ store åº”è¯¥å·²ç»åˆ›å»ºã€‚
Â  Â  Â  checkAndRunDockerSetup(createdWindow);
Â  Â  }
Â  });
}



================================================
FILE: Makefile
================================================
# Makefile

# Configurable variables for easy modification
IMAGE_NAME   := hexdolemonai/lemon-runtime-sandbox
TAG          := v0.0.5
DOCKERFILE   := containers/runtime/Dockerfile
PLATFORMS    := linux/amd64,linux/arm64
FRONTEND_DIR := frontend  # Frontend directory variable

APP_IMAGE_NAME   := hexdolemonai/lemon
APP_TAG          := v0.0.16
APP_DOCKERFILE   := containers/app/Dockerfile

# ANSI color codes
GREEN=$(shell tput -Txterm setaf 2)
YELLOW=$(shell tput -Txterm setaf 3)
RED=$(shell tput -Txterm setaf 1)
BLUE=$(shell tput -Txterm setaf 6)
RESET=$(shell tput -Txterm sgr0)

# Declare phony targets to avoid conflicts with files of the same name
.PHONY: build start-backend start-frontend run

# Default goal: Start both frontend and backend
.DEFAULT_GOAL := run

# Build and push Docker image
build-runtime-sandbox:
	@echo "Building and pushing $(IMAGE_NAME):$(TAG) for platforms [$(PLATFORMS)]"
	docker buildx build \
	  --platform $(PLATFORMS) \
	  --tag $(IMAGE_NAME):$(TAG) \
	  --tag $(IMAGE_NAME):latest \
	  -f $(DOCKERFILE) \
	  --push .

build-app:
	@echo "Building and pushing $(APP_IMAGE_NAME):$(APP_TAG) for platforms [$(PLATFORMS)]"
	docker buildx build \
	  --platform $(PLATFORMS) \
	  --tag $(APP_IMAGE_NAME):$(APP_TAG) \
	  --tag $(APP_IMAGE_NAME):latest \
	  -f $(APP_DOCKERFILE) \
	  --push .

# Start backend service
start-backend:
	npm run start

# Start frontend service
start-frontend:
	cd $(FRONTEND_DIR) && npm run dev

# Start both frontend and backend
run:
	@$(MAKE) -s init-tables
	@$(MAKE) -s start-backend &
	@$(MAKE) -s start-frontend 

# Init tables
init-tables:
	node src/models/sync.js

install-frontend-dependencies:
	@echo "$(YELLOW)Setting up frontend environment...$(RESET)"
	echo "$(BLUE)Installing frontend dependencies with npm...$(RESET)"
	@cd frontend && npm install
	@echo "$(GREEN)Frontend dependencies installed successfully.$(RESET)"

install-backend-dependencies:
	@echo "$(YELLOW)Setting up backend environment...$(RESET)"
	echo "$(BLUE)Installing backend dependencies with npm...$(RESET)"
	@npm install --production
	@echo "$(GREEN)Backend dependencies installed successfully.$(RESET)"

init:
	@echo "$(GREEN)Init project...$(RESET)"
	@$(MAKE) -s install-backend-dependencies
	@$(MAKE) -s install-frontend-dependencies
	@$(MAKE) -s init-tables
	@echo "$(GREEN)Init completed successfully.$(RESET)"


================================================
FILE: nodemon.json
================================================
{
  "ignore": [
    "logs/",
    "public/",
    "temp/",
    "cache/",
    "lemon_cache/",
    "Caches/",
    "data/",
    "node_modules/",
    "*.test.js",
    "frontend",
    "workspace"
  ]
}


================================================
FILE: package.json
================================================
{
  "name": "LemonAI",
  "productName": "LemonAI",
  "version": "0.4.0",
  "private": true,
  "main": ".vite/main.js",
  "scripts": {
    "start": "node bin/www",
    "dev": "./node_modules/.bin/nodemon bin/www",
    "prd": "pm2 start bin/www",
    "test": "mocha ./test/**/*.test.js",
    "package": "electron-forge package",
    "make": "electron-forge make",
    "make-skip": "electron-forge make --skip-package",
    "electron-start": "electron-forge start"
  },
  "dependencies": {
    "@dqbd/tiktoken": "^1.0.21",
    "@modelcontextprotocol/sdk": "^1.13.0",
    "@playwright/test": "^1.52.0",
    "axios": "^1.9.0",
    "chai": "^4.3.4",
    "cheerio": "^1.0.0",
    "debug": "^4.1.1",
    "dockerode": "^4.0.6",
    "dotenv": "^16.5.0",
    "e2b": "^2.1.5",
    "fast-xml-parser": "^4.5.3",
    "jsonwebtoken": "^9.0.2",
    "koa": "^2.7.0",
    "koa-body": "^6.0.1",
    "koa-convert": "^1.2.0",
    "koa-json": "^2.0.2",
    "koa-logger": "^3.2.0",
    "koa-onerror": "^4.1.0",
    "koa-router": "^7.4.0",
    "koa-static": "^5.0.0",
    "koa2-swagger-ui": "^5.11.0",
    "marked": "^15.0.12",
    "minimist": "^1.2.8",
    "mocha": "^11.1.0",
    "module-alias": "^2.2.3",
    "mysql2": "^3.14.0",
    "node-xlsx": "^0.24.0",
    "pino": "^9.6.0",
    "playwright": "^1.52.0",
    "sequelize": "^6.37.7",
    "sinon": "^20.0.0",
    "sqlite3": "^5.1.7",
    "supertest": "^7.1.0",
    "swagger-jsdoc": "^6.2.8",
    "uuid": "^11.1.0",
    "which": "^5.0.0",
    "winston": "^3.17.0"
  },
  "devDependencies": {
    "@electron-forge/cli": "^7.8.1",
    "@electron-forge/maker-deb": "^7.8.1",
    "@electron-forge/maker-dmg": "^7.8.1",
    "@electron-forge/maker-rpm": "^7.8.1",
    "@electron-forge/maker-squirrel": "^7.8.1",
    "@electron-forge/maker-zip": "^7.8.1",
    "@electron-forge/plugin-auto-unpack-natives": "^7.8.1",
    "@electron-forge/plugin-fuses": "^7.4.0",
    "@electron-forge/plugin-vite": "^7.8.1",
    "@electron/fuses": "^1.8.0",
    "@types/node": "^22.15.2",
    "@vitejs/plugin-vue": "^5.2.4",
    "electron": "29.2.0",
    "electron-forge": "^5.2.4",
    "electron-rebuild": "^3.2.9",
    "electron-squirrel-startup": "^1.0.1",
    "electron-store": "^10.0.1",
    "node-abi": "^4.8.0",
    "nodemon": "^1.19.1",
    "sass-embedded": "^1.89.0",
    "unplugin-vue-components": "^28.7.0",
    "vite": "^6.3.5",
    "vite-svg-loader": "^5.1.0"
  },
  "_moduleAliases": {
    "@src": "src"
  },
  "packageManager": "pnpm@9.15.5+sha512.845196026aab1cc3f098a0474b64dfbab2afe7a1b4e91dd86895d8e4aa32a7a6d03049e2d0ad770bbe4de023a7122fb68c1a1d6e0d033c7076085f9d5d4800d4"
}



================================================
FILE: preload.js
================================================
// src/preload.js
const { contextBridge, ipcRenderer } = require('electron');

// æš´éœ²å®‰å…¨çš„ API ç»™æ¸²æŸ“è¿›ç¨‹
contextBridge.exposeInMainWorld('electronAPI', {
  // å‘é€æ¶ˆæ¯åˆ°ä¸»è¿›ç¨‹ (ç”¨äºå•å‘é€šä¿¡)
  send: (channel, data) => {
    const validSendChannels = ['setup-complete-load-main'];
    if (validSendChannels.includes(channel)) {
      ipcRenderer.send(channel, data);
    }
  },
  // ç›‘å¬ä¸»è¿›ç¨‹çš„æ¶ˆæ¯ (ç”¨äºä¸»è¿›ç¨‹ -> æ¸²æŸ“è¿›ç¨‹é€šä¿¡)
  on: (channel, callback) => {
    const validOnChannels = [
      'from-main',
      'api-response',
      'setup-status',
      'start-setup-process',
      'oauth-code',
      'oauth-login-success',
      'stripe-payment-success',
      'stripe-payment-cancel'
    ];
    if (validOnChannels.includes(channel)) {
      const subscription = (event, ...args) => callback(...args);
      ipcRenderer.on(channel, subscription);
      return () => ipcRenderer.removeListener(channel, subscription);
    } else {
      console.warn(`ipcRenderer.on: Channel "${channel}" is not whitelisted.`);
      return () => {};
    }
  },
  // ç§»é™¤ç›‘å¬å™¨
  removeListener: (channel, callback) => {
    const validOnChannels = [
      'from-main',
      'api-response',
      'setup-status',
      'start-setup-process',
      'oauth-code',
      'oauth-login-success',
      'stripe-payment-success',
      'stripe-payment-cancel'
    ];
    if (validOnChannels.includes(channel)) {
      ipcRenderer.removeListener(channel, callback);
    }
  },
  // è°ƒç”¨ä¸»è¿›ç¨‹çš„ handle æ–¹æ³• (ç”¨äºåŒå‘é€šä¿¡)
  invoke: (channel, ...args) => {
    const validInvokeChannels = ['start-docker-setup'];
    if (validInvokeChannels.includes(channel)) {
      return ipcRenderer.invoke(channel, ...args);
    } else {
      console.warn(`ipcRenderer.invoke: Channel "${channel}" is not whitelisted.`);
      return Promise.reject(new Error(`Channel "${channel}" is not allowed.`));
    }
  }
});



================================================
FILE: README_CN.md
================================================
# Lemon AIæ˜¯å…¨çƒé¦–ä¸ªå…¨æ ˆå¼€æºè‡ªè¿›åŒ–é€šç”¨AIæ™ºèƒ½ä½“,æä¾›å®Œå…¨æœ¬åœ°åŒ–çš„æ›¿ä»£æ–¹æ¡ˆ,å¯æ›¿ä»£Manuså’ŒGenspark AIç­‰æ™ºèƒ½ä½“å¹³å°ã€‚å®ƒé…å¤‡é›†æˆçš„ä»£ç è§£é‡Šå™¨è™šæ‹Ÿæœºæ²™ç®±,å¯å®‰å…¨æ‰§è¡Œä»£ç ã€‚

<br><br>
<div align=center>
  <img src="./public/img/LemonAI_Evolving.png" width="500">
</div>
<br><br>
<p align="center">
  <a href="https://lemon-11.gitbook.io/lemonai/lemon-docs">å¿«é€Ÿäº†è§£ Lemon AI</a> Â·
  <a href="https://lemon-11.gitbook.io/lemonai/lemon-docs/kai-fa-bu-shu-zhi-nan/docker-kuai-su-bu-shu">Dockerå¿«é€Ÿéƒ¨ç½²</a> Â·
  <a href="https://lemon-11.gitbook.io/lemonai/lemon-docs">æ–‡æ¡£</a> Â·
  <a href="https://www.lemonai.cc">è®¿é—®å®˜ç½‘</a> Â·
  <a href="https://deepwiki.com/hexdocom/lemonai">DeepWiki</a> 
</p>

<p align="center">
  <a href="./README.md"><img alt="README in English" src="https://img.shields.io/badge/English-d9d9d9"></a>
  <a href="./README_CN.md"><img alt="ç®€ä½“ä¸­æ–‡ç‰ˆè‡ªè¿°æ–‡ä»¶" src="https://img.shields.io/badge/ç®€ä½“ä¸­æ–‡-d9d9d9"></a>
</p>

Lemon AIæ˜¯å…¨çƒé¦–ä¸ªå…¨æ ˆå¼€æºè‡ªè¿›åŒ–é€šç”¨AIæ™ºèƒ½ä½“,æä¾›å®Œå…¨æœ¬åœ°åŒ–çš„æ›¿ä»£æ–¹æ¡ˆ,å¯æ›¿ä»£Manuså’ŒGenspark AIç­‰æ™ºèƒ½ä½“å¹³å°ã€‚å®ƒé…å¤‡é›†æˆçš„ä»£ç è§£é‡Šå™¨è™šæ‹Ÿæœºæ²™ç®±,å¯å®‰å…¨æ‰§è¡Œä»£ç ã€‚

Lemon AIæ”¯æŒæ·±åº¦ç ”ç©¶ã€ç½‘é¡µæµè§ˆã€å¯è¡Œæ€§ç¼–ç å’Œæ•°æ®åˆ†æâ€”â€”å®Œå…¨åœ¨æ‚¨çš„æœ¬åœ°ç¡¬ä»¶ä¸Šè¿è¡Œã€‚å®ƒé€šè¿‡Ollamaã€VLLMæ”¯æŒä½¿ç”¨æœ¬åœ°å¤§è¯­è¨€æ¨¡å‹(å¦‚DeepSeekã€Kimiã€Qwenã€Llamaã€Gemmaã€GPTOSS)å®ç°è§„åˆ’ã€è¡ŒåŠ¨ã€åæ€å’Œè®°å¿†åŠŸèƒ½,ç¡®ä¿å®Œå…¨éšç§ä¿æŠ¤å’Œé›¶äº‘ç«¯ä¾èµ–ã€‚

ä¸ºå¢å¼ºå®‰å…¨æ€§,Lemon AIé€šè¿‡Dockeråœ¨æœ¬åœ°è™šæ‹Ÿæœº(VM)æ²™ç®±å†…è¿è¡Œã€‚è¯¥æ²™ç®±é€šè¿‡å®‰å…¨åœ°å¤„ç†æ‰€æœ‰ä»£ç ç¼–å†™ã€æ‰§è¡Œå’Œç¼–è¾‘ä»»åŠ¡,ä¿æŠ¤æ‚¨æœºå™¨çš„æ–‡ä»¶å’Œæ“ä½œç³»ç»Ÿã€‚

æ­¤å¤–,Lemon AIè¿˜æä¾›çµæ´»é…ç½®åŠŸèƒ½,å¯ä½¿ç”¨Claudeã€GPTã€Geminiå’ŒGrokç­‰é¢†å…ˆäº‘ç«¯æ¨¡å‹çš„APIæ¥å¢å¼ºç»“æœæ•ˆæœã€‚

<a href="https://youtu.be/OmU_4rrZUHE?si=iseqOl5TV2n2kovy">
  <figure>
    <img src="./public/img/githubvideo.png" alt="">
  </figure>
</a>

### åŠŸèƒ½ä¸ç‰¹ç‚¹

**å…¨çƒç¬¬â¼€æ¬¾å…¨æ ˆå¼€æºçš„ AI Agentic æ¡†æ¶ï¼Œå¤šå¿«å¥½çœï¼Œæ»¡â¾œå„ç±»éœ€æ±‚**

#### å¤šï¼šæ— é™å¤šå¯èƒ½ï¼Œæ— é™å¤šåœºæ™¯ 
Lemon AIä½œä¸ºæ”¯æŒæ— é™ä»»åŠ¡åœºæ™¯çš„é€šç”¨ AI Agent èƒ½åŠ›ï¼ŒåŒ…æ‹¬ï¼š
- æ·±åº¦æœç´¢ä¸ç ”ç©¶æŠ¥å‘Š  
- ä»£ç ç”Ÿæˆä¸æ•°æ®åˆ†æ  
- å†…å®¹åˆ›ä½œä¸æ–‡æ¡£å¤„ç†  
- æ”¯æŒç»éªŒåº“è‡ªå­¦ä¹ åŠæ‰©å±•ä¼ä¸šå®šåˆ¶åŒ–åŠŸèƒ½

#### è‡ªæˆ‘è¿›åŒ–
ä¸ºæ¯ä¸€æ¬¡å¯¹è¯å»ºç«‹ä¸“å±è®°å¿†ï¼Œè®© Agent éšç€ä½¿ç”¨å˜å¾—è¶Šæ¥è¶Šèªæ˜ã€è¶Šæ¥è¶Šè´´åˆä½ çš„éœ€æ±‚ã€‚

#### AI Agent HTML ç¼–è¾‘å™¨
ä½ åªéœ€ç‚¹å‡»ä»»æ„ HTML å…ƒç´ ï¼Œå°±èƒ½ç”± AI Agent ç›´æ¥ä¿®æ”¹å®ƒï¼Œæ— éœ€æ¯æ¬¡éƒ½é‡æ–°ç”Ÿæˆæ•´ä»½ HTML æ–‡ä»¶ã€‚å¯ä»¥ä¸æ–­è°ƒæ•´ï¼Œç›´åˆ°ä½ å®Œå…¨æ»¡æ„ä¸ºæ­¢ã€‚


**éƒ¨ç½²æ–¹å¼ï¼š** å¼€æºä»£ç ã€å®¹å™¨ã€å®¢æˆ·ç«¯åº”ç”¨ã€åœ¨çº¿è®¢é˜… â€”â€” å…¼å®¹äº‘ç«¯/æœ¬åœ°/ä¸€ä½“åŒ–ç³»ç»Ÿ  

#### å¿«ï¼šæé€Ÿéƒ¨ç½²ï¼Œå³åˆ»ä¸Šæ‰‹  
ä¸€é”®éƒ¨ç½²ï¼Œæ— éœ€å¤æ‚é…ç½®å³å¯ç«‹å³ä½¿ç”¨ï¼š
- æ‰€æœ‰éƒ¨ç½²æ–¹å¼å‡ç®€åŒ–å®‰è£…æµç¨‹  
- æ— éœ€å¤æ‚é…ç½®å³å¯å¿«é€Ÿæ­å»º  
- 5åˆ†é’Ÿå†…å³å¯ä½¿ç”¨çš„ç³»ç»Ÿ  
- æ”¯æŒä»ä¸ªäººç”µè„‘åˆ°ä¼ä¸šæœåŠ¡å™¨çš„å„ç§éƒ¨ç½²ç¯å¢ƒï¼Œé…å¤‡å®Œæ•´æ–‡æ¡£ä»¥ç¡®ä¿é¡ºåˆ©å®æ–½  

#### å¥½ï¼šåŠŸèƒ½å¼ºå¤§ï¼Œçµæ´»å¯å®šåˆ¶
åŠŸèƒ½å¼ºå¤§çš„æ¡†æ¶ï¼Œå…·å¤‡å¹¿æ³›çš„èƒ½åŠ›ï¼š
- è™šæ‹Ÿæœºé›†æˆ  
- ä»£ç ç”Ÿæˆä¸æ‰§è¡Œ  
- æµè§ˆå™¨æ“ä½œä¸ç½‘é¡µæœç´¢  
- å¤šå·¥å…·é›†æˆ  
- é«˜åº¦å¯æ‰©å±•æ¶æ„ï¼Œæ”¯æŒæ ¹æ®ç‰¹å®šä¸šåŠ¡éœ€æ±‚è¿›è¡Œå®šåˆ¶ä¿®æ”¹å’Œæ‰©å±•ï¼Œå¹¶å¯ä¸ç°æœ‰ç³»ç»Ÿæ— ç¼é›†æˆ  

#### çœï¼šåŒç­‰è´¨é‡ï¼Œæˆæœ¬é™ä½10å€ 
æ˜¾è‘—é™ä½è¿è¥æˆæœ¬ï¼š
- ä¸å…¶ä»–AI Agentäº§å“ç›¸æ¯”ï¼ŒLemon AIçš„å•æ¬¡ä»»åŠ¡æˆæœ¬å¯é™ä½10å€ä»¥ä¸Š  
- å¼€æºè®¢é˜…æ¨¡å¼  
- åŸºäºå¼€æº DeepSeekV3 æ¨¡å‹  
- åœ¨ä¸ç‰ºç‰²è´¨é‡å’Œæ€§èƒ½çš„å‰æä¸‹å¤§å¹…èŠ‚çœæˆæœ¬ï¼Œä½¿å„ç±»è§„æ¨¡ç»„ç»‡éƒ½èƒ½è½»æ¾è·å–å…ˆè¿›çš„ AI èƒ½åŠ›

### Lemon AI Editor

**å…¨çƒé¦–æ¬¾é€šç”¨AIæ™ºèƒ½ä½“ç¼–è¾‘å™¨---Lemon AI Editor**

#### ä¸ºä»€ä¹ˆæˆ‘ä»¬éœ€è¦ä¸€ä¸ªé€šç”¨AIæ™ºèƒ½ä½“ç¼–è¾‘å™¨ï¼Ÿ

å½“ä½ ä½¿ç”¨æ™ºèƒ½ä½“åˆ›å»ºç ”ç©¶æŠ¥å‘Šã€Vibeç¼–ç¨‹æˆ–ç”Ÿæˆæ•°æ®åˆ†æå›¾è¡¨æ—¶ï¼Œç»“æœå¾€å¾€å¹¶ä¸å®Œç¾ã€‚è€Œå½“ä½ è¯•å›¾ä¿®å¤æŸä¸€éƒ¨åˆ†æ—¶ï¼Œå…¶ä½™éƒ¨åˆ†å¯èƒ½ä¼šå˜å¾—æ··ä¹±ã€‚æˆ‘ä»¬çœŸæ­£éœ€è¦çš„æ˜¯äººç±»ä¸AIä¹‹é—´çš„æ— ç¼åä½œã€‚Lemon AIç¼–è¾‘å™¨è®©ä½ èƒ½å¤Ÿæ ¹æ®éœ€è¦å¤šæ¬¡ä¼˜åŒ–æ‰€æœ‰è¿™äº›ç»“æœï¼Œç›´åˆ°ä½ å®Œå…¨æ»¡æ„ä¸ºæ­¢ã€‚ä½ å¯ä»¥ä¸€éåˆä¸€éåœ°åå¤ç¼–è¾‘ã€‚

#### åŠŸèƒ½å’Œç‰¹ç‚¹

Lemon AI Editor åŠŸèƒ½æ”¯æŒå¯¹ç”Ÿæˆçš„HTMLé¡µé¢è¿›è¡ŒæŒç»­ç¼–è¾‘ã€ä¿®æ”¹ã€å®Œå–„ï¼Œæ‰€è§å³æ‰€å¾—ï¼Œæ‰€ç‚¹å³å¯æ”¹ã€‚

1.AI ç¼–è¾‘æ¨¡å¼ï¼š

 - è®©AIä¿®æ”¹é¡µé¢ä¸­ä»»æ„æ¿å—å†…å®¹

 - è®©AIæ’å…¥å…¨æ–°æ®µè½æˆ–å†…å®¹

 - è®©AIé‡æ–°æ ¼å¼åŒ–æ•´ä¸ªé¡µé¢

2.é«˜çº§ç¼–è¾‘æ¨¡å¼ï¼šç›´æ¥ç¼–è¾‘ï¼Œå¿«é€Ÿäººå·¥è°ƒæ•´æ–‡æœ¬ã€‚

<a href="https://youtu.be/XaU4Vnt1lTI?si=iQJRSAaiUcqaN45k">
  <figure>
    <img src="./public/img/githubEditor2.png" alt="">
  </figure>
</a>

### ä½¿ç”¨ Lemon AI

* ä½¿ç”¨è¿™ä¸ª[å…¥é—¨æŒ‡å—](https://lemon-11.gitbook.io/lemon-docs)å¿«é€Ÿåœ¨æ‚¨çš„ç¯å¢ƒä¸­è¿è¡Œ Lemon AIã€‚æ›´å¤šå‚è€ƒå’Œè¯¦ç»†è¯´æ˜è¯·å‚é˜…æˆ‘ä»¬çš„æ–‡æ¡£ã€‚

### è¿è¡Œ Lemon AI

#### ç³»ç»Ÿè¦æ±‚ <a href="#system-requirements" id="system-requirements"></a>

* [æ”¯æŒ Docker Desktop](https://docs.docker.com/desktop/setup/install/mac-install/#system-requirements)çš„ MacOS
* Linux
* [æ”¯æŒWSL](https://learn.microsoft.com/en-us/windows/wsl/install)å’Œ[Docker Desktop çš„](https://docs.docker.com/desktop/setup/install/windows-install/#system-requirements)Windows

å»ºè®®ä½¿ç”¨å…·æœ‰ç°ä»£å¤„ç†å™¨å’Œè‡³å°‘**4GB RAMçš„ç³»ç»Ÿæ¥è¿è¡Œ Lemon AIã€‚**

#### **MacOS**

**Docker æ¡Œé¢**

1.  [åœ¨ Mac ä¸Šå®‰è£… Docker Desktop](https://docs.docker.com/desktop/setup/install/mac-install)ã€‚
2.  æ‰“å¼€ Docker Desktopï¼Œè½¬åˆ°`Settings > Advanced`å¹¶ç¡®ä¿`Allow the default Docker socket to be used`å·²å¯ç”¨ã€‚

#### **Linux**

ä½¿ç”¨ Ubuntu 22.04 æµ‹è¯•ã€‚

**Docker æ¡Œé¢**

1.  [åœ¨ Linux ä¸Šå®‰è£… Docker Desktop](https://docs.docker.com/desktop/setup/install/linux/)ã€‚

#### **Windows**

**WSL**

1.  [å®‰è£… WSL](https://learn.microsoft.com/en-us/windows/wsl/install)ã€‚
2.  `wsl --version`åœ¨ powershell ä¸­è¿è¡Œå¹¶ç¡®è®¤`Default Version: 2`ã€‚

**Docker æ¡Œé¢**

1.  [åœ¨ Windows ä¸Šå®‰è£… Docker Desktop](https://docs.docker.com/desktop/setup/install/windows-install)ã€‚
2.  æ‰“å¼€Docker Desktopï¼Œå‰å¾€`Settings`å¹¶ç¡®è®¤ä»¥ä¸‹å†…å®¹ï¼š

    * å¸¸è§„ï¼š`Use the WSL 2 based engine`å·²å¯ç”¨ã€‚
    * èµ„æº > WSL é›†æˆï¼š`Enable integration with my default WSL distro`å·²å¯ç”¨ã€‚

å¿…é¡»åœ¨ WSL ç»ˆç«¯å†…è¿è¡Œä»¥ä¸‹ç”¨äºå¯åŠ¨åº”ç”¨ç¨‹åºçš„ docker å‘½ä»¤ã€‚

### å¯åŠ¨åº”ç”¨ç¨‹åº <a href="#start-the-app" id="start-the-app"></a>

è¿è¡ŒLemon AIæœ€ç®€å•çš„æ–¹æ³•æ˜¯ä½¿ç”¨ Dockerã€‚

```bash
docker pull hexdolemonai/lemon-runtime-sandbox:latest

docker run -it --rm --pull=always \
  --name lemon-app \
  --env DOCKER_HOST_ADDR=host.docker.internal \
  --env ACTUAL_HOST_WORKSPACE_PATH=${WORKSPACE_BASE:-$PWD/workspace} \
  --publish 5005:5005 \
  --add-host host.docker.internal:host-gateway \
  --volume /var/run/docker.sock:/var/run/docker.sock \
  --volume ~/.cache:/.cache \
  --volume ${WORKSPACE_BASE:-$PWD/workspace}:/workspace \
  --volume ${WORKSPACE_BASE:-$PWD/data}:/app/data \
  --interactive \
  --tty \
  hexdolemonai/lemon:latest make run
```

### è´¡çŒ®

å¯¹äºé‚£äº›æƒ³è¦è´¡çŒ®ä»£ç çš„äººï¼Œè¯·å‚é˜…æˆ‘ä»¬çš„[è´¡çŒ®æŒ‡å—](https://github.com/hexdocom/lemon/blob/main/CONTRIBUTING_CN.md)ã€‚åŒæ—¶ï¼Œè¯·è€ƒè™‘é€šè¿‡ç¤¾äº¤åª’ä½“ã€æ´»åŠ¨å’Œä¼šè®®æ¥æ”¯æŒ Lemon AI çš„åˆ†äº«ã€‚

#### è´¡çŒ®è€…

<a href="https://github.com/hexdocom/lemonai/graphs/contributors">
  <img src="https://contrib.rocks/image?repo=hexdocom/lemonai" />
</a>


### ç¤¾åŒºä¸æ”¯æŒ

æˆ‘ä»¬æ¬¢è¿æ‚¨ä¸º Lemon AI ä½œå‡ºè´¡çŒ®ï¼Œä»¥å¸®åŠ©æ”¹å–„ Lemon AIã€‚åŒ…æ‹¬ï¼šæäº¤ä»£ç ã€é—®é¢˜ã€æ–°æƒ³æ³•ï¼Œæˆ–åˆ†äº«æ‚¨åŸºäº Lemon AIåˆ›å»ºçš„æœ‰è¶£ä¸”æœ‰ç”¨çš„ AI åº”ç”¨ç¨‹åºã€‚åŒæ—¶ï¼Œæˆ‘ä»¬ä¹Ÿæ¬¢è¿æ‚¨åœ¨ä¸åŒçš„æ´»åŠ¨ã€ä¼šè®®å’Œç¤¾äº¤åª’ä½“ä¸Šåˆ†äº« Lemon AIã€‚

* [GitHub Discussion](https://github.com/hexdocom/lemonai/discussions). ğŸ‘‰ï¼šåˆ†äº«æ‚¨çš„åº”ç”¨ç¨‹åºå¹¶ä¸ç¤¾åŒºäº¤æµã€‚
* [GitHub Issues](https://github.com/hexdocom/lemon/issues)ã€‚ğŸ‘‰ï¼šä½¿ç”¨ Lemon AI æ—¶é‡åˆ°çš„é”™è¯¯å’Œé—®é¢˜ï¼Œè¯·å‚é˜…è´¡çŒ®æŒ‡å—
* ç”µå­é‚®ä»¶æ”¯æŒğŸ‘‰ï¼šå…³äºä½¿ç”¨ Lemonçš„é—®é¢˜ã€‚
* [X(Twitter)](https://x.com/LemonAI_cc)ã€‚ğŸ‘‰ï¼šåˆ†äº«æ‚¨çš„åº”ç”¨ç¨‹åºå¹¶ä¸ç¤¾åŒºäº¤æµã€‚
* [Discord](https://discord.com/invite/gjEXg4UBR4)ã€‚ğŸ‘‰ï¼šåˆ†äº«æ‚¨çš„åº”ç”¨ç¨‹åºå¹¶ä¸ç¤¾åŒºäº¤æµã€‚
* å•†ä¸šè®¸å¯ã€‚ğŸ‘‰ï¼šæœ‰å…³å•†ä¸šç”¨é€”è®¸å¯å‘é€é‚®ä»¶è‡³feedback@lemonai.ccè¿›è¡ŒLemon AIçš„å•†ä¸šå’¨è¯¢ã€‚

### Star History

[![Star History Chart](https://api.star-history.com/svg?repos=hexdocom/lemonai&type=Date)](https://www.star-history.com/#hexdocom/lemonai&Date)

### å®‰å…¨é—®é¢˜

ä¸ºäº†ä¿æŠ¤æ‚¨çš„éšç§ï¼Œè¯·é¿å…åœ¨ GitHub ä¸Šå‘å¸ƒå®‰å…¨é—®é¢˜ã€‚å‘é€é—®é¢˜è‡³feedback@lemonai.ccæˆ‘ä»¬å°†ä¸ºæ‚¨åšæ›´è¿›ä¸€æ­¥çš„è§£ç­”ã€‚

### æ‰§ç…§

æœ¬ä»“åº“éµå¾ªLemon AI Open Source License åè®®å¼€æºï¼Œè¯¥è®¸å¯è¯æœ¬è´¨ä¸Šæ˜¯Apache 2.0ï¼Œä½†æœ‰ä¸€äº›é¢å¤–çš„é™åˆ¶ã€‚



================================================
FILE: setup-renderer.js
================================================
// renderer/setup-renderer.js

// ä» window.electronAPI è®¿é—®æš´éœ²çš„ API
// å¦‚æœ preload è„šæœ¬ä¸­æš´éœ²çš„å±æ€§åä¸åŒï¼Œè¿™é‡Œä¹Ÿéœ€è¦ç›¸åº”ä¿®æ”¹
const { on, invoke,send } = window.electronAPI;

const statusMessageEl = document.getElementById('status-message');
const progressBarEl = document.getElementById('progress-bar');
const progressBarContainerEl = document.getElementById('progress-bar-container');
const errorMessageEl = document.getElementById('error-message');

// ç›‘å¬ä¸»è¿›ç¨‹å‘é€çš„çŠ¶æ€æ›´æ–°
// ä½¿ç”¨æš´éœ²çš„ on æ–¹æ³•
// æ³¨æ„ï¼šæš´éœ²çš„ on æ–¹æ³•é€šå¸¸ä¼šå»æ‰ event å‚æ•°
on('setup-status', (status) => {
    //ç¬¬ä¸€æ­¥ checking-docker
    console.log('status:', status);
    if  (status.step === 'checking-docker') {
        //æ‰¾åˆ°ç¬¬ä¸€ä¸ª step-number å¤šä¸ª å–ç¬¬ä¸€ä¸ª å¢åŠ ä¸€ä¸ªç±»å active
        const stepNumberEl = document.getElementsByClassName('step-number')[0]
        console.log("stepNumberEl",stepNumberEl)
        stepNumberEl.classList.add('active');
        statusMessageEl.innerText =  status.message;
    }
    if  (status.step === 'startDocker') {
        const stepNumberEl = document.getElementsByClassName('step-number')[1]
        console.log("stepNumberEl",stepNumberEl)
        stepNumberEl.classList.add('active');
        statusMessageEl.innerText = status.message;
    }
    //checkDockerImages
    if  (status.step === 'checkDockerImages') {
        const stepNumberEl = document.getElementsByClassName('step-number')[2]
        console.log("stepNumberEl",stepNumberEl)
        stepNumberEl.classList.add('active');
        statusMessageEl.innerText =  status.message;
    }

    console.log('Setup status received:', status);
    statusMessageEl.innerText = status.message;

    if (status.step === 'downloading' && status.progress !== undefined) {
        //æ˜¾ç¤º #progress-bar-container
        progressBarContainerEl.style.display = 'block';
        const percentage = Math.round(status.progress * 100);
        progressBarEl.style.width = percentage + '%';
        progressBarEl.innerText = percentage + '%';
        progressBarContainerEl.style.display = 'block'; // æ˜¾ç¤ºè¿›åº¦æ¡
    } else {
         progressBarContainerEl.style.display = 'none'; // å…¶ä»–æ­¥éª¤éšè—è¿›åº¦æ¡
    }

    if (status.step === 'error') {
        errorMessageEl.innerText = status.message;
        errorMessageEl.style.display = 'block';
        // å¯ä»¥æ·»åŠ ä¸€ä¸ªé‡è¯•æŒ‰é’®æˆ–è€…å¼•å¯¼ç”¨æˆ·å¦‚ä½•è§£å†³é—®é¢˜
    } else if (status.step === 'complete') {
         // è®¾ç½®å®Œæˆï¼Œç­‰å¾…ä¸»è¿›ç¨‹åŠ è½½ä¸»é¡µé¢
         errorMessageEl.style.display = 'none';
    }
});


================================================
FILE: setup.html
================================================
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Application Initialization...</title>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; padding-top: 50px; background-color: #f9f9f9; }
        .container { max-width: 600px; margin: 0 auto; }
        .steps-container { display: flex; justify-content: space-between; align-items: flex-start; }
        .step-item { width: calc(33.33% - 20px); position: relative;    display: flex;flex-direction: column;align-content: center;align-items: center;}
        #progress-bar-container { display: none; width: 80%; margin: 20px auto; background-color: #f3f3f3; border-radius: 5px; }
        #progress-bar { width: 0%; height: 25px; background-color: #4CAF50; border-radius: 5px; text-align: center; line-height: 25px; color: white; }
        .step-number { 
            font-size: 1em; font-weight: bold; color: #fff;
            width: 32px;
            height: 32px;
            margin-top: 10px;
            margin-bottom: 10px;
            border-radius: 100px;
            background: #d9d9d9;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #status-message{
            margin-top: 30px;
        }
        .step-number.active { background: #1677ff; }
        /* .step-number.success { color: #52c41a; }
        .step-number.failed { color: #f5222d; } */
        .step-title { font-size: 16px; margin-bottom: 5px; color: #333; text-align: center; }
        .status-message { color: #777; text-align: center; }
        .progress-bar-container { width: 100%; background-color: #e0e0e0; border-radius: 5px; overflow: hidden; display: none; margin-top: 10px; }
        .progress-bar { height: 25px; background-color: #1890ff; border-radius: 5px; text-align: center; line-height: 25px; color: white; transition: width 1s ease-in-out; }
        .progress-bar.failed { background-color: #f5222d; }
        .arrow { position: absolute; right: 0; top: 50%; transform: translateY(-50%); font-size: 2em; color: #aaa; }
        .last-step .arrow { display: none; }
        #error-message { color: red; margin-top: 20px; display: none; font-size: 1.1em; }
    </style>
</head>
<body>
    <div class="container">
        <h1 style="color: #333;">Application Initialization</h1>
        <div class="steps-container">
            <div class="step-item">
                <span class="step-number active" id="step-number-step1">1</span>
                <div class="step-title">Check if Docker is Installed</div>
            </div>
            <div class="step-item">
                <span class="step-number" id="step-number-step2">2</span>
                <div class="step-title">Check if Docker is Start </div>
            </div>
            <div class="step-item last-step">
                <span class="step-number" id="step-number-step3">3</span>
                <div class="step-title">Check if image exists</div>
            </div>
        </div>
        <div id="status-message">Initializing...</div>
        <div id="progress-bar-container">
            <div id="progress-bar">0%</div>
        </div>
        <div id="error-message"></div>
    </div>
     <script src="./setup-renderer.js"></script>
</body>
</html>


================================================
FILE: vite.main.config.js
================================================
import { defineConfig } from 'vite';
import { builtinModules } from 'node:module';
import pkg from './package.json';

const builtins = [
  'electron',
  ...builtinModules.map((m) => [m, `node:${m}`]).flat(),
];

const external = [...builtins, ...Object.keys(pkg.dependencies || {})];

export default defineConfig({
  root: '.',
  build: {
    outDir: '.vite',   // æŒ‡å®šæ„å»ºç›®å½•ä¸º .vite
    emptyOutDir: true, // æ¯æ¬¡æ„å»ºå‰æ¸…ç©ºç›®å½•
    sourcemap: false,
    rollupOptions: {
      input: 'main.js',   // æŒ‡å®šå…¥å£æ–‡ä»¶
      external,
      output: {
        format: 'cjs',
        entryFileNames: 'main.js',  // ç”Ÿæˆæ–‡ä»¶å
      },
    },
    target: 'node16',  // ç›®æ ‡ç¯å¢ƒï¼ˆnodeç‰ˆæœ¬ï¼‰
    minify: false,     // ä¸»è¿›ç¨‹ä¸€èˆ¬ä¸å¼€å¯å‹ç¼©ï¼Œæ–¹ä¾¿è°ƒè¯•
  },
});



================================================
FILE: vite.preload.config.js
================================================
import { defineConfig } from 'vite';
import { builtinModules } from 'node:module';
import pkg from './package.json';

export const builtins = [
  'electron',
  ...builtinModules.map((m) => [m, `node:${m}`]).flat(),
];

export const external = [...builtins, ...Object.keys(pkg.dependencies || {})];


export default defineConfig({
  root: '.', 
  build: {
    lib: {
      entry: 'preload.js', // é¢„åŠ è½½è„šæœ¬å…¥å£
      formats: ['cjs'],
      fileName: () => 'preload.js',
    },
    rollupOptions: {
      external
    },
    outDir: '.vite',  
    emptyOutDir: true,
  },
});


================================================
FILE: WEB_README.md
================================================
### Front End Configuration File

Front-end configuration files are located infrontend/.envUnder the document. You can referfrontend/.env.exampleFile to learn about the available configuration items and their examples.

#### Configuration Item Description

* **VITE\_SERVICE\_URL**
  * Description: Defines the start address and port of the backend service.
  * Default:http://127.0.0.1:3000
  * Example:

VITE\_SERVICE\_URL=http://127.0.0.1:3000\


*
  * Note: Modify the endpoint and port of the backend service.
* **VITE\_PORT**
  * Description: Defines the port number of the front-end application.
  * Default:5005
  * Example:

VITE\_PORT=5005\


*
  * Description: After the front end is started, you can passhttp://localhost:5005Access the Lemon app.



================================================
FILE: .env.example
================================================
STORAGE_PATH=data/database.sqlite
WORKSPACE_DIR=workspace
RUNTIME_TYPE=local-docker
ENABLE_KNOWLEDGE=ON


================================================
FILE: browser_server/readme.md
================================================
the project use python environment

# install

```bash
cd /path/to/browserUse
```
you can use uv or pip or other to install 

## uv installï¼š

recommend uv to manage python environment


create virtual environment

```
uv venv 
```

activate virtual environment

+ Linux/macOSï¼š

```
source .venv/bin/activate
```

+ windows

```
.venv\Scripts\activate
```

install requirements

+ pyproject.tomlï¼š

```
uv pip install .
```

+ requirements.txtï¼š

```
uv pip install -r requirements.txt
```

## Pip installï¼š

acitavate virtual environment


```
pip install -r requirements.txt
```


## browser plugins install:

```bash
# before this step, you need to activate virtual environment
patchright install chromium --with-deps --no-shell
```



# launch

```bash
cd /path/to/browser_server
```

```bash
# activate virtual environment
```

```
python src/server.py
```



# tips:

the model must support tool calling and function calling, vision mode only supports gpt-4o



================================================
FILE: browser_server/pyproject.toml
================================================
[project]
name = "browser-server"
version = "0.1.0"
description = "a web server for browser-use"
readme = "README.md"
requires-python = ">=3.11"
dependencies = [
    "browser-use[memory]>=0.2.5",
    "fastapi>=0.115.12",
    "pyobjtojson>=0.3",
    "uvicorn>=0.34.3",
    "patchright>=1.52.0"
]



================================================
FILE: browser_server/report.md
================================================
[Binary file]


================================================
FILE: browser_server/requirements.txt
================================================
browser-use[memory]==0.2.5
fastapi>=0.115.12
pyobjtojson>=0.3
uvicorn>=0.34.3
patchright>=1.52.0


================================================
FILE: browser_server/browser_use/server.py
================================================
import datetime
import os
from fastapi import FastAPI, Request,HTTPException
from service.browser_agent import browser_agent_manager
from config.load_config import config
from utils.response_util import create_response
from utils.request_util import parse_task_json

def init():
    #  must be set OPENAI_API_KEY ENV
    os.environ["OPENAI_API_KEY"] = ""
    # SKIP_LLM_API_KEY_VERIFICATION = true  ;this will skip the api key verification
    # os.environ["SKIP_LLM_API_KEY_VERIFICATION"] = 'true' 
    # print(os.environ)
    return
    
app = FastAPI()

@app.post("/api/browser/task")
async def browser_task(request: Request):
    start_time = datetime.datetime.now()
    try:
        data = await request.json()
        print("[INFO]    [agent] Recevied request data:\n", data)
        task = await parse_task_json(data)
        llm_config = task.llm_config
        # try:
        history = await browser_agent_manager.run_task_only(
            task.prompt,
            model=llm_config["model_name"],
            api_key=llm_config["api_key"],
            base_url=llm_config["api_url"],
            conversation_id=task.conversation_id,
        )
        end_time = datetime.datetime.now()
        response = create_response(
            200,
            "Task Finished",
            {
                "time": datetime.datetime.now().isoformat(),
                "time_cost": (end_time - start_time).total_seconds(),
                "history": history
            },
        )
        return response
    except ConnectionError as e:
        return HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        print("[ERROR]     Exception:",e)
        return HTTPException(status_code=400, detail=str(e))
        

    

if __name__ == "__main__":
    import uvicorn
    init()
    uvicorn.run(app, host=config['server']['host'], port=config['server']['port'])


================================================
FILE: browser_server/browser_use/agent/agent.py
================================================
from langchain_openai import ChatOpenAI
from browser_use import Agent
# from utils.read_file import read_file
import os
from pathlib import Path
from typing import Optional

class BrowserAgent:
    def __init__(self):
        # agent prompt path
        self.prompts_base_path = Path(__file__).parent.parent / 'agent' / 'prompt'
        self.prompts_extend_path = self.prompts_base_path / 'extend'
        self.prompts_extend = self._load_prompts(self.prompts_extend_path)
    
    def _load_prompts(self,prompt_files_path: Path):
        prompts = []
        for file_path in os.listdir(prompt_files_path):
            with open(os.path.join(prompt_files_path, file_path), 'r', encoding='utf-8') as file:
                prompts.append(file.read())
        return prompts

    def get_agent(self, task: str,model:str,api_key:str,base_url,extend_prompt_id:int=-1,browser_session = None,conversation_id:str=None):
        # init llm
        llm = self._get_llm(model,api_key,base_url,conversation_id)
        
        # get extend prompt
        extend_prompt = self.prompts_extend[extend_prompt_id]
        print(f"INFO  [system] system extend agent prompt:\n\n\n{extend_prompt}\n\n\n")
        tool_calling_method = 'auto'
        if 'doubao' in model:
            tool_calling_method = 'raw'
        return Agent(task=task, llm=llm,
                      override_system_message=None,
                      extend_system_message=extend_prompt,
                      browser_session = browser_session,
                      use_vision=False,
                      tool_calling_method=tool_calling_method
                      )
    def get_extend_prompt(self, prompt_id:int = 0):
        return self.prompts_extend[prompt_id]
    

    def _get_llm(self,model,api_key,base_url,conversation_id):
        print(f"INFO   [system] Init LLM model:{model}; api_key:**************** ; base_url:{base_url}")
        llm = ChatOpenAI(model=model, api_key=api_key, base_url=base_url,
                         extra_body=self._extra_body(conversation_id)
                         )
        return llm
    @staticmethod
    def _extra_body(conversation_id:Optional[str] = None):
        if conversation_id:
            print(f"INFO   [system] Lemon conversation_id:{conversation_id}")
            return {"conversation_id":conversation_id,
                    "enable_thinking": False, 
                    }
        else:
            return {
                "enable_thinking": False, 
            }

browser_agent = BrowserAgent()

if  __name__ == "__main__":
    browser_agent = BrowserAgent()
    print(browser_agent.get_extend_prompt(1))


================================================
FILE: browser_server/browser_use/agent/prompt/base_system_prompt.md
================================================
You are an AI agent designed to automate browser tasks. Your goal is to accomplish the ultimate task following the rules.

# Input Format

Task
Previous steps
Current URL
Open Tabs
Interactive Elements
[index]<type>text</type>

- index: Numeric identifier for interaction
- type: HTML element type (button, input, etc.)
- text: Element description
  Example:
  [33]<div>User form</div>
  \t*[35]*<button aria-label='Submit form'>Submit</button>

- Only elements with numeric indexes in [] are interactive
- (stacked) indentation (with \\t) is important and means that the element is a (html) child of the element above (with a lower index)
- Elements with \* are new elements that were added after the previous step (if url has not changed)

# Response Rules

1. RESPONSE FORMAT: You must ALWAYS respond with valid JSON in this exact format:
   {{"current_state": {{"evaluation_previous_goal": "Success|Failed|Unknown - Analyze the current elements and the image to check if the previous goals/actions are successful like intended by the task. Mention if something unexpected happened. Shortly state why/why not",
   "memory": "Description of what has been done and what you need to remember. Be very specific. Count here ALWAYS how many times you have done something and how many remain. E.g. 0 out of 10 websites analyzed. Continue with abc and xyz",
   "next_goal": "What needs to be done with the next immediate action"}},
   "action":[{{"one_action_name": {{// action-specific parameter}}}}, // ... more actions in sequence]}}

2. ACTIONS: You can specify multiple actions in the list to be executed in sequence. But always specify only one action name per item. Use maximum {max_actions} actions per sequence.
Common action sequences:

- Form filling: [{{"input_text": {{"index": 1, "text": "username"}}}}, {{"input_text": {{"index": 2, "text": "password"}}}}, {{"click_element": {{"index": 3}}}}]
- Navigation and extraction: [{{"go_to_url": {{"url": "https://example.com"}}}}, {{"extract_content": {{"goal": "extract the names"}}}}]
- Actions are executed in the given order
- If the page changes after an action, the sequence is interrupted and you get the new state.
- Only provide the action sequence until an action which changes the page state significantly.
- Try to be efficient, e.g. fill forms at once, or chain actions where nothing changes on the page
- only use multiple actions if it makes sense.

3. ELEMENT INTERACTION:

- Only use indexes of the interactive elements

4. NAVIGATION & ERROR HANDLING:

- If no suitable elements exist, use other functions to complete the task
- If stuck, try alternative approaches - like going back to a previous page, new search, new tab etc.
- Handle popups/cookies by accepting or closing them
- Use scroll to find elements you are looking for
- If you want to research something, open a new tab instead of using the current tab
- If captcha pops up, try to solve it - else try a different approach
- If the page is not fully loaded, use wait action

5. TASK COMPLETION:

- Use the done action as the last action as soon as the ultimate task is complete
- Dont use "done" before you are done with everything the user asked you, except you reach the last step of max_steps.
- If you reach your last step, use the done action even if the task is not fully finished. Provide all the information you have gathered so far. If the ultimate task is completely finished set success to true. If not everything the user asked for is completed set success in done to false!
- If you have to do something repeatedly for example the task says for "each", or "for all", or "x times", count always inside "memory" how many times you have done it and how many remain. Don't stop until you have completed like the task asked you. Only call done after the last step.
- Don't hallucinate actions
- Make sure you include everything you found out for the ultimate task in the done text parameter. Do not just say you are done, but include the requested information of the task.

6. VISUAL CONTEXT:

- When an image is provided, use it to understand the page layout
- Bounding boxes with labels on their top right corner correspond to element indexes

7. Form filling:

- If you fill an input field and your action sequence is interrupted, most often something changed e.g. suggestions popped up under the field.

8. Long tasks:

- Keep track of the status and subresults in the memory.
- You are provided with procedural memory summaries that condense previous task history (every N steps). Use these summaries to maintain context about completed actions, current progress, and next steps. The summaries appear in chronological order and contain key information about navigation history, findings, errors encountered, and current state. Refer to these summaries to avoid repeating actions and to ensure consistent progress toward the task goal.

9. Extraction:

- If your task is to find information - call extract_content on the specific pages to get and store the information.
  Your responses must be always JSON with the specified format.



================================================
FILE: browser_server/browser_use/agent/prompt/extend/extend_prompt_v1.md
================================================
### 10. Task Termination Conditions
- **Multiple Attempts Without Progress**:
  - If no substantial progress is made toward the goal after multiple attempts (3 consecutive action sequences) and the plan remains unchanged, terminate the task immediately.
  - Use the `done` action, set `success` to `false`, and provide possible reasons for failure in the `text` parameter (e.g., missing critical interactive elements, unexpected page structure, or unavailable target information).
- **CAPTCHA or Human Verification**:
  - If a CAPTCHA or any form of human verification (e.g., slider, image selection) is encountered, attempt to use an alternative website or method to achieve the goal.
  - If human verification appears on 3 consecutive different websites, terminate the task immediately.
  - Use the `done` action, set `success` to `false`, and specify in the `text` parameter that the task was terminated due to repeated human verification issues.
- **Stuck in a Loop**:
  - If the task repeatedly executes actions on the same page or similar state (3 consecutive actions without significant page state change, such as unchanged URL or interactive elements), identify this as "stuck in a loop" and terminate the task immediately.
  - Use the `done` action, set `success` to `false`, and explain in the `text` parameter that the task was terminated due to looping, with possible reasons like failed dynamic page loading or restricted interaction logic.
- **Termination Response Format**:
  - When terminating the task, use the following JSON format for the `done` action:
    ```json
    {
      "current_state": {
        "evaluation_previous_goal": "Failed - No progress after multiple attempts, CAPTCHA issues, or stuck in a loop",
        "memory": "Detailed description of attempts made, websites visited, and issues encountered (e.g., 3 CAPTCHAs, no new elements after 3 actions)",
        "next_goal": "Task terminated due to lack of progress, CAPTCHA issues, or looping"
      },
      "action": [
        {
          "done": {
            "success": false,
            "text": "Task terminated. Possible reasons: [e.g., no progress after 3 attempts due to missing interactive elements, 3 consecutive CAPTCHAs, or looping on the same page]"
          }
        }
      ]
    }
    ```


================================================
FILE: browser_server/browser_use/agent/prompt/extend/extend_prompt_v2.md
================================================
10. ERROR TERMINATION CONDITIONS:
   - **Repeated Human Verification**:
     - If human verification prompts (e.g., CAPTCHAs, sliders, image selection, or text input) are encountered during task execution, abandon the source triggering the verification (e.g., website, search engine) and switch to an alternative path to achieve the task goal.
     - If human verification is encountered on **3 consecutive different sources** (e.g., websites or search engines), terminate the task immediately.
     - Use the `done` action, set `success` to `false`, and specify in the `text` parameter that the task was terminated due to repeated human verification issues, including details of the sources attempted (e.g., URLs and verification types).
     - Example: Encountered CAPTCHAs on example.com, test.org, and site.net consecutively.
   - **No Progress After Multiple Steps**:
     - If no meaningful progress is made toward the task goal after **3 consecutive action sequences** (e.g., no new relevant elements, data, or page state changes), terminate the task immediately.
     - Use the `done` action, set `success` to `false`, and provide detailed reasons for failure in the `text` parameter, such as missing critical interactive elements (e.g., no search bar or form), unexpected page structure (e.g., 404 error), or unavailable target information (e.g., no relevant results).
   - **Stuck in a Loop**:
     - If the task repeatedly executes actions on the same page or similar state (e.g., unchanged URL, DOM structure, or interactive elements after **3 consecutive actions**), classify this as "stuck in a loop" and terminate the task immediately.
     - Use the `done` action, set `success` to `false`, and explain in the `text` parameter that the task was terminated due to looping, with possible reasons such as failed dynamic page loading (e.g., JavaScript errors), restricted interaction logic (e.g., disabled buttons), or server-side restrictions (e.g., rate limits).
   - **Termination Response**:
     - Upon termination, include a clear explanation of the failure reason and explicitly instruct the caller **not to retry the task**, as repeated attempts are unlikely to resolve the underlying issues.
     - Ensure the `memory` field includes a comprehensive log with timestamps, visited sources (e.g., URLs), actions taken, specific issues encountered (e.g., error messages, network issues), and any external factors (e.g., rate limits, authentication barriers).
     - Use the following JSON format for the `done` action:
       ```json
       {
         "current_state": {
           "evaluation_previous_goal": "Failed - [Specific reason: Repeated human verification, no progress after multiple steps, or stuck in a loop]",
           "memory": "Detailed log of attempts, including timestamps, sources visited (e.g., URLs), actions taken, issues encountered (e.g., 3 CAPTCHAs on [list sources], no new elements after 3 actions on [URL], JavaScript error on [URL]), and external factors (e.g., network errors, rate limits)",
           "next_goal": "Task terminated due to [specific reason: repeated human verification, lack of progress, or looping]"
         },
         "action": [
           {
             "done": {
               "success": false,
               "text": "Task terminated. Possible reasons: [e.g., 3 consecutive human verifications on different sources, no progress after 3 action sequences due to missing interactive elements, looping on the same page due to failed dynamic loading]. Do not Retry this task, as the underlying issues are unlikely to resolve with repeated attempts."
             }
           }
         ]
       }
       ```


================================================
FILE: browser_server/browser_use/browser/browser.py
================================================
# base import 
from browser_use import BrowserSession,BrowserProfile
from browser_use.browser.browser import Browser, BrowserConfig
from config.load_config import config



class BrowserFactory():
    def __init__(self):
        self.user_agent = config['browser']['user-agent']
        self.browser_profile_alive = self._get_browser_profile()

    def create_shared_session(self,headless=True,*args):
        return BrowserSession(
            headless=headless,
            browser_profile=self.browser_profile_alive,
            user_data_dir= None ,# config['browser']['user_data_dir'],
            *args
        )
    
    def _get_browser_profile(self):
        return BrowserProfile(
                    headless=False,
                    wait_for_network_idle_page_load_time=3.0,
                    viewport={"width": 1280, "height": 1100},
                    user_agent=self.user_agent,
                    highlight_elements=False, # off highlight
                    viewport_expansion=500,
                    keep_alive=False,
                    chromium_sandbox = False, # must be false if using docker as root 
                )


browser_factory = BrowserFactory()




================================================
FILE: browser_server/browser_use/config/config.yaml
================================================
server:
  host: 0.0.0.0
  port: 9000

browser:
  user-agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36
  # user_data_dir: '~/.config/browseruse/profiles/default'

agent:
  max_steps: 30
  max_extracted_content_length: 20000 # If it is too long, it will be considered as junk information and the return will be set to null
  


================================================
FILE: browser_server/browser_use/config/load_config.py
================================================
from pathlib import Path
import yaml
import os

config_path = Path(__file__).parent / 'config.yaml'

def read_yaml_file(config_path = config_path):
    try:
        with open(config_path, 'r') as file:
            return yaml.safe_load(file)
    except FileNotFoundError:
        raise FileNotFoundError(f"File is not exist: {config_path}")
    except yaml.YAMLError as e:
        raise yaml.YAMLError(f"File parser error: {e}")


config = read_yaml_file()

if __name__ == '__main__':
    print(config)
    print(type(config['agent']['max_steps']))
    print(config['browser']['user-agent'])



================================================
FILE: browser_server/browser_use/service/browser_agent.py
================================================
from agent.agent import browser_agent
from config.load_config import config
from browser.browser import browser_factory
import uuid
from datetime import datetime
from typing import Dict, Optional
from browser_use.agent.views import AgentHistoryList
from typing import Optional

class BrowserAgentManager:

    def __init__(self):
        self.browser_session = browser_factory.create_shared_session(headless=True)
        pass

    async def run_task_only(self, task: str, model: str, api_key: str, base_url: str,conversation_id:Optional[str] = None) -> str:
        try:
            uid = str(uuid.uuid4())
            agent = browser_agent.get_agent(task=task,model=model,api_key=api_key,base_url=base_url,browser_session = self.browser_session,conversation_id=conversation_id)
            history = await agent.run(max_steps=config['agent']['max_steps'])
            if len(self._format_history(history))!=0:
                result = self._format_history(history)
            else:
                result = [
                    self._get_null_response_result(model=model)
                ]
                
            # the run task only return the last result of history
            print(f"[INFO]    [user]âœ… task finished:{task};history summary:\n {self._format_history(history=history)}",end="\n\n")
            total_duration_seconds = history.total_duration_seconds()
            total_input_tokens = history.total_input_tokens()
            is_successful = history.is_successful()
            is_done = history.is_done()
            number_of_steps = history.number_of_steps()
            return {
                "uid": uid,
                "task": task,
                "status": "finished",
                "time": datetime.now().strftime("%Y%m%d%H%M%S"),
                "total_duration_seconds":total_duration_seconds,
                "total_tokens":total_input_tokens,
                "is_successful":is_successful,
                "is_done":is_done,
                "final_browser_result": self._get_final_result(history=history),
                "number_of_steps":number_of_steps,
                "history_all_info": self._get_all_info_history(history),
                "browser_history":   result,
                "browser_history_screenshot": history.screenshots()
            }
        except ConnectionError as e:
            raise e # return directly
        except Exception as e:
            print(f"[ERROR]    [user]âŒ task failed:{task};error:{str(e)}",end="\n\n")
            return {
                "uid": uid,
                "task": task,
                "status": "Error",
                "time": datetime.now().strftime("%Y%m%d%H%M%S"),
                "total_duration_seconds": -1,
                "total_tokens": -1,
                "is_successful":False,
                "is_done":False,
                "final_browser_result": None,
                "number_of_steps": -1,
                "history_all_info": None,
                "browser_history":  self._get_null_response_result(model=model,error=str(e)),
                "browser_history_screenshot": []
            }

    @staticmethod
    def _format_history(history : AgentHistoryList ):
        extracted_content = history.extracted_content()
        urls = history.urls()
        errors = history.errors()
        result = []
        model_outputs = history.model_outputs()
        for i in range(len(model_outputs)):
            try:
                url = urls[i]
            except IndexError:
                url = None
            try:
                error = errors[i]
            except IndexError:
                error = None
            try: 
                model_outputs_single = model_outputs[i]
                current_model_outputs = None
                if model_outputs_single.action[-1].done is not None:
                    current_model_outputs = "task finised,the final result:" + model_outputs_single.action[-1].done.text
                else:
                    current_model_outputs = model_outputs_single.current_state.evaluation_previous_goal
            except IndexError:
                current_model_outputs = error
            extracted_content_single = extracted_content[i]
            if len(extracted_content[i]) >= config['agent']['max_extracted_content_length']:
                extracted_content_single = None # to long will be set to None
            result.append({
                "browser_status":current_model_outputs,
                "extracted_content":extracted_content_single,
                "url":url,
                "error": error
            })
        return result
    @staticmethod
    def _get_all_info_history(history:AgentHistoryList):
        action_names = history.action_names()
        model_thoughts = history.model_thoughts()
        model_outputs = history.model_outputs()
        model_actions = history.model_actions()
        action_results = history.action_results()
        model_actions_filtered = history.model_actions_filtered()
        return {
            "action_names":action_names,
            "model_thoughts":model_thoughts,
            "model_outputs":model_outputs,
            "model_actions":model_actions,
            "action_results":action_results,
            "model_actions_filtered":model_actions_filtered
        }
    @staticmethod
    def _get_final_result(history:AgentHistoryList):
        if history.is_done():
            try:
                result = history.last_action()['done']['text']
                return result
            except Exception:
                return 'The task failed âŒ,browser tool seems something wrong,do not retry this task'
        else:
            return None
    @staticmethod
    def _get_null_response_result(model,error=""):
        return{
            "browser_status": 'Error',
            "extracted_content":f"The task failed âŒ,browser tool seems something wrong,do not retry this task,current agent llm:{model}",
            "url":"",
            "error": error
        }


    
browser_agent_manager = BrowserAgentManager()





    





================================================
FILE: browser_server/browser_use/utils/request_util.py
================================================
from pydantic import BaseModel, Field, ValidationError
from fastapi import Request, HTTPException
from typing import Optional,Required

"""
Standard TaskRequest
"""
class TaskRequest(BaseModel):
    prompt: str = Field(..., min_length=1)
    llm_config: dict = Field(..., description="include model_name, api_key, api_url")
    conversation_id: Optional[str] = Field(None, description="conversation_id")

async def parse_task_json(data: dict):
    """
    Asynchronously parse JSON data from a FastAPI request and convert it into TaskRequest format.
    Supports input JSON data in either TaskRequest or TaskRequest_v2 format.

    Args:
        data (dict): JSON data from the request

    Returns:
        TaskRequest: A parsed and converted TaskRequest instance

    Raises:
        HTTPException: If the JSON data is invalid or model validation fails
    """
    try:
        # Attempt to parse as TaskRequest
        return TaskRequest(**data)
    except ValidationError as e:
        print("[INFO] [agent] TaskRequest validation failed:", e)
        raise HTTPException(status_code=400, detail=f"TaskRequest validation failed: {str(e)}")
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Unexpected error: {str(e)}")


================================================
FILE: browser_server/browser_use/utils/response_util.py
================================================


def create_response(code: int, message: str, data: dict) -> dict:
    return {"code": code, "message": message, "data": data}


================================================
FILE: browser_server/test/chat_open_ai.py
================================================
import argparse
from langchain_openai import ChatOpenAI
from langchain_core.messages import HumanMessage

# --- Argument Parsing ---
# Sets up how we can provide input to the script from the command line.
argparser = argparse.ArgumentParser(description="Chat with an OpenAI compatible model.")
argparser.add_argument("--model", type=str, default="", help="The model to use.")
argparser.add_argument("--api_key", type=str, default="", help="Your API key.")
argparser.add_argument("--base_url", type=str, default="", help="The base URL for the API.")

if __name__ == "__main__":
    args = argparser.parse_args()
    print("--- Running with the following arguments ---")
    print(args)
    print("------------------------------------------")

    try:
        # --- Language Model Initialization ---
        # Here we create an instance of the ChatOpenAI class.
        llm = ChatOpenAI(
            model=args.model,
            api_key=args.api_key,
            base_url=args.base_url,
            # streaming=False,  # We are making a single, non-streaming request.
            # stream_usage=False,
            extra_body={"enable_thinking": False},
            # This is the corrected line.
            # The DashScope API requires 'enable_thinking' to be false for non-streaming calls.
            # We pass this model-specific argument using model_kwargs.
            # model_kwargs={"enable_thinking": False}
            # enable_thinking=False

        )

        # --- Invoking the Model ---
        # We send a message to the model and wait for the complete response.
        print("\nSending prompt to the model...")
        response = llm.invoke([HumanMessage(content="what is the capital of France?")])
        
        # --- Printing the Response ---
        print("\n--- Model Response ---")
        print(response.content)
        print("----------------------")

    except Exception as e:
        print(f"\nAn error occurred: {e}")


================================================
FILE: containers/app/Dockerfile
================================================
# Start from the Node.js 22 slim image
FROM node:22-slim

# Set the working directory in the container
WORKDIR /app

# --- Layer 1: System Dependencies (Least Frequent Change) ---
# Switch to root user to install packages
USER root
RUN apt-get update && \
    apt-get upgrade -y && \
    apt-get install -y --no-install-recommends \
    wget curl sudo apt-utils git jq tmux bash curl ca-certificates file make \
    libgl1-mesa-glx \
    libasound2-plugins libatomic1 && \
    # Remove packages with CVEs and no updates yet, if present
    (apt-get remove -y libaom3 || true) && \
    (apt-get remove -y libjxl0.7 || true) && \
    (apt-get remove -y libopenexr-3-1-30 || true) && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*

# --- Layer 2: Package Manager Manifests (Infrequent Change) ---
# Copy package.json and Makefile. If you have a lock file (package-lock.json or yarn.lock),
# copy it here as well. This is crucial for caching dependency installation.
COPY ./package.json ./
RUN npm install --production

# COPY ./package-lock.json ./  # Or yarn.lock - uncomment and use if you have one!
COPY ./Makefile ./

# --- Layer 3: Install Project Dependencies (Changes when manifests change) ---
# This runs 'npm install' or similar based on your Makefile's 'init' target.
# This layer will be cached as long as package.json, lock file, and Makefile haven't changed.
COPY ./frontend ./frontend
RUN cd frontend && npm install

# --- Layer 4: Playwright Installation (Changes if Playwright version in package.json changes or make init changes) ---
# Installs Playwright browsers and their OS dependencies.
# Using --with-deps is generally more efficient and ensures OS dependencies are met.
# RUN npx playwright install --with-deps
RUN npx playwright install
RUN npx playwright install-deps

# --- Layer 5: Create static directories (Very infrequent change) ---
# This is a lightweight operation.
RUN mkdir workspace

# --- Layer 6: Application Code (Most Frequent Change) ---
# Copy your application code last, as this is what changes most often.
COPY ./public ./public
COPY ./bin ./bin
COPY ./src ./src
COPY ./types ./types
RUN make init-tables

# At this point, the image is built with root permissions for the build steps.
# For running the application, you might want to switch to a non-root user.
# e.g., USER node (the default user for the 'node' image)
# USER node

# Your original Dockerfile had 'USER root' quite late.
# It's needed for 'apt-get'. If 'make init' or 'npx playwright install'
# also require root, then keeping USER root as set above is fine for the build process.

# The 'ls' and 'pwd' commands were likely for debugging and are removed from the optimized version.

# Define CMD or ENTRYPOINT below to run your application
# Example: CMD ["node", "src/index.js"]


================================================
FILE: containers/app/VERSION
================================================
v0.0.35



================================================
FILE: containers/runtime/Dockerfile
================================================
# FROM nikolaik/python-nodejs:python3.12-nodejs22
FROM node:22-slim

# Shared environment variables
ENV MAMBA_ROOT_PREFIX=/chataa/micromamba \
    LANG=C.UTF-8 \
    LC_ALL=C.UTF-8 \
    EDITOR=code \
    VISUAL=code \
    GIT_EDITOR="code --wait" \
    OPENVSCODE_SERVER_ROOT=/chataa/.openvscode-server


# Install base system dependencies
RUN apt-get update && \
    apt-get upgrade -y && \
    apt-get install -y --no-install-recommends \
        wget curl sudo apt-utils git jq tmux bash curl ca-certificates file lsof zip unzip \
        libatomic1 && \
    # Remove packages with CVEs and no updates yet, if present
    (apt-get remove -y libaom3 || true) && \
    (apt-get remove -y libjxl0.7 || true) && \
    (apt-get remove -y libopenexr-3-1-30 || true) && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*

# Remove UID 1000 if it's called pn--this fixes the nikolaik image for ubuntu users
RUN if getent passwd 1000 | grep -q pn; then userdel pn; fi

# Create necessary directories
RUN mkdir -p /chataa && \
    mkdir -p /chataa/logs 


# Install micromamba
RUN mkdir -p /chataa/micromamba/bin && \
    /bin/bash -c "PREFIX_LOCATION=/chataa/micromamba BIN_FOLDER=/chataa/micromamba/bin INIT_YES=no CONDA_FORGE_YES=yes $(curl -L https://micro.mamba.pm/install.sh)" && \
    /chataa/micromamba/bin/micromamba config remove channels defaults && \
    /chataa/micromamba/bin/micromamba config list

# Create the chataa virtual environment and install poetry and python
RUN /chataa/micromamba/bin/micromamba create -n chataa \
      -c conda-forge \
      python=3.12 \
      poetry \
      -y
ENV PATH=/chataa/micromamba/envs/chataa/bin:$PATH


RUN \
    if [ -d /chataa/code ]; then rm -rf /chataa/code; fi && \
    mkdir -p /chataa/code/chataa  

COPY ./src/runtime/plugins/vscode/settings.json /workspace/.vscode/settings.json
RUN chmod -R a+rwx /workspace/.vscode/settings.json


# Install all dependencies
WORKDIR /chataa/code

# ================================================================
# END: Build Runtime Image from Scratch
# ================================================================


# ================================================================
# Copy Project source files
# ================================================================
RUN if [ -d /chataa/code/chataa ]; then rm -rf /chataa/code/chataa; fi


COPY ./src/runtime/plugins/vscode/settings.json /workspace/.vscode/settings.json
RUN chmod -R a+rwx /workspace/.vscode/settings.json

COPY ./src/runtime /chataa/code/chataa
RUN chmod a+rwx /chataa/code/chataa/action_execution_server.js

COPY ./package.json ./package-lock.json /chataa/code/
RUN npm i --production

COPY ./browser_server /chataa/code/browser_server

# å®‰è£… browser_server ä¾èµ–å¹¶å®‰è£… chromium
RUN pip install -r /chataa/code/browser_server/requirements.txt && \
    patchright install chromium --with-deps --no-shell

# Setup VSCode Server
ARG RELEASE_TAG="openvscode-server-v1.94.2"
ARG RELEASE_ORG="gitpod-io"
# ARG USERNAME=openvscode-server
# ARG USER_UID=1000
# ARG USER_GID=1000

RUN if [ -z "${RELEASE_TAG}" ]; then \
        echo "The RELEASE_TAG build arg must be set." >&2 && \
        exit 1; \
    fi && \
    arch=$(uname -m) && \
    if [ "${arch}" = "x86_64" ]; then \
        arch="x64"; \
    elif [ "${arch}" = "aarch64" ]; then \
        arch="arm64"; \
    elif [ "${arch}" = "armv7l" ]; then \
        arch="armhf"; \
    fi && \
    wget https://github.com/${RELEASE_ORG}/openvscode-server/releases/download/${RELEASE_TAG}/${RELEASE_TAG}-linux-${arch}.tar.gz && \
    tar -xzf ${RELEASE_TAG}-linux-${arch}.tar.gz && \
    if [ -d "${OPENVSCODE_SERVER_ROOT}" ]; then rm -rf "${OPENVSCODE_SERVER_ROOT}"; fi && \
    mv ${RELEASE_TAG}-linux-${arch} ${OPENVSCODE_SERVER_ROOT} && \
    cp ${OPENVSCODE_SERVER_ROOT}/bin/remote-cli/openvscode-server ${OPENVSCODE_SERVER_ROOT}/bin/remote-cli/code && \
    rm -f ${RELEASE_TAG}-linux-${arch}.tar.gz

ENV SKIP_LLM_API_KEY_VERIFICATION=true

# ================================================================
# END: Build from versioned image
# ================================================================


# Install extra dependencies if specified


================================================
FILE: containers/runtime/VERSION
================================================
v0.0.9


================================================
FILE: frontend/README.md
================================================
# Vue 3 + Vite

This template should help get you started developing with Vue 3 in Vite. The template uses Vue 3 `<script setup>` SFCs, check out the [script setup docs](https://v3.vuejs.org/api/sfc-script-setup.html#sfc-script-setup) to learn more.

Learn more about IDE Support for Vue in the [Vue Docs Scaling up Guide](https://vuejs.org/guide/scaling-up/tooling.html#ide-support).

## ç»„ä»¶åº“

https://antdv.com/docs/vue/introduce-cn

pnpm add ant-design-vue@4.x --save

## è·¯ç”±

https://router.vuejs.org/zh

pnpm add vue-router

## çŠ¶æ€ç®¡ç†

https://pinia.vuejs.org/zh

pnpm add pinia-plugin-persistedstate
pnpm add pinia

## è¯·æ±‚

pnpm add axios



================================================
FILE: frontend/deploy.sh
================================================
pnpm build

scp -r dist/* root@101.200.163.36:/mnt/open-hands-vue/dist



================================================
FILE: frontend/index.html
================================================
<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/svg+xml" href="/src/assets/image/lemon.jpg" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Lemon</title>
  <!-- Font Awesome å›¾æ ‡åº“ -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
</head>

<body>
  <div id="app"></div>
  <script type="module" src="/src/main.js"></script>
</body>

</html>


================================================
FILE: frontend/jsconfig.json
================================================
{
  "compilerOptions": {
    "baseUrl": "./",
    "paths": {
      "@/*": [
        "src/*"
      ]
    }
  }
}


================================================
FILE: frontend/package.json
================================================
{
  "name": "vite-vue3-template",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "@ant-design/icons-vue": "^7.0.1",
    "@codemirror/lang-html": "^6.4.10",
    "@codemirror/state": "^6.5.2",
    "@codemirror/theme-one-dark": "^6.1.3",
    "@codemirror/view": "^6.38.4",
    "@microsoft/fetch-event-source": "^2.0.1",
    "@types/prismjs": "^1.26.5",
    "@vue-office/docx": "^1.6.3",
    "@vue-office/excel": "^1.7.14",
    "@vue-office/pdf": "^2.0.10",
    "@vue-office/pptx": "^1.0.1",
    "@vueuse/core": "^13.3.0",
    "@xterm/xterm": "^5.5.0",
    "@zumer/snapdom": "^1.9.11",
    "ant-design-vue": "~4.2.6",
    "axios": "^1.7.7",
    "driver.js": "^1.3.6",
    "file-saver": "^2.0.5",
    "highlight.js": "^11.11.1",
    "html2pdf": "^0.0.11",
    "html2pdf.js": "^0.10.3",
    "jszip": "^3.10.1",
    "less": "^4.3.0",
    "less-loader": "^12.2.0",
    "mammoth": "^1.9.1",
    "markdown-it": "^14.1.0",
    "markdown-it-attrs": "^4.3.1",
    "marked": "^15.0.8",
    "md5": "^2.3.0",
    "mermaid": "^11.6.0",
    "mitt": "^3.0.1",
    "pinia": "^2.2.6",
    "pinia-plugin-persistedstate": "^3.2.3",
    "prismjs": "^1.30.0",
    "socket.io-client": "^4.8.1",
    "uuid": "^11.1.0",
    "vue": "^3.5.13",
    "vue-codemirror": "^6.1.1",
    "vue-i18n": "^11.1.3",
    "vue-router": "^4.4.5",
    "xlsx": "^0.18.5",
    "xterm-addon-fit": "^0.8.0"
  },
  "devDependencies": {
    "@svgr/core": "^8.1.0",
    "@vitejs/plugin-vue": "^5.2.0",
    "sass": "^1.81.0",
    "unplugin-vue-components": "^0.27.4",
    "vite": "^5.4.11",
    "vite-plugin-svg-icons": "^2.0.1",
    "vite-plugin-svgr": "^4.3.0",
    "vite-svg-loader": "^5.1.0"
  },
  "packageManager": "pnpm@9.15.5+sha512.845196026aab1cc3f098a0474b64dfbab2afe7a1b4e91dd86895d8e4aa32a7a6d03049e2d0ad770bbe4de023a7122fb68c1a1d6e0d033c7076085f9d5d4800d4"
}



================================================
FILE: frontend/vite.config.js
================================================
import { defineConfig, loadEnv } from 'vite';
import vue from '@vitejs/plugin-vue';
import Components from 'unplugin-vue-components/vite';
import { AntDesignVueResolver } from 'unplugin-vue-components/resolvers';
import path from 'path';
import svgLoader from 'vite-svg-loader';

// https://vitejs.dev/config/
export default defineConfig(({ mode }) => {
  const env = loadEnv(mode, process.cwd()); // âœ… æ ¹æ® --mode è‡ªåŠ¨åŠ è½½æ­£ç¡®çš„ .env æ–‡ä»¶

  return {
  root: __dirname,
  // æ ¹æ®ç¯å¢ƒå˜é‡ VITE_IS_CLIENT å†³å®šä½¿ç”¨å“ªä¸ª base 
  base: env.VITE_IS_CLIENT === 'true' ? './' : '/', 
  build: {
    outDir: '../.vite/renderer/main_window', // è¾“å‡ºåˆ° Electron Forge æœŸæœ›çš„ç›®å½•
    emptyOutDir: false
  },
  plugins: [
    vue(),
    svgLoader(),
    Components({
      resolvers: [
        AntDesignVueResolver({
          importStyle: 'less',
        }),
      ],
    }),
  ],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, 'src'),
      '~@': path.resolve(__dirname, 'src'),
    },
  },
  server: {
    port: env.VITE_PORT || 5005,
    host: '0.0.0.0',
    strictPort: true,
    proxy: {
      '/api': {
        target: env.VITE_SERVICE_URL || 'http://127.0.0.1:3000',
        protocol: 'http',
        changeOrigin: true,
        ws: true,
      },
      '/coding-screenshots': {
        target: env.VITE_SERVICE_URL ||'http://localhost:3000',
        changeOrigin: true,
      }
    },
    },
  };
});



================================================
FILE: frontend/.env.example
================================================
VITE_SERVICE_URL=http://127.0.0.1:3000
VITE_PORT=5005


================================================
FILE: frontend/.env.production
================================================
#æœ¬åœ°
VITE_SERVICE_URL=http://127.0.0.1:3000
VITE_PORT=5005
VITE_REGION=abroad
VITE_IS_CLIENT=false
VITE_GOOGLE_REDIRECT_URI_ELECTRON=/api/users/auth/google
VITE_EDITABLE=ON


================================================
FILE: frontend/src/App.vue
================================================
<template>
  <a-config-provider :theme="{
    token: {
      colorPrimary: '#1a1a19',  // ä¸»è‰²
      colorLink: '#1a1a19',     // é“¾æ¥è‰²
      colorSuccess: '#52c41a',  // æˆåŠŸè‰²ï¼ˆå¯æŒ‰éœ€ä¿®æ”¹ï¼‰
      colorWarning: '#faad14',  // è­¦å‘Šè‰²ï¼ˆå¯æŒ‰éœ€ä¿®æ”¹ï¼‰
      colorError: '#ff4d4f',    // é”™è¯¯è‰²ï¼ˆå¯æŒ‰éœ€ä¿®æ”¹ï¼‰
    }
  }">
    <router-view></router-view>
  </a-config-provider>
</template>

<script setup>
</script>

<style scoped>

/* ç§»åŠ¨ç«¯é€‚é… */
@media (max-width: 768px) {
  .language-switcher {
    display: none;
  }
}
</style>



================================================
FILE: frontend/src/main.js
================================================
import { createApp } from 'vue';
console.log('main.js started');
import './style.scss';
console.log('style.scss imported');
//ant
import Antd from 'ant-design-vue';
import 'ant-design-vue/dist/reset.css'; // å¼•å…¥é‡ç½®æ ·å¼
console.log('Antd imported');
import App from './App.vue';
console.log('App.vue imported');

const app = createApp(App);
console.log('Vue app created');

app.use(Antd);
console.log('Antd used');

import router from "./router/index.js";
console.log('router imported');
app.use(router);
console.log('router used');

import store from "./store";
console.log('store imported');
app.use(store);
console.log('store used');

import i18n from './locals';
console.log('i18n imported');
app.use(i18n);
console.log('i18n used');

// é…ç½®å…¨å±€ t å‡½æ•°
app.config.globalProperties.$t = i18n.global.t;
console.log('$t global property configured');

console.log('Attempting to mount app...');
app.mount('#app');
console.log('app.mount called'); // æ³¨æ„ï¼šè¿™ä¸€è¡Œä¸ä¸€å®šè¡¨ç¤ºæŒ‚è½½æˆåŠŸï¼Œåªè¡¨ç¤ºæ–¹æ³•è¢«è°ƒç”¨


================================================
FILE: frontend/src/style.scss
================================================
:root {
  font-family: Inter, system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  box-sizing: border-box;
}

div {
  box-sizing: border-box;
}

#app { 
  background-color: rgba(255, 255, 255, 1);
  color: #242424;
}

a {
  font-weight: 500;
  color: #646cff;
  text-decoration: inherit;
}
a:hover {
  color: #535bf2;
}

body {
  margin: 0;
  display: flex;
  place-items: center;
  min-width: 320px;
  min-height: 100vh;
}

p {
  margin: 0;
  padding: 0;
}

h1 {
  font-size: 3.2em;
  line-height: 1.1;
}

#app {
  width: 100%;
  min-width: 1024px;
  // max-width: 1280px;
  height: 100vh;
  margin: 0 auto;
}

//é€‚é…ç§»åŠ¨ç«¯
@media screen and (max-width: 768px) {
  #app {
    width: 100%;
    min-width: 375px;
    height: 100vh;
    margin: 0 auto;
  }

  .ant-modal-body {
    height: 80% !important;
    overflow-y: auto !important;
  }
}



.resume-box {
  border: 1px solid #f5f5f5;
  border-radius: 8px;
  padding: 10px;
  flex: 1;
}

@media (prefers-color-scheme: light) {
  :root {
    color: #213547;
    background-color: #ffffff;
  }
  a:hover {
    color: #747bff;
  }
  button {
    background-color: #f9f9f9;
  }
}



================================================
FILE: frontend/src/components/logo.vue
================================================
<template>
    <div class="logo-title">
        <img class="logo" :src="LemonAI" alt="logo" />
        <!-- <span class="beta-tag">Beta</span> -->
    </div>
</template>
<script setup> 
import LemonAI from '@/assets/LemonAI.png'
</script>
<style scoped> 
.logo-title {
    font-size: 36px;
    font-weight: 600;
    color: #333;
    line-height: 1.2;
}

.logo-title .logo {
    width: 110px;
    height: 48px;
}

.beta-tag {
    font-size: 11px;
    background-color: #FFD43B;
    color: #fff;
    padding: 2px;
    border-radius: 8px;
    margin-left: 8px;
}

</style>


================================================
FILE: frontend/src/components/Navbar.vue
================================================
<template>
  <div class="navbar">
    <div class="logo">
      <router-link to="/">Open Hands Vue</router-link>
    </div>
    <div class="nav-links">
      <router-link to="/" v-if="isLoggedIn">é¦–é¡µ</router-link>
      <router-link to="/mindmap" v-if="isLoggedIn">æ€ç»´å¯¼å›¾</router-link>
      <router-link to="/demo" v-if="isLoggedIn">æ¼”ç¤º</router-link>
      <a @click="handleLogout" v-if="isLoggedIn">ç™»å‡º</a>
      <router-link to="/auth" v-if="!isLoggedIn">ç™»å½•</router-link>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted, onUnmounted } from 'vue';
import { useRouter } from 'vue-router';
import { message } from 'ant-design-vue';
import auth from '@/services/auth';

const router = useRouter();
const isLoggedIn = ref(auth.isLoggedIn());

// ç›‘å¬å­˜å‚¨å˜åŒ–ï¼Œæ›´æ–°ç™»å½•çŠ¶æ€
const handleStorageChange = () => {
  isLoggedIn.value = auth.isLoggedIn();
};

// å¤„ç†ç™»å‡º
const handleLogout = () => {
  auth.logout();
  message.success('å·²æˆåŠŸç™»å‡º');
  isLoggedIn.value = false;
  router.push('/auth');
};

onMounted(() => {
  window.addEventListener('storage', handleStorageChange);
  // åˆå§‹æ£€æŸ¥ç™»å½•çŠ¶æ€
  isLoggedIn.value = auth.isLoggedIn();
});

onUnmounted(() => {
  window.removeEventListener('storage', handleStorageChange);
});
</script>

<style lang="scss" scoped>
.navbar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0 20px;
  height: 64px;
  background-color: #fff;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
  
  .logo {
    font-size: 18px;
    font-weight: bold;
    
    a {
      color: #1890ff;
      text-decoration: none;
    }
  }
  
  .nav-links {
    display: flex;
    gap: 20px;
    
    a {
      color: #333;
      text-decoration: none;
      cursor: pointer;
      
      &:hover {
        color: #1890ff;
      }
      
      &.router-link-active {
        color: #1890ff;
        font-weight: 500;
      }
    }
  }
}
</style>


================================================
FILE: frontend/src/components/browser/image.vue
================================================
<template>
  <div class="image-container">
    <img :src="formattedImageData" alt="Displaying image" />
  </div>
</template>

<script setup>
import { computed } from 'vue';

const props = defineProps({
  content: {
    type: Array, // æœŸæœ›è¿™é‡Œæ˜¯åŒ…å« Base64 å­—ç¬¦ä¸²çš„æ•°ç»„
    required: true
  },
  // å¢åŠ ä¸€ä¸ª prop æ¥æŒ‡å®šå›¾ç‰‡ç±»å‹ï¼Œé»˜è®¤ä¸º 'image/jpeg'
  imageType: {
    type: String,
    default: 'image/jpeg' // æ ¹æ®ä½ çš„å®é™…å›¾ç‰‡ç±»å‹è°ƒæ•´ï¼Œ'image/png', 'image/gif' ç­‰
  }
});

// ä½¿ç”¨ computed å±æ€§æ¥åŠ¨æ€ç”Ÿæˆå®Œæ•´çš„ Data URI
const formattedImageData = computed(() => {
  //æ•°ç»„éç©ºæ ¡éªŒ
  if (!props.content || props.content.length === 0) {
    return '';
  }
  const base64Data = props.content[props.content.length-1]; // è·å– Base64 å­—ç¬¦ä¸²

  if (!base64Data) {
    console.warn("ImageDisplay component received empty or invalid content.");
    return ''; // å¦‚æœæ²¡æœ‰æ•°æ®ï¼Œè¿”å›ç©ºå­—ç¬¦ä¸²
  }

  // æ‹¼æ¥ Data URI å‰ç¼€å’Œ Base64 æ•°æ®
  // ç¡®ä¿ base64Data ä¸åŒ…å«ä»»ä½• Data URI å‰ç¼€ï¼Œå¦‚æœåŒ…å«ï¼Œéœ€è¦å…ˆç§»é™¤
  if (base64Data.startsWith('data:')) {
    // å¦‚æœä¼ è¿›æ¥çš„ Base64 å­—ç¬¦ä¸²å·²ç»åŒ…å«äº† Data URI å‰ç¼€ï¼Œåˆ™ç›´æ¥ä½¿ç”¨
    return base64Data;
  } else {
    // å¦åˆ™ï¼Œæ‰‹åŠ¨æ·»åŠ å‰ç¼€
    return `data:${props.imageType};base64,${base64Data}`;
  }
});
</script>

<style lang="scss" scoped>
.image-container {
  width: 100%;
  display: flex;
  justify-content: center;
  
  img {
    max-width: 100%;
    height: auto;
    object-fit: contain;
    border: 1px solid #dadada;
  }
}
</style>


================================================
FILE: frontend/src/components/browser/searchResults.vue
================================================
<template>
  <div class="search-result-list-container">
    <!-- éå†æœç´¢ç»“æœ -->
    <div class="result-item" v-for="(result, index) in props.searchResults" :key="index">
      <div class="header">
        <!-- <img :src="result.icon" alt="favicon" class="icon"> -->
        <a :href="result.url" target="_blank">{{ result.title }}</a>
      </div>
      <div class="summary-container">
        <span class="summary">{{ result.content }}</span>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, computed } from 'vue'

// props
const props = defineProps({
  searchResults: {
    type: Array,
    required: true
  }
})
</script>

<style lang="scss" scoped>
.search-result-list-container {
  padding: 0.75rem 1rem; // ä¸Šä¸‹å†…è¾¹è·ä¸º 0.75remï¼Œå·¦å³å†…è¾¹è·ä¸º 1rem
  max-height: 100%; // ç¡®ä¿å®¹å™¨é«˜åº¦é€‚é…çˆ¶çº§
  overflow-y: auto; // å¦‚æœå†…å®¹è¿‡å¤šï¼Œæ˜¾ç¤ºæ»šåŠ¨æ¡
  display: flex;
  flex-direction: column; // å‚ç›´æ’åˆ—å­å…ƒç´ 
}
.search-result-list-container::-webkit-scrollbar  { 
  width: 0;
  height: 0;
}


.result-item {
  padding: 0.75rem 0; // æ¯ä¸ªç»“æœé¡¹çš„ä¸Šä¸‹å†…è¾¹è·
  border-bottom: 1px solid #e5e7eb; // åº•éƒ¨è¾¹æ¡†åˆ†éš”çº¿

  .header {
    display: flex; // å›¾æ ‡å’Œæ ‡é¢˜æ°´å¹³æ’åˆ—
    align-items: center; // å‚ç›´å±…ä¸­å¯¹é½
    margin-bottom: 0.5rem; // æ ‡é¢˜ä¸æ‘˜è¦ä¹‹é—´çš„é—´è·

    .icon {
      width: 1rem; // å›¾æ ‡å®½åº¦
      height: 1rem; // å›¾æ ‡é«˜åº¦
      margin-right: 0.5rem; // å›¾æ ‡ä¸æ ‡é¢˜ä¹‹é—´çš„é—´è·
      flex-shrink: 0; // é˜²æ­¢å›¾æ ‡è¢«å‹ç¼©
    }

    a {
      color: #34322d; // é“¾æ¥é»˜è®¤é¢œè‰²
      text-decoration: none; // å»æ‰ä¸‹åˆ’çº¿
      font-size: 0.875rem; // å­—ä½“å¤§å°
      line-height: 1.25rem; // è¡Œé«˜
      font-weight: 500; // å­—ä½“åŠ ç²—
      transition: color 0.3s ease; // é¼ æ ‡æ‚¬åœæ—¶çš„é¢œè‰²å˜åŒ–æ•ˆæœ
      cursor: pointer; // é¼ æ ‡æ‚¬åœæ—¶æ˜¾ç¤ºæ‰‹å‹

      &:hover {
        text-decoration: underline; // é¼ æ ‡æ‚¬åœæ—¶æ˜¾ç¤ºä¸‹åˆ’çº¿
      }
    }
  }

  .summary-container {
    .summary {
      color: #858481; // æ‘˜è¦æ–‡å­—é¢œè‰²
      font-size: 0.75rem; // å­—ä½“å¤§å°
      line-height: 1rem; // è¡Œé«˜
      margin-top: 0.125rem; // æ‘˜è¦ä¸æ ‡é¢˜ä¹‹é—´çš„é—´è·
      word-wrap: break-word; // è‡ªåŠ¨æ¢è¡Œ
      overflow: hidden; // é˜²æ­¢å†…å®¹æº¢å‡º
      text-overflow: ellipsis; // è¶…å‡ºéƒ¨åˆ†çœç•¥å·è¡¨ç¤º
      display: -webkit-box; // å…è®¸å¤šè¡Œçœç•¥
      -webkit-line-clamp: 3; // æœ€å¤šæ˜¾ç¤º 3 è¡Œ
      -webkit-box-orient: vertical; // å‚ç›´æ’åˆ—
    }
  }
}
</style>


================================================
FILE: frontend/src/components/browser/video.vue
================================================
<template>
  <div>

  </div>
</template>

<script setup>

</script>

<style lang="scss" scoped></style>


================================================
FILE: frontend/src/components/defaultModel/assistantSetting.vue
================================================
[Binary file]


================================================
FILE: frontend/src/components/defaultModel/index.vue
================================================
<template>
    <div class="default-model-container">
        <!-- åŠ©æ‰‹æ¨¡å‹ -->
        <div class="default-item assistant-container">

            <div class="item-header item">
                <p class="item-title">{{ $t('setting.defaultModel.defaultAssistantModel') }}</p>
            </div>

            <div class="item-model item">
                <selectModel class="select_model" :platform_models="platform_models"
                    :model_choose="assistant_model_number" :select_type="assistant_model.setting_type"/>
                <div class="assistant setting">
                    <SettingOutlined class="icon" @click="handleAssistantSetting" />
                </div>
            </div>

            <div class="item-tips item">
                <p>{{ $t('setting.defaultModel.assistantModelTips') }}</p>
            </div>

        </div>
        <!-- å‘½åæ¨¡å‹ -->
        <div class="default-item topic-naming-contianer">

            <div class="item-header item">
                <p class="item-title">{{ $t('setting.defaultModel.topicNamingModel') }}</p>
            </div>

            <div class="item-model item">
                <selectModel class="select_model" :platform_models="platform_models"
                    :model_choose="topic_naming_model_number" :select_type="topic_naming_model.setting_type" />
                <div class="topic_naming setting">
                    <SettingOutlined class="icon" @click="handleTopicNamingSetting" />
                </div>
            </div>

            <div class="item-tips item">
                <p>{{ $t('setting.defaultModel.topicNamingModelTips') }}</p>
            </div>
        </div>
        <!-- ç¿»è¯‘æ¨¡å‹ -->
<!--        <div class="default-item translation-contianer">-->

<!--            <div class="item-header item">-->
<!--                <p class="item-title">{{ $t('setting.defaultModel.translationModel') }}</p>-->
<!--            </div>-->
<!--            <div class="item-model item">-->
<!--                <selectModel class="select_model" :platform_models="platform_models"-->
<!--                    :model_choose="translation_model_number" :select_type="translation_model.setting_type" />-->
<!--                <div class="translation setting">-->
<!--                    <SettingOutlined class="icon" @click="handleTranslationSetting" />-->
<!--                </div>-->
<!--            </div>-->
<!--            <div class="item-tips item">-->
<!--                <p>{{ $t('setting.defaultModel.translationModelTips') }}</p>-->
<!--            </div>-->
<!--        </div>-->
<!--        <div class="default-item browser-use-contianer">-->

<!--            <div class="item-header item">-->
<!--                <p class="item-title">{{ $t('setting.defaultModel.browserUseModel') }}</p>-->
<!--            </div>-->
<!--            <div class="item-model item">-->
<!--                <selectModel class="select_model" :platform_models="platform_models"-->
<!--                    :model_choose="browser_use_model_number" :select_type="browser_use_model.setting_type" />-->
<!--                <div class="browser-use setting">-->
<!--                    <SettingOutlined class="icon" @click="handleTranslationSetting" />-->
<!--                </div>-->
<!--            </div>-->
<!--            <div class="item-tips item">-->
<!--                <p>{{ $t('setting.defaultModel.browserUseModelTips') }}</p>-->
<!--            </div>-->
<!--        </div>-->
    </div>

    <assistantSetting ref="assistantSettingRef" :model-value="assistant_model" />
    <topicNamingSetting ref="topicNamingSettingRef" :model-value="topic_naming_model" />
    <translationSetting ref="translationSettingRef" :model-value="translation_model" />


</template>

<script setup>
import selectModel from './selectModel.vue'
import assistantSetting from './assistantSetting.vue'
import topicNamingSetting from './TopicNaming.vue'
import translationSetting from './translation.vue'
import { ref, onMounted, onBeforeMount, onUnmounted,nextTick } from 'vue'
import { useI18n } from 'vue-i18n'
const { t } = useI18n()
import service from '@/services/default-model-setting'
import emitter from '@/utils/emitter'
import { message } from 'ant-design-vue'
import { SettingOutlined } from '@ant-design/icons-vue'
import { driver } from "driver.js";
import "driver.js/dist/driver.css";


// å®šä¹‰ç›¸å…³å˜é‡
const platform_models = ref([])
const assistant_model_number = ref(Number())
const topic_naming_model_number = ref(Number())
const translation_model_number = ref(Number())
const browser_use_model_number = ref(Number())


const assistant_model = ref({
    setting_type: 'assistant',
    config: {
        assistant_name: null,
        prompt: null,
        temperature: 1,
        top_p: 1,
        max_tokens: 5,
        enable_length_limit: false
    },
    model_id: Number()
})
const topic_naming_model = ref({
    setting_type: 'topic-naming',
    config: {
        auto_naming: false,
        prompt: ''
    },
    model_id: Number()
})
const translation_model = ref({
    setting_type: 'translation',
    config: {
        prompt: ''
    },
    model_id: Number()
})
const browser_use_model = ref({
    setting_type: 'browser-use',
    config: {
        
    },
    model_id: Number()
})


//å­ç»„ä»¶å¼•ç”¨
const assistantSettingRef = ref()
const topicNamingSettingRef = ref()
const translationSettingRef = ref()
// åŠ©æ‰‹æ¨¡å‹è®¾ç½®
const handleAssistantSetting = () => {
    assistantSettingRef.value.showModal()
}
// å‘½åæ¨¡å‹è®¾ç½®
const handleTopicNamingSetting = () => {
    topicNamingSettingRef.value.showModal()
}
// ç¿»è¯‘æ¨¡å‹è®¾ç½®
const handleTranslationSetting = () => {
    translationSettingRef.value.showModal()
}

const handleBrowserSetting = () => {

}
onBeforeMount(async () => {
    const res = await service.getModels()
    platform_models.value = res
    const modelsSettings = await service.getModelBySetting()
    modelsSettings.forEach((model) => {
        if (model.setting_type === 'assistant') {
            assistant_model.value = model
            assistant_model_number.value = model.model_id
        }
        if (model.setting_type === 'topic-naming') {
            topic_naming_model.value = model
            topic_naming_model_number.value = model.model_id
        }
        if (model.setting_type === 'translation') {
            translation_model.value = model
            translation_model_number.value = model.model_id
        }
        if (model.setting_type === 'browser-use') {
            browser_use_model.value = model
            browser_use_model_number.value = model.model_id
        }
    })
})




let tourDriver = null; // æå‡ä½œç”¨åŸŸï¼Œå¹¶åˆå§‹åŒ–ä¸ºç©º

const step1 = async () => {
  tourDriver = driver({
    animate: true,
    showProgress: true,
    prevBtnText: t('setting.prevStep'),
    nextBtnText: t('setting.nextStep'),
    doneBtnText: t('setting.doneStep'),
    steps: [
      {
        element: '.assistant-container',
        popover: {
          side: 'bottom',
          title: t('setting.defaultModel.defaultAssistantModel'),
          description: t('setting.defaultModel.assistantModelTips'),
          onNextClick: async () => {
            nextTick(() => { 
              tourDriver.moveNext();
            });
          },
        }
      },
      {
        element: '.topic-naming-contianer',
        popover: {
          side: 'bottom',
          title: t('setting.defaultModel.topicNamingModel'),
          description: t('setting.defaultModel.topicNamingModelTips'),
          onNextClick: async () => {
            nextTick(() => { 
              // è®¾ç½®ç¼“å­˜ï¼Œç»“æŸå¼•å¯¼
              localStorage.setItem('tour_end', 'true');
              localStorage.setItem('tour', 'false');
              tourDriver.moveNext();
            });
          },
        }
      }
    ]
  });

  tourDriver.drive();
};

onMounted(async () => {
    // localStorage.setItem('tour', 'true');
    if (localStorage.getItem('tour') === 'true' && localStorage.getItem('tour_end') !== 'true') {
        step1();
    }
    emitter.on('default-assistant-setting-save', (model_config) => {
        assistant_model.value.config = model_config
        console.log(assistant_model.value);
        service.updateModel(assistant_model.value).then((res) => {
            message.success(t('setting.defaultModel.saveSuccess'))
        })
    })

    emitter.on('default-topic_naming-setting-save', (model_config) => {
        topic_naming_model.value.config = model_config
        service.updateModel(topic_naming_model.value).then((res) => {
            message.success(t('setting.defaultModel.saveSuccess'))
        })
    })

    emitter.on('default-translation-setting-save', (model_config) => {
        translation_model.value.config = model_config
        service.updateModel(translation_model.value).then((res) => {
            message.success(t('setting.defaultModel.saveSuccess'))
        })
    })


    emitter.on('default-model-changed', (newValue) => {
        const setting_type = newValue.setting_type
        // str => int
        const model_id = newValue.model_id
        // const model_id = newValue.model_id
        //æ›´æ–°
        if (setting_type === 'assistant') {
            assistant_model_number.value = model_id
            assistant_model.value.model_id = model_id
            // console.log(assistant_model.value);

            service.updateModel(assistant_model.value).then((res) => {
            })
        } else if (setting_type === 'topic-naming') {
            topic_naming_model_number.value = model_id
            topic_naming_model.value.model_id = model_id

            service.updateModel(topic_naming_model.value).then((res) => {

            })
        }
        else if (setting_type === 'translation') {
            translation_model_number.value = model_id
            translation_model.value.model_id = model_id
            service.updateModel(translation_model.value).then((res) => {

            })
        }else if (setting_type === 'browser-use') {
            browser_use_model_number.value = model_id
            browser_use_model.value.model_id = model_id
            service.updateModel(browser_use_model.value).then((res) => {

            })

        }

    }

    )

})

onUnmounted(() => {
    emitter.off('default-assistant-setting-save')
    emitter.off('default-topic_naming-setting-save')
    emitter.off('default-translation-setting-save')

    emitter.off('default-model-changed')
})


</script>

<style scoped>
.default-model-container {
    display: flex;
    flex-direction: column;
}

.default-item {
    padding: 16px;
    margin-bottom: 10px;
    background-color: rgb(255, 255, 255);
    width: 70%;
    border: 1px solid #c6c6c6;
    border-radius: 10px;
    display: flex;
    flex-direction: column;
    gap: 16px;
}

.item-header p {
    font-size: 18px;
}

.item-model {
    display: flex;
    align-items: center;
}

.item-tips {
    align-items: center;
}

.item-tips p {
    font-size: 12px;
    color: #5f5f5f;
}

.select_model {
    width: 95%;
    height: 100%;
    justify-content: start;
    align-items: center;
    display: flex;
}

.setting {
    color: #ffffff;
    height: 100%;
    display: flex;
    align-items: center;
}

.icon {
    color: #3c3c46c5;
}

@media screen and (max-width: 768px) {
    .default-model-container {
        margin: 0 !important;
    }

    .default-item {
        width: 100% !important;
        margin: 0 !important;
        margin-bottom: 16px !important;
        height: 100% !important;
    }


}
</style>



================================================
FILE: frontend/src/components/defaultModel/selectModel.vue
================================================
<template>
  <div class="select-model">
    <a-select
      v-model:value="selectedModel"
      style="width: 97% "
      :placeholder= "t('setting.defaultModel.emptymodelTips')" 
      :disabled="!hasModels"
      class="select_model_ed"
    >
      <a-select-opt-group v-for="group in groupedModels" :key="group.name" :label="group.name">
        <a-select-option
          v-for="model in group.models"
          :key="model.id"
          :value="model.name"
        >
          {{ model.model_name }} | {{ model.group_name }}
        </a-select-option>
      </a-select-opt-group>
    </a-select>
  </div>
</template>

<script setup>
import { ref, computed, watch, defineProps } from 'vue'
import emitter from '@/utils/emitter'
import { useI18n } from 'vue-i18n'
const { t } = useI18n();
const props = defineProps({
  platform_models: {
    type: Array,
    default: () => []
  },
  model_choose: {
    type: Number,
    default: () => 0
  },
  select_type: {
    type: String,
    default: () => 'assistant'
  }
})

const hasModels = computed(() => {
  return Array.isArray(props.platform_models) && props.platform_models.length > 0
})

const selectedModel = ref(hasModels.value ? props.model_choose : null)

watch(() => props.model_choose, (newValue) => {
  if (hasModels.value) {
    selectedModel.value = newValue
  }
})

const groupedModels = computed(() => {
  /**
   * result: [
   *   {
   *     name: 'platform_name',
   *     models: [
   *       {
   *         id: 'model_id',
   *         model_name: 'model_name',
   *         group_name: 'group_name'
   *       }
   *     ]
   *   }
   * ]
   */
  const result = [];
  if (hasModels.value) {
    for (const item of props.platform_models) {
      // æŸ¥æ‰¾æ˜¯å¦å·²ç»æœ‰è¿™ä¸ª platform_name çš„ç»„
      let group = result.find(group => group.name === item.platform_name);
      // å¦‚æœæ²¡æœ‰æ‰¾åˆ°ï¼Œåˆ™æ–°å»ºä¸€ä¸ªç»„å¹¶åŠ å…¥ç»“æœæ•°ç»„
      if (!group) {
        group = {
          name: item.platform_name,
          models: []
        };
        result.push(group);
      }
      // å°†å½“å‰æ¨¡å‹åŠ å…¥å¯¹åº”çš„ç»„ä¸­
      group.models.push({
        id: item.id,
        model_name: item.model_name,
        group_name: item.group_name,
        model_id: item.model_id,
        // ä½ å¯ä»¥æ ¹æ®éœ€è¦é€‰æ‹©æ€§åœ°æ·»åŠ å…¶ä»–å­—æ®µ
      });
    }
  }

  return result;
});

watch(selectedModel, async (newValue) => {
  if (newValue) {
    emitter.emit(`default-model-changed`, {
      setting_type: props.select_type,
      model_id: Number(newValue)
    })
  }
})
</script>

<style scoped>
.select-model {
  width: 90%;
  height: 100%;
}
</style>


================================================
FILE: frontend/src/components/defaultModel/TopicNaming.vue
================================================
<template>
    <a-modal
      class="topic-naming"
      v-model:open="visible"
      :title="$t('setting.defaultModel.topicNamingSettings')"
      @ok="handleOk"
      @cancel="handleCancel"
      :confirmLoading="confirmLoading"
      :okButtonProps="{ disabled: false }"
      :centered="true"
      :okText="$t('setting.defaultModel.confirm')"
      :cancelText="$t('setting.defaultModel.cancel')"
    >
      <a-form :model="formState" layout="vertical">
        <a-form-item :label="$t('setting.defaultModel.topicAutoNaming')">
          <a-switch v-model:checked="formState.config.auto_naming" />
        </a-form-item>
        <a-form-item :label="$t('setting.defaultModel.topicNamingPrompt')">
          <a-textarea
            v-model:value="formState.config.prompt"
            :rows="4"
            :placeholder="$t('setting.defaultModel.promptPlaceholder')"
          />
        </a-form-item>
      </a-form>
    </a-modal>
  </template>
  
  <script setup>
  import { ref, reactive, watch, computed } from 'vue'
  import { useI18n } from 'vue-i18n'
  import { message } from 'ant-design-vue'
  import emitter from '@/utils/emitter'
  
  const { t } = useI18n()
  
  const props = defineProps({
    modelValue: {
      type: Object,
      required: true
    }
  })
  
  const visible = ref(false)
  const confirmLoading = ref(false)
  
  const formState = reactive({
    config: {
      prompt: '',
      auto_naming: false
    },
    originalConfig: null
  })
  
  const hasChanges = computed(() => {
    if (!formState.originalConfig) return false
    return JSON.stringify(formState.config) !== JSON.stringify(formState.originalConfig)
  })
  
  watch(() => props.modelValue, (newVal) => {
    if (newVal && newVal.config) {
      Object.assign(formState.config, newVal.config)
      formState.originalConfig = JSON.parse(JSON.stringify(newVal.config))
    }
  }, { deep: true })
  
  const showModal = () => {
    visible.value = true
  }
  
  const handleOk = () => {
    confirmLoading.value = true
    emitter.emit('default-topic_naming-setting-save', formState.config)
    setTimeout(() => {
      visible.value = false
      confirmLoading.value = false
    }, 1000)
  }
  
  const handleCancel = () => {
    visible.value = false
  }
  
  defineExpose({
    showModal
  })
  </script>
  
  <style scoped>
  </style>


================================================
FILE: frontend/src/components/defaultModel/translation.vue
================================================
<template>
    <a-modal
      v-model:open="visible"
      :title="$t('setting.defaultModel.translationSettings')"
      @ok="handleOk"
      @cancel="handleCancel"
      :confirmLoading="confirmLoading"
      :okButtonProps="{ disabled: false }"
      :centered="true"
      :okText="$t('setting.defaultModel.confirm')"
      :cancelText="$t('setting.defaultModel.cancel')"
    >
      <a-form :model="formState" layout="vertical">
        <a-form-item :label="$t('setting.defaultModel.translationPrompt')">
          <a-textarea
            v-model:value="formState.config.prompt"
            :rows="4"
            :placeholder="$t('setting.defaultModel.promptPlaceholder')"
          />
        </a-form-item>
      </a-form>
    </a-modal>
  </template>
  
  <script setup>
  import { ref, reactive, watch, computed } from 'vue'
  import { useI18n } from 'vue-i18n'
  import emitter from '@/utils/emitter'
  
  const { t } = useI18n()
  
  const props = defineProps({
    modelValue: {
      type: Object,
      required: true
    }
  })
  
  const visible = ref(false)
  const confirmLoading = ref(false)
  
  const formState = reactive({
    config: {
      prompt: ''
    },
    originalConfig: null
  })
  
  const hasChanges = computed(() => {
    if (!formState.originalConfig) return false
    return JSON.stringify(formState.config) !== JSON.stringify(formState.originalConfig)
  })
  
  watch(() => props.modelValue, (newVal) => {
    if (newVal && newVal.config) {
      Object.assign(formState.config, newVal.config)
      formState.originalConfig = JSON.parse(JSON.stringify(newVal.config))
    }
  }, { deep: true })
  
  const showModal = () => {
    visible.value = true
  }
  
  const handleOk = () => {
    confirmLoading.value = true
    emitter.emit('default-translation-setting-save', formState.config)
    setTimeout(() => {
      visible.value = false
      confirmLoading.value = false
    }, 1000)
  }
  
  const handleCancel = () => {
    visible.value = false
  }
  
  defineExpose({
    showModal
  })
  </script>
  
  <style scoped>
  </style>


================================================
FILE: frontend/src/components/DiffViewer/index.vue
================================================
<template>
  <div class="diff-viewer">
    <div class="diff-content">
      <div class="diff-sections">
        <!-- ç»Ÿä¸€ diff è§†å›¾ -->
        <div class="diff-section unified">
          <div class="section-header">
            <span class="section-title"> <i class="fas fa-exchange-alt mr-1"></i> Code Diff </span>
          </div>
          <div class="unified-diff">
            <div v-for="(line, index) in unifiedDiff" :key="index" :class="['diff-line', line.type]">
              <span class="line-number">{{ line.number }}</span>
              <span class="line-content">{{ line.content }}</span>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup>
import { computed } from "vue";

const props = defineProps({
  filename: {
    type: String,
    default: "Unknown File",
  },
  find: {
    type: String,
    default: "",
  },
  with: {
    type: String,
    default: "",
  },
});

// å¤„ç†å†…å®¹
const findContent = computed(() => props.find.trim());
const withContent = computed(() => props.with.trim());

// ç”Ÿæˆç»Ÿä¸€çš„ diff è§†å›¾
const unifiedDiff = computed(() => {
  console.log("DiffViewer props:", {
    filename: props.filename,
    find: props.find,
    with: props.with,
  });

  const lines = [];
  let lineNumber = 1;

  // æ·»åŠ åˆ é™¤çš„è¡Œ
  if (findContent.value) {
    findContent.value.split("\n").forEach((line) => {
      lines.push({
        type: "removed",
        number: `-${lineNumber}`,
        content: line,
      });
      lineNumber++;
    });
  }

  // æ·»åŠ æ–°å¢çš„è¡Œ
  if (withContent.value) {
    let addLineNumber = 1;
    withContent.value.split("\n").forEach((line) => {
      lines.push({
        type: "added",
        number: `+${addLineNumber}`,
        content: line,
      });
      addLineNumber++;
    });
  }

  console.log("Generated unified diff lines:", lines);
  return lines;
});
</script>

<style lang="scss" scoped>
.diff-viewer {
  height: 100%;
  display: flex;
  flex-direction: column;
  background: #fff;
}

.diff-content {
  flex: 1;
  overflow: auto;
  padding: 16px 20px;
}

.diff-sections {
  display: flex;
  flex-direction: column;
  gap: 24px;
}

.diff-section {
  border: 1px solid #e1e8ed;
  border-radius: 8px;
  overflow: hidden;

  .section-header {
    padding: 12px 16px;
    background: #f8f9fa;
    border-bottom: 1px solid #e1e8ed;
    display: flex;
    align-items: center;
    justify-content: space-between;

    .section-title {
      font-size: 14px;
      font-weight: 500;
      color: #374151;
    }

    .line-count {
      font-size: 12px;
      color: #6b7280;
      background: #e5e7eb;
      padding: 2px 8px;
      border-radius: 12px;
    }
  }

  &.removed .section-header {
    background: #fef2f2;
    border-bottom-color: #fecaca;

    .section-title {
      color: #dc2626;
    }
  }

  &.added .section-header {
    background: #f0fdf4;
    border-bottom-color: #bbf7d0;

    .section-title {
      color: #16a34a;
    }
  }
}

.code-block {
  background: #1e1e1e;

  pre {
    margin: 0;
    padding: 16px;
    overflow-x: auto;

    code {
      font-family: "Monaco", "Consolas", monospace;
      font-size: 13px;
      line-height: 1.5;
      color: #d4d4d4;

      &.removed-code {
        background: rgba(220, 38, 38, 0.1);
      }

      &.added-code {
        background: rgba(22, 163, 74, 0.1);
      }
    }
  }
}

.unified-diff {
  background: #1e1e1e;
  font-family: "Monaco", "Consolas", monospace;
  font-size: 13px;
  line-height: 1.5;

  .diff-line {
    display: flex;
    padding: 2px 16px;

    &.removed {
      background: rgba(220, 38, 38, 0.15);
      color: #fca5a5;
    }

    &.added {
      background: rgba(22, 163, 74, 0.15);
      color: #86efac;
    }

    .line-number {
      width: 60px;
      color: #6b7280;
      text-align: right;
      margin-right: 16px;
      user-select: none;
    }

    .line-content {
      flex: 1;
      white-space: pre-wrap;
      word-break: break-all;
      color: #d4d4d4;
    }
  }
}

// å“åº”å¼è®¾è®¡
@media (max-width: 768px) {
  .diff-content {
    padding: 12px;
  }

  .diff-sections {
    gap: 16px;
  }

  .code-block pre {
    padding: 12px;
    font-size: 12px;
  }

  .unified-diff {
    font-size: 12px;

    .diff-line {
      padding: 1px 12px;

      .line-number {
        width: 50px;
        margin-right: 12px;
      }
    }
  }
}
</style>



================================================
FILE: frontend/src/components/file/imgModal.vue
================================================
<template>
    <div class="image-zoom-container">
        <!-- Modal -->
        <transition name="fade">
            <div v-if="visible" class="modal" @click="handleClose">
                <!-- Loading Animation -->
                <!-- <div v-if="isLoading" class="loader">loading...</div> -->
                <!-- Large Image -->
                <img class="large-image" :src="props.url" alt="Large Image" @load="onImageLoad" @error="onImageError" />
            </div>
        </transition>
    </div>
</template>

<script setup>
import { ref, onMounted, onUnmounted } from 'vue';

// Define Props
const props = defineProps({
    url: String, // Image URL
    visible: Boolean // Modal visibility
});

// Define Emits
const emit = defineEmits(['close']);

// Loading state
const isLoading = ref(true);

// Image load handler
const onImageLoad = () => {
    if (props.url) {
        console.log("getFile", props.url)
        isLoading.value = false;
    }

};

// Image error handler
const onImageError = () => {
    isLoading.value = false;
    console.error('Image failed to load');
    // Optional: emit('error', 'Image failed to load');
};

// Close handler
const handleClose = () => {
    emit('close'); // Notify parent to close
};

// ESC key handler
const handleEsc = (e) => {
    if (e.key === 'Escape' && props.visible) {
        emit('close');
    }
};

// Add and clean up event listener
onMounted(() => {
    window.addEventListener('keydown', handleEsc);
});
onUnmounted(() => {
    window.removeEventListener('keydown', handleEsc);
});
</script>

<style scoped>
.image-zoom-container {
    display: inline-block;
}

.modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.6);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 9999;
    overflow: auto;
    /* Enable scrolling for oversized images */
}

.large-image {
    max-width: 90%;
    max-height: 90%;
    object-fit: contain;
    border-radius: 8px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    /* Neumorphic shadow */
    touch-action: pinch-zoom;
    /* Enable pinch-to-zoom on mobile */
}

.loader {
    color: #fff;
    font-size: 16px;
    font-weight: bold;
    animation: pulse 1.5s infinite;
}

@keyframes pulse {
    0% {
        opacity: 1;
    }

    50% {
        opacity: 0.5;
    }

    100% {
        opacity: 1;
    }
}

/* Fade transition */
.fade-enter-active,
.fade-leave-active {
    transition: opacity 0.3s ease;
}

.fade-enter-from,
.fade-leave-to {
    opacity: 0;
}

/* Mobile responsiveness */
@media (max-width: 768px) {
    .large-image {
        max-width: 95%;
        max-height: 95%;
    }
}
</style>


================================================
FILE: frontend/src/components/file/index.vue
================================================
<template>
  <div class="file-content-container">
    <pre><code v-html="highlightedContent"></code></pre>
  </div>
</template>

<script setup>
import { computed } from 'vue';
import hljs from 'highlight.js/lib/core';
import 'highlight.js/styles/github.css';

// å¼•å…¥è¯­è¨€æ”¯æŒ
import javascript from 'highlight.js/lib/languages/javascript';
import python from 'highlight.js/lib/languages/python';
import json from 'highlight.js/lib/languages/json';
import xml from 'highlight.js/lib/languages/xml';
import css from 'highlight.js/lib/languages/css';
import markdown from 'highlight.js/lib/languages/markdown';
import java from 'highlight.js/lib/languages/java';
import cpp from 'highlight.js/lib/languages/cpp';
import ruby from 'highlight.js/lib/languages/ruby';
import go from 'highlight.js/lib/languages/go';
import sql from 'highlight.js/lib/languages/sql';
import yaml from 'highlight.js/lib/languages/yaml';
import typescript from 'highlight.js/lib/languages/typescript';
import php from 'highlight.js/lib/languages/php';
import bash from 'highlight.js/lib/languages/bash';
import csharp from 'highlight.js/lib/languages/csharp';
import rust from 'highlight.js/lib/languages/rust';
import kotlin from 'highlight.js/lib/languages/kotlin';
import scala from 'highlight.js/lib/languages/scala';
import perl from 'highlight.js/lib/languages/perl';
import swift from 'highlight.js/lib/languages/swift';
import r from 'highlight.js/lib/languages/r';
import matlab from 'highlight.js/lib/languages/matlab';
import dart from 'highlight.js/lib/languages/dart';
import lua from 'highlight.js/lib/languages/lua';
import { watch } from 'less';

// æ³¨å†Œè¯­è¨€
hljs.registerLanguage('javascript', javascript);
hljs.registerLanguage('python', python);
hljs.registerLanguage('json', json);
hljs.registerLanguage('xml', xml);
hljs.registerLanguage('css', css);
hljs.registerLanguage('markdown', markdown);
hljs.registerLanguage('java', java);
hljs.registerLanguage('cpp', cpp);
hljs.registerLanguage('ruby', ruby);
hljs.registerLanguage('go', go);
hljs.registerLanguage('sql', sql);
hljs.registerLanguage('yaml', yaml);
hljs.registerLanguage('typescript', typescript);
hljs.registerLanguage('php', php);
hljs.registerLanguage('bash', bash);
hljs.registerLanguage('csharp', csharp);
hljs.registerLanguage('rust', rust);
hljs.registerLanguage('kotlin', kotlin);
hljs.registerLanguage('scala', scala);
hljs.registerLanguage('perl', perl);
hljs.registerLanguage('swift', swift);
hljs.registerLanguage('r', r);
hljs.registerLanguage('matlab', matlab);
hljs.registerLanguage('dart', dart);
hljs.registerLanguage('lua', lua);

const props = defineProps({
  filePath: {
    type: String,
    required: true
  },
  fileContent: {
    type: String,
    required: true
  }
});
// æ£€æµ‹æ–‡ä»¶è¯­è¨€
const detectedLanguage = computed(() => {
  if (!props.filePath) {
    return 'typescript';
  }
  const extension = props.filePath.split('.').pop().toLowerCase();
  const languageMap = {
    js: 'javascript',
    ts: 'typescript',
    py: 'python',
    json: 'json',
    html: 'xml',
    htm: 'xml',
    css: 'css',
    md: 'markdown',
    xml: 'xml',
    java: 'java',
    c: 'cpp',
    cpp: 'cpp',
    cc: 'cpp',
    cxx: 'cpp',
    h: 'cpp',
    rb: 'ruby',
    go: 'go',
    sql: 'sql',
    yaml: 'yaml',
    yml: 'yaml',
    php: 'php',
    sh: 'bash',
    bash: 'bash',
    cs: 'csharp',
    rs: 'rust',
    kt: 'kotlin',
    scala: 'scala',
    pl: 'perl',
    swift: 'swift',
    r: 'r',
    m: 'matlab',
    dart: 'dart',
    lua: 'lua'
  };
  return languageMap[extension] || 'typescript';
});

// é«˜äº®å†…å®¹
const highlightedContent = computed(() => {
  try {
    // console.log('highlightedContent',props.fileContent);
    if (!props.fileContent) {
      console.log('file content',props.fileContent)
      return '';
    }
    // console.log('highlightedContent',props.fileContent);
    if(!Array.isArray(props.fileContent)){
      return hljs.highlight(props.fileContent, { language: detectedLanguage.value }).value;
    }
  } catch (error) {
    console.error('Failed to highlight content:', error);
    return props.fileContent;
  }
})


</script>

<style scoped>
.file-content-container {
  padding: 5px;
  width: 100%;
  height: 100%;
  box-sizing: border-box;
  overflow: auto;
  background-color: #f5f5f5;
}
/* ä¸åŠ¨æ—¶æ¶ˆå¤±æ»šåŠ¨æ¡ */
.mcp-server-content::-webkit-scrollbar-track {
  background-color: #f5f5f5;
}

.file-content-container::-webkit-scrollbar {
  width: 3px;
}

.file-content-container::-webkit-scrollbar-thumb {
  background-color: #d2d2d2;
  border-radius: 6px;
  opacity: 0; /* é»˜è®¤éšè—æ»šåŠ¨æ¡ */
  transition: opacity 0.3s ease; /* å¹³æ»‘è¿‡æ¸¡æ•ˆæœ */
}
.file-content-container:hover::-webkit-scrollbar-thumb {
  opacity: 1;
}

pre {
  margin: 0;
  padding: 0;
  white-space: pre-wrap;
  word-wrap: break-word;
}

code {
  font-family: 'Fira Code', 'Consolas', monospace;
  font-size: 14px;
}
</style>


================================================
FILE: frontend/src/components/file/officePreview.vue
================================================
<template>
  <div class="office-preview-container">
    <!-- Loading overlay -->
    <div v-if="loading" class="loading-overlay">
      <div class="loading-container">
        <div class="loading-spinner"></div>
        <p>Loading document...</p>
      </div>
    </div>

    <!-- Document toolbar -->
    <div v-if="(fileType === 'docx' || ['pptx', 'ppt'].includes(fileType)) && fileUrl && !error && !loading" class="document-toolbar">
      <div class="toolbar-left" v-if="fileType === 'docx'">
        <button class="tool-btn" @click="zoomOut" :disabled="documentScale <= 0.5">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
            <path d="M19,13H5V11H19V13Z" />
          </svg>
        </button>
        <span class="zoom-level">{{ Math.round(documentScale * 100) }}%</span>
        <button class="tool-btn" @click="zoomIn" :disabled="documentScale >= 3">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
            <path d="M19,13H13V19H11V13H5V11H11V5H13V11H19V13Z" />
          </svg>
        </button>
      </div>
      
      <div class="toolbar-center" v-if="(fileType === 'docx' || ['pptx', 'ppt'].includes(fileType)) && totalPages > 0">
        <button class="tool-btn" @click="prevPage" :disabled="currentPage <= 1">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
            <path d="M15.41,16.58L10.83,12L15.41,7.41L14,6L8,12L14,18L15.41,16.58Z" />
          </svg>
        </button>
        <div class="page-input">
          <input 
            v-model.number="pageInput" 
            @keyup.enter="goToPage"
            @blur="goToPage"
            type="number" 
            :min="1" 
            :max="totalPages"
          />
          <span>/ {{ totalPages }}</span>
        </div>
        <button class="tool-btn" @click="nextPage" :disabled="currentPage >= totalPages">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
            <path d="M8.59,16.58L13.17,12L8.59,7.41L10,6L16,12L10,18L8.59,16.58Z" />
          </svg>
        </button>
      </div>
      
      <div class="toolbar-center" v-else-if="fileType === 'docx'">
        <span class="document-type">DOCX Document</span>
      </div>
      
      <div class="toolbar-center" v-else-if="['pptx', 'ppt'].includes(fileType)">
        <span class="document-type">PPTX Presentation</span>
      </div>

      <div class="toolbar-right" v-if="fileType === 'docx'">
        <button class="tool-btn reset-btn" @click="resetZoom">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
            <path d="M12,2A10,10 0 0,1 22,12A10,10 0 0,1 12,22A10,10 0 0,1 2,12A10,10 0 0,1 12,2M12,4A8,8 0 0,0 4,12A8,8 0 0,0 12,20A8,8 0 0,0 20,12A8,8 0 0,0 12,4M12,6A6,6 0 0,1 18,12A6,6 0 0,1 12,18A6,6 0 0,1 6,12A6,6 0 0,1 12,6Z" />
          </svg>
          <span>Reset</span>
        </button>
      </div>
    </div>

    <!-- Document container -->
    <div class="office-container" ref="officeContainer">
      <!-- Error state -->
      <div v-if="error" class="error-container">
        <p class="error-message">{{ error }}</p>
        <button class="retry-btn" @click="loadFile">Retry</button>
      </div>

      <!-- Document preview -->
      <div v-show="fileUrl && !error && containerReady" class="document-wrapper">
        <!-- PDF preview -->
        <div v-if="fileType === 'pdf'" class="pdf-wrapper">
          <div class="pdf-zoom-container" :style="{ 
            transform: `scale(${documentScale})`,
            transformOrigin: 'center top'
          }">
            <!-- ä¸´æ—¶éšè—VueOfficePdfç»„ä»¶ -->
            <!-- <VueOfficePdf
              :key="fileUrl"
              :src="fileUrl"
              style="height: 100vh;"
              @rendered="onPdfRendered"
              @error="onDocumentError"
            /> -->
            
            <!-- ä½¿ç”¨iframeåµŒå¥—PDF -->
            <iframe
               :src="fileUrl + '#toolbar=1&navpanes=0&scrollbar=1&view=FitH'"
              style="width: 100%; height: 100vh; border: none;"
              type="application/pdf"
            ></iframe>
          </div>
        </div>
        
        <!-- DOCX preview -->
        <div v-else-if="fileType === 'docx'" class="docx-wrapper">
          <div class="docx-scaler" :style="{ 
            transform: `scale(${documentScale})`,
            transformOrigin: 'top left'
          }">
            <VueOfficeDocx
              :key="fileUrl"
              :src="fileUrl"
              style="width: 100%; height: 100%;"
              @rendered="onDocumentReady"
              @error="onDocumentError"
            />
          </div>
        </div>
        
        <!-- DOC preview (unsupported) -->
        <div v-else-if="fileType === 'doc'" class="unsupported-format">
          <p>DOC format is not supported</p>
          <p>Please convert the file to DOCX format for preview</p>
          <p>Supported formats: PDF, DOCX, XLSX, XLS, PPTX, PPT</p>
        </div>
        
        <!-- EXCEL preview -->
        <div v-else-if="['xlsx', 'xls'].includes(fileType)" class="excel-wrapper">
          <VueOfficeExcel
            :key="fileUrl"
            :src="fileUrl"
            style="width: 100%; height: 100vh;"
            @rendered="onDocumentReady"
            @error="onDocumentError"
          />
        </div>
        
        <!-- PPTX preview -->
        <div v-else-if="['pptx', 'ppt'].includes(fileType)" class="pptx-wrapper" :style="{
          '--document-scale': documentScale
        }">
          <VueOfficePptx
            :key="fileUrl"
            :src="fileUrl"
            style="width: 100%; height: 100vh;"
            @rendered="onDocumentReady"
            @error="onDocumentError"
          />
        </div>
        
        <!-- Unsupported format -->
        <div v-else class="unsupported-format">
          <p>Unsupported file format: {{ fileType.toUpperCase() }}</p>
          <p>Supported formats: PDF, DOCX, XLSX, XLS, PPTX, PPT</p>
          <p v-if="fileType === 'doc'" style="color: #ff7875; margin-top: 8px;">
            Note: Legacy DOC format is not supported. Please convert to DOCX format.
          </p>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted, computed, watch, onUnmounted } from 'vue'
import VueOfficePdf from '@vue-office/pdf'
import VueOfficeDocx from '@vue-office/docx'
import VueOfficeExcel from '@vue-office/excel'
import VueOfficePptx from '@vue-office/pptx'
import workspaceService from '@/services/workspace'
//å¼•å…¥ç›¸å…³æ ·å¼
import '@vue-office/excel/lib/index.css'
// Props
const props = defineProps({
  filePath: {
    type: String,
    required: true
  }
})

// Reactive data
const loading = ref(false)
const error = ref(null)
const fileUrl = ref('')
const fileBlob = ref(null)
const containerReady = ref(false)

// Document toolbar related
const documentScale = ref(1) // PPT default 100%
const currentPage = ref(1)
const totalPages = ref(0)
const pageInput = ref(1)

// PDF uses documentScale directly

// DOM references
const officeContainer = ref(null)

// Calculate file name
const fileName = computed(() => {
  if (!props.filePath) return ''
  return props.filePath.split('/').pop() || ''
})

// Calculate file type
const fileType = computed(() => {
  if (!props.filePath) return ''
  const ext = props.filePath.split('.').pop()?.toLowerCase() || ''
  return ext
})

// Load file
const loadFile = async () => {
  if (!props.filePath) return
  
  loading.value = true
  error.value = null
  
  try {
    // Clean up previous file URL
    if (fileUrl.value) {
      URL.revokeObjectURL(fileUrl.value)
      fileUrl.value = ''
    }
    
    console.log('Loading file:', props.filePath)
    
    // Get file content
    const response = await workspaceService.getFile(props.filePath)
    
    let blob
    if (response instanceof Blob) {
      blob = response
    } else if (response instanceof ArrayBuffer) {
      blob = new Blob([response], { type: getMimeType(fileType.value) })
    } else if (response.data) {
      if (response.data instanceof Blob) {
        blob = response.data
      } else if (response.data instanceof ArrayBuffer) {
        blob = new Blob([response.data], { type: getMimeType(fileType.value) })
      } else {
        throw new Error('Unsupported file format')
      }
    } else {
      throw new Error('Unable to get file content')
    }
    
    // Create blob URL
    fileBlob.value = blob
    fileUrl.value = URL.createObjectURL(blob)
    
    console.log('File loaded successfully, URL created')
    
    // Delay closing loading
    setTimeout(() => {
      loading.value = false
    }, 2000)
    
  } catch (err) {
    console.error('Failed to load file:', err)
    error.value = err.message || `Unable to load ${fileType.value.toUpperCase()} file`
    loading.value = false
  }
}

// Get MIME type
const getMimeType = (fileType) => {
  const mimeTypes = {
    'pdf': 'application/pdf',
    'docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
    'doc': 'application/msword',
    'xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
    'xls': 'application/vnd.ms-excel',
    'pptx': 'application/vnd.openxmlformats-officedocument.presentationml.presentation',
    'ppt': 'application/vnd.ms-powerpoint'
  }
  return mimeTypes[fileType] || 'application/octet-stream'
}

// PDF render complete callback
const onPdfRendered = (pdf) => {
  console.log('PDF rendered successfully', pdf)
  
  // è·å–PDFæ€»é¡µæ•°çš„å¤šç§æ–¹å¼
  const getTotalPages = () => {
    // æ–¹å¼1: ä»PDFå¯¹è±¡ç›´æ¥è·å–é¡µæ•°(å¦‚æœå¯ç”¨)
    if (pdf && pdf.numPages) {
      totalPages.value = pdf.numPages
      currentPage.value = 1
      pageInput.value = 1
      console.log('Total pages from PDF object:', pdf.numPages)
      return true
    }
    
    // æ–¹å¼2: ä»vue-office-pdfç»„ä»¶å®ä¾‹è·å–
    try {
      const pdfElement = document.querySelector('.vue-office-pdf')
      if (pdfElement && pdfElement.__vue__ && pdfElement.__vue__.numPages) {
        totalPages.value = pdfElement.__vue__.numPages
        currentPage.value = 1
        pageInput.value = 1
        console.log('Total pages from component:', pdfElement.__vue__.numPages)
        return true
      }
    } catch (e) {
      // ignore
    }
    
    // æ–¹å¼3: ç»Ÿè®¡canvaså…ƒç´ æ•°é‡
    const canvases = document.querySelectorAll('.vue-office-pdf-wrapper canvas, .vue-office-pdf canvas')
    if (canvases.length > 0) {
      totalPages.value = canvases.length
      currentPage.value = 1
      pageInput.value = 1
      console.log('Total pages from canvas count:', canvases.length)
      return true
    }
    
    // æ–¹å¼4: æŸ¥æ‰¾é¡µé¢å®¹å™¨
    const pageElements = document.querySelectorAll('.vue-office-pdf .page, .vue-office-pdf-wrapper .page')
    if (pageElements.length > 0) {
      totalPages.value = pageElements.length
      currentPage.value = 1
      pageInput.value = 1
      console.log('Total pages from page elements:', pageElements.length)
      return true
    }
    
    return false
  }
  
  // ç«‹å³å°è¯•è·å–
  if (!getTotalPages()) {
    // å¦‚æœç«‹å³è·å–å¤±è´¥ï¼Œå»¶è¿Ÿé‡è¯•
    setTimeout(() => {
      if (!getTotalPages()) {
        // å†æ¬¡é‡è¯•
        setTimeout(() => {
          if (!getTotalPages()) {
            // æœ€åä¸€æ¬¡é‡è¯•ï¼ŒåŒæ—¶å¼€å¯ç›‘å¬
            setTimeout(() => {
              getTotalPages()
              startPageCountObserver()
            }, 3000)
          }
        }, 1000)
      }
    }, 500)
  } else {
    // å¦‚æœæˆåŠŸè·å–ï¼Œä¹Ÿå¼€å¯ç›‘å¬ä»¥é˜²æ»šåŠ¨åŠ è½½æ›´å¤šé¡µé¢
    startPageCountObserver()
  }
}

// Document render complete callback
const onDocumentReady = () => {
  console.log('Document rendered successfully')
  
  // å¯åŠ¨å®¹å™¨å°ºå¯¸ç›‘å¬å™¨
  setTimeout(() => {
    startContainerResizeObserver()
  }, 500)
  
  // If Excel file, handle scrollbar issues
  if (['xlsx', 'xls'].includes(fileType.value)) {
    setTimeout(() => {
      setupExcelScrollbarFix()
    }, 1000)
  }
  
  // If DOCX file, delay calculating page count
  if (fileType.value === 'docx') {
    setTimeout(() => {
      calculateDocxPages()
    }, 1000)
  }
  
  // If PPTX file, delay calculating page count and set adaptive scale
  if (['pptx', 'ppt'].includes(fileType.value)) {
    setTimeout(() => {
      if (typeof calculatePptxPages === 'function') {
        calculatePptxPages()
      } else {
        console.error('calculatePptxPages function not defined')
      }
      // Set adaptive initial scale for PPT
      setAdaptivePptScale()
    }, 1000)
  }
}

// Calculate DOCX page count
const calculateDocxPages = () => {
  // Find section elements in DOCX (each section represents a page)
  const docxSections = document.querySelectorAll('.vue-office-docx section')
  
  if (docxSections.length > 0) {
    totalPages.value = docxSections.length
    currentPage.value = 1
    pageInput.value = 1
    console.log('DOCX pages found via section elements:', docxSections.length)
    return
  }
  
  // Fallback: estimate page count based on container height
  const docxContainer = document.querySelector('.vue-office-docx')
  if (docxContainer) {
    const containerHeight = docxContainer.scrollHeight
    const estimatedPages = Math.max(1, Math.ceil(containerHeight / 1122))
    totalPages.value = estimatedPages
    currentPage.value = 1
    pageInput.value = 1
    console.log('DOCX pages estimated by height:', estimatedPages, 'Container height:', containerHeight)
  }
}


// Calculate PPTX page count
const calculatePptxPages = () => {
  console.log('Calculating PPTX pages...')
  
  // Find slide wrapper elements in PPTX (each represents a slide)
  const pptxSlides = document.querySelectorAll('.vue-office-pptx .pptx-preview-slide-wrapper')
  
  if (pptxSlides.length > 0) {
    totalPages.value = pptxSlides.length
    currentPage.value = 1
    pageInput.value = 1
    console.log('PPTX slides found via slide wrapper elements:', pptxSlides.length)
    return
  }
  
  // Fallback: look for other possible slide elements
  const altSlides = document.querySelectorAll('.vue-office-pptx .slide, .vue-office-pptx [data-slide]')
  if (altSlides.length > 0) {
    totalPages.value = altSlides.length
    currentPage.value = 1
    pageInput.value = 1
    console.log('PPTX slides found via alternative selectors:', altSlides.length)
    return
  }
  
  console.log('No PPTX slides found')
}

// Set adaptive PPT scale based on screen size
const setAdaptivePptScale = () => {
  const pptxWrapper = document.querySelector('.pptx-wrapper')
  if (!pptxWrapper) return

  // Get container width
  const containerWidth = pptxWrapper.clientWidth
  console.log('Container width:', containerWidth)
  
  // PPT standard width is 960px, calculate adaptive scale
  const pptStandardWidth = 960
  let adaptiveScale = containerWidth / pptStandardWidth
  
  // Set reasonable scale limits (0.3 to 1.0)
  adaptiveScale = Math.max(0.3, Math.min(1.0, adaptiveScale))
  
  // Apply scale with some padding margin (reduce by 10% for better display)
  adaptiveScale = adaptiveScale * 0.9
  
  console.log('Calculated adaptive PPT scale:', adaptiveScale)
  
  // Update document scale
  documentScale.value = adaptiveScale
}

// Document error callback
const onDocumentError = (err) => {
  // Ignore Transport destroyed errors, which usually occur when component is destroyed
  if (err && (
    (typeof err === 'string' && err.includes('Transport destroyed')) ||
    (err.message && err.message.includes('Transport destroyed')) ||
    (err.toString && err.toString().includes('Transport destroyed'))
  )) {
    // Handle silently, no error log output
    return
  }
  
  console.error('Document render error:', err)
  error.value = 'Document rendering failed, please check if the file format is correct'
}

// Download file
const downloadFile = () => {
  if (!fileBlob.value) return
  
  const link = document.createElement('a')
  link.href = fileUrl.value
  link.download = fileName.value
  document.body.appendChild(link)
  link.click()
  document.body.removeChild(link)
}

// Document toolbar functions
const zoomIn = () => {
  if (documentScale.value < 3) {
    const oldScale = documentScale.value
    documentScale.value = Math.min(3, documentScale.value + 0.25)
    adjustScrollPositionAfterZoom(oldScale, documentScale.value)
  }
}

const zoomOut = () => {
  if (documentScale.value > 0.5) {
    const oldScale = documentScale.value
    documentScale.value = Math.max(0.5, documentScale.value - 0.25)
    adjustScrollPositionAfterZoom(oldScale, documentScale.value)
  }
}

const resetZoom = () => {
  const oldScale = documentScale.value
  documentScale.value = 1 // Reset all formats to 100%
  adjustScrollPositionAfterZoom(oldScale, documentScale.value)
}

// è°ƒæ•´ç¼©æ”¾åçš„æ»šåŠ¨ä½ç½®
const adjustScrollPositionAfterZoom = (oldScale, newScale) => {
  setTimeout(() => {
    const pdfWrapper = document.querySelector('.pdf-wrapper')
    if (pdfWrapper) {
      const scaleRatio = newScale / oldScale
      const centerX = pdfWrapper.scrollLeft + pdfWrapper.clientWidth / 2
      const centerY = pdfWrapper.scrollTop + pdfWrapper.clientHeight / 2
      
      // è®¡ç®—æ–°çš„æ»šåŠ¨ä½ç½®ï¼Œä¿æŒè§†è§‰ä¸­å¿ƒä¸å˜
      const newScrollLeft = centerX * scaleRatio - pdfWrapper.clientWidth / 2
      const newScrollTop = centerY * scaleRatio - pdfWrapper.clientHeight / 2
      
      pdfWrapper.scrollTo({
        left: Math.max(0, newScrollLeft),
        top: Math.max(0, newScrollTop),
        behavior: 'auto'
      })
    }
  }, 50) // ç­‰å¾…transformåº”ç”¨å®Œæˆ
}

const prevPage = () => {
  if (currentPage.value > 1) {
    currentPage.value--
    pageInput.value = currentPage.value
    scrollToPage(currentPage.value)
  }
}

const nextPage = () => {
  if (currentPage.value < totalPages.value) {
    currentPage.value++
    pageInput.value = currentPage.value
    scrollToPage(currentPage.value)
  }
}

const goToPage = () => {
  const page = Number(pageInput.value)
  if (page >= 1 && page <= totalPages.value) {
    currentPage.value = page
    scrollToPage(page)
  } else {
    // Restore current page when input is invalid
    pageInput.value = currentPage.value
  }
}

const scrollToPage = (pageNum) => {
  setTimeout(() => {
    if (fileType.value === 'pdf') {
      scrollToPdfPage(pageNum)
    } else if (fileType.value === 'docx') {
      scrollToDocxPage(pageNum)
    } else if (['pptx', 'ppt'].includes(fileType.value)) {
      scrollToPptxPage(pageNum)
    }
  }, 100)
}

const scrollToPdfPage = (pageNum) => {
  const pdfWrapper = document.querySelector('.pdf-wrapper')
  if (!pdfWrapper) return
  
  // Find target page through canvas elements
  const canvases = document.querySelectorAll('.vue-office-pdf-wrapper canvas')
  if (canvases.length === 0) return
  
  const targetCanvas = canvases[pageNum - 1] // Page numbers start from 1, array from 0
  if (!targetCanvas) return
  
  // Simplified logic: calculate directly based on canvas element position
  const canvasRect = targetCanvas.getBoundingClientRect()
  const wrapperRect = pdfWrapper.getBoundingClientRect()
  
  // Calculate canvas position relative to scroll container
  const relativeTop = canvasRect.top - wrapperRect.top + pdfWrapper.scrollTop
  
  // Subtract some offset to better display page top
  const scrollTop = Math.max(0, relativeTop - 20)
  
  pdfWrapper.scrollTo({
    top: scrollTop,
    behavior: 'smooth'
  })
  
  console.log(`Scrolled to PDF page ${pageNum}, position: ${scrollTop}`)
}

const scrollToDocxPage = (pageNum) => {
  const docxContainer = document.querySelector('.vue-office-docx')
  if (!docxContainer) return
  
  // Find target section element (each page in DOCX corresponds to a section)
  const docxSections = document.querySelectorAll('.vue-office-docx section')
  console.log('DOCX sections found:', docxSections.length)
  
  if (docxSections.length > 0 && docxSections[pageNum - 1]) {
    const targetSection = docxSections[pageNum - 1]
    
    // Calculate target section position relative to .vue-office-docx container
    const sectionOffsetTop = targetSection.offsetTop
    const scrollTop = Math.max(0, sectionOffsetTop - 20)
    
    docxContainer.scrollTo({
      top: scrollTop,
      behavior: 'smooth'
    })
    
    console.log(`Scrolled to DOCX page ${pageNum} via section element, position: ${scrollTop}`)
    return
  }
  
  // Fallback: page position based on height estimation
  if (docxContainer && totalPages.value > 0) {
    const containerHeight = docxContainer.scrollHeight
    const pageHeight = containerHeight / totalPages.value
    const scrollTop = Math.max(0, (pageNum - 1) * pageHeight - 20)
    
    docxContainer.scrollTo({
      top: scrollTop,
      behavior: 'smooth'
    })
    
    console.log(`Scrolled to DOCX page ${pageNum} via height estimation, position: ${scrollTop}`)
  }
}

const scrollToPptxPage = (pageNum) => {
  console.log(`Attempting to scroll to PPTX slide ${pageNum}`)
  
  // First find the scroll container
  const pptxWrapper = document.querySelector('.pptx-wrapper')
  if (!pptxWrapper) {
    console.log('pptx-wrapper not found')
    return
  }
  
  // Find target slide elements
  const pptxSlides = document.querySelectorAll('.vue-office-pptx .pptx-preview-slide-wrapper')
  console.log('PPTX slides found:', pptxSlides.length)
  
  if (pptxSlides.length > 0 && pptxSlides[pageNum - 1]) {
    const targetSlide = pptxSlides[pageNum - 1]
    console.log('Target slide found:', targetSlide)
    
    // Use scrollIntoView method, more reliable
    targetSlide.scrollIntoView({
      behavior: 'smooth',
      block: 'start',
      inline: 'center'
    })
    
    console.log(`Scrolled to PPTX slide ${pageNum} using scrollIntoView`)
    return
  }
  
  // Fallback 1: look for alternative selectors
  const altSlides = document.querySelectorAll('.vue-office-pptx .pptx-slide')
  console.log('Alternative PPTX slides found:', altSlides.length)
  
  if (altSlides.length > 0 && altSlides[pageNum - 1]) {
    const targetSlide = altSlides[pageNum - 1]
    targetSlide.scrollIntoView({
      behavior: 'smooth',
      block: 'start',
      inline: 'center'
    })
    console.log(`Scrolled to PPTX slide ${pageNum} using alternative selector`)
    return
  }
  
  // Fallback 2: based on height estimation
  const pptxContainer = document.querySelector('.vue-office-pptx')
  if (pptxContainer && totalPages.value > 0) {
    const containerHeight = pptxContainer.scrollHeight
    const slideHeight = containerHeight / totalPages.value
    const scrollTop = Math.max(0, (pageNum - 1) * slideHeight - 20)
    
    pptxWrapper.scrollTo({
      top: scrollTop,
      behavior: 'smooth'
    })
    
    console.log(`Scrolled to PPTX slide ${pageNum} via height estimation, position: ${scrollTop}`)
  } else {
    console.log('No suitable scrolling method found for PPTX')
  }
}

// ç›‘å¬é¡µé¢æ•°é‡å˜åŒ–å’Œæ»šåŠ¨ä½ç½®
let pageCountObserver = null
let scrollTimeout = null
let resizeObserver = null
let resizeTimeout = null

// å¯åŠ¨é¡µé¢è®¡æ•°ç›‘å¬å™¨
const startPageCountObserver = () => {
  // æ¸…ç†ä¹‹å‰çš„ç›‘å¬å™¨
  if (pageCountObserver) {
    pageCountObserver.disconnect()
  }
  
  // åˆ›å»ºMutationObserverç›‘å¬DOMå˜åŒ–
  pageCountObserver = new MutationObserver(() => {
    const canvases = document.querySelectorAll('.vue-office-pdf-wrapper canvas, .vue-office-pdf canvas')
    const pageElements = document.querySelectorAll('.vue-office-pdf .page, .vue-office-pdf-wrapper .page')
    
    const newPageCount = Math.max(canvases.length, pageElements.length)
    if (newPageCount > totalPages.value) {
      totalPages.value = newPageCount
      console.log('Updated total pages via observer:', newPageCount)
    }
  })
  
  // å¼€å§‹è§‚å¯ŸPDFå®¹å™¨çš„å˜åŒ–
  const pdfContainer = document.querySelector('.vue-office-pdf, .vue-office-pdf-wrapper')
  if (pdfContainer) {
    pageCountObserver.observe(pdfContainer, {
      childList: true,
      subtree: true
    })
    
    // æ·»åŠ æ»šåŠ¨ç›‘å¬
    const pdfWrapper = document.querySelector('.pdf-wrapper')
    if (pdfWrapper) {
      pdfWrapper.addEventListener('scroll', updateCurrentPageOnScroll)
    }
  }
}

// åŸºäºæ»šåŠ¨ä½ç½®æ›´æ–°å½“å‰é¡µ
const updateCurrentPageOnScroll = () => {
  if (scrollTimeout) {
    clearTimeout(scrollTimeout)
  }
  
  scrollTimeout = setTimeout(() => {
    const pdfWrapper = document.querySelector('.pdf-wrapper')
    if (!pdfWrapper || totalPages.value === 0) return
    
    const canvases = document.querySelectorAll('.vue-office-pdf-wrapper canvas, .vue-office-pdf canvas')
    if (canvases.length === 0) return
    
    const wrapperRect = pdfWrapper.getBoundingClientRect()
    const wrapperCenter = wrapperRect.top + wrapperRect.height / 2
    
    let closestPage = 1
    let minDistance = Infinity
    
    canvases.forEach((canvas, index) => {
      const canvasRect = canvas.getBoundingClientRect()
      const canvasCenter = canvasRect.top + canvasRect.height / 2
      const distance = Math.abs(canvasCenter - wrapperCenter)
      
      if (distance < minDistance) {
        minDistance = distance
        closestPage = index + 1
      }
    })
    
    if (closestPage !== currentPage.value && closestPage <= totalPages.value) {
      currentPage.value = closestPage
      pageInput.value = closestPage
      console.log('Current page updated via scroll:', closestPage)
    }
  }, 100)
}

// Clean up resources
const cleanup = () => {
  if (fileUrl.value) {
    URL.revokeObjectURL(fileUrl.value)
    fileUrl.value = ''
  }
  fileBlob.value = null
  error.value = null
  loading.value = false
  
  // æ¸…ç†ç›‘å¬å™¨
  if (pageCountObserver) {
    pageCountObserver.disconnect()
    pageCountObserver = null
  }
  
  if (scrollTimeout) {
    clearTimeout(scrollTimeout)
    scrollTimeout = null
  }
  
  if (resizeTimeout) {
    clearTimeout(resizeTimeout)
    resizeTimeout = null
  }
  
  if (resizeObserver) {
    resizeObserver.disconnect()
    resizeObserver = null
  }
  
  // æ¸…ç†Excelèœå•ç›‘å¬å™¨
  if (excelMenuRef) {
    excelMenuRef.removeEventListener('click', resetExcelScrollbar)
    excelMenuRef = null
  }
  
  const pdfWrapper = document.querySelector('.pdf-wrapper')
  if (pdfWrapper) {
    pdfWrapper.removeEventListener('scroll', updateCurrentPageOnScroll)
  }
  
  // Reset document related state
  documentScale.value = 1 // Default 100%
  currentPage.value = 1
  totalPages.value = 0
  pageInput.value = 1
}

// Handle window resize for PPT adaptive scaling
const handleWindowResize = () => {
  if (['pptx', 'ppt'].includes(fileType.value) && containerReady.value) {
    setTimeout(() => {
      setAdaptivePptScale()
    }, 100)
  }
}

// å¤„ç†å®¹å™¨å¤§å°å˜åŒ–
const handleContainerResize = () => {
  if (resizeTimeout) {
    clearTimeout(resizeTimeout)
  }
  
  resizeTimeout = setTimeout(() => {
    console.log('Container size changed, triggering refresh...')
    
    // Excelç»„ä»¶é‡æ–°æ¸²æŸ“
    if (['xlsx', 'xls'].includes(fileType.value) && containerReady.value) {
      refreshExcelComponent()
    }
    
    // PPTè‡ªé€‚åº”ç¼©æ”¾
    if (['pptx', 'ppt'].includes(fileType.value) && containerReady.value) {
      setAdaptivePptScale()
    }
    
    // DOCXé‡æ–°è®¡ç®—é¡µé¢
    if (fileType.value === 'docx' && containerReady.value) {
      setTimeout(() => {
        calculateDocxPages()
      }, 500)
    }
  }, 300) // é˜²æŠ–300ms
}

// åˆ·æ–°Excelç»„ä»¶
const refreshExcelComponent = () => {
  console.log('Refreshing Excel component...')
  
  // æ–¹æ¡ˆ1: ç›´æ¥è°ƒç”¨Excelç»„ä»¶çš„resizeæ–¹æ³•ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
  const excelElement = document.querySelector('.vue-office-excel')
  if (excelElement && excelElement.__vue__ && typeof excelElement.__vue__.resize === 'function') {
    excelElement.__vue__.resize()
    console.log('Excel component resized via API')
    // é‡æ–°è®¾ç½®æ»šåŠ¨æ¡ä¿®å¤
    setTimeout(() => {
      resetExcelScrollbar()
    }, 100)
    return
  }
  
  // æ–¹æ¡ˆ2: è§¦å‘çª—å£resizeäº‹ä»¶ï¼Œè®©Excelç»„ä»¶è‡ªé€‚åº”
  const excelContainer = document.querySelector('.excel-wrapper')
  if (excelContainer) {
    // æ´¾å‘resizeäº‹ä»¶
    window.dispatchEvent(new Event('resize'))
    console.log('Excel component refreshed via resize event')
    // é‡æ–°è®¾ç½®æ»šåŠ¨æ¡ä¿®å¤
    setTimeout(() => {
      resetExcelScrollbar()
    }, 100)
  }
}

// è®¾ç½®Excelæ»šåŠ¨æ¡ä¿®å¤
let excelMenuRef = null
const setupExcelScrollbarFix = () => {
  console.log('Setting up Excel scrollbar fix...')
  
  // æŸ¥æ‰¾sheetèœå•å…ƒç´ 
  const menuElement = document.querySelector('.x-spreadsheet-menu')
  
  if (menuElement && !excelMenuRef) {
    excelMenuRef = menuElement
    // æ·»åŠ ç‚¹å‡»ç›‘å¬å™¨æ¥ä¿®å¤åˆ‡æ¢sheetæ—¶çš„æ»šåŠ¨æ¡é—®é¢˜
    menuElement.addEventListener('click', resetExcelScrollbar)
    console.log('Excel menu click listener added')
  }
  
  // ç«‹å³æ‰§è¡Œä¸€æ¬¡æ»šåŠ¨æ¡é‡ç½®
  resetExcelScrollbar()
}

// é‡ç½®Excelæ»šåŠ¨æ¡ä½ç½®
const resetExcelScrollbar = () => {
  // æ¨ªå‘æ»šåŠ¨æ¡
  const scrollbarElementX = document.querySelector('.x-spreadsheet-scrollbar.horizontal')
  // ç«–å‘æ»šåŠ¨æ¡
  const scrollbarElementY = document.querySelector('.x-spreadsheet-scrollbar.vertical')

  // ç«–å‘é‡ç½®åˆ°é¡¶éƒ¨
  if (scrollbarElementY) {
    // å…ˆä¿è¯excelè§†å›¾çš„æ­£ç¡®æ¸²æŸ“
    setTimeout(() => {
      scrollbarElementY.scrollTop = 1
    })
    // å†é‡ç½®æ»šåŠ¨æ¡ä½ç½®
    setTimeout(() => {
      scrollbarElementY.scrollTop = 0
    }, 10)
    console.log('Vertical scrollbar reset')
  }

  // æ¨ªå‘é‡ç½®åˆ°å·¦ä¾§
  if (scrollbarElementX) {
    // å…ˆä¿è¯excelè§†å›¾çš„æ­£ç¡®æ¸²æŸ“
    setTimeout(() => {
      scrollbarElementX.scrollLeft = 1
    })
    // å†é‡ç½®æ»šåŠ¨æ¡ä½ç½®
    setTimeout(() => {
      scrollbarElementX.scrollLeft = 0
    }, 10)
    console.log('Horizontal scrollbar reset')
  }
}

// å¯åŠ¨å®¹å™¨å°ºå¯¸ç›‘å¬å™¨
const startContainerResizeObserver = () => {
  if (!window.ResizeObserver) {
    console.warn('ResizeObserver not supported')
    return
  }
  
  // æ¸…ç†ä¹‹å‰çš„ç›‘å¬å™¨
  if (resizeObserver) {
    resizeObserver.disconnect()
  }
  
  const targetContainer = officeContainer.value
  if (!targetContainer) {
    console.warn('Office container not found')
    return
  }
  
  resizeObserver = new ResizeObserver((entries) => {
    for (let entry of entries) {
      const { width, height } = entry.contentRect
      console.log(`Container resized: ${width}x${height}`)
      handleContainerResize()
    }
  })
  
  // å¼€å§‹ç›‘å¬å®¹å™¨å¤§å°å˜åŒ–
  resizeObserver.observe(targetContainer)
  console.log('Container resize observer started')
}

// Open in new window
const openInNewTab = () => {
  if (!fileUrl.value) return
  window.open(fileUrl.value, '_blank')
}

// Watch file path changes
watch(() => props.filePath, (newPath, oldPath) => {
  if (newPath && newPath !== oldPath) {
    cleanup()
    // Only load file after container is ready
    if (containerReady.value) {
      loadFile()
    }
  } else if (!newPath) {
    cleanup()
  }
}, { immediate: false })

// Watch container ready state
watch(containerReady, (ready) => {
  if (ready && props.filePath) {
    loadFile()
  }
})

// Lifecycle
onMounted(() => {
  // Ensure container DOM is rendered
  setTimeout(() => {
    containerReady.value = true
  }, 100)
  
  // Add window resize listener for PPT adaptive scaling
  window.addEventListener('resize', handleWindowResize)
})

onUnmounted(() => {
  cleanup()
  // Remove window resize listener
  window.removeEventListener('resize', handleWindowResize)
})
</script>

<style scoped lang="less">
.office-preview-container {
  display: flex;
  flex-direction: column;
  height: 100%;
  background: #f5f5f5;
  position: relative;
}

.office-toolbar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px 20px;
  background: #fff;
  border-bottom: 1px solid #e0e0e0;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  flex-shrink: 0;

  .toolbar-left,
  .toolbar-right {
    display: flex;
    align-items: center;
    gap: 12px;
  }

  .toolbar-right {
    justify-content: flex-end;
  }

  .file-name {
    font-size: 16px;
    font-weight: 600;
    color: #333;
    max-width: 300px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .file-type {
    padding: 4px 8px;
    background: #1890ff;
    color: #fff;
    font-size: 12px;
    font-weight: 500;
    border-radius: 4px;
    text-transform: uppercase;
  }

  .toolbar-btn {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 8px 12px;
    border: 1px solid #d0d0d0;
    border-radius: 6px;
    background: #fff;
    cursor: pointer;
    font-size: 14px;
    transition: all 0.2s;
    font-weight: 500;

    svg {
      flex-shrink: 0;
    }

    &:hover {
      background: #f0f8ff;
      border-color: #1890ff;
      color: #1890ff;
    }

    &:active {
      transform: translateY(1px);
    }
  }
}

.document-toolbar {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 8px 16px;
  background: #fff;
  border-bottom: 1px solid #e0e0e0;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  flex-shrink: 0;
  z-index: 10;

  .toolbar-left,
  .toolbar-center,
  .toolbar-right {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .toolbar-center {
    flex: 1;
    justify-content: center;
  }

  .tool-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 32px;
    height: 32px;
    border: 1px solid #d0d0d0;
    border-radius: 4px;
    background: #fff;
    cursor: pointer;
    transition: all 0.2s;
    
    &:hover:not(:disabled) {
      background: #f0f8ff;
      border-color: #1890ff;
      color: #1890ff;
    }

    &:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    &.reset-btn {
      width: auto;
      padding: 6px 12px;
      gap: 6px;
      
      span {
        white-space: nowrap;
        font-size: 14px;
      }
    }
  }

  .zoom-level {
    min-width: 45px;
    text-align: center;
    font-size: 14px;
    color: #666;
  }

  .document-type {
    font-size: 14px;
    color: #666;
    font-weight: 500;
  }

  .page-input {
    display: flex;
    align-items: center;
    gap: 8px;
    
    input {
      width: 50px;
      height: 28px;
      padding: 4px 8px;
      border: 1px solid #d0d0d0;
      border-radius: 4px;
      text-align: center;
      font-size: 14px;
      background: #fff;
      color: #333;
      
      &:focus {
        outline: none;
        border-color: #1890ff;
        background: #fff;
      }

      /* Fix number input up/down arrow styles */
      &::-webkit-outer-spin-button,
      &::-webkit-inner-spin-button {
        -webkit-appearance: none;
        margin: 0;
      }
      
      /* Firefox compatibility */
      &[type=number] {
        -moz-appearance: textfield;
      }
    }
    
    span {
      font-size: 14px;
      color: #666;
      white-space: nowrap;
    }
  }
}

.office-container {
  flex: 1;
  position: relative;
  overflow: hidden;
}

.document-wrapper {
  width: 100%;
  height: 100%;
}

.pdf-wrapper {
  width: 100%;
  height: 100%;
  overflow: auto;
  position: relative;
  display: flex;
  justify-content: center;
}

.pdf-zoom-container {
  width: fit-content;
  min-width: 100%;
  height: auto;
  min-height: 100vh;
  transition: transform 0.2s ease;
  overflow: visible;
  margin: 0 auto;
}

.excel-wrapper {
  width: 100%;
  height: 100%;
  overflow: auto;
  position: relative;
}

.docx-wrapper {
  width: 100%;
  height: 100%;
  overflow: auto;
  position: relative;
}

.docx-scaler {
  min-width: 100%;
  min-height: 100%;
  display: inline-block;
}

.pptx-wrapper {
  width: 100%;
  height: 100%;
  overflow: auto;
  position: relative;
  display: flex;
  flex-direction: column;
  align-items: center;
}

.loading-overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(255, 255, 255, 1);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

.loading-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  
  .loading-spinner {
    width: 50px;
    height: 50px;
    border: 4px solid #f3f3f3;
    border-top: 4px solid #1890ff;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin-bottom: 16px;
  }

  p {
    color: #666;
    font-size: 16px;
    font-weight: 500;
  }
}

.error-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  padding: 20px;
  
  .error-message {
    color: #ff4d4f;
    font-size: 16px;
    margin-bottom: 16px;
    text-align: center;
    line-height: 1.5;
  }

  .retry-btn {
    padding: 10px 20px;
    background: #1890ff;
    color: #fff;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-size: 14px;
    font-weight: 500;
    transition: all 0.2s;

    &:hover {
      background: #40a9ff;
      transform: translateY(-1px);
    }

    &:active {
      transform: translateY(0);
    }
  }
}

.unsupported-format {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  padding: 20px;
  text-align: center;

  p {
    font-size: 16px;
    color: #666;
    margin-bottom: 8px;
    line-height: 1.5;

    &:first-child {
      color: #ff4d4f;
      font-weight: 500;
      font-size: 18px;
    }
  }
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* Responsive design */
@media (max-width: 768px) {
  .office-toolbar {
    padding: 10px 16px;
    flex-direction: column;
    gap: 12px;

    .toolbar-left,
    .toolbar-right {
      width: 100%;
      justify-content: center;
    }

    .file-name {
      max-width: none;
      text-align: center;
    }
  }
}

/* Override Vue Office component default styles */
:deep(.vue-office-wrapper) {
  height: 100% !important;
}

/* Minimal PDF styling to avoid interference */
:deep(.vue-office-pdf) {
  width: 100% !important;
  height: 100% !important;
}

:deep(.vue-office-docx) {
  height: 100% !important;
  overflow: auto !important;
}

/* Fix DOCX scrolling issues */
:deep(.vue-office-docx .docx-wrapper) {
  overflow: auto !important;
  max-height: none !important;
}

:deep(.vue-office-docx .docx-container) {
  overflow: auto !important;
  height: auto !important;
  max-height: none !important;
}

/* Excel component styles */
:deep(.vue-office-excel) {
  width: 100% !important;
  height: 100% !important;
  overflow: auto !important;
}

:deep(.vue-office-excel .excel-wrapper) {
  overflow: auto !important;
  max-width: none !important;
  max-height: none !important;
}

:deep(.vue-office-excel .luckysheet) {
  overflow: auto !important;
  width: 100% !important;
  height: 100% !important;
}

:deep(.vue-office-excel .luckysheet-container) {
  overflow: auto !important;
}

/* å¼ºåˆ¶æ˜¾ç¤ºExcelæ»šåŠ¨æ¡å’Œæ»šåŠ¨å— - é’ˆå¯¹x-spreadsheet */
:deep(.x-spreadsheet-scrollbar) {
  opacity: 1 !important;
  visibility: visible !important;
  display: block !important;
}

:deep(.x-spreadsheet-scrollbar.vertical) {
  opacity: 1 !important;
  visibility: visible !important;
  display: block !important;
  width: 15px !important;
}

:deep(.x-spreadsheet-scrollbar.horizontal) {
  opacity: 1 !important;
  visibility: visible !important;
  display: block !important;
  height: 15px !important;
}

/* å¼ºåˆ¶æ˜¾ç¤ºæ»šåŠ¨å— thumb */
:deep(.x-spreadsheet-scrollbar .x-scrollbar-thumb) {
  opacity: 1 !important;
  visibility: visible !important;
  display: block !important;
  background: #c1c1c1 !important;
  border-radius: 6px !important;
}

:deep(.x-spreadsheet-scrollbar.vertical .x-scrollbar-thumb) {
  width: 100% !important;
  min-height: 20px !important;
}

:deep(.x-spreadsheet-scrollbar.horizontal .x-scrollbar-thumb) {
  height: 100% !important;
  min-width: 20px !important;
}

/* hoverçŠ¶æ€çš„æ»šåŠ¨å— */
:deep(.x-spreadsheet-scrollbar .x-scrollbar-thumb:hover) {
  background: #a8a8a8 !important;
}

/* ç¡®ä¿æ»šåŠ¨æ¡è½¨é“ä¹Ÿæ˜¾ç¤º */
:deep(.x-spreadsheet-scrollbar .x-scrollbar-track) {
  opacity: 1 !important;
  visibility: visible !important;
  background: #f1f1f1 !important;
}

/* ç¡®ä¿æ»šåŠ¨æ¡å®¹å™¨ä¹Ÿå§‹ç»ˆæ˜¾ç¤º */
:deep(.x-spreadsheet) {
  --scrollbar-size: 15px;
}

/* Macç³»ç»ŸåŸç”Ÿæ»šåŠ¨æ¡å¼ºåˆ¶æ˜¾ç¤ºï¼ˆå¤‡ç”¨æ–¹æ¡ˆï¼‰ */
:deep(.x-spreadsheet-scrollbar::-webkit-scrollbar) {
  width: 15px;
  height: 15px;
  -webkit-appearance: none;
}

:deep(.x-spreadsheet-scrollbar::-webkit-scrollbar-track) {
  background: #f1f1f1;
  border-radius: 6px;
}

:deep(.x-spreadsheet-scrollbar::-webkit-scrollbar-thumb) {
  background: #c1c1c1;
  border-radius: 6px;
  min-height: 20px;
  min-width: 20px;
}

:deep(.x-spreadsheet-scrollbar::-webkit-scrollbar-thumb:hover) {
  background: #a8a8a8;
}


:deep(.vue-office-pptx) {
  height: 100% !important;
  overflow: auto !important;
}

/* Fix PPTX preview container height issues */
:deep(.vue-office-pptx .pptx-preview-wrapper) {
  width: 100% !important;
  height: auto !important;
  overflow: visible !important;
  min-height: 100vh;
}

/* PPT container overall scaling */
:deep(.vue-office-pptx) {
  width: 100% !important;
  height: auto !important;
  zoom: calc(var(--document-scale, 1) * 0.8) !important; /* Default 80%, multiplied by user scale ratio */
  transform-origin: top center !important;
}

/* PPT preview container */
:deep(.vue-office-pptx .pptx-preview-wrapper) {
  width: 100% !important;
  height: auto !important;
  overflow: visible !important;
  display: flex !important;
  flex-direction: column !important;
  align-items: center !important;
}

/* Each slide container */
:deep(.vue-office-pptx .pptx-preview-slide-wrapper) {
  width: 960px !important; /* Keep original width */
  margin: 10px auto !important;
  display: block !important;
  overflow: visible !important;
}

/* Slide content */
:deep(.vue-office-pptx .pptx-slide) {
  width: 960px !important;
  height: auto !important;
  margin: 0 !important;
  display: block !important;
  overflow: visible !important;
}
</style>


================================================
FILE: frontend/src/components/fileClass/fileSvg.vue
================================================
<template>
    <img v-if="isImageType" :src="img" alt="" class="file-icon img-file" />
    <component v-else :is="iconComponent" class="file-icon" />
</template>

<script setup>
import { computed, ref } from 'vue'
import PptIcon from '@/assets/fileClass/ppt.svg?component'
import WordIcon from '@/assets/fileClass/word.svg?component'
import ExcelIcon from '@/assets/fileClass/excel.svg?component'
import PdfIcon from '@/assets/fileClass/pdf.svg?component'
import TextIcon from '@/assets/fileClass/txt.svg?component'
import CodeIcon from '@/assets/fileClass/code.svg?component'
import ImageIcon from '@/assets/fileClass/image.svg?component'
import workspaceService from '@/services/workspace'
// import DefaultIcon from '@/assets/fileClass/default.svg?component'
const imageTypes = ['png', 'jpg', 'jpeg', 'gif', 'bmp', 'svg', 'webp']
const props = defineProps({
    url: {
        type: String,
        default: ''
    },
    filepath: {
        type: String,
        default: '',
        required: false
    },
    isUpdate: {
        type: Boolean,
        default: false
    }
})

const fileTypes = {
    ppt: {
        extensions: ['ppt', 'pptx'],
        component: PptIcon
    },
    text: {
        extensions: ['txt', 'md'],
        component: TextIcon
    },
    word: {
        extensions: ['doc', 'docx'],
        component: WordIcon
    },
    excel: {
        extensions: ['xls', 'xlsx'],
        component: ExcelIcon
    },
    pdf: {
        extensions: ['pdf'],
        component: PdfIcon
    },
    code: {
        extensions: ['js', 'ts', 'html', 'css', 'vue','py','rb','go','sql','yaml','yml','php','sh','bash','cs','rs','kt','scala'],
        component: CodeIcon
    },
    image: {
        extensions: imageTypes,
        component: ImageIcon
    }
}



const img = ref('')
// Check if the file type is an image
const isImageType = computed(() => {
    if (props.isUpdate) {
        return false
    }
    if (imageTypes.includes(props.url.split('.').pop().toLowerCase())){
        // console.log("getFile",props.url)
        workspaceService.getFile(props.filepath).then(res => {
            const imageURL = URL.createObjectURL(res); // blob -> url
            img.value = imageURL
        })
        return true
    }
    return false
})

// Determine which icon component to render for non-image files
const iconComponent = computed(() => {
    const extension = props.url.split(".").pop().toLowerCase()
    for (const [_, config] of Object.entries(fileTypes)) {
        if (config.extensions.includes(extension)) {
            return config.component
        }
    }
    // return è¿”å›æ–‡æœ¬æ–‡ä»¶å›¾æ ‡
    return TextIcon
})
</script>

<style scoped>
.file-icon {
    display: block;
    scrollbar-width: thin;
    scrollbar-color: transparent transparent;
    box-sizing: border-box;
    border: 0 solid #e5e7eb;
    width: 32px; 
    height: 32px;
}
.img-file{
    border-radius: 4px;
}
</style>


================================================
FILE: frontend/src/components/lang/index.vue
================================================
<template>
  <div class="lang-container">
    <h3>{{ $t('setting.basic.langTitle') }}</h3>
    <div class="lang-setting-container">
      <!-- <span style="width:30%">{{ $t('setting.basic.languagePreference') }}</span> -->
      <div class="lang-options" style="width: 70%; display:flex;flex-direction:end">
        <a-select v-model:value="selectedLang" style="width: 30%;font-size: 15px" @change="handleLangChange">
          <a-select-option v-for="item in langList" :key="item.id" :value="item.type" style="font-size: 15px">
            <span>{{ item.title }}</span>
          </a-select-option>
        </a-select>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue'
import { useI18n } from 'vue-i18n'

const { t, locale } = useI18n()

const langList = ref([
  { id: 1, type: 'en', title: "ğŸ‡ºğŸ‡¸ English" },
  { id: 2, type: 'zh', title: "ğŸ‡¨ğŸ‡³ ä¸­æ–‡" },
  // { id: 3, type: 'de' },
  // { id: 4, type: 'es' },
  // { id: 5, type: 'fr' },
  // { id: 6, type: 'ja' },
  // { id: 7, type: 'kr' },
  // { id: 8, type: 'tr' },
  // { id: 9, type: 'pt' },
  // { id: 10, type: 'tw' },
  // { id: 11, type: 'vi' }
])

const selectedLang = ref(locale.value || 'en')

const handleLangChange = (value) => {
  locale.value = value
  localStorage.setItem('lang', value)
}

onMounted(() => {
  const savedLang = localStorage.getItem('lang')
  if (savedLang && langList.value.some(lang => lang.type === savedLang)) {
    selectedLang.value = savedLang
    locale.value = savedLang
  }
})
</script>

<style scoped lang="scss">
.lang-container {
  display: flex;
  flex-direction: column;
}

.lang-setting-container {
  display: flex;
  flex-direction: row;
  align-items: center;
  gap: 10px;
}

@media screen and (max-width: 768px) {
  h3 {
    margin-bottom: 16px !important;
    margin-top: 0px !important;
  }

  .lang-options {
    width: 100% !important;

    div {
      width: 100% !important;
    }
  }
}
</style>


================================================
FILE: frontend/src/components/markdown/index.vue
================================================
<template>
  <div v-html="renderHTML" class="markdown-render"></div>
</template>

<script setup>
import { ref, watch, onMounted,nextTick } from "vue";

// API æ–‡æ¡£: https://markdown-it.github.io/markdown-it
import markdownIt from "markdown-it";

// https://github.com/arve0/markdown-it-attrs
import markdownItAttrs from "markdown-it-attrs";
// https://www.npmjs.com/package/markdown-it-graphviz
// import markdownItGraphviz from "markdown-it-graphviz";
// import markdownItCodeCopy from 'markdown-it-code-copy';
import markdownItMermaid from "./markdown-it-mermaid";
import markdownItPrism from "./markdown-it-prism";
// https://github.com/jGleitz/markdown-it-prism#options
// ä»£ç é«˜äº®

// è„‘å›¾æ¸²æŸ“
// import markdownItMarkmap from './markdown-it-markmap';

// import markdownItHighlight from 'markdown-it-highlightjs'
// import hljs from 'highlight.js/lib/core';
// import 'highlight.js/styles/github.css';

const md = markdownIt({
  html: false,
  breaks: true,
  langPrefix: "language-",
  quotes: "â€œâ€â€˜â€™",
})
  .use(markdownItAttrs)
  .use(markdownItMermaid, { theme: "forest" })

// md.use(markdownItGraphviz);
// md.use(markdownItCodeCopy);
md.use(markdownItPrism);
// md.use(markdownItMarkmap);

// import markdownItThink from "./markdown-it-think.js";
// md.use(markdownItThink);

// md.use(markdownItHighlight, { hljs });

const props = defineProps({
  content: {
    type: String,
    default: "",
  },
});

const renderHTML = ref("");

watch(
  () => props.content,
  (val) => {
    nextTick(() => {
      renderHTML.value = md.render(val);
    })
  }
);


// console.log("props", props.content);
onMounted(() => {
  nextTick(() => {
    renderHTML.value = md.render(props.content || "");
  })
 
});
</script>

<style lang="scss">
.dialog-item {

  /* ä»£ç ä¸æ¢è¡Œ */
  pre {
    box-sizing: border-box;
  }

  pre>code[class*="language-"] {
    box-sizing: border-box !important;
    white-space: pre-wrap;
    font-size: 14px;
    color: #213547 !important;
    text-shadow:unset!important;
  }
}

/* markdown-it-thinking.css */
.thinking-container {
  min-height: 30px;
  position: relative;
  transition: background-color 0.3s ease;
  margin-bottom: 12px;
}

.thinking-toggle {
  width: fit-content;
  color: rgb(38, 38, 38);
  background-color: #e0e0e0;
  padding: 8px 16px;
  font-size: 12px;
  border-radius: 10px;
  cursor: pointer;
  transition: background-color 0.3s ease;
  margin-bottom: 12px;
  user-select: none;
}

.thinking-content {
  padding: 0 16px;
  border-left: 1px solid #ddd;
  animation: fadeIn 0.3s ease;
  color: #8b8b8b;
  font-size: 14px;
  margin: 12px 0;
}


@keyframes fadeIn {
  from {
    opacity: 0;
  }

  to {
    opacity: 1;
  }
}
.markdown-render {
  table {
    width: 90%;
    border-collapse: collapse;
    background: rgba(255, 255, 255, 0.95);
    border-radius: 10px;
    overflow: hidden;
    margin: 12px 0;
  }
  h1 {
    font-size: 1.8em!important;
  }
  p{
    margin:0px!important;
  }

  th,
  td {
    padding: 15px 25px;
    text-align: center;
    border-bottom: 1px solid rgba(0, 0, 0, 0.08);
  }

  th {
    background: rgba(0, 150, 255, 0.1);
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 1px;
    font-size: 0.9em;
    color: #0066cc;
  }

  tr:hover {
    background: rgba(0, 150, 255, 0.03);
    transition: background 0.3s ease;
  }

  td {
    transition: all 0.3s ease;
  }

  tr:hover td {
    color: #0066cc;
  }

  tbody tr:last-child td {
    border-bottom: none;
  }
  // direct element
  & > pre{
    background: #272822;
    padding: 12px;
    border-radius: 8px;
    code{
      // color: #8b8b8b;
      text-shadow: none;
      
    }
  }
}
</style>



================================================
FILE: frontend/src/components/markdown/markdown-it-markmap.js
================================================
import { Transformer, fillTemplate } from 'markmap-lib';
const transformer = new Transformer();
// import { Markmap } from 'markmap-view/dist/index.esm.js';
import * as markmap from 'markmap-view';
const { Markmap } = markmap;

if (!window.markmapHash) {
  window.markmapHash = {};
}

function markmapPlugin(md, options = {}) {
  const defaultFenceRenderer = md.renderer.rules.fence;

  md.renderer.rules.fence = (tokens, idx, options, env, slf) => {

    const token = tokens[idx];

    if (token.info === 'mindmap') {
      try {
        console.log("markmapHash", markmapHash);
        const { root } = transformer.transform(token.content.trim());
        const domID = Date.now().toString(16);
        setTimeout(() => {
          // const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
          // const el = document.getElementById(domID);
          const svg = document.getElementById(domID);
          const mm = Markmap.create(svg, {}, root);
          mm.fit();
          markmapHash[domID] = mm;
        }, 100);
        return `<div><svg id="${domID}"></svg></div>`;

      } catch (ex) {
        console.log('error', ex);
        return `<pre>${ex}</pre>`
      }
    }

    return defaultFenceRenderer(tokens, idx, options, env, slf)
  };
}

export default markmapPlugin


================================================
FILE: frontend/src/components/markdown/markdown-it-mermaid.js
================================================
import MarkdownIt from "markdown-it";
// https://mermaid.js.org/
// https://github.com/mermaid-js/mermaid#readme
// https://github.com/mermaid-js/mermaid-live-editor

// Note: V9 is OK, but V10 is not.
// import Mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@9/dist/mermaid.esm.min.mjs';
import Mermaid from "mermaid";

// Define interface to await readiness of import
export default function mermaid(md, options = {}) {

  // Setup Mermaid
  Mermaid.initialize({
    startOnLoad: true,
    securityLevel: "loose",
    ...options,
  });

  function getLangName(info) {
    return info.split(/\s+/g)[0];
  }

  // Store reference to original renderer.
  let defaultFenceRenderer = md.renderer.rules.fence;

  // Render custom code types as SVGs, letting the fence parser do all the heavy lifting.
  function customFenceRenderer(tokens = [], idx, options = {}, env, slf) {

    let token = tokens[idx];
    let info = token.info.trim();
    let langName = info ? getLangName(info) : "";

    if (["mermaid", "{mermaid}"].indexOf(langName) === -1) {
      if (defaultFenceRenderer !== undefined) {
        return defaultFenceRenderer(tokens, idx, options, env, slf);
      }
      // Missing fence renderer!
      return "";
    }

    let imageHTML = "";
    let imageAttrs = [];

    // Create element to render into
    const element = document.createElement("div");
    document.body.appendChild(element);

    // Render with Mermaid
    try {
      // console.log('token.content', token.content);
      const container_id = "mermaid-container";
      // console.log('Mermaid.mermaidAPI', Mermaid.mermaidAPI);

      Mermaid.mermaidAPI.render(
        container_id,
        token.content,
        (html) => {
          // console.log('html', html);
          // We need to forcibly extract the max-width/height attributes to set on img tag
          let svg = document.getElementById(container_id);
          if (svg !== null) {
            imageAttrs.push([
              "style",
              `max-width:${svg.style.maxWidth};max-height:${svg.style.maxHeight}`,
            ]);
          }
          // Store HTML
          imageHTML = html;
        },
        element
      );
    } catch (e) {
      console.log('render error', e);
      return defaultFenceRenderer(tokens, idx, options, env, slf);
    } finally {
      // element.remove();
    }

    // Store encoded image data
    imageAttrs.push([
      "src",
      `data:image/svg+xml,${encodeURIComponent(imageHTML)}`,
    ]);
    return `<img ${slf.renderAttrs({ attrs: imageAttrs })}>`;
  }

  md.renderer.rules.fence = customFenceRenderer;
}



================================================
FILE: frontend/src/components/markdown/markdown-it-prism.js
================================================
import Prism from "prismjs";
import "prismjs/themes/prism-okaidia.css";
import 'prismjs/components/prism-typescript';
import "prismjs/components/prism-css";
import "prismjs/components/prism-sql";
import "prismjs/components/prism-java";
import "prismjs/components/prism-go";
import "prismjs/components/prism-git";
import "prismjs/components/prism-json";
import "prismjs/components/prism-scss";
import "prismjs/components/prism-jsx";
import "prismjs/components/prism-powershell";
import "prismjs/components/prism-python";
import "prismjs/components/prism-csharp";
import "prismjs/components/prism-c";
import "prismjs/components/prism-bash";
import i18n from '@/locals/index'

export default function prism(md, options = {}) {

  function getLangName(info) {
    return info.split(/\s+/g)[0];
  }

  // Store reference to original renderer.
  let defaultFenceRenderer = md.renderer.rules.fence;

  // Render custom code types as SVGs, letting the fence parser do all the heavy lifting.
  function prismRender(tokens = [], idx, options = {}, env, slf) {
    // console.log('prismRender', arguments)
    const token = tokens[idx];
    const info = token.info.trim();
    const language = info ? getLangName(info) : "js";

    const object = Prism.languages[language];
    // å¦‚æœæ˜¯ Prism ä¸æ”¯æŒçš„è¯­è¨€ï¼Œå°±ä¸æ¸²æŸ“äº†
    if (!object) {
      return defaultFenceRenderer(tokens, idx, options, env, slf);
    }

    const code = token.content;
    // console.log(`==${code}==`)
    const rendered = Prism.highlight(code, Prism.languages[language], language)
    // console.log('rendered', rendered);
    // return rendered;
    const domID = Date.now().toString(16);

    const copyText = i18n.global.t('copy');

    window.markdownItCopy = (codeblockId, event) => {
      const el = document.getElementById(codeblockId)
      const text = el.innerText
      const textarea = document.createElement('textarea')
      textarea.value = text
      document.body.appendChild(textarea)
      textarea.select()
      document.execCommand('copy')
      document.body.removeChild(textarea)
      // console.log("event", event);
      // console.log("target", event.currentTarget);

      const target = event.currentTarget;
      // console.log("target", target)
      const children = target.children;
      const span = children[1];
      span.innerText = i18n.global.t('success', { msg: i18n.global.t('copy') });
      setTimeout(() => {
        span.innerText = i18n.global.t('copy');
      }, 1000);
    }

    return `
<div class="code-block" style="border-radius: 6px; overflow: hidden;">
  <div class="toolbar" style="padding: 8px 16px; display: flex; justify-content: space-between; align-items: center; width: 100%; color: rgba(217,217,227,1); background: rgba(52,53,65,1); border-radius: 6px 6px 0 0">
    <span></span>
    <span style="display:flex;align-items:center;cursor: pointer;" onclick="markdownItCopy('C${domID}', event)" data-v-500f045f="" role="img" aria-label="copy" >
      <svg focusable="false" class="" data-icon="copy" width="1em" height="1em" fill="currentColor" aria-hidden="true" viewBox="64 64 896 896"><path d="M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z"></path>
      </svg>
      <span style="margin-left:6px;font-size:14px">${copyText}</span>
    </span>
  </div>
<pre class="language-${language}" style="width: 100%; margin: 0; border-radius: 0 0 6px 6px">
<code class="language-${language}" id="C${domID}">${rendered}</code>
</pre>
</div>`
  }

  md.renderer.rules.fence = prismRender;
}



================================================
FILE: frontend/src/components/markdown/markdown-it-think.js
================================================

function markdownItThinking(md, options = {}) {
  // å®šä¹‰ä¸€ä¸ª block è§£æè§„åˆ™ï¼ŒåŒ¹é… <think> ... </think> åŒºå—
  function thinkBlock(state, startLine, endLine, silent) {
    const startPos = state.bMarks[startLine] + state.tShift[startLine];
    const maxPos = state.eMarks[startLine];
    const lineText = state.src.slice(startPos, maxPos).trim();

    if (!lineText.startsWith('<think>')) return false;

    // æœç´¢ç»“æŸæ ‡è®° </think>
    let nextLine = startLine;
    let foundEnd = false;
    while (nextLine < endLine) {
      const pos = state.bMarks[nextLine] + state.tShift[nextLine];
      const max = state.eMarks[nextLine];
      const currLine = state.src.slice(pos, max);
      if (currLine.trim().endsWith('</think>')) {
        foundEnd = true;
        break;
      }
      nextLine++;
    }
    if (!foundEnd) return false; // æ²¡æœ‰æ‰¾åˆ°ç»“æŸæ ‡è®°åˆ™è·³è¿‡

    // å¦‚æœæ˜¯ silent æ¨¡å¼ï¼Œåªæ£€æµ‹æ˜¯å¦åŒ¹é…
    if (silent) return true;

    // ç”Ÿæˆ open tokenï¼ˆåŒ…å«å®¹å™¨å¼€å§‹æ ‡ç­¾ï¼‰
    let token = state.push('think_open', 'div', 1);
    token.block = true;
    token.map = [startLine, nextLine];
    token.attrs = [['class', 'thinking-container']];

    // ç”Ÿæˆå†…å®¹ tokenï¼Œå†…å®¹ä¸º <think> å’Œ </think> ä¹‹é—´çš„å†…å®¹
    const contentLines = [];
    // å¦‚æœå¼€å§‹è¡Œé™¤äº† <think> åè¿˜æœ‰å†…å®¹ï¼Œä¹Ÿç®—ä½œç¬¬ä¸€è¡Œå†…å®¹
    const firstLine = state.src.slice(startPos, maxPos);
    const startTagIndex = firstLine.indexOf('<think>');
    let firstContent = firstLine.slice(startTagIndex + '<think>'.length);
    if (firstContent.trim()) {
      contentLines.push(firstContent);
    }
    for (let i = startLine + 1; i < nextLine; i++) {
      const pos = state.bMarks[i] + state.tShift[i];
      const max = state.eMarks[i];
      contentLines.push(state.src.slice(pos, max));
    }
    // æœ€åä¸€è¡Œå»æ‰ </think>
    const lastLine = contentLines.pop() || '';
    const endTagIndex = lastLine.lastIndexOf('</think>');
    const lastContent = endTagIndex >= 0 ? lastLine.slice(0, endTagIndex) : lastLine;
    contentLines.push(lastContent);

    // ç”Ÿæˆ close tokenï¼ˆç”¨äºæ¸²æŸ“æŒ‰é’®å’Œå®¹å™¨ç»“æŸæ ‡ç­¾ï¼‰
    token = state.push('think_close', 'div', 0);
    token.block = true;
    token.map = [startLine, nextLine];

    token = state.push('thinking_content', 'div', -1);
    token.block = true;
    token.content = contentLines.join('\n').trim();
    token.map = [startLine, nextLine];

    state.line = nextLine + 1;
    return true;
  }

  // æ³¨å†Œ block è§„åˆ™ï¼Œä¼˜å…ˆäº fence
  md.block.ruler.before('fence', 'think', thinkBlock, { alt: [] });

  // æ¸²æŸ“è§„åˆ™ï¼šopen token
  md.renderer.rules.think_open = function (tokens, idx, options, env, self) {
    return `<div class="thinking-container">`;
  };

  // æ¸²æŸ“è§„åˆ™ï¼šå†…å®¹ tokenï¼Œåˆå§‹éšè—ï¼Œä½¿ç”¨ md.render å¤„ç†å†…å®¹ï¼ˆä½ ä¹Ÿå¯ä»¥ä¸åšäºŒæ¬¡è§£æï¼‰
  md.renderer.rules.thinking_content = function (tokens, idx, options, env, self) {
    // æ­¤å¤„ç›´æ¥è¾“å‡º token.contentï¼Œå¦‚æœ‰éœ€è¦å¯ä½¿ç”¨ md.renderInline(tokens[idx].content)
    return `<div class="thinking-content" style="display:block;">${md.render(tokens[idx].content)}</div>`;
  };

  // æ¸²æŸ“è§„åˆ™ï¼šclose tokenï¼Œåœ¨å®¹å™¨æœ«å°¾æ·»åŠ å±•å¼€/æ”¶èµ·æŒ‰é’®ï¼Œå¹¶å…³é—­å®¹å™¨
  md.renderer.rules.think_close = function (tokens, idx, options, env, self) {
    return `<div class="thinking-toggle" onclick="(function(el){ 
      var content = el.nextElementSibling;
      if(content.style.display==='none'){
        content.style.display='block'; 
        el.innerText='å·²æ·±åº¦æ€è€ƒ â–³';
      } else {
        content.style.display='none'; 
        el.innerText='å·²æ·±åº¦æ€è€ƒ â–½';
      }
    })(this)">å·²æ·±åº¦æ€è€ƒ â–³</div>`;
  };
}

export default markdownItThinking;


================================================
FILE: frontend/src/components/mcpServer/index.vue
================================================
<template>
  <div class="mcp-manager-container">
    <div class="top-action-bar">
      <h2 class="title">{{ $t("setting.mcpService.title") }}</h2>
      <div class="actions">
        <a-button @click="showImportModal">
          <template #icon>
            <ImportOutlined />
          </template>
          {{ $t("setting.mcpService.importFromJson") }}
        </a-button>
        <a-button type="primary" @click="handleAddServer" style="margin-left: 8px">
          <template #icon>
            <PlusOutlined />
          </template>
          {{ $t("setting.mcpService.addMcpServer") }}
        </a-button>
      </div>
    </div>

    <div class="main-content">
      <div class="server-list-panel">
        <ServerList :servers="mcpServerList" :selectedServerId="chooseMCPServer?.id" @select="handleMcpServer" />
      </div>
      <div class="server-settings-panel">
        <template v-if="chooseMCPServer">
          <ServerSettings :server="chooseMCPServer" @update:server="handleUpdateServer" @save="handleMCPServerSave" @delete="handleMCPServerDelete" />
        </template>
        <div v-else class="no-server-placeholder">
          <div class="placeholder-content">
            <div class="placeholder-icon">
              <CodeOutlined />
            </div>
            <p class="placeholder-text">{{ $t("setting.mcpService.noServerSelected") }}</p>
          </div>
        </div>
      </div>
    </div>

    <a-modal
      v-model:visible="importModalVisible"
      :title="$t('setting.mcpService.importModalTitle')"
      @ok="handleImportOk"
      :ok-text="$t('setting.mcpService.ok')"
      :cancel-text="$t('setting.mcpService.cancel')"
    >
      <pre>{{ exampleJson }}</pre>
      <a-textarea v-model:value="importJsonText" placeholder="" :rows="10" />
    </a-modal>
  </div>
</template>

<script setup>
import { ref, onMounted, watch, computed } from "vue";
import { storeToRefs } from "pinia";
import { message } from "ant-design-vue";
import { PlusOutlined, CodeOutlined, ImportOutlined } from "@ant-design/icons-vue";
import { useI18n } from "vue-i18n";
import ServerList from "./ServerList.vue";
import ServerSettings from "./ServerSettings.vue";
import { useServerStore } from "@/store/modules/server";

const { t } = useI18n();
const serverStore = useServerStore();
const { servers: mcpServerList } = storeToRefs(serverStore);
const { addServer, updateServer, deleteServer, fetchServers } = serverStore;

const chooseMCPServer = ref(null);
const importModalVisible = ref(false);
const importJsonText = ref("");

const exampleServer = {
  mcpServers: {
    "amap-amap-sse": {
      url: "https://mcp.amap.com/sse?key=amap_key",
    },
  },
};

const exampleJson = JSON.stringify(exampleServer, null, 2);

const handleMcpServer = (server) => {
  chooseMCPServer.value = server;
};

const handleUpdateServer = (server) => {
  chooseMCPServer.value = { ...chooseMCPServer.value, ...server };
};

const handleMCPServerSave = () => {
  if (chooseMCPServer.value) {
    updateServer(chooseMCPServer.value);
  }
};

const handleMCPServerDelete = (serverId) => {
  deleteServer(serverId);
};

const handleAddServer = () => {
  const newServer = {
    name: "MCP Server",
    description: "",
    activate: false,
    type: "stdio",
    command: "",
    registryUrl: "",
    args: [],
    env: {},
  };
  addServer(newServer);
};

const showImportModal = () => {
  importModalVisible.value = true;
  importJsonText.value = "";
};

const resolveMcpServerType = (server) => {
  const { url = "", command = "" } = server;
  if (url.includes("sse")) {
    return "sse";
  } else if (command.startsWith("npx") || command.startsWith("uvx")) {
    return "stdio";
  } else if (url.includes("mcp")) {
    return "streamableHttp";
  }
  return "stdio";
};

const handleImportOk = () => {
  try {
    const importData = JSON.parse(importJsonText.value);

    if (importData.mcpServers) {
      const servers = importData.mcpServers;
      let serversAddedCount = 0;
      for (const serverName in servers) {
        if (Object.prototype.hasOwnProperty.call(servers, serverName)) {
          const serverConfig = servers[serverName];
          const type = resolveMcpServerType(serverConfig);

          const newServer = {
            name: serverName,
            description: serverConfig.description || "",
            activate: false,
            url: serverConfig.url,
            type: type,
            command: type === "stdio" ? serverConfig.command : "",
            args: serverConfig.args || [],
            env: serverConfig.env || {},
          };
          addServer(newServer);
          serversAddedCount++;
        }
      }

      if (serversAddedCount > 0) {
        message.success(t("mcpService.importSuccess", { count: serversAddedCount }));
      } else {
        message.warn(t("mcpService.noValidServer"));
      }
    } else {
      if (!importData.name) {
        message.error(t("mcpService.nameRequired"));
        return;
      }
      addServer(importData);
      message.success(t("mcpService.importSuccessSingle"));
    }

    importModalVisible.value = false;
  } catch (e) {
    message.error(t("mcpService.invalidJson"));
    console.error("JSON parsing error:", e);
  }
};

watch(
  () => [...mcpServerList.value],
  (newServers, oldServers) => {
    if (newServers.length > oldServers.length) {
      const addedServer = newServers.find((ns) => !oldServers.some((os) => os.id === ns.id));
      if (addedServer) {
        chooseMCPServer.value = addedServer;
        return;
      }
    }

    const selectedServerExists = chooseMCPServer.value && newServers.some((s) => s.id === chooseMCPServer.value.id);
    if (!selectedServerExists) {
      chooseMCPServer.value = newServers[0] || null;
    }
  },
  {
    deep: true,
  }
);

onMounted(() => {
  fetchServers();
});
</script>

<style scoped lang="scss">
.mcp-manager-container {
  display: flex;
  flex-direction: column;
  height: 100%;
  background-color: #f0f2f5;
}

.top-action-bar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px 24px;
  background-color: #fff;
  border-bottom: 1px solid #e8e8e8;

  .title {
    font-size: 20px;
    font-weight: 500;
    margin: 0;
  }
}

.main-content {
  display: flex;
  flex-grow: 1;
  overflow: hidden;
  padding: 24px;
  gap: 24px;
}

.server-list-panel {
  width: 280px;
  flex-shrink: 0;
  background: #fff;
  border-radius: 8px;
  overflow-y: auto;
  box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.03);
}

.server-settings-panel {
  flex-grow: 1;
  background: #fff;
  border-radius: 8px;
  overflow-y: auto;
  box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.03);
}

.no-server-placeholder {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 100%;
  padding: 50px;

  .placeholder-content {
    text-align: center;
    color: rgba(0, 0, 0, 0.25);

    .placeholder-icon {
      font-size: 48px;
      margin-bottom: 16px;
    }

    .placeholder-text {
      font-size: 16px;
      margin: 0;
    }
  }
}

pre {
  background-color: #f5f5f5;
  padding: 10px;
  border-radius: 4px;
  white-space: pre-wrap;
  word-wrap: break-word;
}
</style>



================================================
FILE: frontend/src/components/mcpServer/ServerList.vue
================================================
<template>
  <div class="mcp-server-menu">
    <div v-if="!servers || servers.length === 0" class="no-servers-info">{{ $t("setting.mcpService.noServersAvailable") }}</div>
    <div v-else v-for="server in servers" :key="server.id" class="menu-item" :class="{ 'menu-item-selected': server.id === selectedServerId }" @click="$emit('select', server)">
      <CodeOutlined />
      <span class="menu-item-label">{{ server.name }}</span>
      <span
        class="menu-item-status"
        :class="{
          'menu-item-status-on': server.activate,
          'menu-item-status-off': !server.activate,
        }"
      ></span>
    </div>
  </div>
</template>

<script setup>
import { CodeOutlined } from "@ant-design/icons-vue";

defineEmits(["select"]);

defineProps({
  servers: {
    type: Array,
    required: true,
  },
  selectedServerId: {
    type: [String, Number],
    default: null,
  },
});
</script>

<style scoped>
.mcp-server-menu {
  padding: 16px 8px;
  height: 100%;
}

.no-servers-info {
  padding: 20px;
  text-align: center;
  color: #888;
}

.menu-item {
  display: flex;
  align-items: center;
  padding: 12px;
  cursor: pointer;
  font-size: 14px;
  border-radius: 4px;
  margin-bottom: 8px;
}

.menu-item:hover {
  background: #f0f0f0;
}

.menu-item-label {
  margin-left: 10px;
  font-size: 14px;
  flex-grow: 1;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.menu-item-status {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  margin-left: 16px;
  flex-shrink: 0;
}

.menu-item-status-on {
  background-color: #52c41a;
}

.menu-item-status-off {
  background-color: #d9d9d9;
}

.menu-item-selected {
  background-color: #e6f7ff;
  color: #1890ff;
}
</style>



================================================
FILE: frontend/src/components/mcpServer/ServerSettings.vue
================================================
<template>
  <div class="mcp-server-content" v-if="server">
    <div class="mcp-server-content-header">
      <div style="display: flex; align-items: center">
        <span class="mcp-server-content-header-title">
          {{ server.name }}
        </span>
        <DeleteOutlined class="mcp-server-content-header-delete-button" @click="showDeleteConfirm(server.id)" />
      </div>
      <div style="display: flex; align-items: center">
        <a-switch v-model:checked="server.activate" class="mcp-server-content-header-activate-switch" :loading="loading" @change="handleActivateChange" />
        <div class="mcp-server-content-header-save-button-container">
          <a-button type="primary" @click="$emit('save')" class="mcp-server-content-header-save-button">
            <SaveOutlined />
            {{ $t("setting.mcpService.save") }}
          </a-button>
        </div>
      </div>
    </div>

    <div class="mcp-server-content-main">
      <div class="mcp-server-content-main-name mcp-server-content-main-item">
        <span>{{ $t("setting.mcpService.name") }}</span>
        <a-input v-model:value="server.name" :placeholder="$t('setting.mcpService.namePlaceholder')" class="text-item input" />
      </div>
      <div class="mcp-server-content-main-description mcp-server-content-main-item">
        <span>{{ $t("setting.mcpService.description") }}</span>
        <a-textarea v-model:value="server.description" :rows="4" :placeholder="$t('setting.mcpService.descriptionPlaceholder')" class="text-item" />
      </div>
      <!-- type -->
      <div class="mcp-server-content-main-type mcp-server-content-main-item">
        <span>{{ $t("setting.mcpService.type") }}</span>
        <a-radio-group v-model:value="server.type" name="radioGroup" class="input radio">
          <a-radio value="stdio">
            {{ $t("setting.mcpService.stdio") }}
          </a-radio>
          <a-radio value="sse">
            {{ $t("setting.mcpService.sse") }}
          </a-radio>
          <a-radio value="streamableHttp">
            {{ $t("setting.mcpService.streamableHttp") }}
          </a-radio>
        </a-radio-group>
      </div>
      <div class="mcp-server-content-main-command mcp-server-content-main-item" v-if="server.type === 'stdio'">
        <span>{{ $t("setting.mcpService.command") }}</span>
        <a-input v-model:value="server.command" :placeholder="$t('setting.mcpService.commandPlaceholder')" class="text-item input" />
      </div>
      <div v-if="false" class="mcp-server-content-main-source mcp-server-content-main-item">
        <span>{{ $t("setting.mcpService.packageSource") }}</span>
        <a-radio-group v-if="startsWithNpx" v-model:value="server.registryUrl" name="radioGroup" class="input radio">
          <a-radio value="">{{ $t("setting.mcpService.default") }}</a-radio>
          <a-radio value="https://registry.npmmirror.com">
            {{ $t("setting.mcpService.taobaoNpmMirror") }}
          </a-radio>
        </a-radio-group>
        <a-radio-group v-if="startsWithUvx" v-model:value="server.registryUrl" name="radioGroup" class="input radio">
          <a-radio value="">{{ $t("setting.mcpService.default") }}</a-radio>
          <a-radio value="https://pypi.tuna.tsinghua.edu.cn/simple">
            {{ $t("setting.mcpService.tsinghua") }}
          </a-radio>
          <a-radio value="http://mirrors.aliyun.com/pypi/simple/">
            {{ $t("setting.mcpService.aliyun") }}
          </a-radio>
          <a-radio value="https://mirrors.ustc.edu.cn/pypi/simple/">
            {{ $t("setting.mcpService.ustc") }}
          </a-radio>
          <a-radio value="https://repo.huaweicloud.com/repository/pypi/simple/">
            {{ $t("setting.mcpService.huaweiCloud") }}
          </a-radio>
          <a-radio value="https://mirrors.cloud.tencent.com/pypi/simple/">
            {{ $t("setting.mcpService.tencentCloud") }}
          </a-radio>
        </a-radio-group>
      </div>
      <div v-if="server.type === 'sse' || server.type === 'streamableHttp'" class="mcp-server-content-main-url mcp-server-content-main-item">
        <span>{{ $t("setting.mcpService.url") }}</span>
        <a-input v-model:value="server.url" :placeholder="$t('setting.mcpService.url')" class="text-item input" @update:value="handleUpdateServer({ url: $event })" />
      </div>
      <div class="mcp-server-content-main-args mcp-server-content-main-item">
        <span>{{ $t("setting.mcpService.args") }}</span>
        <a-textarea v-model:value="argsText" :rows="4" :placeholder="$t('setting.mcpService.argsPlaceholder')" class="text-item" @update:value="handleArgsChange" />
      </div>
      <div class="mcp-server-content-main-env mcp-server-content-main-item">
        <span>{{ $t("setting.mcpService.env") }}</span>
        <a-textarea v-model:value="envText" :rows="4" :placeholder="$t('setting.mcpService.envPlaceholder')" class="text-item" @update:value="handleEnvChange" />
      </div>
    </div>
  </div>
</template>

<script setup>
import { computed, ref, watch, h } from "vue";
import { SaveOutlined, DeleteOutlined, ExclamationCircleOutlined, LoadingOutlined } from "@ant-design/icons-vue";
import { message, Modal } from "ant-design-vue";
import { useI18n } from "vue-i18n";
import mcp_service from "@/services/mcp";

const props = defineProps({
  server: {
    type: Object,
    required: true,
  },
});

const { t } = useI18n();
const emit = defineEmits(["update:server", "save", "delete"]);

const argsText = ref("");
const envText = ref("");
const loading = ref(false);

const startsWithNpx = computed(() => {
  return props.server?.command?.startsWith("npx");
});

const startsWithUvx = computed(() => {
  return props.server?.command?.startsWith("uv");
});

const validateServerConnection = async () => {
  try {
    loading.value = true;
    const r = await mcp_service.connect(props.server);
    return r.ok;
  } catch (error) {
    message.error(error.message);
    return false;
  } finally {
    loading.value = false;
  }
};

const handleActivateChange = async (checked) => {
  if (checked) {
    const isValid = await validateServerConnection();
    if (!isValid) {
      message.error(t("mcpService.connectionFailed"));
      emit("update:server", { ...props.server, activate: false });
      return;
    }
  }
  emit("update:server", { ...props.server, activate: checked });
  emit("save");
};

const handleArgsChange = (value) => {
  if (!value) {
    emit("update:server", { ...props.server, args: [] });
    return;
  }
  const args = value.split("\n").filter((arg) => arg.trim() !== "");
  emit("update:server", { ...props.server, args });
};

const handleEnvChange = (value) => {
  if (!value) {
    emit("update:server", { ...props.server, env: {} });
    return;
  }
  const env = {};
  value.split("\n").forEach((line) => {
    const trimmedLine = line.trim();
    if (trimmedLine) {
      const [key, ...values] = trimmedLine.split("=");
      const trimmedKey = key.trim();
      const trimmedValue = values.join("=").trim();
      if (trimmedKey && trimmedValue) {
        env[trimmedKey] = trimmedValue;
      }
    }
  });
  emit("update:server", { ...props.server, env });
};

const formatArgsText = (args) => {
  return Array.isArray(args) ? args.join("\n") : "";
};

const formatEnvText = (env) => {
  return Object.entries(env || {})
    .map(([key, value]) => `${key}=${value}`)
    .join("\n");
};

const showDeleteConfirm = (serverId) => {
  Modal.confirm({
    title: t("setting.mcpService.deleteConfirmTitle"),
    icon: () => h(ExclamationCircleOutlined, { style: "color: #ff4d4f" }),
    content: t("setting.mcpService.deleteConfirmContent"),
    okText: t("common.yes", "Yes"),
    okType: "danger",
    cancelText: t("common.cancel", "Cancel"),
    onOk() {
      emit("delete", serverId);
    },
    onCancel() {
      console.log("Cancel");
    },
  });
};

const handleUpdateServer = (data) => {
  emit("update:server", { ...props.server, ...data });
};

watch(
  () => props.server,
  (newServer) => {
    if (!newServer) return;
    argsText.value = formatArgsText(newServer.args || []);
    envText.value = formatEnvText(newServer.env || {});
  },
  { immediate: true, deep: true }
);
</script>

<style scoped>
.mcp-server-content {
  flex: 1;
  padding: 16px;
  overflow-y: auto;
}

.mcp-server-content-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px;
  background: white;
  border-radius: 8px;
  margin-bottom: 16px;
  box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.03);
}

.mcp-server-content-header-title {
  font-size: 16px;
  font-weight: 500;
  margin-right: 16px;
}

.mcp-server-content-header-delete-button {
  color: #ff4d4f;
  font-size: 16px;
  cursor: pointer;
  margin-left: 8px;
}

.mcp-server-content-header-save-button-container {
  margin-left: 16px;
}

.mcp-server-content-main {
  background: white;
  border-radius: 8px;
  padding: 24px;
  box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.03);
}

.mcp-server-content-main-item {
  margin-bottom: 24px;
}

.mcp-server-content-main-item > span {
  display: block;
  margin-bottom: 8px;
  font-weight: 500;
  color: rgba(0, 0, 0, 0.85);
}

.text-item {
  width: 100%;
}

.radio {
  display: block;
  line-height: 32px;
}
</style>



================================================
FILE: frontend/src/components/menu/LeftRight.vue
================================================
<template>
  <div v-if="messages.length > 1" class="message-nav">
    <LeftOutlined
      class="change-btn"
      :class="canBeLeft?'enabled' : 'disabled'"
      @click="leftClick"
    />
    <div class="change-btns-text">{{ localCurrentMessageIndex + 1 }}<span class="" style="margin-right: 2px;margin-left: 2px;"> / </span>{{ messages.length }}</div>
    <RightOutlined
      class="change-btn"
      :class="canBeRight?'enabled' : 'disabled'"
      @click="rightClick"
    />
  </div>
</template>

<script setup>
import { defineProps, defineEmits, defineExpose, computed ,ref} from 'vue';
import { LeftOutlined, RightOutlined } from '@ant-design/icons-vue';

const props = defineProps({
  messages: {
    type: Array,
    default: () => [],
  },
  currentMessageIndex: {
    type: Number,
    default: 0
  }
});

const emit = defineEmits(['update:currentMessageIndex','changeChat']);

const localCurrentMessageIndex = computed({
  get: () => props.currentMessageIndex,
  set: (val) => emit('update:currentMessageIndex', val)
});

const canBeRight = computed (() => {
  return localCurrentMessageIndex.value < props.messages.length - 1;
})
const canBeLeft = computed(() => {
  return localCurrentMessageIndex.value > 0;
})


//ç‚¹å‡»äº‹ä»¶
const leftClick = (index) => {
  //è°ƒç”¨æ¥å£ changeChat
  emit('changeChat',localCurrentMessageIndex.value - 1 )
  emit('update:currentMessageIndex',localCurrentMessageIndex.value - 1)
}

const rightClick = (index) => {
    //è°ƒç”¨æ¥å£ changeChat
    emit('changeChat',localCurrentMessageIndex.value + 1)
    emit('update:currentMessageIndex',localCurrentMessageIndex.value + 1)
}

defineExpose({ currentMessageIndex: localCurrentMessageIndex });
</script>

<style scoped>
.change-btn {
  cursor: pointer;
  font-size: 16px;
  color: #1e1e1e;
}

.message-nav {
  display: flex;
  align-items: center;
  gap: 4px;
}
.enabled{
  cursor: pointer;
  color: #1e1e1e;
  font-size: 16px;

}
.disabled{
  cursor: not-allowed;
  color: #d9d9d9;
  font-size: 16px;
}

</style>


================================================
FILE: frontend/src/components/menu/TaskIcon.vue
================================================
<template>
  <div class="icon-container" :class="props.class" @click="handleClick">
    <a-tooltip v-if="props.showIcon" :arrow="false" placement="right">
      <template #title>{{ props.name }}</template>
      <div style="    height: 20px;width: 20px;" >
        <component :is="props.icon" v-bind="$attrs" :style="{
          width: props.width ? `${props.width}px` : undefined,
          height: props.height ? `${props.height}px` : undefined
        }" />
      </div>
    </a-tooltip>


    <div v-else class="name-container">
      <span>
        {{ props.name }}
      </span>
    </div>
  </div>
</template>

<script setup>
import { ref, watch, onMounted } from 'vue'

const props = defineProps({
  icon: {
    type: Object,
    required: true
  },
  name: {
    type: String,
    required: true
  },
  showIcon: {
    type: Boolean,
    required: false,
    default: true
  },
  width: {
    type: Number,
    default: undefined
  },
  height: {
    type: Number,
    default: undefined
  },
  click: {
    type: Function,
    default: () => { }
  },
  clickParams: {
    type: [Object, Array, String, Number, Boolean, null],
    default: undefined
  },
  class: {
    type: [String, Object, Array],
    default: ''
  }
})
const emit = defineEmits(['click'])

const handleClick = (event) => {
  if (props.click) {
    // if clickParams exist then pass clickParams to click function
    if (props.clickParams !== undefined) {
      props.click(props.clickParams)
      emit('click', event, props.clickParams)
    } else {
      props.click(event)
      emit('click', event)
    }
  }
}
</script>

<style scoped>
.icon-container {
  display: inline-flex;
  align-items: center;
  cursor: pointer;
  /* å½“æœ‰ click äº‹ä»¶æ—¶æç¤ºå¯ç‚¹å‡» */
  border-radius: 10px;
  box-sizing: border-box;
  padding: 6px;
  width: 32px;
  height: 32px;
}

.name-container {
  display: inline-block;
  text-align: start !important;
  color: #333;
  /* é»˜è®¤é¢œè‰² */
  font-size: 16px;
  font-style: normal;
  font-weight: 500;
  align-content: center;
  align-items: center;
  justify-content: start !important;
  justify-items: start !important;
  margin-left: 10px;
}
</style>


================================================
FILE: frontend/src/components/menu/User.vue
================================================
<template>
  <div class="sidebar-footer">
    <div class="user-profile">
      <div class="avatar">
        <User />
      </div>
      <div class="user-name">{{ user.user_name || user.mobile || user.user_email }}</div>
      <div class="opDiv"><!-- v-if="opShow" -->
        <UserProFile />
      </div>
    </div>
    <!-- current version -->
    <div class="version-info" @click="handleVersionInfo">
      V {{ versionInfo.localVersion }}
    </div>
  </div>
</template>

<script setup>
import { ref, computed, onMounted, nextTick } from 'vue'
import { useRoute, useRouter } from 'vue-router'
import service from '@/services/default-model-setting'
import userService from '@/services/auth'
import { useI18n } from 'vue-i18n'

import User from '@/assets/sidebar/user.svg'
import { useUserStore } from '@/store/modules/user.js'
let { user, membership, points } = useUserStore();
import versionService from '@/services/version';

const router = useRouter();
const opShow = ref(true);

const { t } = useI18n()
import UserProFile from '@/view/auth/components/user-profile.vue'
const delay = ms => new Promise(resolve => setTimeout(resolve, ms));
//checkModel

//æ£€æŸ¥æ˜¯å¦é…ç½®æ¨¡å‹
// async function checkModel() {
//   //åˆ¤æ–­æœ‰æ²¡æœ‰ localStorage.setItem('tour_end', 'true');
//   if (localStorage.getItem('tour_end') == 'true') {
//     localStorage.setItem('tour', 'false');
//     return;
//   }
//   let res = await service.checkModel();
//   if (res.has_default_platform && res.has_enabled_platform && res.has_search_setting) {
//     localStorage.setItem('tour', 'false');
//   } else {
//     localStorage.setItem('tour', 'true');
//     tour();
//   }
// }
const isLogin = computed(() => {
  //åˆ¤æ–­æ˜¯å¦å­˜åœ¨ç”¨æˆ·ID user
  if (user.id) {
    return true;
  }
  return false;
});

const handleVersionInfo = () => {
  //https://github.com/hexdocom/lemonai/releases
  window.open("https://github.com/hexdocom/lemonai/releases", '_blank');
}

//è·å–ç”¨æˆ·ä¿¡æ¯ getUserInfo
async function getUserInfo() {
  //åˆ¤æ–­æœ‰æ²¡æœ‰ç™»å½•
  if (!isLogin.value) {
    return;
  }
  let res = await userService.getUserInfo();
  //è®¾ç½®ç¼“å­˜
  membership = res.membership;
  points = res.points;
}

const versionInfo = ref({
  localVersion: '...',
  latestVersion: '0.0.0',
  isLatest: true,
  updateUrl: 'https://github.com/yu-mengyun/vue-admin-template',
  message: 'the current version is the latest version',
});

onMounted(() => {
  nextTick(() => {
    // checkModel();
    getUserInfo();
    versionService.getVersionInfo().then((res) => {
      console.log(res);
      versionInfo.value = res;
    });
  });
});
</script>

<style lang="scss" scoped>
.opDiv {
  position: absolute;
  background: #fff;
  display: none;
  z-index: 9999;
  border-radius: 6px;
  box-shadow: 0 4px 12px 0 rgba(0, 0, 0, .08), 0 8px 24px 0 rgba(0, 0, 0, .04);
  bottom: 35px;
  left: 16px;
  font-size: 12px;
  width: 298px;
  padding: 10px 16px;

  div {
    border-radius: 6px;
  }

  span {
    margin-right: 8px;
  }

  img {
    margin-right: 5px;
  }
}

.user-profile {
  display: flex;
  align-items: center;
  cursor: pointer;
  gap: 8px;

  &:hover {
    .opDiv {
      display: block;
    }
  }
}

.avatar {
  width: 24px;
  height: 24px;
  border-radius: 50%;
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
  font-size: 14px;

  img {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    object-fit: cover;
  }
}

.footer-actions {
  display: flex;
  gap: 12px;
  width: 100%;
  justify-content: space-between;
}

.version-info {
  font-size: 12px;
  color: #666;
  margin-left: 10px;
  padding: 2px 4px;
  cursor: pointer;

  &:hover {
    color: #333;
    background-color: #fff;
    border-radius: 99999px;

  }
}

.footer-button {
  background: none;
  border: none;
  cursor: pointer;
  color: #666;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 32px;
  height: 32px;
  border-radius: 8px;

  &:hover {
    background-color: #f5f5f5;
    color: #333;
  }
}

.login {
  border: 1px solid #666;
  background: unset;
  font-size: 14px;
  border-radius: 20px;
  height: 32px;
  cursor: pointer;
  min-width: 64px
}
</style>


================================================
FILE: frontend/src/components/MessageFileList/index.vue
================================================
<template>
 
  <div class="file-list" v-if="list.length > 0">
    <div class="file-item" v-for="(file, index) in displayedFiles" :key="index" @click="handleOpenFile(file)" :title="file.filename.split('\\').pop()">
      <div class="file-icon">
        <fileSvg :url="file?.filename" :filepath="file.filepath" />
      </div>
      <div class="file-info">
        <div class="file-name">{{ file.filename.split("\\").pop() }}</div>
        <div class="file-meta">
          <span class="file-type">{{ getFileType(file.filename) }}</span>
          <span class="file-size" v-if="file.filesize && file.filesize>0">{{ formatFileSize(file.filesize) }}</span>
        </div>
      </div>
    </div>
    <div class="view-all-item" v-if="list.length - displayedFiles.length > 0 && action_type === 'finish_summery'" @click="handleViewAllFiles">
      <div class="file-icon">
        <FileSearchOutlined />
      </div>
      <div class="file-name">view all files in this task</div>
    </div>
  </div>
  <imgModal :url="imageUrl" v-model:visible="isModalVisible" @close="isModalVisible = false" />
</template>
<script setup>
import { computed, ref } from "vue";
import fileSvg from "@/components/fileClass/fileSvg.vue";
import emitter from "@/utils/emitter";
import imgModal from "@/components/file/imgModal.vue";
import fileUtil from "@/utils/file";
import workspaceService from "@/services/workspace";
import { FileSearchOutlined } from "@ant-design/icons-vue";

import { storeToRefs } from "pinia";

import { useChatStore } from "@/store/modules/chat";
const chatStore = useChatStore();
const { messages } = storeToRefs(chatStore);

const props = defineProps({
  message: {
    type: Array,
    default: () => [],
  },
  role: {
    type: String,
    default: "assistant",
  },
  action_type: {
    type: String,
    default: "finish_summery",
  },
});

const isModalVisible = ref(false);
const imageUrl = ref("");
const list = computed(() => {
  const json = props?.message?.meta?.json;
  if (!json) return [];
  let files = JSON.parse(JSON.stringify(json));
  if (files && Array.isArray(files)) {
    for (const file of files) {
      if (file.filepath) {
        file.filename = file.filepath.split("/").pop(); // ä»è·¯å¾„ä¸­å–æ–‡ä»¶å
      } else {
        file.filename = file.name || ""; // æ²¡æœ‰ name çš„è¯å°±è®¾ä¸ºç©ºå­—ç¬¦ä¸²
      }
    }
    return files;
  }
  return files;
});

const displayedFiles = computed(() => {
  const types = new Set(["finish_summery", "question", "progress"]);
  if (types.has(props.action_type)) {
    const currentMessageIndex = messages.value.findIndex((msg) => msg.id === props.message.id);

    let filteredFiles = [];
    let planMessage = null;

    if (currentMessageIndex !== -1) {
      // ä»å½“å‰æ¶ˆæ¯å¾€å‰æŸ¥æ‰¾æœ€è¿‘çš„ä¸€æ¡ action_type ä¸º 'plan' çš„æ•°æ®
      for (let i = currentMessageIndex - 1; i >= 0; i--) {
        const message = messages.value[i];
        if (message.meta && message.meta.action_type === "plan") {
          planMessage = message;
          console.log("æ‰¾åˆ°æœ€è¿‘çš„planæ•°æ®:", message);
          break;
        }
      }
    }

    // å¤„ç†æ–‡ä»¶è¿‡æ»¤é€»è¾‘
    if (planMessage && planMessage.meta && planMessage.meta.json) {
      try {
        let planData;
        if (typeof planMessage.meta.json === "string") {
          planData = JSON.parse(planMessage.meta.json);
        } else if (typeof planMessage.meta.json === "object") {
          planData = planMessage.meta.json;
        } else {
          throw new Error("Unsupported json data type");
        }

        const lastPlan = planData[planData.length - 1]; // è·å–æœ€åä¸€æ¡æ•°æ®

        console.log("lastPlan:", lastPlan);

        if (lastPlan && lastPlan.actions && Array.isArray(lastPlan.actions)) {
          // åˆå¹¶æ‰€æœ‰ actions çš„ content å†…å®¹
          const allContent = lastPlan.actions.map((action) => action.content || "").join(" ");
          console.log("æ‰€æœ‰actionsçš„contentå†…å®¹:", allContent);

          // è¿‡æ»¤æ–‡ä»¶ï¼šæ–‡ä»¶åå‡ºç°åœ¨actionsçš„contentä¸­
          filteredFiles = list.value.filter((file) => {
            const fileName = file.filename || "";
            const isMatched = allContent.includes(fileName) && fileName.toLowerCase() !== "todo.md";
            console.log(`æ–‡ä»¶ ${fileName} æ˜¯å¦åŒ¹é…:`, isMatched);
            return isMatched;
          });

          console.log("è¿‡æ»¤åçš„æ–‡ä»¶:", filteredFiles);
        }
      } catch (error) {
        console.error("è§£æplanæ•°æ®å‡ºé”™:", error);
      }
    }
    if (filteredFiles.length === 0) {
      // å¦‚æœæ²¡æœ‰è¿‡æ»¤çš„æ–‡ä»¶åˆ™è¿”å›é»˜è®¤çš„å‰3ä¸ª
      filteredFiles = list.value.filter((file) => {
        const fileName = file.filename || "";
        return fileName.toLowerCase() !== "todo.md";
      });
    }

    // å¦‚æœæœ‰è¿‡æ»¤çš„æ–‡ä»¶åˆ™è¿”å›è¿‡æ»¤åçš„ï¼Œå¦åˆ™è¿”å›é»˜è®¤çš„å‰3ä¸ª
    return filteredFiles.length > 0 ? filteredFiles : list.value.slice(0, 3);
  }
  return list.value;
});

// æ‰“å¼€æ–‡ä»¶
const handleOpenFile = (file) => {
  console.log("handleOpenFile", file, file.filepath);
  if (fileUtil.imgType.includes(file.filepath.split(".").pop())) {
    workspaceService.getFile(file.filepath).then((res) => {
      imageUrl.value = URL.createObjectURL(res);
    });
    isModalVisible.value = true;
  } else {
    emitter.emit("fullPreviewVisable", file);
  }
};

// æŸ¥çœ‹æ‰€æœ‰æ–‡ä»¶
const handleViewAllFiles = () => {
  // è¿™é‡Œå¯ä»¥è§¦å‘ä¸€ä¸ªäº‹ä»¶æˆ–è€…æ‰“å¼€ä¸€ä¸ªæ¨¡æ€æ¡†æ¥æ˜¾ç¤ºæ‰€æœ‰æ–‡ä»¶
  emitter.emit("file-explorer-visible", true);
};

// è·å–æ–‡ä»¶ç±»å‹
const getFileType = (filename) => {
  if (!filename) return '';
  
  const extension = filename.split('.').pop()?.toLowerCase();
  
  const typeMap = {
    'md': 'Markdown',
    'txt': 'Text',
    'pdf': 'PDF',
    'doc': 'Word',
    'docx': 'Word',
    'xls': 'Excel',
    'xlsx': 'Excel',
    'ppt': 'PowerPoint',
    'pptx': 'PowerPoint',
    'jpg': 'Image',
    'jpeg': 'Image',
    'png': 'Image',
    'gif': 'Image',
    'svg': 'Image',
    'mp4': 'Video',
    'avi': 'Video',
    'mov': 'Video',
    'mp3': 'Audio',
    'wav': 'Audio',
    'zip': 'Archive',
    'rar': 'Archive',
    '7z': 'Archive',
    'js': 'JavaScript',
    'ts': 'TypeScript',
    'html': 'HTML',
    'css': 'CSS',
    'json': 'JSON',
    'xml': 'XML',
    'py': 'Python',
    'java': 'Java',
    'cpp': 'C++',
    'c': 'C',
    'php': 'PHP',
    'rb': 'Ruby',
    'go': 'Go',
    'rs': 'Rust',
    'sql': 'SQL'
  };
  
  return typeMap[extension] || extension?.toUpperCase() || 'File';
};

// æ ¼å¼åŒ–æ–‡ä»¶å¤§å°
const formatFileSize = (bytes) => {
  if (!bytes || bytes === 0) return '0 B';
  
  const sizes = ['B', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(1024));
  
  if (i === 0) return bytes + ' B';
  
  return (bytes / Math.pow(1024, i)).toFixed(1) + ' ' + sizes[i];
};
</script>
<style scoped>
.file-list {
  flex-wrap: wrap;
  margin-top: 16px;
  display: grid;
  gap: 5px;
  grid-template-columns: repeat(2, 1fr);
  max-width: 100%;
  overflow: hidden;
}
.file-list > :only-child {
  grid-column: 1 / -1;
}

.file-item {
  display: flex;
  padding: 0.5rem;
  background-color: #FFF;
  border: 1px solid rgba(0, 0, 0, 0.12);
  border-radius: 10px;
  gap: 0.375rem;
  align-items: center;
  cursor: pointer;
  line-height: 24px;
  min-width: 0;
  max-width: 100%;

  .file-info {
    min-width: 0;
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 2px;
  }

  .file-name {
    word-wrap: break-word;
    word-break: break-word;
    overflow-wrap: break-word;
    line-height: 1.4;
    min-width: 0;
    font-size: 14px;
  }

  .file-meta {
    display: flex;
    gap: 8px;
    font-size: 12px;
    color: #7F7F7F;
    line-height: 1rem;
    
    .file-type,
    .file-size {
      white-space: nowrap;
    }
  }
}

.view-all-item {
  display: flex;
  padding: 0.5rem;
  background-color: #FFF;
  border: 1px solid rgba(0, 0, 0, 0.12);
  border-radius: 10px;
  gap: 0.375rem;
  justify-content: center;
  align-items: center;
  cursor: pointer;
  line-height: 24px;
  min-height: 55px;
}
</style>



================================================
FILE: frontend/src/components/office/docxPreview.vue
================================================
<template>
    <div class="docx-viewer">
      <div class="docx-content">
        <!-- åŠ è½½çŠ¶æ€ -->
        <div v-if="isLoading" class="loading">loading DOCX...</div>
        <!-- é”™è¯¯æç¤º -->
        <div v-if="error" class="error">{{ error }}</div>
        <!-- æ–‡æ¡£æ¸²æŸ“ -->
        <iframe v-if="!isLoading && !error" ref="docxIframe" class="docx-iframe" :srcdoc="iframeContent"></iframe>
      </div>
    </div>
  </template>
  
  <script setup>
  import { ref, watch, onMounted } from 'vue';
  import mammoth from 'mammoth';
  
  // å®šä¹‰ props
  const props = defineProps({
    docxArrayBuffer: {
      type: [ArrayBuffer, null],
      default: null
    }
  });
  
  // å“åº”å¼å˜é‡
  const isLoading = ref(false);
  const error = ref(null);
  const docxIframe = ref(null);
  const iframeContent = ref('');
  
  // å®šä¹‰ iframe çš„ CSS æ ·å¼ï¼Œä¸ XLSXViewer ä¸€è‡´
  const iframeStyles = `
    <style>
      body {
        font-family: Arial, sans-serif;
        background-color: unset;
      },      
      table {
        width: 100%;
        border-collapse: collapse;
      }
      th, td {
        border: 1px solid #cdcccc;
        padding: 8px;
        text-align: left;
        min-width: 100px;
        white-space: normal;
        word-break: break-all;
      }
      th {
        background-color: #333;
        font-weight: bold;
      }
      td:empty::after {
        content: '-';
        color: #999;
      }
      p {
        margin: 0 0 10px 0;
      }
    </style>
  `;
  
  // è§£æ DOCX æ–‡ä»¶
  const parseDOCX = async (arrayBuffer) => {
    if (!arrayBuffer || !(arrayBuffer instanceof ArrayBuffer) || arrayBuffer.byteLength === 0) {
      error.value = 'Invalid DOCX Data';
      return;
    }
    isLoading.value = true;
    error.value = null;
  
    try {
      const uint8Array = new Uint8Array(arrayBuffer);
      if (!uint8Array.buffer || uint8Array.buffer.byteLength === 0) {
        throw new Error('ArrayBuffer already decorated');
      }
  
      // ä½¿ç”¨ mammoth.js è½¬æ¢ä¸º HTML
      const result = await mammoth.convertToHtml({ arrayBuffer });
      // ç»„åˆ HTML å’Œæ ·å¼
      iframeContent.value = `
        <!DOCTYPE html>
        <html>
        <head>
          ${iframeStyles}
        </head>
        <body>
          ${result.value}
        </body>
        </html>
      `;
  
      isLoading.value = false;
    } catch (err) {
      isLoading.value = false;
      error.value = `Error DOCX: ${err.message}`;
      console.error('DOCX error:', err);
    }
  };
  
  // ç›‘å¬ docxArrayBuffer å˜åŒ–
  watch(() => props.docxArrayBuffer, (newBuffer) => {
    if (newBuffer) {
      parseDOCX(newBuffer);
    }
  });
  
  // ç»„ä»¶æŒ‚è½½æ—¶è§£æ
  onMounted(() => {
    if (props.docxArrayBuffer) {
      parseDOCX(props.docxArrayBuffer);
    }
  });
  </script>
  
  <style scoped>
  .docx-viewer {
    height: 100%;
    width: 100%;
    margin: 0 auto;
    padding: 0;
  }
    
  .docx-content {
    height: 100%;
  }
  
  .docx-iframe {
    width: 100%;
    height: 100%;
    border: 1px solid #cdcccc; /* ä¸ XLSXViewer ä¸€è‡´çš„è¾¹æ¡† */
    background-color: #fff;
    border-radius: 4px;
  }
  
  .loading {
    text-align: center;
    padding: 20px;
    font-size: 16px;
    color: #666;
  }
  
  .error {
    text-align: center;
    padding: 20px;
    color: #d32f2f;
    font-size: 14px;
  }
  </style>


================================================
FILE: frontend/src/components/office/pdfPreview.vue
================================================
<template>
    <div class="pdf-viewer">
        <iframe v-if="pdfUrl" :src="pdfUrl" width="100%" height="100%" style="border-radius: 10px;"></iframe>
        <div v-if="error" class="error">{{ error }}</div>
    </div>
</template>

<script setup>
import { ref, watch, onMounted, onUnmounted } from 'vue';

const props = defineProps({
    pdfArrayBuffer: { type: [ArrayBuffer, null], default: null }
});

const pdfUrl = ref(null);
const error = ref(null);

const loadPDF = (arrayBuffer) => {
    if (!arrayBuffer || !(arrayBuffer instanceof ArrayBuffer) || arrayBuffer.byteLength === 0) {
        error.value = 'invalid PDF data';
        return;
    }
    try {
        const blob = new Blob([arrayBuffer], { type: 'application/pdf' });
        pdfUrl.value = URL.createObjectURL(blob);
    } catch (err) {
        error.value = `load PDF failed: ${err.message}`;
    }
};

watch(() => props.pdfArrayBuffer, (newBuffer) => {
    if (newBuffer) {
        loadPDF(newBuffer);
    }
});

onMounted(() => {
    if (props.pdfArrayBuffer) {
        loadPDF(props.pdfArrayBuffer);
    }
});

onUnmounted(() => {
    if (pdfUrl.value) {
        URL.revokeObjectURL(pdfUrl.value);
    }
});
</script>

<style scoped>
.pdf-viewer {
    height: 100%;
    width: 100%;
    margin: 0 auto;
}

.pdf-header {
    margin-bottom: 10px;
}

.error {
    text-align: center;
    padding: 20px;
    color: #d32f2f;
    font-size: 14px;
}
</style>


================================================
FILE: frontend/src/components/office/xlsxPreview.vue
================================================
<template>
  <div class="xlsx-viewer">
    <div class="xlsx-content">
      <!-- åŠ è½½çŠ¶æ€ -->
      <div v-if="isLoading" class="loading">Loading XLSX...</div>
      <!-- é”™è¯¯æç¤º -->
      <div v-if="error" class="error">{{ error }}</div>
      <!-- è¡¨æ ¼æ¸²æŸ“ -->
      <div v-if="tableData.length" class="table-container">
        <table class="xlsx-table">
          <thead>
            <tr>
              <th v-for="(header, index) in tableData[0]" :key="index">{{ header || 'column' + (index + 1) }}</th>
            </tr>
          </thead>
          <tbody>
            <tr v-for="(row, rowIndex) in tableData.slice(1)" :key="rowIndex">
              <td v-for="(cell, cellIndex) in row" :key="cellIndex">{{ cell ?? '-' }}</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, watch, onMounted } from 'vue';
import * as XLSX from 'xlsx';

// å®šä¹‰ props
const props = defineProps({
  xlsxArrayBuffer: {
    type: [ArrayBuffer, null],
    default: null
  }
});

// å“åº”å¼å˜é‡
const isLoading = ref(false);
const error = ref(null);
const tableData = ref([]);

// è§£æ XLSX æ–‡ä»¶
const parseXLSX = async (arrayBuffer) => {
  if (!arrayBuffer || !(arrayBuffer instanceof ArrayBuffer) || arrayBuffer.byteLength === 0) {
    error.value = 'InValid XLSX data';
    return;
  }
  isLoading.value = true;
  error.value = null;

  try {
    const uint8Array = new Uint8Array(arrayBuffer);
    if (!uint8Array.buffer || uint8Array.buffer.byteLength === 0) {
      throw new Error('ArrayBuffer already disposed');
    }

    // è§£æ XLSX
    const workbook = XLSX.read(uint8Array, { type: 'array', defval: '' });
    const firstSheetName = workbook.SheetNames[0];
    const worksheet = workbook.Sheets[firstSheetName];

    // è½¬æ¢ä¸º JSON æ•°æ®ï¼Œè®¾ç½® defval ç¡®ä¿ç©ºå€¼ä¸ºç©ºå­—ç¬¦ä¸²
    const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: '' });
    tableData.value = jsonData;

    isLoading.value = false;
  } catch (err) {
    isLoading.value = false;
    error.value = `Error XLSX: ${err.message}`;
    console.error('XLSX Error:', err);
  }
};

// ç›‘å¬ xlsxArrayBuffer å˜åŒ–
watch(() => props.xlsxArrayBuffer, (newBuffer) => {
  if (newBuffer) {
    parseXLSX(newBuffer);
  }
});

// ç»„ä»¶æŒ‚è½½æ—¶è§£æ
onMounted(() => {
  if (props.xlsxArrayBuffer) {
    parseXLSX(props.xlsxArrayBuffer);
  }
});
</script>

<style scoped>
.xlsx-viewer {
  height: 100%;
  width: 100%;
  margin: 0 auto;
  padding: 0;
}

.table-container {
  max-height: 100%;
  overflow: auto;
}

.xlsx-table {
  width: 100%;
  border-collapse: collapse;
  /* ç§»é™¤ table-layout: fixedï¼Œå…è®¸è‡ªé€‚åº”å®½åº¦ */
}

.xlsx-table th,
.xlsx-table td {
  border: 1px solid #9e9e9e; /* ç¡®ä¿è¾¹æ¡† */
  padding: 8px;
  text-align: left;
  min-width: 30px; /* æœ€å°å®½åº¦ */
  white-space: normal; /* å…è®¸æ¢è¡Œ */
  word-break: break-all; /* é•¿æ–‡æœ¬è‡ªåŠ¨æ¢è¡Œ */
  /* å¯é€‰ï¼šé™åˆ¶æœ€å¤§å®½åº¦ï¼Œè¶…å‡ºæ˜¾ç¤ºçœç•¥å· */
  /* max-width: 200px; */
  /* overflow: hidden; */
  /* text-overflow: ellipsis; */
}

.xlsx-table th {
  background-color: #d4d4d4;
  font-weight: bold;
  position: sticky;
  top: 0;
  z-index: 1;
}

.xlsx-table td:empty::after {
  content: ''; /* ç©ºå•å…ƒæ ¼å ä½ç¬¦ */
  color: #999;
}

.loading {
  text-align: center;
  padding: 20px;
  font-size: 16px;
  color: #666;
}

.error {
  text-align: center;
  padding: 20px;
  color: #d32f2f;
  font-size: 14px;
}
</style>


================================================
FILE: frontend/src/components/platforms/addPlatform.vue
================================================
<template>
  <a-modal
    v-model:open="visible"
    :title="$t('setting.modelService.addProvider')"
    @ok="handleOk"
    @cancel="handleCancel"
    :maskClosable="false"
    :centered="true"
    :okText="$t('setting.modelService.confirm')"
    :cancelText="$t('setting.modelService.cancel')"
  >
    <div class="add-platform-form">
      <div class="platform-logo-upload" @click="triggerFileInput">
        <div v-if="!formData.logo_url" class="platform-letter" :style="{ backgroundColor: defaultColor }">
          P
        </div>
        <img v-else :src="formData.logo_url" :alt="$t('setting.modelService.platformLogo')" class="platform-logo" />
        <input
          type="file"
          ref="fileInput"
          style="display: none"
          accept="image/*"
          @change="handleFileChange"
        />
      </div>
      <a-form :model="formData" :rules="rules" ref="formRef">
        <a-form-item :label="$t('setting.modelService.providerName')" name="name">
          <a-input v-model:value="formData.name" :placeholder="$t('setting.modelService.namePlaceholder')" />
        </a-form-item>
        
        <a-form-item :label="$t('setting.modelService.providerType')" name="type" style="margin-left: 10px;">
          <a-select v-model:value="formData.provider_type" :placeholder="$t('setting.modelService.typePlaceholder')">
            <a-select-option value="openai">OpenAI</a-select-option>
            <!-- only support OpenAI -->
            <!-- <a-select-option value="gemini">Gemini</a-select-option>
            <a-select-option value="anthropic">Anthropic</a-select-option>
            <a-select-option value="azure">Azure OpenAI</a-select-option> -->
          </a-select>
        </a-form-item>
      </a-form>
    </div>
  </a-modal>
</template>

<script setup>
import { ref, defineEmits } from 'vue'
import { useI18n } from 'vue-i18n'
import service from '@/services/platforms'
import { message } from 'ant-design-vue'
import emitter from '@/utils/emitter'

const { t } = useI18n()
const emit = defineEmits(['add-platform'])
const visible = ref(false)
const fileInput = ref(null)
const formRef = ref(null)
const defaultColor = '#4ECDC4'

const formData = ref({
  name: '',
  provider_type: 'OpenAI',
  logo_url: '',
  source_type: 'user',
})

const rules = {
  name: [
    { required: true, message: t('setting.modelService.enterName'), trigger: 'blur' }
  ],
  provider_type: [
    { required: true, message: t('setting.modelService.selectType'), trigger: 'change' }
  ]
}

const triggerFileInput = () => {
  fileInput.value.click()
}

const handleFileChange = async (e) => {
  const file = e.target.files[0];
  if (file) {
    // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦ä¸ºå›¾ç‰‡æ ¼å¼
    const validImageTypes = ['image/png', 'image/jpeg', 'image/gif', 'image/webp'];
    if (!validImageTypes.includes(file.type)) {
      console.error('Invalid file type. Please select an image (PNG, JPEG, GIF, or WebP).');
      return;
    }

    // ä½¿ç”¨ Promise åŒ…è£… FileReader
    const loadImage = () => {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
          resolve(e.target.result);
        };
        reader.onerror = (error) => {
          reject(error);
        };
        reader.readAsDataURL(file);
      });
    };

    try {
      // 
      const result = await loadImage();
      formData.value.logo_url = result;

      // print
      // console.log('Selected file:', file);
      // console.log('Form data:', formData.value);
    } catch (error) {
      // console.error('Error loading image:', error);
    }
  }
};

const handleOk = async () => {
  try {
    // await formRef.value.validate()
    service.insertPlatform(formData.value).then((res) => {
      // console.log(res)
      if(res.id !== undefined){
        message.success(t('setting.modelService.addPlatformSuccess'))
        emit('add-platform', res)
        emitter.emit('fresh-pages')
      }else{
        message.error(t('setting.modelService.addPlatformFailed'))
      }
      
    })
    visible.value = false
    resetForm()
  } catch (error) {
    console.error('Form validation failed:', error)
    message.error(t('setting.modelService.formValidationFailed'))
  }
}

const handleCancel = () => {
  visible.value = false
  resetForm()
}

const resetForm = () => {
  formData.value = {
    name: '',
    provider_type: 'OpenAI',
    logo_url: '',
    source_type: 'user'
  }
  
  formRef.value?.resetFields()
}

const showModal = () => {
  visible.value = true
}

defineExpose({
  showModal
})
</script>

<style scoped>
.add-platform-form {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 20px;
}

.platform-logo-upload {
  width: 80px;
  height: 80px;
  border-radius: 8px;
  margin-bottom: 24px;
  cursor: pointer;
  overflow: hidden;
  display: flex;
  align-items: center;
  justify-content: center;
  border: 2px dashed #d9d9d9;
}

.platform-logo-upload:hover {
  border-color: #40a9ff;
}

.platform-letter {
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  font-size: 32px;
  font-weight: bold;
}

.platform-logo {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

:deep(.ant-form) {
  width: 100%;
}

:deep(.ant-form-item) {
  margin-bottom: 16px;
}


@media screen and (max-width: 768px) {
  .ant-form-item {
    div{
      margin-left: 0px!important;
    }
  }
}
</style>


================================================
FILE: frontend/src/components/platforms/modelinfo.vue
================================================
<template>
  <a-modal
    v-model:open="visible"
    :title="isEdit ? $t('setting.modelService.editModel') : $t('setting.modelService.addModel')"
    @ok="handleOk"
    @cancel="handleCancel"
    :maskClosable="false"
    :centered="true"
    :okText="$t('setting.modelService.confirm')"
    :cancelText="$t('setting.modelService.cancel')"
  >
    <div class="model-form">
      <a-form :model="formData" :rules="rules" ref="formRef">
        <a-form-item :label="$t('setting.modelService.modelId')" name="model_id" style="display: flex; justify-content: end">
          <a-input 
            v-model:value="formData.model_id" 
            :placeholder="$t('setting.modelService.modelIdPlaceholder')" 
            :disabled="isEdit"
          />
        </a-form-item>
        
        <a-form-item :label="$t('setting.modelService.modelName')" name="model_name">
          <a-input v-model:value="formData.model_name" :placeholder="$t('setting.modelService.modelNamePlaceholder')" />
        </a-form-item>

        <a-form-item :label="$t('setting.modelService.groupName')" name="group_name">
          <a-input v-model:value="formData.group_name" :placeholder="$t('setting.modelService.groupNamePlaceholder')" />
        </a-form-item>

        <div class="more-options">
          <a @click="toggleModelTypes" class="toggle-link">
            {{ showModelTypes ? $t('setting.modelService.hideOptions') : $t('setting.modelService.showMoreOptions') }}
          </a>
        </div>

        <a-form-item
          v-if="showModelTypes"
          :label="$t('setting.modelService.modelTypes')"
          name="model_types"
          class="model-types-item"
        >
          <a-checkbox-group v-model:value="formData.model_types" class="model-type-group">
            <a-checkbox class="checkbox-item" value="vision">
              {{ $t('setting.modelService.typeVision') }}
            </a-checkbox>
            <a-checkbox class="checkbox-item" value="network">
              {{ $t('setting.modelService.typeNetwork') }}
            </a-checkbox>
            <a-checkbox class="checkbox-item" value="embed">
              {{ $t('setting.modelService.typeEmbed') }}
            </a-checkbox>
            <a-checkbox class="checkbox-item" value="tool">
              {{ $t('setting.modelService.typeTool') }}
            </a-checkbox>
            <a-checkbox class="checkbox-item" value="reasoning">
              {{ $t('setting.modelService.typeReasoning') }}
            </a-checkbox>
          </a-checkbox-group>
        </a-form-item>
      </a-form>
    </div>
  </a-modal>
</template>

<script setup>
import { ref, defineProps } from 'vue'
import { useI18n } from 'vue-i18n'
import service from '@/services/platforms'
import { message } from 'ant-design-vue'
import emitter from '@/utils/emitter'

const { t } = useI18n()
const visible = ref(false)
const formRef = ref(null)
const isEdit = ref(false)
const showModelTypes = ref(false) // æ§åˆ¶ model_types æ˜¾ç¤º/éšè—

const props = defineProps({
  platform_id: {
    type: Number,
    default: -1
  }
})

const formData = ref({
  model_id: '',
  model_name: '',
  group_name: '',
  model_types: [],
  platform_id: -1,
  logo_url: ''
})

const rules = {
  model_id: [
    { required: true, message: t('setting.modelService.enterModelId'), trigger: 'blur' }
  ],
  model_name: [
    { required: false, message: t('setting.modelService.enterModelName'), trigger: 'blur' }
  ],
  group_name: [
    { required: false, message: t('setting.modelService.enterGroupName'), trigger: 'blur' }
  ],
  model_types: [
    {
      required: false,
      type: 'array',
      message: t('setting.modelService.selectModelType'),
      trigger: 'change',
      // validator: (_, value) => {
      //   if (!showModelTypes.value) return Promise.resolve(); // è·³è¿‡éšè—æ—¶çš„éªŒè¯
      //   return value && value.length > 0 ? Promise.resolve() : Promise.reject();
      // }
    }
  ]
}

const handleOk = async () => {
  try {
    await formRef.value.validate()
    if (isEdit.value) {
      await service.updateModel(formData.value)
      emitter.emit('fresh-models', true)
      message.success(t('setting.modelService.updateModelSuccess'))
    } else {
      formData.value.platform_id = props.platform_id
      const res = await service.insertModel(formData.value)
      // console.log(res)
      // Model already exists
      if(res.code === 1){
        message.error(t('setting.modelService.modelAlreadyExists'))
        return
      }
      emitter.emit('fresh-models', res)
      message.success(t('setting.modelService.addModelSuccess'))
    }
    visible.value = false
    resetForm()
  } catch (error) {
    console.error('Form validation failed:', error)
    message.error(t('setting.modelService.formValidationFailed'))
  }
}

const handleCancel = () => {
  visible.value = false
  resetForm()
}

const resetForm = () => {
  formData.value = {
    model_id: '',
    model_name: '',
    group_name: '',
    model_types: [],
    platform_id: props.platform_id,
    logo_url: ''
  }
  showModelTypes.value = false // é‡ç½®æ—¶éšè— model_types
  formRef.value?.resetFields()
}

const showModal = (model = null) => {
  if (model) {
    isEdit.value = true
    formData.value = {
      ...model,
      model_name: model.model_name || '',
      model_types: model.model_types || [],
      platform_id: model.platform_id || props.platform_id,
    }
  } else {
    isEdit.value = false
    resetForm()
  }
  visible.value = true
}

const toggleModelTypes = () => {
  showModelTypes.value = !showModelTypes.value
}

defineExpose({
  showModal
})
</script>

<style scoped>
.model-form {
  padding: 6px;
}

:deep(.ant-form-item) {
  margin-bottom: 16px;
}

.model-type-group {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(70px, 1fr));
  gap: 8px; /* é—´è·ç¼©å° */
  width: 100%;
}

.checkbox-item {
  display: flex;
  align-items: center;
  padding: 4px 2px; /* å‡å°å†…è¾¹è· */
  border-radius: 4px;
  transition: background-color 0.2s;
}

.checkbox-item:hover {
  background-color: #f5f5f5;
}

:deep(.ant-checkbox-wrapper) {
  margin: 0;
}

:deep(.ant-checkbox-checked .ant-checkbox-inner) {
  background-color: #1890ff;
  border-color: #1890ff;
}

.model-types-item {
  align-items: start;
}

.more-options {
  margin-bottom: 16px;
}

.toggle-link {
  color: #9f9f9f;
  cursor: pointer;
  font-size: 14px;
  transition: color 0.2s;
}

.toggle-link:hover {
  color: #40a9ff;
}
</style>


================================================
FILE: frontend/src/components/platforms/modelsList.vue
================================================
<template>
  <div class="platform-model-container">
    <div class="model-header">
      <span>{{ $t('setting.modelService.models') }}</span>
    </div>
    <div class="models-list">
      <div v-for="group in groupedModels" :key="group.name" class="model-group">
        <div class="group-header" @click="toggleGroup(group.name)">
          <span class="group-toggle">
            <DownOutlined v-if="groupStates[group.name]"/>
            <RightOutlined v-else/>
          </span>
          <span class="group-name">{{ group.name }}</span>
        </div>
        <div class="model-items" :class="{ 'collapsed': !groupStates[group.name] }">
          <div v-for="model in group.models" :key="model.id" class="model-item">
            <div class="model-logo">
              <div v-if="model.logo_url" class="logo-image">
                <img :src="model.logo_url" alt="logo">
              </div>
              <div v-else class="logo-letter" :style="{ backgroundColor: getRandomColor(model.model_id) }">
                {{ model.model_id.charAt(0) }}
              </div>
            </div>
            <div class="model-info">
              <a-popover>
                <template #content>
                  <div
                      style="display: flex; flex-direction: row; justify-items: center; align-items: center; gap: 5px;">
                    <span style="display: flex; justify-content: center; align-content: center;">{{
                        model.model_name
                      }}</span>
                    <component
                        :is="copyState[model.model_id]?.isCopied ? CheckOutlined : SnippetsOutlined"
                        style="align-items: center;"
                        @click="copyModelName(model.model_id, model.model_name)"
                    />
                  </div>
                </template>
                <span class="model-name">{{ model.model_name }}</span>
              </a-popover>

              <div class="model-type" v-for="type in model.model_types" :key="type">
                <a-popover>
                  <template #content>
                    <div style="display: flex; flex-direction: row; justify-items: center; align-items: center;">
                      <span>{{ type }}</span>
                    </div>
                  </template>
                  <component
                      :is="typeIconMap[type]?.component"
                      v-if="typeIconMap[type]"
                      :class="typeIconMap[type]?.class"
                      class="type-icon"
                  />
                </a-popover>
              </div>
            </div>
            <div class="model-actions"  v-if="!is_subscribe">
              <setting-outlined class="action-icon" @click.stop="handleModelSetting(model)"/>
              <minus-outlined class="action-icon" @click.stop="handleModelDelete(model)"/>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="model-more-detail">
      <span>{{ $t('setting.modelService.viewOfficialDocs') }}</span>
    </div>
    <div v-if="!is_subscribe">
      <a-button type="primary" class="addmodel" @click="handleModelSetting()">
        <PlusOutlined/>
        {{ $t('setting.modelService.add') }}
      </a-button>
    </div>
    <!-- é›†æˆ ModelInfo ç»„ä»¶ -->
    <model-info :platform_id="props.platform_id" ref="modelInfoRef"/>
  </div>
</template>

<script setup>
import {computed, ref, h, onMounted} from 'vue';
import {useI18n} from 'vue-i18n';
import {
  SettingOutlined,
  MinusOutlined,
  PlusOutlined,
  DownOutlined,
  RightOutlined,
  SnippetsOutlined,
  CheckOutlined,
  ToolOutlined,
  GlobalOutlined,
  BranchesOutlined,
  CameraOutlined
} from '@ant-design/icons-vue';
import {message} from 'ant-design-vue';
import ModelInfo from '@/components/platforms/modelinfo.vue';
import service from '@/services/platforms';
import emitter from '@/utils/emitter';

const {t} = useI18n();

const props = defineProps({
  models: {
    type: Array,
    default: () => []
  },
  platform_id: {
    type: Number,
    default: -1
  },
  is_subscribe:{
    type: Boolean,
    default: false
  }
});

const emit = defineEmits(['setting', 'delete', 'add-model', 'update-model']);
const groupStates = ref({});
const modelInfoRef = ref(null);
const copyState = ref({}); // å­˜å‚¨æ¯ä¸ª model çš„å¤åˆ¶çŠ¶æ€ï¼Œé”®ä¸º model_id

const groupedModels = computed(() => {
  const groups = {};
  props.models.forEach(model => {
    const groupName = model.group_name || t('setting.modelService.ungrouped');
    if (!groups[groupName]) {
      groups[groupName] = {
        name: groupName,
        models: []
      };
      if (groupStates.value[groupName] === undefined) {
        groupStates.value[groupName] = true;
      }
    }
    groups[groupName].models.push(model);
  });
  return Object.values(groups);
});

const toggleGroup = (groupName) => {
  groupStates.value[groupName] = !groupStates.value[groupName];
};


const modelColors = ref({});
const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEEAD', '#D4A5A5', '#9B59B6', '#3498DB'];

const getRandomColor = (modelId) => {
  if (!modelColors.value[modelId]) {
    const index = Math.abs(modelId.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0)) % colors.length;
    modelColors.value[modelId] = colors[index];
  }
  return modelColors.value[modelId];
};

const handleModelSetting = (model = null) => {
  modelInfoRef.value.showModal(model);
  emit('setting', model);
};

const handleModelDelete = async (model) => {
  try {
    await service.deleteModel(model.id);
    emitter.emit('fresh-models');
    message.success(t('setting.modelService.deleteModelSuccess'));
  } catch (error) {
    console.error('Failed to delete model:', error);
    message.error(t('setting.modelService.deleteModelFailed'));
  }
};

const typeIconMap = {
    ['tool']: {
      component: ToolOutlined,
      class: 'type-tool'
    },
    ['network']: {
      component: GlobalOutlined,
      class: 'type-network'
    },
    ['embed']: {
      component: () => h('div', {}, 'em'),
      class: 'type-embed'
    },
    ['reasoning']: {
      component: BranchesOutlined,
      class: 'type-reasoning'
    },
    ['vision']: {
      component: CameraOutlined,
      class: 'type-vision'
    }
  };

onMounted(() => {
});

const handleAddModel = (response) => {
  // message.success(t('setting.modelService.addModelSuccess'));
  // emit('add-model', response);
};

const handleUpdateModel = (response) => {
  // message.success(t('setting.modelService.updateModelSuccess'));
  emit('update-model', response);
};

const copyModelName = (modelId, modelName) => {
  navigator.clipboard.writeText(modelName).then(() => {
    copyState.value[modelId] = {isCopied: true};
    message.success(t('setting.modelService.copySuccess'));
    setTimeout(() => {
      copyState.value[modelId] = {isCopied: false};
    }, 2000);
  }).catch((err) => {
    console.error('Failed to copy:', err);
    message.error(t('setting.modelService.copyFailed'));
  });
};
</script>

<style scoped>
.model-header {
  margin-top: 20px;
  margin-bottom: 10px;
  display: flex;
  align-items: center;
  font-size: 16px;
  font-weight: 500;
  font-weight: bold;
}

.models-h {
  align-items: center;
  margin-left: 16px;
}

.models-list {
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(255, 255, 255, 0.09);
}

.model-group {
  margin-bottom: 10px;
  border-radius: 6px;
  border: #d1d1d1 solid 1px;
  overflow: hidden
}

.group-header {
  display: flex;
  align-items: center;
  cursor: pointer;
  background-color: #f5f5f5;
  padding: 12px;
  gap: 12px;
}

.group-name {
  font-size: 13px;
  font-weight: 500;
  color: #202020;
  font-weight: bold;
}

.group-toggle {
  font-size: 14px;
  color: #a4a2a2;
  transition: transform 0.6s;
}

.group-toggle.expanded {
  transform: rotate(180deg);
  border-bottom: #666 solid 1px;
}

.model-items {
  transition: max-height 0.6s ease-in-out, opacity 0.6s ease-in-out;
  opacity: 1;
  overflow: hidden;
  display: flex;
  flex-direction: column;
}

.model-items.collapsed {
  max-height: 0;
  opacity: 0;
  margin: 0;
  padding: 0;
}

.model-item {
  display: flex;
  align-items: center;
  background: #fff;
  transition: all 0.3s;
  padding: 12px;
  gap: 12px;
}

.logo-image img {
  width: 32px;
  height: 32px;
  border-radius: 4px;
}

.logo-letter {
  width: 32px;
  height: 32px;
  border-radius: 4px;
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  font-weight: bold;
}

.model-info {
  flex: 1;
  display: flex;
  flex-direction: row;
  gap: 10px;
  align-items: center;
}

.model-name {
  font-size: 14px;
  color: #333;
}

.model-type {
  font-size: 12px;
  color: #666;
}

.model-actions {
  display: flex;
  gap: 8px;
}

.action-icon {
  color: #2f2f2f;
  cursor: pointer;
  padding: 4px;
}

.action-icon:hover {
  color: #1890ff;
}

.platform-model-container {
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
}

.addmodel {
  margin-top: 10px;
  background-color: #ffffff;
  border: #c5c5c5 solid 1px;
  font-size: smaller;
  color: #000;
  box-shadow: none;
}

.addmodel:hover {
  background-color: #f5f5f5;
  color: #000;
}

.model-more-detail {
  margin-top: 10px;
  color: #999;
  font-size: 12px;
}

.type-icon {
  height: 18px;
  width: 25px;
  border-radius: 7px;
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: 10px;
}

.type-tool {
  background-color: #ffe1ce;
  color: #a07b64;
}

.type-network {
  background-color: #b1d7f4;
  color: #537fa1;
}

.type-embed {
  background-color: #f3d4a5;
  color: #917142;
}

.type-reasoning {
  background-color: #b0bac9;
  color: #51617d;
}

.type-vision {
  background-color: #c9f6d3;
  color: #54b46a;
}
</style>



================================================
FILE: frontend/src/components/platforms/settingPlatform.vue
================================================
<template>
  <a-modal
    v-model:open="visible"
    :maskClosable="false"
    :centered="true"
    :okText="$t('setting.modelService.confirm')"
    :cancelText="$t('setting.modelService.cancel')"
    @ok="handleOk"
    @cancel="handleCancel"
  >
    <template #title>
      <div style="display: flex; align-items: center; justify-content: start;">
        <span>{{ $t('setting.modelService.editProvider') }}</span>
        <a-button type="text" danger class="delete-button">
          <delete-outlined @click="handleDelete"/>
        </a-button>
      </div>
    </template>

    <div class="add-platform-form">
      <div class="platform-logo-upload" @click="triggerFileInput">
        <div v-if="!formData.logo_url" class="platform-letter" :style="{ backgroundColor: defaultColor }">
          {{ formData.name ? formData.name.charAt(0) : 'P' }}
        </div>
        <img v-else :src="formData.logo_url" :alt="$t('setting.modelService.platformLogo')" class="platform-logo" />
        <input type="file" ref="fileInput" style="display: none" accept="image/*" @change="handleFileChange" />
      </div>

      <a-form :model="formData" :rules="rules" ref="formRef">

        <a-form-item :label="$t('setting.modelService.providerName')" name="name">
          <a-input v-model:value="formData.name" :placeholder="$t('setting.modelService.namePlaceholder')" />
        </a-form-item>

        <a-form-item :label="$t('setting.modelService.providerType')" name="type" style="margin-left:10px;">
          <!-- <a-select v-model:value="formData.provider_type"> -->
          <a-select v-model:value="OpenAI">
            <a-select-option value="OpenAI">OpenAI</a-select-option>
          </a-select>
        </a-form-item>


      </a-form>
    </div>
  </a-modal>
</template>

<script setup>
import { ref, defineEmits } from 'vue'
import { useI18n } from 'vue-i18n'
import { DeleteOutlined } from '@ant-design/icons-vue'
import service from '@/services/platforms'
import { message } from 'ant-design-vue'
import emitter from '@/utils/emitter'

const { t } = useI18n()
const emit = defineEmits(['update-platform'])
const visible = ref(false)
const fileInput = ref(null)
const formRef = ref(null)
const defaultColor = '#4ECDC4'
const OpenAI = ref('OpenAI')
const formData = ref({
  id: '',
  name: '',
  provider_type: '',
  logo_url: '',
  source_type: 'user',
  api_key: '',
  api_url: '',
  api_version: '',
  is_enabled: true,
  activate_time: -1,
  key_obtain_url: ''
})

const rules = {
  name: [
    { required: true, message: t('setting.modelService.enterName'), trigger: 'blur' }
  ],
  provider_type: [
    { required: true, message: t('setting.modelService.selectType'), trigger: 'change' }
  ]
}

const triggerFileInput = () => {
  fileInput.value.click()
}

const handleFileChange = async (e) => {
  const file = e.target.files[0];
  if (file) {
    // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦ä¸ºå›¾ç‰‡æ ¼å¼
    const validImageTypes = ['image/png', 'image/jpeg', 'image/gif', 'image/webp'];
    if (!validImageTypes.includes(file.type)) {
      console.error('Invalid file type. Please select an image (PNG, JPEG, GIF, or WebP).');
      return;
    }

    // ä½¿ç”¨ Promise åŒ…è£… FileReader
    const loadImage = () => {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
          resolve(e.target.result);
        };
        reader.onerror = (error) => {
          reject(error);
        };
        reader.readAsDataURL(file);
      });
    };

    try {
      // ç­‰å¾…å›¾ç‰‡åŠ è½½å®Œæˆ
      const result = await loadImage();
      formData.value.logo_url = result;

      // å›¾ç‰‡åŠ è½½å®Œæˆåå†æ‰“å°
      console.log('Selected file:', file);
      console.log('Form data:', formData.value);
    } catch (error) {
      console.error('Error loading image:', error);
    }
  }
};

const handleOk = async () => {
  try {
    await formRef.value.validate()
    service.updatePlatform(formData.value).then((res) => {
      emit('update-platform', res)
      emitter.emit('fresh-pages')
      message.success(t('setting.modelService.updatePlatformSuccess'))
    })
    visible.value = false
  } catch (error) {
    // console.error('Form validation failed:', error)
    // message.error(t('setting.modelService.formValidationFailed'))
  }
}

const handleCancel = () => {
  visible.value = false
}

const handleDelete = async () => {
  try {
    // console.log(formData.value.id)
    const res = await service.deletePlatform(formData.value.id)
    console.log(res)
    if(res.code===0){
      message.success(t('setting.modelService.deletePlatformSuccess'))
    }
    visible.value = false
    emitter.emit('fresh-pages')
    
  } catch (error) {
    console.error('Failed to delete platform:', error)
    // message.error(t('setting.modelService.deletePlatformFailed'))
  }
}

const showModal = (platform) => {
  formData.value = { ...platform }
  visible.value = true
}

defineExpose({
  showModal
})
</script>

<style scoped>
.add-platform-form {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 20px;
}

.platform-logo-upload {
  width: 80px;
  height: 80px;
  border-radius: 8px;
  margin-bottom: 24px;
  cursor: pointer;
  overflow: hidden;
  display: flex;
  align-items: center;
  justify-content: center;
  border: 2px dashed #d9d9d9;
}

.platform-logo-upload:hover {
  border-color: #40a9ff;
}

.platform-letter {
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  font-size: 32px;
  font-weight: bold;
}

.platform-logo {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

:deep(.ant-form) {
  width: 100%;
}

:deep(.ant-form-item) {
  margin-bottom: 16px;
}

.delete-button{
  margin-left: 5px;

}
</style>


================================================
FILE: frontend/src/components/preview/fileClass.vue
================================================
<template>
  <a-modal :open="fileExplorerVisible" :footer="null" style="
    width: 600px; background-color: #fff; border-color: hsla(0, 0%, 100%, .05);
    border-width: 1px; border-radius: 20px; overflow: auto;
    flex-direction: column; max-width: 95%; max-height: 95%;
    height: 680px; padding: 0px;" :closable="false" @cancel="handleClose" :centered="true" class="modal">
      <div class="content">
          <div class="classList" v-if="!batchDownload">
              <div class="header">
                  <h1 class="title">{{ $t('lemon.fileExplorer.allFilesInTask') }}</h1>
                  <div class="btns">
                      <div class="svg">
                          <downloadSvg @click="handleBatchDownload"
                              :class="clickDisable ? 'disable' : 'svgDownload'" />
                      </div>
                      <div class="svg" @click="handleClose">
                          <closeSvg class="svgClose" />
                      </div>
                  </div>
              </div>
              <div class="main">
                  <div class="classTitle">
                      <div v-for="type in fileTypes" :key="type" class="classBtn"
                          :class="chooseClassType === type ? 'active' : ''" @click="chooseClassType = type">
                          {{ $t(`lemon.fileExplorer.fileTypes.${type}`) }}
                      </div>
                  </div>
                  <div class="classFiles" v-if="!clickDisable">
                      <div v-for="(group, time) in fileListFilterByTimeAndType" :key="time" class="timeGroup">
                          <h3 class="timeTitle">{{ $t(`lemon.fileExplorer.timeGroups.${time}`) }}</h3>
                          <div class="fileList">
                              <div v-for="file in group" :key="file.id" class="fileItem"
                                  @click="handleOpenFile(file)">
                                  <fileSvg :url="file.filename" :filepath="file.filepath" class="svgItem" />
                                  <div class="fileInfo">
                                      <!-- æ–‡ä»¶å -->
                                      <div class="fileNameContainer">
                                          <div class="fileNameDiv">
                                              <span class="fileNameSpan">{{
                                                      file.filename.split('/').pop().split('\\').pop()
                                              }}</span>
                                          </div>
                                          <span class="time">{{ formatTimeWithHMS(file.timestamp) }}</span>
                                      </div>
                                      <!-- æ›´å¤šé€‰é¡¹ -->
                                      <div class="moreOption" @click.stop>
                                          <a-tooltip placement="bottomRight" :arrow="false" color="#ffffff"
                                              trigger="click" :visible="tooltipVisible[file.id] || false"
                                              @visibleChange="visible => handleTooltipVisibleChange(file.id, visible)">
                                              <template #title>
                                                  <div class="custom-tooltip">
                                                      <div class="svg-tooltip" @click="handlePreview(file)">
                                                          <clickSvg /> {{ $t('lemon.fileExplorer.preview') }}
                                                      </div>
                                                      <div class="svg-tooltip" @click="handleFileDownload(file)">
                                                          <downloadSvgDown /> {{ $t('lemon.fileExplorer.download') }}
                                                      </div>
                                                  </div>
                                              </template>
                                              <moreOptionsSvg @click="toggleTooltip(file.id)" />
                                          </a-tooltip>
                                      </div>
                                  </div>
                              </div>
                          </div>
                      </div>
                  </div>
                  <div class="empty" v-else-if="clickDisable">
                      <div class="emptyIcon">
                          <fileEmptySvg />
                      </div>
                      <div class="emptyText">
                          <span>{{ $t('lemon.fileExplorer.noContent') }}</span>
                      </div>
                  </div>
              </div>
          </div>
          <!-- Batch download mode -->
          <div class="batchDownloadList" v-else>
              <!-- å…¨é€‰ + å–æ¶ˆ -->
              <div class="header">
                  <div class="selectAll" @click="selectAll">
                      <a-checkbox v-model:checked="selectedAll" :indeterminate="isIndeterminate" />
                      <span>{{ $t('lemon.fileExplorer.selectAll') }}</span>
                  </div>
                  <span class="cancel" @click="handleCancelBatchDownload">{{ $t('lemon.fileExplorer.cancel') }}</span>
              </div>
              <!-- æ–‡ä»¶åˆ—è¡¨ -->
              <div class="batchMain">
                  <div class="batchMainContent">
                      <div v-for="(group, time) in fileListFilterByTimeAndType" :key="time" class="timeGroup">
                          <h3 class="timeTitle">{{ $t(`lemon.fileExplorer.timeGroups.${time}`) }}</h3>
                          <div class="fileList">
                              <div v-for="file in group" :key="file.id" class="fileItem">
                                  <a-checkbox v-model:checked="file.selected" @change="updateSelectedAll" />
                                  <fileSvg :url="file.filepath" :filepath="file.filepath" class="svgItem" />
                                  <div class="timeContainer">
                                      <span class="fileName">{{
                                                      file.filename.split('/').pop().split('\\').pop()
                                                       }}</span>
                                      <span class="time">{{ formatTimeWithHMS(file.timestamp) }}</span>
                                  </div>
                              </div>
                          </div>
                      </div>
                  </div>
              </div>
              <!-- åº•éƒ¨æŒ‰é’® æ‰¹é‡ä¸‹è½½ -->
              <div class="batchFooter">
                  <a-button type="primary" @click="confirmBatchDownload" class="btnDownload"
                      :class="clickDowload ? 'disableDownload' : 'enableDownload'">
                      <downloadSvg class="svg" />
                      <span class="span">{{ $t('lemon.fileExplorer.batchDownload') }}</span>
                  </a-button>
              </div>
          </div>
      </div>
  </a-modal>
  <imgModal :url="imgUrl" :visible="imgVisable" @close="imgVisable = false" />
</template>

<script setup>
import { ref, computed, reactive, watch } from 'vue'
import { useI18n } from 'vue-i18n'
import JSZip from 'jszip'
import { saveAs } from 'file-saver'
import downloadSvg from '@/assets/svg/download.svg'
import closeSvg from '@/assets/filePreview/close.svg'
import emitter from '@/utils/emitter'
import fileSvg from '@/components/fileClass/fileSvg.vue'
import moreOptionsSvg from '@/assets/filePreview/moreOptions.svg'
import fileEmptySvg from '@/assets/fileClass/file.svg'
import clickSvg from '@/assets/fileClass/click.svg'
import downloadSvgDown from '@/assets/fileClass/download.svg'
import { viewList } from '@/utils/viewList'
import { useChatStore } from '@/store/modules/chat'
import { storeToRefs } from 'pinia'
import workspaceService from '@/services/workspace'
import imgModal from '../file/imgModal.vue'
import fileUtil from '@/utils/file'
import { formatTimeWithHMS } from '@/utils/time'

const chatStore = useChatStore()
const { messages } = storeToRefs(chatStore)

const { t } = useI18n()

const batchDownload = ref(false)
const fileExplorerVisible = ref(false)
const chooseClassType = ref('all')
const clickDisable = ref(false)
const tooltipVisible = ref({})
const imgUrl = ref('')
const imgVisable = ref(false)
const clickDowload = ref(false)

// ä½¿ç”¨ reactive å­˜å‚¨æ–‡ä»¶åˆ—è¡¨
const fileListState = reactive([])

// åŒæ­¥ fileListState ä¸ messages
const updateFileList = () => {
const files = viewList.viewLocal(messages.value, false)
const existingFiles = new Map(fileListState.map(file => [file.id, file.selected]))
fileListState.length = 0
files.forEach(file => {
  fileListState.push({
    ...file,
    selected: existingFiles.get(file.id) ?? false
  })
})
}

// åˆå§‹åŠ è½½å’Œç›‘å¬ messages å˜åŒ–
updateFileList()
watch(messages, updateFileList, { deep: true })

// æ–‡ä»¶ç±»å‹
const fileTypes = ['all', 'document', 'image', 'codeFile', 'link']

const fileTypeExtensions = {
link: ['com'],
codeFile: ['js', 'css', 'html', 'java', 'c#', 'cpp', 'py', 'go', 'php', 'ruby', 'swift', 'kotlin', 'scala', 'rust'],
image: ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'svg', 'tiff', 'webp', 'ico'],
document: ['doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx', 'pdf', 'txt', 'md']
}

// è¿‡æ»¤æ–‡ä»¶
const filteredFiles = computed(() => {
console.log('chooseClassType.value', chooseClassType.value)
return chooseClassType.value === 'all'
  ? fileListState
  : fileListState.filter(file => {
      const ext = file.filename.split('.').pop().toLowerCase()
      return fileTypeExtensions[chooseClassType.value]?.includes(ext)
    })
})

// æŒ‰æ—¶é—´åˆ†ç»„
const fileListFilterByTimeAndType = computed(() => {
return groupFilesByTime(filteredFiles.value)
})

// å…¨é€‰çŠ¶æ€
const selectedAll = ref(false)
const isIndeterminate = computed(() => {
const files = filteredFiles.value
if (files.length === 0) return false
const someSelected = files.some(file => file.selected)
const allSelected = files.every(file => file.selected)
return someSelected && !allSelected
})

// å…¨é€‰/å–æ¶ˆå…¨é€‰
const selectAll = () => {
selectedAll.value = !selectedAll.value
filteredFiles.value.forEach(file => {
  file.selected = selectedAll.value
})
}

// æ›´æ–°å…¨é€‰çŠ¶æ€
const updateSelectedAll = () => {
const files = filteredFiles.value
if (files.length === 0) {
  selectedAll.value = false
  return
}
selectedAll.value = files.every(file => file.selected)
}

// æ§åˆ¶ä¸‹è½½æŒ‰é’®ç¦ç”¨çŠ¶æ€
const hasSelectedFilesInCurrentGroup = computed(() => {
return Object.values(fileListFilterByTimeAndType.value).some(group =>
  group.some(file => file.selected)
)
})

watch(hasSelectedFilesInCurrentGroup, (hasSelected) => {
clickDowload.value = !hasSelected
}, { immediate: true })

watch(filteredFiles, (newFiles) => {
// clickDisable.value = newFiles.length === 0
updateSelectedAll()
}, { immediate: true })

function groupFilesByTime(files) {
clickDisable.value = files.length == 0;
const today = new Date()
today.setHours(0, 0, 0, 0)
const yesterday = new Date(today)
yesterday.setDate(yesterday.getDate() - 1)

const groups = {
  today: [],
  yesterday: [],
  earlier: []
}
//files é™åºæ’åˆ—
files.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))
files.forEach(file => {
  const fileDate = new Date(file.timestamp)
  fileDate.setHours(0, 0, 0, 0)
  if (fileDate.getTime() === today.getTime()) {
    groups.today.push(file)
  } else if (fileDate.getTime() === yesterday.getTime()) {
    groups.yesterday.push(file)
  } else {
    groups.earlier.push(file)
  }
})


return Object.fromEntries(
  Object.entries(groups).filter(([_, files]) => files.length > 0)
)
}

const handleClose = () => {
fileExplorerVisible.value = false
}

const handleBatchDownload = () => {
batchDownload.value = true
}

const handleCancelBatchDownload = () => {
batchDownload.value = false
selectedAll.value = false
fileListState.forEach(file => {
  file.selected = false
})
}

async function handleFileDownload(file) {
tooltipVisible.value[file.id] = false
fileUtil.handleFileDownload(file);
}

const handleOpenFile = (file) => {
if (fileUtil.imgType.includes(file.filename.split('.').pop())) {
  workspaceService.getFile(file.filepath).then(res => {
    imgUrl.value = URL.createObjectURL(res)
    imgVisable.value = true
  })
} else {
  emitter.emit('fullPreviewVisable', file)
}
fileExplorerVisible.value = false
}

const handlePreview = (file) => {
if (fileUtil.imgType.includes(file.filename.split('.').pop())) {
  workspaceService.getFile(file.filepath).then(res => {
    imgUrl.value = URL.createObjectURL(res)
    imgVisable.value = true
  })
} else {
  handleOpenFile(file)
}
// tooltipVisible.value = file.id
tooltipVisible.value[file.id] = false
}

const toggleTooltip = (fileId) => {
tooltipVisible.value[fileId] = !tooltipVisible.value[fileId]
}

const handleTooltipVisibleChange = (fileId, visible) => {
tooltipVisible.value[fileId] = visible
}

async function confirmBatchDownload() {
if (clickDowload.value) return

const selectedFiles = Object.values(fileListFilterByTimeAndType.value)
  .flat()
  .filter(file => file.selected)

if (selectedFiles.length === 0) {
  batchDownload.value = false
  return
}
console.log('selectedFiles', selectedFiles)
// åˆ›å»º ZIP æ–‡ä»¶
const zip = new JSZip()
const promises = selectedFiles.map(async (file) => {
  const fileName = file.filename.split('/').pop()
  const fileContent = await workspaceService.getFile(file.filepath)
  console.log('fileContent', fileContent)
  
  // æ ¹æ®æ–‡ä»¶æ‰©å±•ååˆ¤æ–­æ˜¯å¦ä¸ºäºŒè¿›åˆ¶æ–‡ä»¶
  const ext = fileName.split('.').pop().toLowerCase()
  const isBinaryFile = fileTypeExtensions.image.includes(ext) || 
                      ['pdf', 'doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx', 'zip', 'rar'].includes(ext)
  
  // å¯¹äºäºŒè¿›åˆ¶æ–‡ä»¶ï¼Œç›´æ¥ä½¿ç”¨åŸå§‹å†…å®¹ï¼›å¯¹äºæ–‡æœ¬æ–‡ä»¶ï¼Œç¡®ä¿æ˜¯å­—ç¬¦ä¸²æ ¼å¼
  let zipContent = fileContent
  if (!isBinaryFile && typeof fileContent !== 'string') {
    // å¦‚æœæ˜¯å¯¹è±¡ï¼ˆå¦‚JSONï¼‰ï¼Œè½¬æ¢ä¸ºæ ¼å¼åŒ–çš„å­—ç¬¦ä¸²
    zipContent = typeof fileContent === 'object' ? JSON.stringify(fileContent, null, 2) : String(fileContent)
  }
  
  zip.file(fileName, zipContent, { binary: isBinaryFile })
})
try {
  // ç­‰å¾…æ‰€æœ‰æ–‡ä»¶å†…å®¹åŠ è½½å®Œæˆ
  await Promise.all(promises)
  // ç”Ÿæˆ ZIP æ–‡ä»¶
  const content = await zip.generateAsync({ type: 'blob' })
  // ä¸‹è½½ ZIP æ–‡ä»¶
  saveAs(content, `files_${new Date().toISOString().slice(0, 10)}.zip`)
} catch (error) {
  console.error('Error creating ZIP file:', error)
  // å¯é€‰ï¼šæ˜¾ç¤ºé”™è¯¯æç¤ºç»™ç”¨æˆ·
}

// é‡ç½®çŠ¶æ€
batchDownload.value = false
selectedAll.value = false
fileListState.forEach(file => {
  file.selected = false
})
}

emitter.on('file-explorer-visible', () => {
fileExplorerVisible.value = true
})
</script>

<style lang="scss" scoped>
.content {
  height: 100%;
  width: 100%;
  background-color: #fff;
  border-color: hsla(0, 0%, 100%, .05);

  .classList {
      display: flex;
      flex-direction: column;
      height: 100%;
      width: 100%;

      .header {
          display: flex;
          padding: 1.5rem 1.5rem 0.625rem;
          align-items: center;
          flex: 1;

          .title {
              color: #34322d;
              font-weight: 600;
              font-size: 1.125rem;
              margin: 0;
              flex: 1;
          }

          .btns {
              display: flex;
              align-items: center;
              gap: 1rem;

              .svg {
                  border-radius: 0.375rem;
                  justify-content: center;
                  align-items: center;
                  width: 1.75rem;
                  height: 1.75rem;
                  display: flex;
              }

              .svgClose {
                  background-color: #fffffe;
                  cursor: pointer;
              }

              .svgDownload {
                  background-color: #f9fafb;
                  cursor: pointer;
              }
          }
      }

      .main {
          display: flex;
          flex-direction: column;
          height: 100%;
          overflow-y: auto;

          .classTitle {
              display: flex;
              flex-wrap: wrap;
              align-items: center;
              gap: 0.5rem;
              padding: 0.25rem 1.5rem 0;

              .classBtn {
                  font-size: 0.875rem;
                  height: 2.5rem;
                  padding: 0 1rem;
                  border-radius: 20px;
                  box-shadow: none;
                  border: 1px solid #0000001f;
                  line-height: 38px;

                  &.active {
                      background-color: #1a1a19;
                      color: #fff;
                  }
              }
          }

          .classFiles {
              margin-top: 1rem;
              padding: 0.25rem 1.5rem 0;
              overflow: auto;
              box-sizing: border-box;

              .timeGroup {
                  margin-bottom: 1.5rem;

                  .timeTitle {
                      font-size: .75rem;
                      line-height: 1rem;
                      color: #858481;
                      padding-left: .75rem;
                      margin: 0;
                  }

                  .fileList {
                      display: flex;
                      flex-direction: column;

                      .fileItem {
                          display: flex;
                          align-items: center;
                          padding: .625rem .75rem;
                          border-radius: .5rem;
                          gap: 0.85rem;
                          cursor: pointer;

                          .svgItem {
                              display: block;
                              scrollbar-width: thin;
                              scrollbar-color: transparent transparent;
                              box-sizing: border-box;
                              border: 0 solid #e5e7eb;
                          }

                          .fileInfo {
                              display: flex;
                              justify-content: space-between;
                              align-items: center;
                              flex: 9;

                              .fileNameContainer {
                                  display: flex;
                                  flex-direction: column;
                                  flex: 1 1 0%;
                                  min-width: 0;

                                  .time {
                                      font-size: .75rem;
                                      color: #858481;
                                  }

                                  .fileNameDiv {
                                      display: flex;
                                      flex-direction: row;

                                      .fileNameSpan {
                                          color: #34322d;
                                          font-size: .875rem;
                                          line-height: 1.25rem;
                                          text-overflow: ellipsis;
                                          overflow: hidden;
                                          white-space: nowrap;
                                      }
                                  }
                              }

                              .moreOption {
                                  display: flex;
                                  color: #858481;
                                  border-radius: .375rem;
                                  justify-content: center;
                                  align-items: center;
                                  cursor: pointer;
                                  width: 2rem;
                                  height: 2rem;
                              }

                              .moreOption:hover {
                                  background-color: #37352f0a;
                              }
                          }
                      }

                      .fileItem:hover {
                          background-color: #37352f0a;
                      }
                  }
              }
          }

          .classFiles::-webkit-scrollbar {
              width: 6px;
              height: 6px;
          }

          .classFiles::-webkit-scrollbar-thumb {
              background-color: #cfcdcd;
              border-radius: 3px;
          }

          .classFiles::-webkit-scrollbar-track {
              background-color: #f5f5f5;
          }

          .empty {
              display: flex;
              flex-direction: column;
              align-items: center;
              padding: 1.5rem 1.5rem 0;
              gap: .75rem;
              justify-content: center;
              height: 100%;
              box-sizing: border-box;

              .emptyIcon {
                  color: #858481;
              }

              .emptyText {
                  color: #858481;
                  font-size: 14px;
              }
          }
      }
  }

  .batchDownloadList {
      display: flex;
      flex-direction: column;
      height: 100%;

      .header {
          display: flex;
          align-items: center;
          padding-top: 1.5rem;
          padding-left: 1.5rem;
          padding-right: 1.5rem;
          padding-bottom: 0.625rem;
          justify-content: space-between;

          .selectAll {
              color: #858481;
              font-size: .875rem;
              line-height: 1.25rem;
              gap: .625rem;
              align-items: center;
              display: flex;
              cursor: pointer;
          }

          .cancel {
              color: #858481;
              font-size: .875rem;
              line-height: 1.25rem;
              cursor: pointer;
          }
      }

      .batchMain {
          padding-bottom: 1rem;
          padding-left: .75rem;
          padding-right: .75rem;
          overflow: auto;
          margin-top: 1rem;
          flex: 8;

          .batchMainContent {
              padding-top: 0;
              gap: .25rem;
              display: flex;
              flex-direction: column;

              .timeTitle {
                  font-size: .75rem;
                  line-height: 1rem;
                  color: #858481;
                  padding-left: .75rem;
                  margin: 0;
              }

              .fileList {
                  display: flex;
                  flex-direction: column;

                  .fileItem {
                      display: flex;
                      align-items: center;
                      padding: .625rem .75rem;
                      border-radius: .5rem;
                      gap: 0.85rem;
                      cursor: pointer;

                      .svgItem {
                          display: block;
                          scrollbar-width: thin;
                          scrollbar-color: transparent transparent;
                          box-sizing: border-box;
                          border: 0 solid #e5e7eb;
                      }

                      .timeContainer {
                          display: flex;
                          flex-direction: column;
                          justify-items: start;
                          flex: 1;

                          .fileName {
                              color: #34322d;
                              font-size: .875rem;
                              line-height: 1.25rem;
                              text-overflow: ellipsis;
                              overflow: hidden;
                              white-space: nowrap;
                          }

                          .time {
                              font-size: .75rem;
                              color: #858481;
                          }
                      }
                  }
              }
          }
      }

      .batchMain::-webkit-scrollbar {
          width: 6px;
          height: 6px;
      }

      .batchMain::-webkit-scrollbar-thumb {
          background-color: #cfcdcd;
          border-radius: 3px;
      }

      .batchMain::-webkit-scrollbar-track {
          background-color: #f5f5f5;
      }

      .batchFooter {
          flex: 0.5;
          padding-top: 1rem;
          padding-bottom: 1rem;
          padding-left: 1.25rem;
          padding-right: 1.25rem;
          justify-content: flex-end;
          display: flex;
          align-items: center;
          border-top: #0000000f 1px solid;

          .btnDownload {
              padding-left: .75rem;
              padding-right: .75rem;
              border-radius: 100px;
              gap: .25rem;
              align-items: center;
              height: 2.25rem;
              background-color: #ffffff0f;        box-shadow: none;
      display: flex;
      justify-content: center;
      flex-direction: row;
      border: #0000000f 1px solid;

      .svg {
        display: block;
        scrollbar-width: thin;
        scrollbar-color: transparent transparent;
        box-sizing: border-box;
        outline: none;
        border: 0 solid #e5e7eb;
      }

      .span {
        font-size: .875rem;
        line-height: 1.25rem;
      }
    }

    .btnDownload:hover {
      background-color: #37352f0a;
    }

    .disableDownload {
      color: #919191;
    }

    .enableDownload {
      color: #535350;
      cursor: pointer;
    }
  }
}
}

.custom-tooltip {
padding: .25rem;
box-sizing: border-box;
outline: none;
border: 0 solid #e5e7eb;

.svg-tooltip {
  color: #535350;
  font-size: .875rem;
  line-height: 1.25rem;
  padding-top: .5rem;
  padding-bottom: .5rem;
  padding-left: .75rem;
  padding-right: .75rem;
  border-radius: 8px;
  gap: .75rem;
  align-items: center;
  cursor: pointer;
  display: flex;
  width: 100%;
}

.svg-tooltip:hover {
  background-color: #37352f0f;
}
}
</style>

<style>
.modal .ant-modal-content {
padding: 0 !important;
height: 680px;
width: 100%;
}

.modal .ant-modal-content .ant-modal-body {
padding: 0 !important;
height: 680px !important;
width: 100%;
}

.disable {
color: #858481;
cursor: not-allowed;
}

.disableDownload {
cursor: not-allowed !important;
pointer-events: none;
}
</style>



================================================
FILE: frontend/src/components/preview/fullPreview.vue
================================================
<template>
  <div v-show="fullPreviewVisable" class="fullpreview" :class="isFullPreview ? `fullPreviewEnable` : null">
    <div class="fullpreview-container">
      <div class="header" v-if="showHeader">
        <div class="title-container">
          <div class="title">
            <fileSvg :url="file?.filename" class="file-type" />
            <span>{{ fileName }}</span>
          </div>
        </div>

        <div class="btns">
          <a-tooltip placement="bottom" :arrow="false" color="#ffffff" trigger="click" overlayClassName="tooltip-com" v-model:open="downloadTooltipVisible">
            <template #title>
              <div class="custom-tooltip">
                <div
                  class="svg-tooltip"
                  @click="
                    handleFileDownload(file);
                    downloadTooltipVisible = false;
                  "
                >
                  <downloadSvgDown />
                  {{ $t("lemon.fullPreview.download") }}
                </div>
                <div
                  class="svg-tooltip"
                  v-if="canBeMd"
                  @click="
                    handleExportPDF();
                    downloadTooltipVisible = false;
                  "
                >
                  <pdfExportSvg />
                  {{ $t("lemon.fullPreview.exportToPDF") }}
                </div>

                <!-- <div class="line"></div> -->
                <!-- <div class="svg-tooltip"
                    @click="handleSaveToGoogleDrive(); downloadTooltipVisible = false">
                    <googleDriverSvg /> {{ $t('lemon.fullPreview.saveToGoogleDrive') }}
                </div> -->
              </div>
            </template>
            <button class="icon-bt">
              <downloadSvg />
            </button>
          </a-tooltip>

          <a-tooltip v-if="!isFullPreview" :arrow="false" overStyle="font-size:10px" overlayClassName="tooltip-tips">
            <template #title>
              <span class="tips-text">{{ $t("lemon.fullPreview.maximize") }}</span>
            </template>
            <button class="icon-bt" @click="isFullPreview = true">
              <maxMizeSvg />
            </button>
          </a-tooltip>
          <a-tooltip v-if="isFullPreview" :arrow="false" overStyle="font-size:10px" overlayClassName="tooltip-tips">
            <template #title>
              <span class="tips-text">{{ $t("lemon.fullPreview.minimize") }}</span>
            </template>
            <button class="icon-bt" @click="isFullPreview = false">
              <minMizeSvg />
            </button>
          </a-tooltip>

          <a-tooltip :arrow="false" overStyle="font-size:10px" overlayClassName="tooltip-tips">
            <template #title>
              <span class="tips-text">{{ $t("lemon.fullPreview.previous") }}</span>
            </template>
            <button class="icon-bt" @click="currentIndex--" :class="currentIndex > 0 ? null : 'disableBtn'">
              <leftSvg />
            </button>
          </a-tooltip>
          <a-tooltip :arrow="false" overStyle="font-size:10px" overlayClassName="tooltip-tips">
            <template #title>
              <span class="tips-text">{{ $t("lemon.fullPreview.next") }}</span>
            </template>
            <button class="icon-bt" @click="currentIndex++" :class="currentIndex < fileList.length - 1 ? null : 'disableBtn'">
              <rightSvg />
            </button>
          </a-tooltip>
          <a-tooltip placement="bottom" :arrow="false" color="#ffffff" trigger="click" overlayClassName="tooltip-com" v-model:open="moreOptionsTooltipVisible">
            <template #title>
              <div class="custom-tooltip more-tooltip">
                <div
                  class="svg-tooltip"
                  @click="
                    handleCopyContent(content);
                    moreOptionsTooltipVisible = false;
                  "
                >
                  <copySvg />
                  {{ $t("lemon.fullPreview.copy") }}
                </div>
                <div
                  class="svg-tooltip"
                  v-if="rendering && (canBeMd || canBeHtml || canBeDiff)"
                  @click="
                    rendering = false;
                    moreOptionsTooltipVisible = false;
                  "
                >
                  <codeSvg />
                  {{ $t("lemon.fullPreview.code") }}
                </div>
                <div
                  class="svg-tooltip"
                  v-if="(canBeMd && !rendering) || (canBeHtml && !rendering) || (canBeDiff && !rendering)"
                  @click="
                    rendering = true;
                    moreOptionsTooltipVisible = false;
                  "
                >
                  <eyeSvg />
                  {{ $t("lemon.fullPreview.preview") }}
                </div>
              </div>
            </template>
            <button class="icon-bt">
              <moreOptionsSvg />
            </button>
          </a-tooltip>
          <a-tooltip :arrow="false" overStyle="font-size:10px" overlayClassName="tooltip-tips">
            <template #title>
              <span class="tips-text">{{ $t("lemon.fullPreview.close") }}</span>
            </template>
            <button class="icon-bt icon-tip" @click="previewVisavleClose">
              <closeSvg />
            </button>
          </a-tooltip>
        </div>
      </div>

      <div class="content" :class="{ 'html-content': rendering && canBeHtml }">
        <!-- Loading-->
        <div v-if="contentLoading" style="height: 100%; display: flex; justify-content: center; align-items: center">
          <a-spin tip="loading ..." style="color: #8b8b8b" />
        </div>
        <!-- Markdown rendering -->
        <MarkDown v-else-if="rendering && canBeMd" :content="content" />
        <!-- Html rendering -->
        <template v-else-if="rendering && canBeHtml">
          <RenderComponent v-if="editable" :path="file.filepath" class="html-render-iframe" />
          <iframe v-else :srcdoc="content" class="html-render-iframe" frameborder="0"></iframe>
        </template>
        <!-- Diff rendering -->

        <DiffViewer
          v-else-if="rendering && canBeDiff"
          :key="`${file.filename}-${file.find?.substring(0, 20)}-${file.with?.substring(0, 20)}`"
          :filename="file.filename"
          :find="file.find"
          :with="file.with"
        />

        <!-- sandbox="allow-scripts" -->
        <!-- Source code rendering -->
        <CodeViewer v-else-if="canCodePreview" :file-path="file.filepath" :file-content="content" />
        <!-- office æ–‡ä»¶é¢„è§ˆ PDF Excel DOC DOCX-->
        <officePreview v-else-if="canOfficePreview" :filePath="file.filepath" />
        <!-- æ— æ³•é¢„è§ˆçš„æ ¼å¼ -->
        <div v-else class="no-preview">
          <div class="detail">
            <div class="detail-info">
              <div class="icon">
                <!-- é¢„è§ˆå›¾æ ‡ -->
                <fileSvg :url="file?.filepath" class="file-type" />
              </div>
              <div class="file-info">
                <div class="file-name">{{ file.filepath.split("/").pop() }}</div>
                <div class="file-type">{{ $t("lemon.fullPreview.fileTypePresentation") }}</div>
              </div>
            </div>
          </div>
          <div class="tips">
            {{ $t("lemon.fullPreview.cannotPreviewFormat") }}<br />
            {{ $t("lemon.fullPreview.downloadToView") }}
          </div>
          <a-button class="download-bt" @click="handleFileDownload(file)">
            <downloadSvg />
            <span class="text">{{ $t("lemon.fullPreview.download") }}</span>
          </a-button>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted, onUnmounted, watch, computed } from "vue";
import { useI18n } from "vue-i18n";
import emitter from "@/utils/emitter";
import { message } from "ant-design-vue";
// Import SVGs
import fileSvg from "@/components/fileClass/fileSvg.vue";
import downloadSvg from "@/assets/filePreview/download.svg";
import maxMizeSvg from "@/assets/filePreview/maxmize.svg";
import minMizeSvg from "@/assets/filePreview/minmize.svg";
import leftSvg from "@/assets/filePreview/left.svg";
import rightSvg from "@/assets/filePreview/right.svg";
import moreOptionsSvg from "@/assets/filePreview/moreOptions.svg";
import closeSvg from "@/assets/filePreview/close.svg";
import downloadSvgDown from "@/assets/fileClass/download.svg";
// import googleDriverSvg from '@/assets/fileClass/googleDriver.svg'
import pdfExportSvg from "@/assets/filePreview/pdfExport.svg";
import copySvg from "@/assets/filePreview/copy.svg";
import codeSvg from "@/assets/filePreview/code.svg";
import eyeSvg from "@/assets/filePreview/eye.svg";
// Import content rendering components
import MarkDown from "@/components/markdown/index.vue";
import CodeViewer from "@/components/file/index.vue";
import officePreview from "@/components/file/officePreview.vue";
import RenderComponent from "@/view/editor/render/index.vue";
import DiffViewer from "@/components/DiffViewer/index.vue";
import workspaceService from "@/services/workspace";
import { useChatStore } from "@/store/modules/chat";
import { storeToRefs } from "pinia";
import { viewList } from "@/utils/viewList";
import MarkdownIt from "markdown-it";
import html2pdf from "html2pdf.js";
import fileUtils from "@/utils/file";
import { useRoute } from "vue-router";
const route = useRoute();
const chatStore = useChatStore();
const editable = ref(false);
const editableFlag = import.meta.env.VITE_EDITABLE || "ON";
editable.value = editableFlag === "ON" && route.name !== "share" && route.name !== "preview";


const { agent, messages } = storeToRefs(chatStore);

const { t } = useI18n();

// Define states
const fullPreviewVisable = ref(false);
const file = ref({});
const rendering = ref(true);
const content = ref();
const contentLoading = ref(true);
const isFullPreview = ref(false);
const moreOptionsTooltipVisible = ref(false);
const downloadTooltipVisible = ref(false);
const canBeMd = ref(false);
const canBeHtml = ref(false);
const showHeader = ref(true);
const canBeDiff = ref(false);
const codePreviewType = ref([
  "js",
  "ts",
  "py",
  "json",
  "html",
  "htm",
  "css",
  "md",
  "xml",
  "java",
  "c",
  "cpp",
  "cc",
  "cxx",
  "h",
  "rb",
  "go",
  "sql",
  "yaml",
  "yml",
  "php",
  "sh",
  "bash",
  "cs",
  "rs",
  "kt",
  "scala",
  "pl",
  "swift",
  "r",
  "m",
  "dart",
  "lua",
]);
const officePreviewType = ref(["pdf", "xlsx", "xls", "docx", "pptx"]);
// Local file list
const fileList = ref([]);

watch(
  () => messages.value,
  (newValue) => {
    fileList.value = viewList.viewLocal(newValue, true);
  },
  { immediate: true }
);

const currentIndex = ref(-1);

watch(currentIndex, (newValue) => {
  if (currentIndex.value === -1) {
    return;
  }
  file.value = fileList.value[newValue];
});
// file name
const fileName = ref("");
//
watch(file, (newValue) => {
  //content is loading
  contentLoading.value = true;

  // åˆ¤æ–­æ–‡ä»¶ç±»å‹
  canBeDiff.value = newValue.type === "diff";
  canBeMd.value = newValue.filepath?.split(".").pop() === "md";
  canBeHtml.value = newValue.filepath?.split(".").pop() === "html";

  // æ›´æ–°æ–‡ä»¶å
  fileName.value = newValue.filename || newValue.filepath?.split("/").pop() || "æœªçŸ¥æ–‡ä»¶";
  fileName.value = fileName.value.split("\\").pop();

  // å‡†å¤‡å†…å®¹
  if (canBeDiff.value) {
    // diff ç±»å‹ï¼šå‡†å¤‡å¯¹æ¯”å†…å®¹ç”¨äºä»£ç è§†å›¾
    const findContent = newValue.find || "";
    const withContent = newValue.with || "";
    content.value = `--- åˆ é™¤çš„å†…å®¹ ---\n${findContent}\n\n+++ æ·»åŠ çš„å†…å®¹ +++\n${withContent}`;
  } else {
    // åˆ¤æ–­æ˜¯å¦ä¸ºä»£ç æ–‡ä»¶ï¼ˆç›´æ¥æ£€æŸ¥æ–‡ä»¶æ‰©å±•åï¼‰
    const fileExtension = newValue.filepath?.split(".").pop();
    if (codePreviewType.value.includes(fileExtension)) {
      // ä»£ç æ–‡ä»¶ï¼šä»æœåŠ¡å™¨åŠ è½½å†…å®¹
      workspaceService.getFile(newValue.filepath).then((res) => {
        let resString = typeof res === "string" ? res : JSON.stringify(res);
        content.value = handleFileContent(resString);
      });
    }
  }

  // è®¾ç½®æ¸²æŸ“æ¨¡å¼
  rendering.value = canBeMd.value || canBeHtml.value || canBeDiff.value;

  // loaded
  contentLoading.value = false;
});

// file content process
function handleFileContent(content) {
  //this function is process differ file content,The output content format may not be correct
  // markdown file process
  if (content.startsWith("```markdown")) {
    content = content.replace("```markdown", "").replace("```", "");
  }
  // html file process: `&lt;` to `<` ;  `&gt;` to `>`
  content = content.replaceAll("&lt;", "<").replaceAll("&gt;", ">");
  content = processMdContent(content);
  return content;
}

function processMdContent(content) {
  // code process markdown
  content = content.replaceAll("````markdown", "").replaceAll("````", "");
  content = content.replace(/```markdown\n([\s\S]*)\n```/, "$1");
  return content;
}

// Check if file can be code format previewed
const canCodePreview = computed(() => {
  // Diff ç±»å‹ä¹Ÿå¯ä»¥æ˜¾ç¤ºä»£ç è§†å›¾
  if (canBeDiff.value) {
    return true;
  }
  return codePreviewType.value.includes(file.value.filepath?.split(".").pop());
});
//
const canOfficePreview = computed(() => {
  return officePreviewType.value.includes(file.value.filepath?.split(".").pop());
});

// Copy content
function handleCopyContent(content) {
  if (!content || content.trim() === "") {
    message.warning(t("lemon.fullPreview.noContentToCopy"));
    return;
  }

  if (!navigator.clipboard) {
    message.error(t("lemon.fullPreview.clipboardNotSupported"));
    return;
  }

  navigator.clipboard
    .writeText(content)
    .then(() => {
      message.success(t("lemon.fullPreview.contentCopied"));
    })
    .catch((err) => {
      // console.error('Copy failed:', err)
      message.error(t("lemon.fullPreview.copyFailed"));
    });
}

// Download file
async function handleFileDownload(file) {
  console.log("handleFileDownload", file);
  fileUtils.handleFileDownload(file);
}

function extractConversationPath(filePath) {
  // Find the index of "Conversation"
  const startIndex = filePath.indexOf("Conversation");
  // If "Conversation" is not found, return null or an appropriate error message
  if (startIndex === -1) {
    return null;
  }
  // Slice the string from the start index to the end
  return filePath.slice(startIndex);
}
const openAIEdit = () => {
  const absolutePath = file.value.filepath;
  const filepath = extractConversationPath(absolutePath);
  window.open(`/editor?path=${filepath}`);
};

// TODO æ¸²æŸ“é¡µé¢æœ‰é—®é¢˜ï¼šæ–‡æœ¬ä¼šè¢«é¡µé¢åˆ†å‰²
function handleExportPDF() {
  const md = new MarkdownIt();
  const renderedMarkdown = md.render(content.value);
  const element = document.createElement("div");
  element.innerHTML = renderedMarkdown;
  element.style.padding = "20px";
  element.style.fontFamily = "Arial, sans-serif";

  // Add global pagination control
  element.style.cssText += `
        page-break-inside: avoid;
        break-inside: avoid;
    `;

  // Apply pagination control to specific elements
  const elements = element.querySelectorAll("h1, h2, h3, h4, h5, h6, p, ul, ol, li, div");
  elements.forEach((el) => {
    el.style.cssText += `
            page-break-inside: avoid;
            break-inside: avoid;
            page-break-before: auto;
            page-break-after: auto;
            margin-bottom: 10px;
        `;
  });

  const opt = {
    margin: 10,
    filename: fileName.value.split(".")[0] + ".pdf",
    image: { type: "jpeg", quality: 0.98 },
    html2canvas: {
      scale: 2,
      useCORS: true,
      windowHeight: 842, // A4 height in pixels (297mm * 2.83)
    },
    jsPDF: { unit: "mm", format: "a4", orientation: "portrait" },
    pagebreak: {
      mode: ["css", "legacy"],
      avoid: ["h1", "h2", "h3", "h4", "h5", "h6", "p", "ul", "ol", "li"],
    },
  };

  html2pdf().set(opt).from(element).save();
  message.info(t("lemon.fullPreview.exportPDFPending"));
}

emitter.on("fullPreviewVisable", (val) => {
  emitter.emit("preview-close");
  console.log("messages.value", val);
  fileList.value = viewList.viewLocal(messages.value, true); // loading again TODO:
  currentIndex.value = fileList.value.findIndex((item) => item.id === val.id);
  //åšä¸€ä¸ªå¤„ç† å¦‚æœcurrentIndex.value ä¸º-1 åˆ™ æŠŠæ•°æ® æ·»åŠ åˆ°fileList.value ä¸­
  if (currentIndex.value === -1) {
    fileList.value.push(val);
    currentIndex.value = fileList.value.length - 1;
  }
  console.log("fileList.value", fileList.value, currentIndex.value);
  fullPreviewVisable.value = true;
});

//é¢„è§ˆæ–‡ä»¶
emitter.on("fullPreviewVisable-open", (val) => {
  showHeader.value = true;
  fileList.value = [val];
  currentIndex.value = 0;
  fullPreviewVisable.value = true;
  file.value = val;
});

emitter.on("fullPreviewVisable-close", () => {
  fullPreviewVisable.value = false;
  fileList.value = [];
  currentIndex.value = -1;
  contentLoading.value = true;
});

const previewVisavleClose = async () => {
  isFullPreview.value = false;
  fullPreviewVisable.value = false;
  emitter.emit("fullPreviewVisable-close");
};
</script>

<style lang="scss">
.fullpreview {
  width: 100%;
  height: 100%;
  scrollbar-width: thin;
  scrollbar-color: transparent transparent;
  outline: none;
  border: 0 solid #e5e7eb;
  z-index: 2;

  .fullpreview-container {
    height: 100%;
    width: 100%;
    overflow: hidden;
    flex-direction: column;
    display: flex;
    border-left: #0000000f 1px solid;
    background-color: #f8f8f7;

    .header {
      display: flex;
      padding-top: 0.6rem;
      padding-bottom: 0.6rem;
      flex-direction: row;
      padding-left: 1rem;
      padding-right: 1rem;
      border-bottom: #0000000f 1px solid;
      justify-content: space-between;
      align-items: center;

      .title-container {
        padding: 0;
        gap: 1rem;
        flex: 1 1 0%;
        width: max-content;

        .title {
          display: flex;
          align-items: center;
          flex-direction: row;
          color: #535350;
          font-weight: 500;
          text-overflow: ellipsis;
          overflow: hidden;
          white-space: nowrap;
          gap: 0.25rem;

          span {
            text-overflow: ellipsis;
            overflow: hidden;
            white-space: nowrap;
          }
        }
      }

      .btns {
        padding-top: 0;
        padding-bottom: 0;
        width: auto;
        display: flex;
        flex-direction: row;
        gap: 0.5rem;

        .icon-bt {
          border-radius: 0.5rem;
          cursor: pointer;
          user-select: none;
          border: #00000000;
          color: #535350;
          display: flex;
          justify-items: center;
          align-items: center;
          background-color: unset;
        }

        .icon-bt:hover {
          background-color: #37352f0a;
        }
      }
    }

    .content {
      padding: 0.5rem;
      width: 100%;
      height: 100%;
      overflow-y: auto;

      &.html-content {
        padding: 0;
      }

      .file-content-container {
        background-color: #00000000 !important;
      }

      .no-preview {
        display: flex;
        gap: 1.5rem;
        justify-content: center;
        align-items: center;
        flex-direction: column;
        align-content: center;
        height: 100%;
        width: 100%;
        flex: 1 1 0%;

        .download-bt {
          display: flex;
          border-radius: 10px;
          cursor: pointer;
          user-select: none;
          border-color: #0000001f;
          box-shadow: none;
          background-color: #0081f2;
          color: white;
          justify-items: center;
          align-items: center;
          justify-content: center;
        }

        .detail {
          display: flex;
          align-items: center;
          flex-direction: row;

          .detail-info {
            display: flex;
            flex-direction: row;
            padding: 0.5rem;
            background-color: #37352f0a;
            border-radius: 10px;
            gap: 0.375rem;
            align-items: center;
            width: fit-content;

            .file-info {
              gap: 0.125rem;
              display: flex;
              flex-direction: column;
              align-items: center;

              .file-name {
                color: #34322d;
                font-size: 0.875rem;
                line-height: 1.25rem;
                overflow: hidden;
                white-space: nowrap;
              }

              .file-type {
                color: #858481;
                font-size: 0.75rem;
                line-height: 1rem;
                overflow: hidden;
                white-space: nowrap;
              }
            }
          }
        }

        .tips {
          color: #858481;
          font-size: 0.875rem;
          line-height: 1.25rem;
          text-align: center;
        }
      }

      .html-render-iframe {
        display: block; // ç¡®ä¿ iframe æ˜¯å—çº§å…ƒç´ 
        width: 100%;
        height: 100%; // éœ€è¦ç¡®ä¿çˆ¶å®¹å™¨ .content æœ‰é«˜åº¦
        border: none; // å†æ¬¡ç¡®è®¤æ— è¾¹æ¡†
      }
    }
  }
}

.fullPreviewEnable {
  position: absolute;
  z-index: 1000;
  left: 0;
  top: 0;
  right: 0;
  bottom: 0;
  width: 100%;
  max-width: 100% !important;

  .fullpreview-container {
    .content {
      // max-width: 768px;
      // margin: auto;
    }
  }
}

.custom-tooltip {
  box-sizing: border-box;
  outline: none;

  .svg-tooltip {
    color: #535350;
    font-size: 0.875rem;
    line-height: 1.25rem;
    padding-top: 0.5rem;
    padding-bottom: 0.5rem;
    padding-left: 0.75rem;
    padding-right: 0.75rem;
    border-radius: 8px;
    gap: 0.75rem;
    align-items: center;
    cursor: pointer;
    display: flex;
    width: 100%;
  }

  .line {
    border-bottom: #0000000f 1px solid;
    margin: 1px;
  }

  .svg-tooltip:hover {
    background-color: #37352f0f;
  }
}

.more-tooltip {
  width: 138px;
}

.tooltip-com {
  padding: 0 !important;
  border: #0000001f 1px solid;
  border-radius: 0.75rem;
  overflow: hidden;
  box-shadow:
    0 0 #0000,
    0 0 #0000,
    0 4px 11px 0px #00000014;

  .ant-tooltip-inner {
    padding: 0.25rem !important;
  }
}

.tooltip-tips {
  padding: 0 !important;

  .ant-tooltip-inner {
    padding-top: 0 !important;
    padding-bottom: 0 !important;
    display: flex;
    justify-items: center;
    align-items: center;
  }

  font-size: 0.75rem !important;
}

.tips-text {
  display: flex;
  justify-content: center;
  align-content: center;
}

.disableBtn {
  opacity: 0.5 !important;
  cursor: not-allowed !important;
}

/* ç§»åŠ¨ç«¯é€‚é… */
@media (max-width: 768px) {
  .fullpreview {
    .fullpreview-container {
      .header {
        .title-container {
          width: 50%;
          .title {
            .file-icon {
              min-width: 32px;
              min-height: 32px;
            }
            span {
              text-overflow: ellipsis;
              overflow: hidden;
              white-space: nowrap;
            }
          }
        }
      }
    }
  }
}
</style>

<style scoped></style>



================================================
FILE: frontend/src/components/preview/index.vue
================================================
<template>
  <div class="preview-container" v-show="preview">
    <!-- å¤´éƒ¨æ ‡é¢˜æ  -->
    <div class="preview-header">
      <div class="title-t">
        <div class="title">
          {{ $t('lemon.preview.title') }}
        </div>
        <div class="icon-ct">
          <div class="sandbox-content" v-if="showVsCode">
            <a-button type="primary" @click="OpenVsCode" class="vscode-btn item">
              <vscodeSvg class="icon"/>
              {{ $t('lemon.preview.openVsCode') }}
            </a-button>
          </div>
          <div class="close-btn" @click="handleClose">
            <CloseOutlined/>
          </div>
        </div>
      </div>
      <div class="title-status">
        <div class="icon">
          <component :is="typeIcon"/>
        </div>
        <div class="status">
          <div class="use-title">
            {{ $t('lemon.preview.using') }} <span class="typeDescription">{{ typeDescription }}</span>
          </div>
          <div class="commonding">
            {{ $t('lemon.preview.performing') }} <span class="typeDetail">{{ typeDetail }}</span>
          </div>
        </div>
      </div>
    </div>

    <!-- å†…å®¹åŒºåŸŸ -->
    <div class="preview-content">
      <div class="main-content">
        <div class="title">
          <span>{{ fileName.split('\\').pop() }}</span>
        </div>
        <div class="main-content-main">
          <!-- Terminalå±•ç¤ºåŒº -->
           
          <Terminal class="terminal" v-if="type === 'terminal_run'" :isPreview="true" v-model:content="fileContent"/>
          <!-- æµè§ˆå™¨å±•ç¤º -->
          <BrowserImage v-else-if="type === 'browser'" :content="browserImageData"/>
          <!-- æ–‡ä»¶å±•ç¤º -->
          <FileContent v-else-if="(((type === 'write_code' || type === 'read_file') && fileName ) || type === 'mcp_tool' || type === 'document_query' )" :filePath="fileName"
                       :file-content="fileContent"/>
          <!-- æµè§ˆå™¨æœç´¢ç»“æœ-->
          <searchResults v-else-if="type === 'web_search'" :search-results="browserContent"/>
          <FileContent v-else :filePath="fileName" :file-content="fileContent"/>
        </div>
        <div class="time-content">
          <div class="btns">
            <a-popover>
              <template #content>
                <p>{{ $t('lemon.preview.previousStep') }}</p>
              </template>
              <StepBackwardOutlined class="item" @click="msgQueryIDSuMinus" :class="{ disabled: msgQueryID == 0 }"/>
            </a-popover>
            <a-popover>
              <template #content>
                <p>{{ $t('lemon.preview.nextStep') }}</p>
              </template>
              <StepForwardOutlined class="item" @click="msgQueryIDAdd"
                                   :class="{ disabled: !(msgQueryID < messageQueue.length - 1) }"/>
            </a-popover>
          </div>
          <div class="time-slider">
            <div class="code-box-demo">
              <a-slider v-model:value="currentTime" :min="minTime" :max="maxTime" :step="1"
                        :tipFormatter="formatTooltip" @change="handleTimeChange"/>
            </div>
            <div class="realtime-tips">
              <div class="realtime-dot" :class="isRealTime ? 'realon' : 'realoff'"></div>
              <span>{{ $t('lemon.preview.realtime') }}</span>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup>
import {ref, computed, watch, onMounted, onUnmounted, markRaw} from 'vue';
import {CloseOutlined, CodeSandboxOutlined, StepBackwardOutlined, StepForwardOutlined} from '@ant-design/icons-vue';
import vscodeSvg from '@/assets/svg/vscode.svg';
import Terminal from '@/components/terminal/index.vue';
import BrowserImage from '@/components/browser/image.vue';
import FileContent from '@/components/file/index.vue';
import emitter from '@/utils/emitter';
import workspaceService from '@/services/workspace';
import Browser from '@/assets/message/browse.svg';
import Edit from '@/assets/message/edit.svg';
import Bash from '@/assets/message/bash.svg';
import Tools from '@/assets/message/tools.svg';
import {storeToRefs} from 'pinia';
import {useI18n} from 'vue-i18n';
import files from '@/services/workspace';
import searchResults from '@/components/browser/searchResults.vue';
import {viewList} from '@/utils/viewList';
import {useChatStore} from '@/store/modules/chat';
import {message} from 'ant-design-vue';

import { useRoute } from 'vue-router'
const route = useRoute();

// ç§»åŠ¨ç«¯æ£€æµ‹
const isMobile = ref(false);
const checkMobile = () => {
  isMobile.value = window.innerWidth <= 768;
};

onMounted(() => {
  checkMobile();
  window.addEventListener('resize', checkMobile);
});

onUnmounted(() => {
  window.removeEventListener('resize', checkMobile);
});

const chatStore = useChatStore();
const {agent, messages} = storeToRefs(chatStore);
const {t} = useI18n();

const msgQueryID = ref(-1);
const previewMessage = ref(null);
const sandboxVisible = ref(false);
const preview = ref(false);
const autoForward = ref(false);
const isRealTime = ref(false);
const messageQueue = computed(() => {
  return viewList.viewRealTime(messages);
});

const svgHash = {
  browser: markRaw(Browser),
  write_code: markRaw(Edit),
  terminal_run: markRaw(Bash),
  read_file: markRaw(Edit),
  web_search: markRaw(Browser),
};

const type = ref('');
const typeIcon = ref(null);
const typeDescription = ref('');
const typeTitle = ref('');
const typeDetail = ref('');
const fileName = ref('');
const fileContent = ref('');
const browserContent = ref('');
const browserImageData = ref('');

const showVsCode = computed(() => {
  // åˆ¤æ–­å½“å‰è·¯ç”±æ˜¯ä¸æ˜¯ share ä¸”ä¸æ˜¯ç§»åŠ¨ç«¯
  return route.name !== 'share' && !isMobile.value;
});

const msgQueryIDSuMinus = () => {
  if (msgQueryID.value === 0) {
    return;
  }
  msgQueryID.value -= 1;
};

const msgQueryIDAdd = () => {
  if (msgQueryID.value >= messageQueue.value.length - 1) {
    return;
  }
  msgQueryID.value += 1;
};

watch(msgQueryID, (newValue) => {
  if (newValue === -1) {
    previewMessage.value = null;
    type.value = '';
    fileName.value = '';
    fileContent.value = '';
  } else {
    previewMessage.value = messageQueue.value[newValue];
    handleMessageUpdate(previewMessage.value);
    currentTime.value = previewMessage.value?.timestamp || -1;
  }
});

// Utility
function handlemdFile(content) {
  if (content?.startsWith('```')) {
    content = content.replace('```markdown', '').replace('```', '');
    const index = content.indexOf('\n');
    if (index !== -1) {
      content = content.substring(index + 1);
    }
  }
  return content || '';
}

async function handleMessageUpdate(newValue) {
  console.log('handleMessageUpdate:', JSON.stringify(newValue, null, 2));
  if (!newValue || !newValue.meta || !newValue.meta.action_type) {
    type.value = '';
    fileName.value = '';
    fileContent.value = '';
    typeDescription.value = '';
    typeTitle.value = '';
    typeDetail.value = '';
    return;
  }

  const actionType = newValue.meta.action_type;
  type.value = actionType;
  typeIcon.value = svgHash[actionType] || markRaw(Tools);
  let result = newValue.content || '';
  const maxLength = 65;
  if (result && result.length > maxLength) {
    result = result.slice(0, maxLength) + '...';
  }
  if (newValue.meta.action_type === 'terminal_run'){
    typeDetail.value = result[0];
  }else {
    typeDetail.value = result;
  }

  switch (actionType) {
    case 'browser':
      typeDescription.value = t('lemon.preview.browser');
      typeTitle.value = t('lemon.preview.browsing');
      browserImageData.value = newValue.meta.json.browser_history_screenshot || '';
      //TODO sequence browser screenshot display
      let lengthBrowserHistory = newValue.meta.json.browser_history.length;
      fileName.value = newValue.meta.json.browser_history[lengthBrowserHistory-1].url.split('?')[0] || '';
      break;
    case 'write_code':
      typeDescription.value = t('lemon.preview.editor');
      typeTitle.value = t('lemon.preview.editingFile');
      fileName.value = newValue.meta?.filepath ? newValue.meta.filepath.split('/').pop() || '' : '';
      if (!newValue.meta?.filepath) {
        console.warn(`Missing filepath in write_code meta:`, newValue);
      }
      if (fileName.value.endsWith('todo.md')) {
        fileContent.value = handlemdFile(newValue.meta?.content);
      } else if (newValue.meta?.filepath) {
        try {
          const res = await files.getFile(newValue.meta.filepath);
          fileContent.value = typeof res === 'string' ? res : res && typeof res === 'object' ? JSON.stringify(res, null, 2) : '';
        } catch (error) {
          console.error(`Failed to fetch file content for ${newValue.meta.filepath}:`, error);
          fileContent.value = '';
        }
      } else {
        fileContent.value = '';
      }
      break;
    case 'read_file':
      typeDescription.value = t('lemon.preview.editor');
      typeTitle.value = t('lemon.preview.readingFile');
      fileName.value = newValue.meta?.filepath ? newValue.meta.filepath.split('/').pop() || '' : '';
      if (!newValue.meta?.filepath) {
        console.warn(`Missing filepath in read_file meta:`, newValue);
      }
      if (fileName.value.endsWith('todo.md')) {
        fileContent.value = handlemdFile(newValue.meta?.content);
      } else if (newValue.meta?.filepath) {
        try {
          const res = await files.getFile(newValue.meta.filepath);
          fileContent.value = typeof res === 'string' ? res : res && typeof res === 'object' ? JSON.stringify(res, null, 2) : '';
        } catch (error) {
          console.error(`Failed to fetch file content for ${newValue.meta.filepath}:`, error);
          fileContent.value = '';
        }
      } else {
        fileContent.value = '';
      }
      break;
    case 'terminal_run':
      typeDescription.value = t('lemon.preview.terminal');
      typeTitle.value = t('lemon.preview.executingCommand');
      fileName.value = 'shell1';
      fileContent.value = newValue.content || '';
      break;
    case 'web_search':
      typeDescription.value = t('lemon.preview.search');
      typeTitle.value = t('lemon.preview.searching');
      fileName.value = t('lemon.preview.search');
      browserContent.value = newValue.meta.json || [];
      fileContent.value = '';
      break;
    case 'document_query':
      typeDescription.value = t('lemon.preview.search');
      typeTitle.value = t('lemon.preview.searching');
      fileName.value = t('lemon.preview.search');
      fileContent.value = newValue.meta.content || '';
      break;
    case 'mcp_tool':
      typeDescription.value = 'mcp'
      typeTitle.value = '';
      // æˆªå–ç¬¬ä¸€ä¸ª __ å‰çš„å†…å®¹
      fileName.value = newValue.content.split("__")[0];
      fileContent.value = newValue.meta.content || '';
      console.log("fileContent.value ",newValue.content);
      break;
    // case "browser":
    //   typeDescription.value = t('lemon.preview.search');
    //   typeTitle.value = t('lemon.preview.searching');
    //   fileName.value = t('lemon.preview.search');
    //   browserImage.value = newValue.meta.json.browser_history_screenshot || '';
    //   console.log('browserImage', newValue.meta.json.browser_history_screenshot );
    //   break;
    default:
      typeDescription.value = 'Tools';
      typeTitle.value = 'Tools';
      fileName.value = '';
      fileContent.value = newValue.meta.content || '';
  }
}

onMounted(() => {
  emitter.on('preview-close', () => {
    msgQueryID.value = -1;
    preview.value = false;
  });
  emitter.on('preview', ({message}) => {
    //ä¿®æ”¹css
    document.querySelector('.time-content').style.display = 'flex';
    if(document.querySelector('.sandbox-content')){
      document.querySelector('.sandbox-content').style.display = 'flex';
    }
    // è¿‡æ»¤messageä¸ºfailureçš„æ¶ˆæ¯
    emitter.emit('fullPreviewVisable-close');
    console.log('messageQueue', messageQueue);
    console.log('message', message);
    const index = messageQueue.value.findIndex((item) => item.uuid === message.uuid);
    console.log('messageQueue_index', index);
    // "status": "failure",
    if (index !== -1) {
      msgQueryID.value = index;
      currentTime.value = message.timestamp || -1;
      preview.value = true;
    } else {
      console.warn('Message not found in messageQueue:', message);
    }
  });
  //æ–°å¢åŠ ä¸€ä¸ªæ–¹æ³• ç›´æ¥é¢„è§ˆ ä¼ å…¥çš„å†…å®¹
  emitter.on('preview-new', ({message}) => { 
    preview.value = true;
    //ç”¨js éšè—å¤´éƒ¨ .preview-header
    // document.querySelector('.preview-header').style.display = 'none';
    // .time-content
    document.querySelector('.time-content').style.display = 'none';
    // .sandbox-content
    document.querySelector('.sandbox-content').style.display = 'none';
    //å¤„ç†ä¸€ä¸‹ message meta.action_type;
    console.log('preview-new message', message);
    //sandbox-content
    //æ·±æ‹·è´
    let new_message = JSON.parse(JSON.stringify(message));
    //åˆ¤æ–­ å¦‚æœ meta.json çš„é¡¹ åŒ…å« url åˆ™æŠŠ action_type è®¾ç½®ä¸º web_search å¦åˆ™ä¸º document_query
    if (new_message.meta.json && new_message.meta.json.length>0 && new_message.meta.json[0].url) {
      new_message.meta.action_type = 'web_search';
    } else {
      new_message.meta.action_type = 'document_query';
    }
    handleMessageUpdate(new_message);
  });
});

onUnmounted(() => {
  msgQueryID.value = -1;
  emitter.off('preview-close');
  emitter.off('preview');
});

const handleClose = () => {
  msgQueryID.value = -1;
  preview.value = false;
  // é€šçŸ¥å…¶ä»–ç»„ä»¶é¢„è§ˆå·²å…³é—­
  emitter.emit('preview-close', false);
};
const props = defineProps({
  title: {
    type: String,
    default: 'lemon',
  },
});

const formatTooltip = (value) => {
  const date = new Date(value || 0);
  return date.toISOString().replace('T', ' ').split('.')[0];
};

const OpenVsCode = async () => {
  try {
    const res = await workspaceService.getVsCodeUrl(chatStore.conversationId);
    window.open(res.url);
  } catch (error) {
    console.error('Failed to open VSCode:', error);
    message.error('æ— æ³•æ‰“å¼€ VSCodeï¼Œè¯·æ£€æŸ¥ runtime_type å¹¶ç¨åé‡è¯•ã€‚');
  }
};
watch(() => chatStore.list.find((c) => c.conversation_id == chatStore.chat?.conversation_id)?.status, (newValue) => {
  isRealTime.value = newValue === 'running';
});

const minTime = computed(() => {
  return messageQueue.value.length === 0 ? 0 : Math.floor(new Date(messageQueue.value[0].timestamp).getTime());
});
const currentTime = ref(-1);
const maxTime = computed(() => {
  isRealTime.value = chatStore.list.find((c) => c.conversation_id == chatStore.chat?.conversation_id)?.status  == 'running';
  if (isRealTime.value && messageQueue.value.length > 0) {
    currentTime.value = Math.floor(new Date(messageQueue.value[messageQueue.value.length - 1].timestamp).getTime());
    msgQueryID.value = messageQueue.value.length - 1;
  }
  return messageQueue.value.length === 0 ? 0 : Math.floor(new Date(messageQueue.value[messageQueue.value.length - 1].timestamp).getTime());
});

const handleTimeChange = (newTime) => {
  const targetTimestamp = newTime;
  if (!messageQueue.value || messageQueue.value.length === 0) {
    return;
  }
  let closestIndex = -1;
  let minDifference = Infinity;
  messageQueue.value.forEach((message, index) => {
    const messageTimestamp = new Date(message.timestamp).getTime();
    const difference = Math.abs(messageTimestamp - targetTimestamp);
    if (difference < minDifference) {
      minDifference = difference;
      closestIndex = index;
    }
  });
  if (closestIndex === messageQueue.value.length - 1 && isRealTime.value) {
    autoForward.value = true;
  } else {
    autoForward.value = false;
  }
  if (closestIndex !== -1) {
    msgQueryID.value = closestIndex;
  }
};
</script>


<style lang="scss" scoped>
.preview-container {
  display: flex;
  flex-direction: column;
  margin: 13px 13px 13px 0;
  border-radius: 18px;
  background: #fff;
  box-shadow: 0 2px 12px rgba(0, 0, 0, 0.1);
  border: #e7dada 1px solid;
  z-index: 12;

  .preview-header {
    flex: 1;
    display: flex;
    flex-direction: column;
    padding: 16px;
    border-bottom: 1px solid #eee;

    .title-t {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;

      .title {
        font-weight: 500;
        color: #34322d;
        font-size: 1rem;
        line-height: 22px;
      }

      .icon-ct {
        display: flex;
        align-items: center;
        gap: 10px;

        .sandbox-btn {
          cursor: pointer;
          padding: 4px;

          &:hover {
            opacity: 0.8;
          }

          border-right: #eee 1px solid;
          padding-right: 10px;
        }

        .close-btn {
          cursor: pointer;
          padding: 4px 8px;

          &:hover {
            opacity: 0.8;
            background-color: #0000000a;
            border-radius: 8px;
          }
        }
      }
    }

    .title-status {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-direction: row;
      //width: 100%;

      .icon {
        width: 40px;
        height: 40px;
        border-radius: 10px;
        background-color: #eceaea;
        display: flex;
        align-items: center;
        justify-content: center;

        svg {
          width: 28px;
          height: 28px;
        }
      }

      .status {
        //
        display: flex;
        flex-direction: column;
        max-width: calc(100% - 50px);

        .use-title {
          color: #858481;
          font-size: 12px;

          .typeDescription {
            color: #535350;
            text-overflow: ellipsis;
            overflow: hidden;
            white-space: nowrap;
          }
        }

        .commonding {
          color: #535350;
          font-size: 12px;
          padding-top: 3px;
          padding-bottom: 3px;
          padding-left: 10px;
          padding-right: 10px;
          background-color: #37352f0a;
          border-color: #0000000a;
          border-width: 1px;
          //text-overflow: ellipsis;
          align-items: center;
          border-radius: 10px;
          display: inline-flex; /* ä½¿ç”¨ inline-flex è‡ªé€‚åº”å†…å®¹å®½åº¦ */
          //justify-content: center;
          overflow: hidden;
          max-width: 100%; /* ä¸è¶…è¿‡çˆ¶å…ƒç´ å®½åº¦ */
          .typeDetail {
            text-overflow: ellipsis;
            overflow: hidden;
            white-space: nowrap;
            flex: 1 1 0%;
            //flex: 1;
            //max-width: 500px; /* ä¸è¶…è¿‡çˆ¶å…ƒç´ å®½åº¦ */

            //min-width: 0;
            margin-left: .25rem;
          }
        }
      }
    }
  }

  .preview-content {
    display: flex;
    flex-direction: column;
    flex: 9;
    height: 100%;
    padding: 14px;
    overflow-y: auto;

    .main-content {
      flex: 15;
      margin-bottom: 10px;
      display: flex;
      flex-direction: column;
      border-radius: 12px;
      background-color: #f8f8f7;
      box-shadow: 0 2px 12px rgba(0, 0, 0, 0.1);
      border: #e7dada 1px solid;
      overflow: hidden;

      .title {
        display: flex;
        font-size: 14px;
        min-height: 36px;
        justify-content: center;
        border-bottom: #e7dada 1px solid;
        align-items: center;

        span {
          color: #858481;
        }
      }

      .main-content-main {
        flex: 12;
        overflow: hidden;
      }

      .time-content {
        border-top: #e7dada 1px solid;
        background-color: #fff;
        display: flex;
        flex-direction: row;
        padding: 0px 1rem;
        align-items: center;
        flex: 1;

        .btns {
          display: flex;
          flex-direction: row;
          align-items: center;
          justify-content: center;
          gap: 10px;
          flex: 1;

          .item {
            cursor: pointer;
            padding: 4px;
            color: #464646;
          }

          .item:hover {
            background-color: #fdfdfd;
            border-radius: 5px;
            opacity: 0.8;
          }

          .disabled {
            color: #d9d9d9;
            cursor: not-allowed;
            pointer-events: none;
          }
        }

        .time-slider {
          display: flex;
          flex-direction: row;
          align-items: center;
          justify-content: center;
          gap: 10px;
          flex: 7;

          .code-box-demo {
            flex: 9;
          }

          .realtime-tips {
            margin-left: 20px;
            flex: 2;
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: start;

            span {
              width: max-content;
              font-size: .875rem;
              line-height: 1.25rem;
              gap: .25rem;
            }

            .realtime-dot {
              margin-right: 10px;
              width: 8px;
              height: 8px;
              border-radius: 50%;
              border: #a4a1a1 1px solid;
            }

            .realon {
              background-color: #25ba3b;
            }

            .realoff {
              background-color: #858481;
            }
          }
        }
      }
    }

    .main-last {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 18px;
      color: #a4a1a1;
      margin-top: 15px;
      flex-direction: column;
      background-color: #f8f8f7;
      border: #e7dada 1px solid;
      border-radius: 12px;
      box-shadow: 0 2px 12px rgba(0, 0, 0, 0.1);
    }
  }
}

.vscode-btn {
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: center;
  padding: 2px 10px !important;
  border-radius: 8px;
  cursor: pointer;
  background-color: #ffffff;
  box-shadow: none !important;
  color: #34322D;
  gap: 5px;

  .icon {
    // margin-right: 10px;
    width: 32px;
    height: 32px;
  }
}

.vscode-btn:hover {
  background-color: #f8f8f8;
  color: #34322D;
}

.container {
  margin: 0px !important;
  box-shadow: none !important;
  border: none !important;
  border-radius: 0px !important;
  background-color: unset !important;
}

:deep(.terminal-header) {
  display: none !important;
}

:deep(.xterm-viewport) {
  background-color: unset !important;
}

:deep(.xterm-rows) {
  color: #34322D !important;
}

:deep(.xterm-selection div) {
  background-color: unset !important;
}
</style>


================================================
FILE: frontend/src/components/preview/office.vue
================================================
<template>
    <pdfPreview v-if="fileExtendName==='pdf' " :pdfArrayBuffer="content"/>
    <xlsxPreview v-else-if="fileExtendName==='xlsx' " :xlsxArrayBuffer="content"/>
    <docxPreview v-else-if="fileExtendName==='docx' " :docxArrayBuffer="content"/>
    <div v-else>{{filename}} can be preview</div>
</template>
<script setup>
import { computed, defineProps } from 'vue';
import pdfPreview from '@/components/office/pdfPreview.vue';
import xlsxPreview from '@/components/office/xlsxPreview.vue';
import docxPreview from '@/components/office/docxPreview.vue';
const props = defineProps({
  content: {
    type: [ArrayBuffer],
    default:  null
  },
  filename: {
    type: String,
    default:  ""
  },
})

const fileExtendName = computed(() => {
  return props.filename.split('.').pop();
});
</script>
<style>

</style>


================================================
FILE: frontend/src/components/searchEngine/index.vue
================================================
<template>
  <div class="search-container">
    <div class="search-choose search-item">
      <div class="search-choose-header header">
        {{ $t('setting.searchService.searchProvider') }}
      </div>
      <div class="search-choose-list">
        <a-select v-model:value="selectedTemplate" :loading="loading" style="width:100%;height: 100%"
                  id="searchTemplates" @change="handleTemplateChange">
          <a-select-option v-for="item in searchTemplates" :key="item.id" :value="item.name">
            <div class="select-option-content">
              <img :src="item.logo_url" alt="" class="logo"/>
              <span>{{ displayName(item.name) }}</span>
            </div>
          </a-select-option>
        </a-select>
        <div class="search-choose-api-config" v-if="selectedTemplate === 'Tavily'">
          <span style="white-space: nowrap">{{ $t('setting.searchService.apiTips') }}</span>
          <a-input-password v-model:value="selectedConfig.base_config.api_key" class="search-choose-api-input"
                            :placeholder="$t('setting.searchService.apiKeyPlaceholder')" :disabled="loading"
                            @change="handleSave"/>
        </div>
        <div class="search-choose-api-config" v-if="selectedTemplate === 'Cloudsway'">
          <span style="white-space: nowrap">{{ $t('setting.searchService.accessKey') }}</span>
          <a-input-password v-model:value="selectedConfig.base_config.api_key" class="search-choose-api-input"
                            :placeholder="$t('setting.searchService.accessKeyPlaceholder')" :disabled="loading"
                            @change="handleSave"/>
          <span style="white-space: nowrap">{{ $t('setting.searchService.endPoint') }}</span>
          <a-input-password v-model:value="selectedConfig.base_config.endpoint" class="search-choose-api-input"
                            :placeholder="$t('setting.searchService.endpointPlaceholder')" :disabled="loading"
                            @change="handleSave"/>
        </div>
        <a-button v-show="selectedTemplate!==`Lemon`" class="save-button" @click="handleCheckApiKey" :loading="checkLoading">{{
            $t('setting.modelService.check')
          }}
        </a-button>
      </div>

      <!--  Tavily link-->
      <a v-if="selectedConfig.provider_name=== 'Tavily'" href="https://app.tavily.com/" target="_blank"
         class="get-api-link">{{ $t('setting.modelService.getApiKey') }}</a>
      <!--  Cloudsway link-->
      <a v-else-if="selectedConfig.provider_name=== 'Cloudsway'" href="https://console.cloudsway.net/" target="_blank"
         class="get-api-link">{{ $t('setting.modelService.getApiKey') }}</a>
    </div>

    <div class="search-rule search-item">
      <div class="search-rule-header header">
        {{ $t('setting.searchService.generalSettings') }}
      </div>
      <!-- <div class="search-include-date header search-bool-item">
        <div>
          <span>{{ $t('setting.searchService.includeDate') }}</span>
        </div>
        <div>
          <a-switch v-model:checked="selectedConfig.include_date" />
        </div>
      </div>
      <div class="search-include-server header search-bool-item">
        <div>
          <span>{{ $t('setting.searchService.includeServer') }}</span>
        </div>
        <div>
          <a-switch v-model:checked="selectedConfig.cover_provider_search" />
        </div>
      </div> -->
      <!-- <div class="search-enhancement header search-bool-item">
        <div>
          <span>{{ $t('setting.searchService.searchEnhancement') }}</span>
        </div>
        <div>
          <a-switch v-model:checked="selectedConfig.enable_enhanced_mode" />
        </div>
      </div> -->

      <div class="search-number header search-slider-item">
        <span>{{ $t('setting.searchService.searchResultCount') }}</span>
        <div class="slider">
          <a-form-item style="height: 10px;">
            <a-slider v-model:value="selectedConfig.result_count" :min="1" :max="20" :step="1" :marks="{
              1: '1',
              5: $t('setting.searchService.default'),
              20: '20'
            }" @afterChange="handleSave"/>
          </a-form-item>
        </div>
      </div>
    </div>
    <!-- <div class="search-backlist search-item">
      <div class="search-backlist-header header">
        {{ $t('setting.searchService.blacklist') }}
      </div>
      <div>
        <p class="tips">{{ $t('setting.searchService.blacklistTips') }}</p>
      </div>
      <div class="search-blacklist-list">
        <a-textarea v-model:value="selectedConfig.blacklist" :rows="4"
          :placeholder="$t('setting.searchService.blacklistPlaceholder')" style="resize: none;" />
      </div>
    </div> -->
    <!-- <div class="search-blacklist-button" style="display: flex;justify-content: end;">
      <a-button type="primary" class="search-blacklist-save-button" @click="handleSave">
        {{ $t('setting.searchService.save') }}
      </a-button>
    </div> -->
  </div>
</template>

<script setup>
import {ref, onMounted, watch, computed, onUnmounted, nextTick} from 'vue'
import {useI18n} from 'vue-i18n'
import searchEngineService from '@/services/search-engine'
import {message} from 'ant-design-vue'
import emitter from '@/utils/emitter'

import {driver} from "driver.js";
import "driver.js/dist/driver.css";

const {t} = useI18n()

const searchTemplates = ref([])
const loading = ref(true)
const selectedTemplate = ref('')
const selectedConfig = ref({
  provider_id: 1,
  provider_name: 'Tavily',
  base_config: {
    api_key: "",
    endpoint: ""
  },
  include_date: true,
  cover_provider_search: true,
  enable_enhanced_mode: true,
  result_count: 5,
  blacklist: null
})


const checkLoading = ref(false)

let tourDriver = null; // æå‡ä½œç”¨åŸŸï¼Œå¹¶åˆå§‹åŒ–ä¸ºç©º

const handleCheckApiKey = async () => {
  console.log("checkApiKeydasdsa")
  let config = {}
  //checkSearchProvider
  if (selectedConfig.value.provider_name == "Tavily") {
    config.type = "tavily"
    config.api_key = selectedConfig.value.base_config.api_key;
    if (config.api_key == "") {
      message.error(t('setting.searchService.apiKeyRequired'))
      return
    }
  } else if (selectedConfig.value.provider_name == "Cloudsway"){
    config.type = "cloudsway"
    config.api_key = selectedConfig.value.base_config.api_key;
    config.endpoint = selectedConfig.value.base_config.endpoint;
    if (config.api_key == ""){
      message.error(t('setting.searchService.accessKeyRequired'))
      return
    }else if (config.endpoint == ""){
      message.error(t('setting.searchService.endpointRequired'))
      return
    }
    
  }else {
    config.type = "local"
    config.engine = selectedConfig.value.provider_name;
  }
  console.log(selectedConfig.value)
  checkLoading.value = true
  let res = await searchEngineService.checkSearchProvider(config)
  checkLoading.value = false
  if (res.status != "fail") {
    message.success(selectedConfig.value.provider_name+' '+ t('setting.searchService.checkSearchEngineSuccess'))
    // message.success(res.message)
  } else {
    message.error(selectedConfig.value.provider_name+' '+ t('setting.searchService.checkSearchEngineFailed'))
  }
}

const step1 = async () => {
  tourDriver = driver({
    animate: true,
    showProgress: true,
    prevBtnText: t('setting.prevStep'),
    nextBtnText: t('setting.nextStep'),
    doneBtnText: t('setting.doneStep'),
    steps: [
      {
        element: '#searchTemplates',
        popover: {
          side: 'bottom',
          title: t('setting.searchService.searchService'),
          description: t('setting.searchService.searchEngineTipsOne'),
          onNextClick: async () => {
            nextTick(() => {
              tourDriver.moveNext();
            });
          },
        }
      },
      {
        element: '.search-choose-api-input',
        popover: {
          side: 'bottom',
          title: t('setting.searchService.searchService'),
          description: t('setting.searchService.searchEngineTipsTwo'),
          onNextClick: async () => {
            nextTick(() => {
              // è®¾ç½®ç¼“å­˜ï¼Œç»“æŸå¼•å¯¼
              localStorage.setItem('tour_end', 'true');
              tourDriver.moveNext();
              emitter.emit('onDefaultModelSetting');
            });
          },
        }
      }
    ]
  });

  tourDriver.drive();
};

async function handleTemplateChange(name) {
  //1.find the id of name
  const provider_id = searchTemplates.value.find(item => item.name === name).id
  //2.update the id of user selected
  try {
    await searchEngineService.updateSearchEngineConfig(
        {
          provider_id: provider_id,
          // api_key: selectedConfig.value.base_config.api_key,
          include_date: selectedConfig.value.include_date,
          cover_provider_search: selectedConfig.value.cover_provider_search,
          enable_enhanced_mode: selectedConfig.value.enable_enhanced_mode,
          result_count: selectedConfig.value.result_count,
          blacklist: selectedConfig.value.blacklist
        }
    )
  }catch (e){
    message.error(t('update platform failed'))
    return
  }
  //3.find the config of the id
  const configs = await searchEngineService.getSearchEngineConfigs()
  const config = configs.find(item => item.provider_id === provider_id)
  //4.update status
  selectedConfig.value.base_config = config.base_config || {api_key: '',endpoint: ''}
  selectedConfig.value.provider_id = provider_id || -1
  selectedConfig.value.provider_name = name || ''
}

//  display name function
function displayName(name) {
  if (name === 'Tavily') {
    return t('setting.searchService.tavilyName')
  } else if (name === 'Baidu') {
    return t('setting.searchService.baiduName')
  } else if (name === 'Bing') {
    return t('setting.searchService.bingName')
  } else if (name === 'Cloudsway') {
    return t('setting.searchService.couldswayName')
  }
  return name
}


onMounted(async () => {
  if (localStorage.getItem('tour') === 'true' && localStorage.getItem('tour_end') !== 'true') {
    step1();
  }
  try {
    searchTemplates.value = await searchEngineService.getSearchEngineTemplates()
    loading.value = false

    try {
      const userConfig = await searchEngineService.getSearchEngineConfig()
      // console.log('userConfig', userConfig)
      if (userConfig.provider_name) {
        selectedTemplate.value = userConfig.provider_name
        selectedConfig.value = {
          ...userConfig
        }
        if (userConfig.provider_name === 'Tavily') {
          selectedConfig.value.base_config = {
            api_key: ""
          }
          selectedConfig.value.base_config.api_key = userConfig?.base_config?.api_key || "";
        } else if (userConfig.provider_name === 'Cloudsway') {
          selectedConfig.value.base_config = {
            api_key: "",
            endpoint: ""
          }
          selectedConfig.value.base_config.api_key = userConfig?.base_config?.api_key || "";
          selectedConfig.value.base_config.endpoint = userConfig?.base_config?.endpoint || "";
        } else {
          selectedConfig.value.base_config = {}
        }
      } else {
        selectedTemplate.value = 'Tavily'
      }
    } catch (error) {
      console.error('Failed to fetch user config:', error)
      selectedTemplate.value = 'Tavily'
    }
  } catch (error) {
    console.error('Failed to fetch templates:', error)
    loading.value = false
  }
})


onUnmounted(() => {
  handleSave()
})
// save function
const handleSave = async () => {
  try {
    //åˆ¤æ–­å½“å‰çš„æœç´¢æœåŠ¡
    console.log("å½“å‰ä¿å­˜", selectedConfig.value)
    if (selectedConfig.value.provider_name === "Tavily") {
      await searchEngineService.updateSearchEngineConfig({
        provider_id: selectedConfig.value.provider_id,
        api_key: selectedConfig.value.base_config.api_key,
        include_date: selectedConfig.value.include_date,
        cover_provider_search: selectedConfig.value.cover_provider_search,
        enable_enhanced_mode: selectedConfig.value.enable_enhanced_mode,
        result_count: selectedConfig.value.result_count,
        blacklist: selectedConfig.value.blacklist
      })
    } else if (selectedConfig.value.provider_name === 'Cloudsway') {
      await searchEngineService.updateSearchEngineConfig({
        provider_id: selectedConfig.value.provider_id,
        api_key: selectedConfig.value.base_config.api_key,
        endpoint: selectedConfig.value.base_config.endpoint,
        include_date: selectedConfig.value.include_date,
        cover_provider_search: selectedConfig.value.cover_provider_search,
        enable_enhanced_mode: selectedConfig.value.enable_enhanced_mode,
        result_count: selectedConfig.value.result_count,
        blacklist: selectedConfig.value.blacklist
      })
    } else {
      await searchEngineService.updateSearchEngineConfig({
        provider_id: selectedConfig.value.provider_id,
        include_date: selectedConfig.value.include_date,
        cover_provider_search: selectedConfig.value.cover_provider_search,
        enable_enhanced_mode: selectedConfig.value.enable_enhanced_mode,
        result_count: selectedConfig.value.result_count,
        blacklist: selectedConfig.value.blacklist
      })
    }
    // message.success(t('setting.searchService.saveBlacklistSuccess'))
  } catch (error) {
    console.error('Failed to save config:', error)
    message.error(t('setting.searchService.saveBlacklistFailed'))
  }
}


</script>

<style scoped lang="scss">
.search-container {
  //padding: auto;
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.slider {
  width: 30%;
}

.search-item {
  padding: 16px;
  background-color: rgb(254, 254, 254);
  width: 100%;
  border: 1px solid #c6c6c6;
  border-radius: 10px;
  font-size: 15px;
}

.search-backlist-subscription-content {
  margin-bottom: 12px;
}

.search-blacklist-list {
  margin-bottom: 12px;
}

.search-rule-header {
  marginĞ·Ğ¾Ñ€: 12px;
}

.search-choose {
  display: flex;
  flex-direction: column;
  height: 100%;
  width: 100%;
}

:deep(.ant-select-selector) {
  height: 45px !important;
  display: flex;
  align-items: center;
}

:deep(.ant-select-selection-item) {
  display: flex;
  align-items: center;
  height: 100%;
}

:deep(.ant-select-selection-item .select-option-content) {
  display: flex;
  align-items: center;
  gap: 8px;
}

.search-choose-header {
  margin-bottom: 12px;
}

.search-choose-list {
  width: 100%;
  display: flex;
  flex-direction: row;
  gap: 16px;
  align-items: center;

  #searchTemplates {
    width: 100%;
  }
}

.search-choose-api-config {
  font-size: 15px;
  display: flex;
  align-items: center;
  flex-direction: row;
  gap: 10px;
  width: 100%;
}

.get-api-link {
  margin-left: 5px;
  margin-top: 5px;
  font-size: 11px;
  color: #1890ff;
}

.search-choose-api-input {
  height: 100%;
}

p {
  font-size: 14px;
  color: #585858;
}

.search-bool-item {
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  width: 100%;
  border-bottom: #dfdfdf 1px solid;
  margin-bottom: 12px;
  padding-bottom: 12px;
}

.search-slider-item {
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  align-items: center;
  width: 100%;
}

.search-slider-item p {
  width: 100%;
}

.tips {
  color: #888888;
  font-size: small;
  margin-top: 5px;
}

.search-blacklist-save-button {
  color: rgb(50, 50, 50);
  background-color: #fff;
  border: #d2cece 1px solid;
}

.search-backlist-subscription-header {
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 12px;
}

.centered-modal {
  display: flex;
  align-items: center;
  justify-content: center;
}

:deep(.centered-modal .ant-modal) {
  top: 0;
  padding-bottom: 0;
  margin: 0;
}

@media screen and (max-width: 768px) {
  .search-choose-list {
    flex-direction: column;
  }

  .search-choose-list div:first-child {
    width: 100% !important;
  }

  .search-choose-list div:last-child {
    width: 100% !important;
  }

  .search-choose-api-config {
    flex-direction: column;
    align-items: flex-start !important;
  }

  :deep(.ant-select-selector) {
    height: 100% !important;
  }

  .search-number {
    flex-direction: column;
    align-items: flex-start !important;
  }

  .slider {
    width: 100% !important;
  }

  .search-backlist-subscription-delete-container {
    flex-direction: column;

    button {
      margin-bottom: 12px;
    }
  }
}

.select-option-content {
  display: flex;
  align-items: center;
  gap: 8px;
}

.logo {
  width: 18px;
  height: 18px;
}
</style>


================================================
FILE: frontend/src/components/terminal/index.vue
================================================
<template>
  <div class="container">
    <div class="terminal-header">
      <span>å‘½ä»¤è¡Œç»ˆç«¯</span>
      <!-- <CloseOutlined @click="visible = false" /> -->
    </div>
    <div ref="terminalRef" class="terminal-container"></div>
  </div>
</template>

<script setup>
import { ref, onMounted, watch } from 'vue'
import { Terminal } from '@xterm/xterm'
import { FitAddon } from 'xterm-addon-fit'
import '@xterm/xterm/css/xterm.css'
import { CloseOutlined } from '@ant-design/icons-vue'
import { useChatStore } from '@/store/modules/chat'
const chatStore = useChatStore()

import emitter from '@/utils/emitter';

const terminalRef = ref(null)
let terminal = null
let currentLine = ''
let commandHistory = []
let historyIndex = -1
const visible = ref(false)

const props = defineProps({
  isPreview: {
    type: Boolean,
    default: false
  },
  content: {
    type: [Array,String],
    default: ''
  }
})

emitter.on('terminal-visible', (value) => {
  visible.value = value
})

const saveHistory = () => {
  console.log('commandHistory', commandHistory)
  localStorage.setItem('terminalHistory', JSON.stringify(commandHistory))
}

// å¤„ç†å‘½ä»¤çš„å‡½æ•°
const handleCommand = async (command) => {
  switch (command.trim()) {
    case 'help':
      terminal.writeln('Available commands:')
      terminal.writeln('  help     - Show this help message')
      terminal.writeln('  clear    - Clear the terminal')
      terminal.writeln('  echo     - Echo the input')
      terminal.writeln('  history  - Show command history')
      terminal.writeln('  server   - Send command to server')
      break
    case 'clear':
      terminal.clear()
      break
    case 'history':
      commandHistory.forEach((cmd, index) => {
        terminal.writeln(`${index + 1}  ${cmd}`)
      })
      break
    case '':
      break
    default:
      if (command.startsWith('echo ')) {
        terminal.writeln(command.slice(5))
      } else {
        await sendToServer(command)
      }
  }
  saveHistory()
}

watch(
  () => props.content,
  (newVal) => {
    if(newVal){
      //æ¸…ç©ºç»ˆç«¯
      terminal.clear();
      terminal.write("\x1b[0m" + newVal);
      terminal.write("\r\n");
      terminal.write("\r\n\x1b[32mubuntu@sandbox:~ $ \x1b[0m");
    }
  }
);

// ä¿®æ”¹ï¼šå‘é€å‘½ä»¤åˆ°æœåŠ¡å™¨
const sendToServer = async (command) => {
  const actionOptions = {
    action: "run",
    args: {
      command: command,
      is_input: false,
      thought: "",
      blocking: false,
      hidden: false,
      confirmation_state: "confirmed"
    }
  }
  chatStore.socket.emit('oh_user_action', actionOptions)
}

onMounted(() => {
  terminal = new Terminal({
    cursorBlink: true,
    fontSize: 14,
    fontFamily: 'Menlo, Monaco, "Courier New", monospace',
    theme: {
      background: '#1e1e1e',
      green: 'rgb(0, 187, 0)', // è‡ªå®šä¹‰ç»¿è‰² (ç”¨äºæç¤ºç¬¦)
    },
    wordWrap: true,
  })
  const fitAddon = new FitAddon();
  terminal.loadAddon(fitAddon);

    // ç›‘å¬çª—å£å¤§å°å˜åŒ–
  window.addEventListener('resize', () => {
        fitAddon.fit(); // æ­£ç¡®è°ƒç”¨ fitAddon å®ä¾‹çš„ fit æ–¹æ³•
  });

  terminal.open(terminalRef.value)
  if(props.isPreview){
    terminal.write("\x1b[32mubuntu@sandbox:~ $ \x1b[0m" + props.content[0]);
    terminal.write("\r\n" + props.content[1]);
    terminal.write("\r\n\x1b[32mubuntu@sandbox:~ $ \x1b[0m");
  }else{
    terminal.write('Welcome to the terminal!\r\n$ ')
  }


  emitter.on('terminal', (value) => {
    if (value.type == 'command') {
      terminal.writeln(`${value.content}`)
    }
    if (value.type == 'observation') {
      terminal.writeln(value.content + '\n')
      terminal.write('$ ')
    }
  })

  // å¤„ç†é”®ç›˜è¾“å…¥
  terminal.onKey(({ key, domEvent }) => {
    const printable = !domEvent.altKey && !domEvent.ctrlKey && !domEvent.metaKey
    if (domEvent.keyCode === 13) { // Enter
      terminal.write('\r\n')
      handleCommand(currentLine)
      commandHistory.push(currentLine)
      historyIndex = commandHistory.length
      currentLine = ''
      terminal.write('$ ')
    } else if (domEvent.keyCode === 8) { // Backspace
      if (currentLine.length > 0) {
        currentLine = currentLine.slice(0, -1)
        terminal.write('\b \b')
      }
    } else if (domEvent.keyCode === 38) { // Up arrow
      if (historyIndex > 0) {
        historyIndex--
        currentLine = commandHistory[historyIndex]
        terminal.write('\r\x1b[K$ ' + currentLine)
      }
    } else if (domEvent.keyCode === 40) { // Down arrow
      if (historyIndex < commandHistory.length - 1) {
        historyIndex++
        currentLine = commandHistory[historyIndex]
        terminal.write('\r\x1b[K$ ' + currentLine)
      } else {
        historyIndex = commandHistory.length
        currentLine = ''
        terminal.write('\r\x1b[K$ ')
      }
    } else if (printable) {
      currentLine += key
      terminal.write(key)
    }
  })
})
</script>

<style lang="scss" scoped>
.container {
  flex: 1;
  display: flex;
  flex-direction: column;
  margin: 20px;
  border-radius: 12px;
  background-color: #1e1e1e;
  box-shadow: 0 2px 12px rgba(0, 0, 0, 0.1);
  overflow: hidden;
}

.terminal-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 12px;
  background-color: #2d2d2d;
  color: #fff;
  cursor: pointer;
  user-select: none;
  border-bottom: 1px solid #3d3d3d;

  &:hover {
    background-color: #363636;
  }
}

.terminal-icon {
  font-size: 12px;
}

.terminal-container {
  display: flex;
  flex: 1;
  width: 100%;
  padding: 10px;
  transition: height 0.3s ease;
}

.terminal-collapsed {
  height: 0;
  overflow: hidden;
}
</style>


================================================
FILE: frontend/src/components/terminal/siderTerminal.vue
================================================
<template>
    <div class="container">
        <div ref="terminalRef" class="terminal-container">

        </div>
    </div>
</template>

<script setup>
import { ref, onMounted } from 'vue'
import { Terminal } from '@xterm/xterm'
import '@xterm/xterm/css/xterm.css'
import { useChatStore } from '@/store/modules/chat'
const chatStore = useChatStore()

import emitter from '@/utils/emitter';

const terminalRef = ref(null)
let terminal = null
let currentLine = ''
let commandHistory = []
let historyIndex = -1

const saveHistory = () => {
    console.log('commandHistory', commandHistory)
    localStorage.setItem('terminalHistory', JSON.stringify(commandHistory))
}

// å¤„ç†å‘½ä»¤çš„å‡½æ•°
const handleCommand = async (command) => {
    switch (command.trim()) {
        case 'help':
            terminal.writeln('Available commands:')
            terminal.writeln('  help     - Show this help message')
            terminal.writeln('  clear    - Clear the terminal')
            terminal.writeln('  echo     - Echo the input')
            terminal.writeln('  history  - Show command history')
            terminal.writeln('  server   - Send command to server')
            break
        case 'clear':
            terminal.clear()
            break
        case 'history':
            commandHistory.forEach((cmd, index) => {
                terminal.writeln(`${index + 1}  ${cmd}`)
            })
            break
        case '':
            break
        default:
            if (command.startsWith('echo ')) {
                terminal.writeln(command.slice(5))
            } else {
                await sendToServer(command)
            }
    }
    saveHistory()
}

// ä¿®æ”¹ï¼šå‘é€å‘½ä»¤åˆ°æœåŠ¡å™¨
const sendToServer = async (command) => {
    const actionOptions = {
        action: "run",
        args: {
            command: command,
            is_input: false,
            thought: "",
            blocking: false,
            hidden: false,
            confirmation_state: "confirmed"
        }
    }
    chatStore.socket.emit('oh_user_action', actionOptions)
}

onMounted(() => {
    terminal = new Terminal({
        fontSize: 14, // å­—ä½“å¤§å°
        fontFamily: 'Menlo, Monaco, "Courier New", monospace',
        cursorStyle: 'bar', // å…‰æ ‡æ ·å¼
        cursorWidth: 7, // å…‰æ ‡å®½åº¦
        // scrollback: 1000, // æ»šåŠ¨å›é€€
        scrollback: 0, // ç¦ç”¨æ»šåŠ¨å›é€€
        theme: {
            background: '#f8f8f7',
            foreground: '#000000',
            cursor: '#888888',
            selection: '#000000',
            selectionBackground: '#555555',
        }
    })

    terminal.open(terminalRef.value)

    emitter.on('terminal', (value) => {
        if (value.type == 'command') {
            terminal.writeln(`${value.content}`)
        }
        if (value.type == 'observation') {
            terminal.writeln(value.content + '\n')
            terminal.write('$ ')
        }
    })

    // å¤„ç†é”®ç›˜è¾“å…¥
    terminal.onKey(({ key, domEvent }) => {
        const printable = !domEvent.altKey && !domEvent.ctrlKey && !domEvent.metaKey
        if (domEvent.keyCode === 13) { // Enter
            terminal.write('\r\n')
            handleCommand(currentLine)
            commandHistory.push(currentLine)
            historyIndex = commandHistory.length
            currentLine = ''
            terminal.write('$ ')
        } else if (domEvent.keyCode === 8) { // Backspace
            if (currentLine.length > 0) {
                currentLine = currentLine.slice(0, -1)
                terminal.write('\b \b')
            }
        } else if (domEvent.keyCode === 38) { // Up arrow
            if (historyIndex > 0) {
                historyIndex--
                currentLine = commandHistory[historyIndex]
                terminal.write('\r\x1b[K$ ' + currentLine)
            }
        } else if (domEvent.keyCode === 40) { // Down arrow
            if (historyIndex < commandHistory.length - 1) {
                historyIndex++
                currentLine = commandHistory[historyIndex]
                terminal.write('\r\x1b[K$ ' + currentLine)
            } else {
                historyIndex = commandHistory.length
                currentLine = ''
                terminal.write('\r\x1b[K$ ')
            }
        } else if (printable) {
            currentLine += key
            terminal.write(key)
        }
    })
})
</script>

<style lang="scss" scoped>
.container {
    display: flex;
    flex-direction: column;
    // max-width: 500px;
    /* å®½åº¦å æ»¡çˆ¶å®¹å™¨ */
    height: 100%;
    /* é«˜åº¦å æ»¡çˆ¶å®¹å™¨ */
    overflow: hidden;
    /* é˜²æ­¢å†…å®¹æº¢å‡º */
    // background-color: aqua;
}

.terminal-container {
    padding: 5px;
    width: 100%;
    /* å®½åº¦ä¸èƒ½è¶…è¿‡çˆ¶å®¹å™¨ */
    height: 100%;
    /* é«˜åº¦å æ»¡çˆ¶å®¹å™¨ */
    overflow: hidden;
    overflow-y: hidden;
    /* é˜²æ­¢å†…å®¹æº¢å‡º */

    /* éšè— xterm.js çš„æ»šåŠ¨æ¡ */
.xterm {
  &::-webkit-scrollbar {
    display: none; /* éšè—æ»šåŠ¨æ¡ */
  }}
}
</style>


================================================
FILE: frontend/src/components/vscode/fileTree.vue
================================================
<template>
  <div class="files-container">
      <div class="file-tree-container">
        <div v-for="item in items" :key="item" class="file-item">
          <!-- æ¸²æŸ“å›¾æ ‡ -->
        <div :class="['file-entry', { 'is-directory': isDirectory(item) }]" @click.stop="handleClick(item)">
          <span class="file-icon">{{ getFileIcon(item) }}</span>
          <span class="file-name">{{ getFileName(item) }}</span>
        </div>

        <div v-if="isDirectory(item) && expandedDirs[fullPath(item)]" class="subdirectory">
          <file-tree
            :items="subDirectories[fullPath(item)] || []" :base-path="fullPath(item)" :conversation-id="conversationId"
            @item-click="emit('item-click', $event)" />
        </div>
      </div>
      </div>
  </div>
</template>

<script setup>
import { ref, reactive, onMounted } from 'vue';
import service from '@/services/workspace';
import { useChatStore } from '@/store/modules/chat'
import emitter from '@/utils/emitter'
// å®šä¹‰ props
const props = defineProps({
  items: {
    type: Array,
    default: () => []
  },
  basePath: {
    type: String,
    default: ''
  },
  conversationId: {
    type: String,
    default: () => useChatStore().conversationId
  }
});



const expandedDirs = reactive({});
const subDirectories = reactive({});
const loadingSubDir = reactive({});

function isDirectory(path) {
  return path.endsWith('/');
}

function getFileName(path) {
  // è·å–è·¯å¾„çš„æœ€åä¸€ä¸ªéƒ¨åˆ†ä½œä¸ºæ–‡ä»¶å
  const cleanPath = path.replace(/\/$/, '');
  const parts = cleanPath.split('/');
  return parts[parts.length - 1] || cleanPath;
}

function fullPath(item) {
  // è§„èŒƒåŒ–è·¯å¾„ï¼Œå¹¶ä¸basePathç»„åˆ
  return item;
}

function getFileIcon(path) {
  // æ ¹æ®è·¯å¾„è·å–æ–‡ä»¶ç±»å‹å›¾æ ‡
  const fullItemPath = fullPath(path);// å®Œæ•´çš„è·¯å¾„
  if (isDirectory(path)) {
    // å¦‚æœæ˜¯ç›®å½•,æ ¹æ®æ˜¯å¦å±•å¼€æ¥è¿”å›ä¸åŒçš„å›¾æ ‡
    return expandedDirs[fullItemPath] ? 'ğŸ“‚' : 'ğŸ“';
  }
  // è·å–æ–‡ä»¶æ‰©å±•å
  const extension = path.split('.').pop().toLowerCase();
  switch (extension) {
    case 'js': return 'ğŸ“œ';
    case 'vue': return 'ğŸŸ¢';
    case 'html': return 'ğŸŒ';
    case 'css': return 'ğŸ¨';
    case 'json': return 'âš™ï¸';
    case 'md': return 'ğŸ“';
    default: return 'ğŸ“„';
  }
}

async function handleClick(item) {
  
  const path = fullPath(item);
  if (isDirectory(item)) {
    if (!expandedDirs[path]) {
      expandedDirs[path] = true;
      await loadSubDirectory(path);
    } else {
      expandedDirs[path] = false;
    }
  }else{
    emitter.emit('file-path', path)
  }
  
}
// åŠ è½½å­ç›®å½•
async function loadSubDirectory(dirPath) {
  if (dirPath in subDirectories) {
    console.log(`${dirPath} å·²åŠ è½½è¿‡ï¼Œç›´æ¥ä½¿ç”¨ç¼“å­˜:`, subDirectories[dirPath]);
    return;
  }
  loadingSubDir[dirPath] = true;
  try {
    console.log(props.conversationId)
    const result = await service.getFiles(props.conversationId, dirPath);
    // console.log(`åŠ è½½ ${dirPath} çš„åŸå§‹ç»“æœ:`, result);
    let normalizedResult = [];
    if (Array.isArray(result)) {
      normalizedResult = result;
    } else if (result && typeof result === 'object') {
      normalizedResult = [];
    } else {
      console.warn(`${dirPath} è¿”å›çš„æ•°æ®æ ¼å¼å¼‚å¸¸:`, result);
      normalizedResult = [];
    }
    subDirectories[dirPath] = normalizedResult;
    // console.log(`è§„èŒƒåŒ–åçš„ ${dirPath} æ•°æ®:`, normalizedResult);
    // console.log('æ›´æ–°åçš„ subDirectories:', subDirectories);
  } catch (err) {
    // console.error('åŠ è½½å­ç›®å½•å¤±è´¥:', err);
    subDirectories[dirPath] = [];
  } finally {
    loadingSubDir[dirPath] = false;
  }
}

// // åˆå§‹åŠ è½½æ ¹ç›®å½•
// onMounted(async () => {
//   // error.value = null;
// });
</script>

<style scoped>
.files-container{
  display: flex;
  flex-direction: column;
}
/* .file-tree-container{
  display: flex;
  flex-direction: column;
} */

.file-entry {
  display: flex;
  align-items: center;
  /* padding: 5px 8px; */
  border-radius: 4px;
  cursor: pointer;
  transition: background-color 0.2s;
}

.file-entry:hover {
  background-color: #646464;
}

.file-icon {
  margin-right: 6px;
  width: 16px;
  text-align: center;
}
/* 
.is-directory {
  font-weight: 500;
} */

.subdirectory {
  margin-left: 16px;
  border-left: 1px dashed #ccc;
  padding-left: 8px;
}
</style>


================================================
FILE: frontend/src/components/vscode/index.vue
================================================
<template>
    <div class="vscode-container" v-show="visible">
        <div class="vscode-header">
            <span>æ–‡ä»¶æµè§ˆå™¨</span>
            
            <CloseOutlined @click="visible = false" />
        </div>
        <div class="vscode-explorer">

            <div class="file-list">
                <fileTree class="file-menu" :items="files"/>
                <div class="vscode-show">
                    <a-button class="vscode-button" type="primary" @click="handleOpenVsCode">
                        <AlignLeftOutlined /> Open in VSCode
                    </a-button>
                </div>
            </div>
            <div class="file-content">
                <pre><code :class="codeLanguage" v-html="highlightedCode"></code></pre>
            </div>
        </div>
    </div>
</template>

<script setup>
import { AlignLeftOutlined } from '@ant-design/icons-vue'
import { ref, onMounted } from 'vue'
import emitter from '@/utils/emitter'
import { useChatStore } from '@/store/modules/chat'
import service from '@/services/workspace'
import { CloseOutlined } from '@ant-design/icons-vue'
import fileTree from '@/components/vscode/fileTree.vue'
import hljs from 'highlight.js'
import 'highlight.js/styles/vs2015.css'
const conversationId = ref('')
// ä»useChatStoreè·å–conversationId
conversationId.value = useChatStore().conversationId
const files = ref([])
const visible = ref(false)
const vscodeUrl = ref('')
const file_content = ref('')
const oldFilePath = ref('')
const codeLanguage = ref('')
const highlightedCode = ref('')

// æ ¹æ®æ–‡ä»¶åç¼€è·å–è¯­è¨€
function getLanguageFromPath(path) {
    const ext = path.split('.').pop()?.toLowerCase()
    const languageMap = {
        'js': 'javascript',
        'jsx': 'javascript',
        'ts': 'typescript',
        'tsx': 'typescript',
        'html': 'html',
        'css': 'css',
        'scss': 'scss',
        'less': 'less',
        'json': 'json',
        'md': 'markdown',
        'py': 'python',
        'java': 'java',
        'cpp': 'cpp',
        'c': 'c',
        'go': 'go',
        'rs': 'rust',
        'sh': 'bash',
        'yaml': 'yaml',
        'yml': 'yaml',
        'xml': 'xml',
        'sql': 'sql',
        'php': 'php',
        'rb': 'ruby',
        'kt': 'kotlin',
        'swift': 'swift',
        'dart': 'dart',
        'vue': 'javascript'
    }
    return languageMap[ext] || 'plaintext'
}


// åŠ è½½æ ¹ç›®å½•æ–‡ä»¶åˆ—è¡¨
async function loadRootFiles() {
  try {
    const result = await service.getFiles(conversationId.value, '')
    files.value = Array.isArray(result) ? result : []
  } catch (err) {
    // console.error('åŠ è½½æ ¹ç›®å½•æ–‡ä»¶å¤±è´¥:', err)
    files.value = []
  }
}

const handleOpenVsCode = () => {
    // æ‰“å¼€vscode
    window.open(vscodeUrl.value)
}





emitter.on('vscode-visible', (value) => {
    visible.value = value
    loadRootFiles()
    try {
        //å‘é€è¯·æ±‚è·å–urlå¹¶è§£æ
        service.getVsCodeUrl(conversationId.value).then((res) => {
            vscodeUrl.value = res.vscode_url // è·å–url
        })
    } catch (error) {
        console.log(error);
    }
})

emitter.on('file-path', (path) => {
    if (path === oldFilePath.value) {
        // console.log('same path');
        return 
    }
    service.getFile(conversationId.value,path).then((res) => {
        file_content.value = res.code
        oldFilePath.value = path
        codeLanguage.value = getLanguageFromPath(path)
        try {
            const highlighted = hljs.highlight(res.code, {
                language: codeLanguage.value
            })
            highlightedCode.value = highlighted.value
        } catch (e) {
            console.error('ä»£ç é«˜äº®å¤±è´¥:', e)
            highlightedCode.value = res.code
        }
    })
})


onMounted(async() => {
})

</script>



<style scoped>
.file-list{
    display: flex;
    flex-direction: column;
    width: 100px;
    flex:2;
    overflow-x: hidden;
}

.file-content{
    
    width: 400px;
    flex: 3;
    overflow-x: hidden;
    background-color: #ffffff;
    padding: 10px;
    border-radius: 5px;
    overflow: auto;
}


.file-menu{
    flex: 9;
    /* border: 1px solid black; */
}
.vscode-show{
    display: flex;
    flex: 1;
    justify-content: center;
}

.vscode-container {
    flex: 2;
    height: 100%;
    width: 100%; 
    margin-bottom: 20px;
}

.vscode-header {
    /* margin: 10px; */
    /* æ·»åŠ åŸè§’ */
    margin: 15px;
    padding: 5px;
    display: flex;
    gap: 12px;
    align-items: center;
    justify-content: space-between;
    border-radius: 5px;
    display: flex;
    background-color: #595959;
}
.vscode-explorer {
    display: flex;
    flex-direction: row;
    /* è·ç¦»åº•è¾¹20px */
    margin-bottom: 20px;
    height: 90%;
    margin-bottom: 10px;
    background-color: #dbdbdb;
    margin: 15px;
    border-radius: 5px;
    padding: 5px;

}

.file-list{
    flex: 1;
    background-color: #c9c9c9;
}



.file-content pre {
    margin: 0;
    padding: 0;
}

.file-content code {
    font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
    font-size: 14px;
    line-height: 1.5;
    white-space: pre;
}


.file-menu{
    overflow: auto;
}


.vscode-button{
    padding: 5px;

}
</style>


================================================
FILE: frontend/src/locals/index.js
================================================
// index.js
import { createI18n } from 'vue-i18n'
import en from './lang/en'
import zh from './lang/zh'
import de from './lang/de'
import es from './lang/es'
import fr from './lang/fr'
import ja from './lang/ja'
import kr from './lang/kr'
import pt from './lang/pt'
import tr from './lang/tr'
import tw from './lang/tw'
import vi from './lang/vi'

const messages = {
  en,
  zh,
  de,
  es,
  fr,
  ja,
  kr,
  pt,
  tr,
  tw,
  vi
}
const language = (navigator.language || 'en').toLocaleLowerCase() // è¿™æ˜¯è·å–æµè§ˆå™¨çš„è¯­è¨€
const i18n = createI18n({
  locale: localStorage.getItem('lang') || language.split('-')[0] || 'en', // é¦–å…ˆä»ç¼“å­˜é‡Œæ‹¿ï¼Œæ²¡æœ‰çš„è¯å°±ç”¨æµè§ˆå™¨è¯­è¨€ï¼Œ
  // locale: 'en', // é¦–å…ˆä»ç¼“å­˜é‡Œæ‹¿ï¼Œæ²¡æœ‰çš„è¯å°±ç”¨æµè§ˆå™¨è¯­è¨€ï¼Œ
  fallbackLocale: 'en', // è®¾ç½®å¤‡ç”¨è¯­è¨€
  messages,
  legacy: false, // å¤„ç† Uncaught SyntaxError: Not available in legacy mode çš„é—®é¢˜
})

export default i18n




================================================
FILE: frontend/src/locals/lang/de.js
================================================
export default {
  //ç™»å½•ç•Œé¢
  auth: {
    loginToLemonAI: "Bei LemonAI anmelden",
    registerLemonAIAccount: "LemonAI-Konto registrieren",
    verifyEmail: "E-Mail verifizieren",
    resetPassword: "Passwort zurÃ¼cksetzen",
    loginWithGoogle: "Mit Google anmelden",
    registerWithGoogle: "Mit Google registrieren",
    login: "Anmelden",
    register: "Registrieren",
    logOut: "Abmelden",
    forgotPassword: "Passwort vergessen",
    resetPasswordButton: "Passwort zurÃ¼cksetzen",
    backToLogin: "ZurÃ¼ck zur Anmeldung",
    verifyEmailButton: "E-Mail verifizieren",
    resendCode: "Code erneut senden",
    email: "E-Mail",
    password: "Passwort",
    fullname: "VollstÃ¤ndiger Name",
    codeSentTo: "Code gesendet an",
    pleaseInputEmail: "Bitte E-Mail eingeben",
    pleaseInputValidEmail: "Bitte gÃ¼ltige E-Mail eingeben",
    pleaseInputPassword: "Bitte Passwort eingeben",
    pleaseInputFullname: "Bitte vollstÃ¤ndigen Namen eingeben",
    pleaseInputVerifyCode: "Bitte Verifizierungscode eingeben",
    pleaseInputNewPassword: "Bitte neues Passwort eingeben",
    pleaseConfirmPassword: "Bitte Passwort bestÃ¤tigen",
    pleaseInput6DigitCode: "Bitte 6-stelligen Code eingeben",
    or: "oder",
    noAccount: "Kein Konto?",
    haveAccount: "Bereits ein Konto?",
    notReceivedCode: "Code nicht erhalten?",
    codeSent: "Code gesendet",
    registrationSuccessful: "Registrierung erfolgreich, bitte anmelden",
    verificationCodeError: "Verifizierungscode falsch, bitte erneut versuchen",
    doNotSendFrequently: "Bitte senden Sie den Code nicht zu hÃ¤ufig",
    codeResent: "Code wurde erneut gesendet",
    loginSuccessful: "Anmeldung erfolgreich",
    loginFailed: "Anmeldung fehlgeschlagen, bitte E-Mail und Passwort Ã¼berprÃ¼fen",
    fillCompleteInfo: "Bitte vollstÃ¤ndige Registrierungsinformationen eingeben",
    pleaseEnterValidEmail: "Bitte eine gÃ¼ltige E-Mail-Adresse eingeben",
    passwordTooShort: "Passwort muss mindestens 6 Zeichen lang sein",
    registrationFailed: "Registrierung fehlgeschlagen, bitte Eingabe Ã¼berprÃ¼fen",
    pleaseInputCode: "Bitte Code eingeben",
    passwordsDoNotMatch: "PasswÃ¶rter stimmen nicht Ã¼berein",
    passwordResetSuccessful: "Passwort erfolgreich zurÃ¼ckgesetzt, bitte anmelden",
    passwordResetFailed: "PasswortrÃ¼cksetzung fehlgeschlagen, bitte Eingabe Ã¼berprÃ¼fen",
    googleLoginFailed: "Google-Anmeldung fehlgeschlagen, bitte spÃ¤ter versuchen",
    appleLoginInProgress: "Apple-Anmeldefunktion in Entwicklung",
    googleRegisterInProgress: "Google-Registrierungsfunktion in Entwicklung",
    appleRegisterInProgress: "Apple-Registrierungsfunktion in Entwicklung",
    verifyingGoogleLogin: "Google-Anmeldung wird Ã¼berprÃ¼ft"
  },
  //ä¸»ç•Œé¢
  lemon: {
    // é¦–é¡µ
    welcome: {
      greeting: "Hallo",
      question: "Was kann ich fÃ¼r dich tun?",
      tabs: {
        featured: "Empfohlen",
        research: "Forschung",
        lifestyle: "Lifestyle",
        dataAnalysis: "Datenanalyse",
        education: "Bildung",
        productivity: "ProduktivitÃ¤t",
        other: "Sonstiges"
      },
      placeholder: "Womit kann ich Ihnen behilflich sein?",
      communityNote: "Alle in der Community angezeigten Aufgaben und Websites werden von Nutzern freiwillig geteilt. Die Plattform zeigt keine Inhalte ohne Zustimmung des Nutzers."
    },
    //å¯¹è¯å¤´éƒ¨
    chatHeader: {
      share: "Teilen",
      viewAllFiles: "Alle Dateien in dieser Aufgabe anzeigen",
      moreOptions: "Weitere Optionen",
      rename: "Umbenennen",
      editTitle: "Titel bearbeiten",
      enterNewTitle: "Neuen Titel eingeben",
      cancel: "Abbrechen",
      confirm: "BestÃ¤tigen",
      favorite: "Zu Favoriten hinzufÃ¼gen",
      unfavorite: "Aus Favoriten entfernen"
    },
    //æ¶ˆæ¯å¯¹è¯åˆ—è¡¨é¡µ
    message: {
      runCommand: "Bash-Befehl ausfÃ¼hren",
      readFile: "Datei lesen",
      editFile: "Datei bearbeiten",
      Browse: "Durchsuchen",
      searching: "Suchen",
      minutesAgo: "Minuten zuvor",
      secondsAgo: "Sekunden zuvor",
      hoursAgo: "Stunden zuvor",
      daysAgo: "Tage zuvor",
      monthsAgo: "Monate zuvor",
      yearsAgo: "Jahre zuvor",
      copySuccess: "Erfolgreich kopiert",
      copyError: "Kopieren fehlgeschlagen",
      botInitialResponse: "Hallo, ich habe Ihre Anfrage erhalten und analysiere das Problem. Bitte warten Sie.",
      botInitialPlan: "Plan wird erstellt"
    },
    //ä¾§è¾¹æ 
    sidebar: {
      newTask: "Neue Aufgabe",
      shortcutKey: "T",
      moreOptions: "Weitere Optionen",
      share: "Teilen",
      rename: "Umbenennen",
      collect: "Sammeln",
      delete: "LÃ¶schen",
      confirmDelete: "LÃ¶schen bestÃ¤tigen",
      deleteConfirmation: "MÃ¶chten Sie diese Konversation wirklich lÃ¶schen?",
      cancel: "Abbrechen",
      confirm: "BestÃ¤tigen",
      noChats: "Starten Sie eine neue Aufgabe, um zu beginnen",
      searchPlaceholder: "Aufgaben suchen..."
    },
    //æ–‡ä»¶æŸ¥çœ‹å™¨
    fileExplorer: {
      allFilesInTask: "Alle Dateien in dieser Aufgabe",
      noContent: "Kein Inhalt verfÃ¼gbar",
      preview: "Vorschau",
      locateInChat: "Im Chat lokalisieren",
      download: "Herunterladen",
      saveToGoogleDrive: "Auf Google Drive speichern",
      selectAll: "Alle auswÃ¤hlen",
      cancel: "Abbrechen",
      batchDownload: "Batch-Download",
      fileTypes: {
        all: "Alle",
        document: "Dokument",
        image: "Bild",
        codeFile: "Codedatei",
        link: "Link"
      },
      timeGroups: {
        today: "Heute",
        yesterday: "Gestern",
        earlier: "FrÃ¼her"
      },
      weekdays: {
        sunday: "Sonntag",
        monday: "Montag",
        tuesday: "Dienstag",
        wednesday: "Mittwoch",
        thursday: "Donnerstag",
        friday: "Freitag",
        saturday: "Samstag"
      }
    },
    fullPreview: {
      download: "Herunterladen",
      exportToPDF: "Als PDF exportieren",
      saveToGoogleDrive: "Auf Google Drive speichern",
      maximize: "Maximieren",
      minimize: "Minimieren",
      previous: "ZurÃ¼ck",
      next: "Weiter",
      copy: "Kopieren",
      code: "Code",
      preview: "Vorschau",
      close: "SchlieÃŸen",
      fileTypePresentation: "Keine Vorschau mÃ¶glich",
      cannotPreviewFormat: "Dieses Format kann nicht in der Vorschau angezeigt werden.",
      downloadToView: "Bitte laden Sie die Datei herunter, um den Inhalt anzuzeigen.",
      noContentToCopy: "Kein Inhalt zum Kopieren vorhanden.",
      clipboardNotSupported: "Die aktuelle Browser unterstÃ¼tzt den Zwischenablagevorgang nicht, bitte manuell kopieren.",
      contentCopied: "Inhalt kopiert.",
      copyFailed: "Kopieren fehlgeschlagen, bitte erneut versuchen oder manuell kopieren.",
      exportPDFPending: "PDF-Export erfolgreich",
      saveToGoogleDrivePending: "Speichern auf Google Drive-Funktion noch nicht implementiert."
    },
    preview: {
      title: "Lemons Computer",
      openVsCode: "VS Code",
      using: "Lemon benutzt",
      performing: "FÃ¼hrt aus",
      previousStep: "Vorheriger Schritt",
      nextStep: "NÃ¤chster Schritt",
      realtime: "Echtzeit",
      waitingForDevelopment: "Warten auf Entwicklung...",
      browser: "Browser",
      Browse: "Durchsuchen",
      editor: "Editor",
      editingFile: "Datei bearbeiten",
      terminal: "Terminal",
      executingCommand: "Befehl ausfÃ¼hren",
      readingFile: "Datei lesen",
      search: "Suche",
      searching: "Suchen"
    }
  },
  //è®¾ç½®ç•Œé¢
  setting: {
    back: "ZurÃ¼ck",
    doneStep: "Fertig",
    prevStep: "ZurÃ¼ck",
    nextStep: "Weiter",
    settingModel: "Modell einrichten",
    settingModelTips: "Klicken Sie auf Einstellungen, um zur Einstellungsseite zu gelangen",
    menu: {
      basic: "Grundeinstellungen",
      defaultModel: "Standardmodell",
      modelService: "Modellservice",
      searchService: "Suchdienst",
      mcpService: "MCP-Dienst",
      experience: 'Erfahrungsbibliothek'
    },
    basic: {
      title: "Grundeinstellungen",
      langTitle: "Spracheinstellungen",
      languagePreference: "SprachprÃ¤ferenz",
      lang: {
        en: "Englisch",
        zh: "Chinesisch (vereinfacht)",
        de: "Deutsch",
        es: "Spanisch",
        fr: "FranzÃ¶sisch",
        ja: "Japanisch",
        kr: "Koreanisch",
        tr: "TÃ¼rkisch",
        pt: "Portugiesisch",
        tw: "Chinesisch (traditionell)",
        vi: "Vietnamesisch"
      }
    },
    modelService: {
      modelService: "Modellservice",
      modelServiceTipsOne: "Schritt eins: Modellanbieter auswÃ¤hlen",
      modelServiceTipsTwo: "Schritt zwei: API-SchlÃ¼ssel eingeben",
      modelServiceTipsThree: "Schritt drei: Modellservice aktivieren",
      title: "Modellservice",
      searchPlaceholder: "Plattform suchen",
      defaultPlatform: "Standard-Systemplattform",
      modelPlatform:  "Modellplattform",
      statusOn: "An",
      addPlatform: "HinzufÃ¼gen",
      save: "Speichern",
      defaultPlatformDescription: "Standardplattformmodelle werden vom System bereitgestellt und erfordern keine Konfiguration",
      apiKey: "API-SchlÃ¼ssel",
      apiKeyPlaceholder: "Bitte API-SchlÃ¼ssel eingeben",
      getApiKey: "Hier klicken, um SchlÃ¼ssel zu erhalten",
      check:  "PrÃ¼fen",
      selectCheckModel:"Bitte wÃ¤hlen Sie das PrÃ¼fmodell aus",
      apiAddress: "API-Adresse",
      apiAddressPlaceholder: "Bitte API-Adresse eingeben",
      apiAddressTip: "Ignoriere v1-Version, wenn mit / endet, erzwinge die Verwendung der eingegebenen Adresse, wenn mit # endet",
      activateTime: "Aktivierungszeit",
      activateTimePlaceholder: "Bitte Aktivierungszeit (Minuten) eingeben",
      models: "Modelle",
      ungrouped: "Ungruppiert",
      viewOfficialDocs: "Offizielle Dokumentation der Plattform fÃ¼r weitere Informationen anzeigen",
      add: "HinzufÃ¼gen",
      confirmDeleteModel: "Soll dieses Modell wirklich gelÃ¶scht werden?",
      deleteModelSuccess: "Modell erfolgreich gelÃ¶scht",
      deleteModelFailed: "Modell konnte nicht gelÃ¶scht werden",
      addModelSuccess: "Modell erfolgreich hinzugefÃ¼gt",
      updateModelSuccess: "Modell erfolgreich aktualisiert",
      copySuccess: "Name kopiert",
      typeVision: "Vision",
      typeNetwork: "Netzwerk",
      typeEmbed: "Einbetten",
      typeReasoning: "Argumentation",
      typeTool: "Werkzeug",
      addProvider: "Anbieter hinzufÃ¼gen",
      confirm: "BestÃ¤tigen",
      cancel: "Abbrechen",
      platformLogo: "Plattform-Logo",
      providerName: "Anbietername",
      namePlaceholder: "Name",
      providerType: "Anbietertyp",
      typePlaceholder: "Typ",
      enterName: "Bitte Namen eingeben",
      selectType: "Bitte Typ auswÃ¤hlen",
      addPlatformSuccess: "Plattform erfolgreich hinzugefÃ¼gt",
      formValidationFailed: "Formularvalidierung fehlgeschlagen",
      addModel: "Modell hinzufÃ¼gen",
      editModel: "Modell bearbeiten",
      modelId: "Modell-ID",
      modelIdPlaceholder: "Bitte Modell-ID eingeben",
      modelName: "Modellname",
      modelNamePlaceholder: "Modellname",
      groupName: "Gruppenname",
      groupNamePlaceholder: "Gruppenname",
      modelTypes: "Modelltypen",
      enterModelId: "Bitte Modell-ID eingeben",
      enterModelName: "Bitte Modellnamen eingeben",
      enterGroupName: "Bitte Gruppennamen eingeben",
      selectModelType: "Bitte mindestens einen Modelltyp auswÃ¤hlen",
      editProvider: "Anbieter bearbeiten",
      updatePlatformSuccess: "Plattform erfolgreich aktualisiert",
      deletePlatformSuccess: "Plattform erfolgreich gelÃ¶scht",
      deletePlatformFailed: "Plattform konnte nicht gelÃ¶scht werden",
      saveSuccess: "Erfolgreich gespeichert",
      saveFailed: "Speichern fehlgeschlagen",
      platforms:{
                Anthropic: "Anthropic",
                ModelScope: "ModelScope é­”å¡”",
                Gemini: "Gemini",
                OpenAI: "OpenAI",
                Ollama: "Ollama",
                qiniu: "ä¸ƒç‰›äº‘",
                WanJieData:  "ä¸‡ç•Œæ•°æ®",
                PPIO: "PPIO æ´¾æ¬§äº‘",
                QianFan: "ç™¾åº¦äº‘åƒå¸†",
                SiliconFlow: "ç¡…åŸºæµåŠ¨",
                Volcengine: "ç«å±±å¼•æ“",
                DeepSeek: "æ·±åº¦æ±‚ç´¢",
                Bailian: "é˜¿é‡Œäº‘ç™¾ç‚¼",
                OpenRouter: "OpenRouter",
                LMStudio: "LM Studio",
            }
    },
    defaultModel: {
      defaultModel: "Standardmodell einrichten",
      defaultModelTipsOne: "Klicken Sie auf Standardmodell, um zur Seite Standardmodell zu gelangen",
      topicNamingModel: "Themen-Benennungsmodell",
      topicNamingModelTips: "Modell zur automatischen Benennung neuer Themen",
      emptymodelTips: "Bitte aktivieren Sie die entsprechende Plattform im Modellservice",
      DefaultModelSetting: "Standardmodelleinstellung",
      defaultAssistantModel: "Standard-Assistentenmodell",
      assistantModelTips: "Modell, das beim Erstellen eines Assistenten verwendet wird",
      topicNamingModel: "Themen-Benennungsmodell",
      topicNamingModelTips: "Modell zur automatischen Benennung neuer Themen",
      translationModel: "Ãœbersetzungsmodell",
      translationModelTips: "Modell, das fÃ¼r Ãœbersetzungsdienste verwendet wird",
      browserUseModel: "Browserservicemodell",
      browserUseModelTips: "Modell, das fÃ¼r den integrierten Browser verwendet wird; muss Werkzeuge und Funktionsaufrufe unterstÃ¼tzen",
      saveSuccess: "Einstellungen erfolgreich gespeichert",
      assistantSettings: "Assistenten-Einstellungen",
      confirm: "BestÃ¤tigen",
      cancel: "Abbrechen",
      assistantName: "Assistentenname",
      assistantNamePlaceholder: "Bitte Assistentennamen eingeben",
      prompt: "Prompt",
      promptPlaceholder: "Bitte Prompt eingeben",
      modelParameters: "Modellparameter",
      temperature: "Temperatur",
      topP: "Top P",
      maxTokens: "Maximale Tokens",
      enableLengthLimit: "LÃ¤ngenbegrenzung aktivieren",
      topicNamingSettings: "Themen-Benennungseinstellungen",
      topicAutoNaming: "Automatische Themenbenennung",
      topicNamingPrompt: "Themen-Benennungs-Prompt",
      translationSettings: "Ãœbersetzungseinstellungen",
      translationPrompt: "Ãœbersetzungs-Prompt"
    },
    searchService: {
      searchService: "Suchdienst einrichten",
      searchServiceTipsOne: "Klicken Sie auf Suchdienst, um zur Seite Suchdienst zu gelangen",
      searchEngineTipsOne: "Schritt eins: Suchdienstleister auswÃ¤hlen",
      searchEngineTipsTwo: "Schritt zwei: API-SchlÃ¼ssel eingeben",
      title: "Suchdienst",
      blacklistSubscription: "Blacklist-Abonnement",
      addSubscription: "Abonnement hinzufÃ¼gen",
      updateNow: "Jetzt aktualisieren",
      deleteSubscription: "Abonnement lÃ¶schen",
      confirm: "BestÃ¤tigen",
      cancel: "Abbrechen",
      subscriptionUrl: "Abonnement-URL",
      subscriptionUrlPlaceholder: "https://example/abcd",
      subscriptionName: "Abonnement-Name",
      subscriptionNamePlaceholder: "Alternativer Name, der verwendet wird, wenn die heruntergeladene Abonnementquelle keinen Namen hat",
      name: "Name",
      url: "URL",
      addSubscriptionSuccess: "Abonnement erfolgreich hinzugefÃ¼gt",
      deleteSubscriptionSuccess: "Abonnement erfolgreich gelÃ¶scht",
      deleteSubscriptionFailed: "Abonnement konnte nicht gelÃ¶scht werden",
      saveConfigSuccess: "Konfiguration erfolgreich gespeichert",
      saveConfigFailed: "Konfiguration speichern fehlgeschlagen",
      loadConfigFailed: "Konfiguration laden fehlgeschlagen",
      formValidationFailed: "Formularvalidierung fehlgeschlagen",
      enterSubscriptionUrl: "Bitte Abonnement-URL eingeben",
      invalidUrl: "Bitte gÃ¼ltige URL eingeben",
      enterSubscriptionName: "Bitte Abonnementnamen eingeben",
      noSubscriptionSelected: "Kein Abonnement ausgewÃ¤hlt",
      searchProvider: "Suchanbieter",
      generalSettings: "Allgemeine Einstellungen",
      includeDate: "Datum einschlieÃŸen",
      includeServer: "Server einschlieÃŸen",
      searchEnhancement: "Suchverbesserung",
      searchResultCount: "Anzahl der Suchergebnisse",
      default: "Standard",
      blacklist: "Blacklist",
      blacklistTips: "Geben Sie DomÃ¤nen ein, die aus den Suchergebnissen ausgeschlossen werden sollen",
      blacklistPlaceholder: "Geben Sie eine DomÃ¤ne pro Zeile ein",
      save: "Speichern",
      apiTips: "API-Konfiguration",
      apiKeyPlaceholder: "Geben Sie Ihren API-SchlÃ¼ssel ein",
      apiKey: "API-SchlÃ¼ssel",
      apiAddress: "API-Adresse",
      tavilyName: "Tavily (SchlÃ¼ssel)",
      baiduName: "Baidu (kostenlos)",
      bingName: "Bing (kostenlos)",
      saveBlacklistSuccess: "Blacklist erfolgreich gespeichert",
      saveBlacklistFailed: "Blacklist speichern fehlgeschlagen"
    },
    mcpService: {
      title: "MCP-Dienst",
      addServer: "Server hinzufÃ¼gen",
      save: "Speichern",
      name: "Name",
      namePlaceholder: "Bitte Namen eingeben",
      description: "Beschreibung",
      descriptionPlaceholder: "Beschreibung",
      type: "Typ",
      stdio: "Standard-Eingabe/Ausgabe (stdio)",
      sse: "Server-Sent Events (sse)",
      streamableHttp: "Streamable HTTP (streamableHttp)",
      command: "Befehl",
      commandPlaceholder: "uvx oder npx",
      packageSource: "Paketquellen",
      default: "Standard",
      taobaoNpmMirror: "Taobao NPM Mirror",
      tsinghua: "Tsinghua UniversitÃ¤t",
      aliyun: "Aliyun",
      ustc: "Chinesische UniversitÃ¤t fÃ¼r Wissenschaft und Technologie",
      huaweiCloud: "Huawei Cloud",
      tencentCloud: "Tencent Cloud",
      args: "Argumente",
      argsPlaceholder: "arg1\narg2",
      env: "Umgebungsvariablen",
      envPlaceholder: "KEY1=VALUE1\nKEY2=VALUE2",
      mcpServer: "MCP-Server"
    },
    experience: {
      title: "Erfahrungsbibliothek",
      addExperience: "Erfahrung hinzufÃ¼gen",
      editExperience: "Erfahrung bearbeiten",
      close: "SchlieÃŸen",
      titleLabel: "Titel",
      titlePlaceholder: "Erfahrungstitel",
      goalLabel: "Ziel",
      goalPlaceholder: "Ziel dieser Erfahrung",
      contentLabel: "Inhalt",
      contentPlaceholder: "Erfahrungsinhalt",
      statusLabel: "Status",
      enabled: "Aktiviert",
      disabled: "Deaktiviert",
      cancel: "Abbrechen",
      save: "Speichern",
      delete: "LÃ¶schen",
      undoChanges: "Ã„nderungen rÃ¼ckgÃ¤ngig machen",
      deleteExperience: "Erfahrung lÃ¶schen",
      deleteConfirm: "MÃ¶chten Sie diese Erfahrung wirklich lÃ¶schen?",
      totalExperience: "Insgesamt {count} Erfahrungen",
      tableTitle: "Titel",
      tableContent: "Inhalt",
      tableCreatedAt: "Erstellt am",
      tableStatus: "Status",
      tableOperation: "Operation",
      filterAll: "Alle",
      deleteSuccess: "Erfolgreich gelÃ¶scht",
      deleteFailed: "LÃ¶schen fehlgeschlagen",
      createSuccess: "Erfahrung erfolgreich hinzugefÃ¼gt",
      createFailed: "Erfahrung hinzufÃ¼gen fehlgeschlagen",
      updateSuccess: "Erfolgreich aktualisiert",
      updateFailed: "Aktualisierung fehlgeschlagen",
      updateFailedDataNotExist: "Aktualisierung fehlgeschlagen, Daten nicht vorhanden",
      getDataError: "Fehler beim Abrufen der Daten",
      detect: "Absichtserkennung",
      plan: "Aufgabenplanung",
      action: "AufgabenausfÃ¼hrung",
      sunday: "Sonntag",
      monday: "Montag",
      tuesday: "Dienstag",
      wednesday: "Mittwoch",
      thursday: "Donnerstag",
      friday: "Freitag",
      saturday: "Samstag",
      earlier: "FrÃ¼her",
    },
  },
  thinking: "Denken",
  task_error: "Aufgabe fehlerhaft beendet",
  stop_task: "Aufgabe gestoppt",
  jump_to_result: "Zum Ergebnis springen",
  replay: "Wiederholung",
  task_finished: "Aufgabe abgeschlossen",
  task_playing: "Aufgabe lÃ¤uft",
  click_here_to_go_to_settings: "Klicken Sie hier, um zu den Einstellungen zu gelangen",
}


================================================
FILE: frontend/src/locals/lang/en.js
================================================
export default {
  // Common
  common: {
    cancel: "Cancel",
  },
  //ç™»å½•ç•Œé¢
  account: {
    usernameLabel: 'Username:',
    edit: 'Edit',
    passwordLabel: 'Password',
    resetPassword: 'Reset Password',
    editUsernameTitle: 'Edit Username',
    newUsernamePlaceholder: 'Please enter a new username',
    cancel: 'Cancel',
    save: 'Save',
    resetPasswordTitle: 'Reset Password',
    newPasswordPlaceholder: 'Please enter a new password',
    updateSuccess: 'Update Success',
    ordersTitle: 'Orders',
    table: {
      orderId: 'Order ID',
      orderAmount: 'Order Amount',
      time: 'Time',
      status: 'Order Status',
    },
    orderStatus: {
      pending: 'Pending',
      paid: 'Paid',
      cancelled: 'Cancelled',
      failed: 'Failed',
      unknown: 'Unknown',
    },
  },
  auth: {
    loginToLemonAI: "Login to LemonAI",
    registerLemonAIAccount: "Register LemonAI Account",
    verifyEmail: "Verify Email",
    resetPassword: "Reset Password",
    loginWithGoogle: "Login with Google",
    registerWithGoogle: "Register with Google",
    login: "Login",
    register: "Register",
    logOut: "Log Out",
    forgotPassword: "Forgot Password",
    resetPasswordButton: "Reset Password",
    backToLogin: "Back to Login",
    verifyEmailButton: "Verify Email",
    resendCode: "Resend Code",
    email: "Email",
    password: "Password",
    fullname: "Fullname",
    codeSentTo: "Code sent to",
    pleaseInputEmail: "Please enter email",
    smsCode: "SMS Code",
    sendCode: "Send Code",
    pleaseInputSMSCode: "Please enter SMS Code",
    pleaseInputValidEmail: "Please enter a valid email",
    pleaseInputValidPassword: "Please enter a valid password",
    pleaseInputFullname: "Please enter fullname",
    pleaseInputVerifyCode: "Please enter verify code",
    pleaseInputNewPassword: "Please enter new password",
    pleaseConfirmPassword: "Please confirm password",
    pleaseInput6DigitCode: "Please enter 6 digit code",
    or: "Or",
    noAccount: "No account?",
    keepOffline: "Keep Offline",
    haveAccount: "Have account?",
    notReceivedCode: "Not received code?",
    codeSent: "Code sent",
    registrationSuccessful: "Registration successful, please login",
    verificationCodeError: "Verification code error, please try again",
    doNotSendFrequently: "Please do not send verification code frequently",
    codeResent: "Verification code resent",
    loginSuccessful: "Login successful",
    loginFailed: "Login failed, please check email and password",
    fillCompleteInfo: "Please fill in the complete registration information",
    pleaseEnterValidEmail: "Please enter a valid email address",
    passwordTooShort: "Password length cannot be less than 6 characters",
    registrationFailed: "Registration failed, please check input",
    pleaseInputCode: "Please enter verify code",
    passwordsDoNotMatch: "Passwords do not match",
    passwordResetSuccessful: "Password reset successful, please login",
    passwordResetFailed: "Password reset failed, please check input",
    googleLoginFailed: "Google login failed, please try again later",
    appleLoginInProgress: "Apple login feature is under development",
    googleRegisterInProgress: "Google register feature is under development",
    appleRegisterInProgress: "Apple register feature is under development",
    verifyingGoogleLogin: "Verifying Google login",
    loginWithPhone: "Login with phone",
    verifyCode: "Verify code",
    smsCode: "SMS code",
    sendCode: "Send code",
    phone: "Phone",
    pleaseInputValidPhone: "Please enter a valid phone number",
    pleaseInputPassword: "Please enter password",
    pleaseInputSMSCode: "Please enter SMS code",
    confirmPassword: "Confirm password",
    pleaseInputPhone: "Please enter phone number",
    keepOffline: "Keep offline",
    otherLogin: "Select other login method",
    subscribeModel: "You are currently selecting a subscription model, please login to use or select other models",
    //æ‚¨å½“å‰é€‰æ‹©æœç´¢æœåŠ¡æ˜¯è®¢é˜…æœåŠ¡ï¼Œè¯·å‰å¾€ç™»å½•åä½¿ç”¨ æˆ– é€‰æ‹©å…¶å®ƒæœåŠ¡
    subscribeService: "The search service you are currently selecting is a subscription service, please login to use or select other services",
    insufficientPoints: "Insufficient points",
    insufficientPointsPleaseGoToUpgradeOrPurchase: "You are using a subscription model or subscription search service, but your current points are insufficient, please go to upgrade or purchase",
  },
  //ä¼šå‘˜
  member: {
    selectPaymentMethod: "Select payment method",
    payWithCard: "Pay with Stripe",
    payWithWeChat: "Pay with WeChat",
    freePlan: 'Free',
    expirationDate: 'Expiration date:',
    upgrade: 'Upgrade',
    purchasePoints: 'Purchase points',
    points: 'Points',
    pointsUnit: 'Points',
    pointsUsageHistory: 'Points usage history',
    noPackagesAvailable: 'No available points packages',
    buyNow: 'Buy now',
    wechatScanToPay: 'Wechat scan to pay',
    wechatScanPrompt: 'Please use Wechat to scan the QR code to complete the payment',
    paymentSuccess: 'Payment successful!',
    paymentTimeout: 'Payment timeout, please re-order',
    qrCodeGenerationFailed: 'QR code generation failed, please try again later',
    pointsType: {
      free: 'Free points',
      monthly: 'Monthly points',
      purchasedAddon: 'Purchased addon points',
      giftedAddon: 'Gifted addon points',
      feedbackAddon: 'Feedback addon points',
    },
    table: {
      details: 'Details',
      time: 'Time',
      pointsChange: 'Points change',
      conversation_title: 'Title',
    },
    pricing: "Pricing",
    mostPopular: "Most popular",
    recommended: "Recommended",
    discount: "Discount",
    annual: "Annual",
    points: "Points",
    month: "Month",
    select: "Select",
    paySuccess: "Payment successful!",
    payFailed: "Payment failed, please try again later",
    payCancel: "Payment canceled",
    payTimeout: "Payment timeout, please re-order",
    qrTitle: "Wechat scan to pay",
    qrTip: "Please use Wechat to scan the QR code to complete the payment",
    billingMonthly: "Monthly",
    billingYearly: "Annual",
    qrError: "QR code generation failed, please try again later",
    noPlanForBilling: "No available plans for billing",
    alreadyCurrentMember: "Already a current member",
    loadPlansFailed: "Failed to load plans",
    cancelMembership: "Cancel subscription",
    confirmCancelTitle: "Confirm Cancellation",
    cancelDowngrade: "Cancel Downgrade",
    unavailable: "Unavailable",
    reactivatePlan: "Reactivate Plan",
    upgradeTo: "Upgrade to",
    downgradeTo: "Downgrade to",
    save: "save",
    year: "Year",
    monthlyBilling: "/ Month",
    yearlyBilling: "/ Year",
    confirmUpgrade: "Confirm Upgrade",
    cancel: "Cancel",
    confirmDowngrade: "Confirm Downgrade",
    confirmDowngradeMessage: "Are you sure you want to downgrade from",
    to: "to",
    effectAtPeriodEnd: "This change will take effect at the end of your current billing period",
    upgradePreviewTitle: "Upgrade Preview",
    upgradeSummary: "Upgrade Summary",
    from: "From:",
    paymentRequired: "Payment Required",
    upgradePrice: "Upgrade Price:",
    confirmCancelMessage: "Are you sure you want to cancel your subscription?",
    confirm: "Confirm",
    downgradeNotice: "Your {planName} membership will be downgraded to {targetPlan} on {date}.",
    reactivateSuccess: "Reactivate subscription success",
    cancelDowngradeSuccess: "Downgrade cancelled successfully",
    cancelDowngradeFailed: "Failed to cancel downgrade. Please try again.",
    downgradeScheduledSuccess: "Downgrade scheduled successfully!",
    downgradeNotSupported: "Sorry, downgrading from WeChat payment is not supported at the moment.",
    downgradeFailed: "Downgrade failed. Please try again.",
    cancelPleaseFirst: "Please cancel your downgrade first before making any changes to your subscription.",
    processingUpgrade: "Processing upgrade payment...",
    upgradeSuccessful: "Upgrade successful!",
    upgradeFailed: "Upgrade failed. Please try again.",
    upgradePreviewFailed: "Failed to load upgrade preview. Please try again.",
    switchNotSupported: "Switching from an annual plan to a monthly plan is not supported at the moment.",
    wechatDowngradeNotSupported: "WeChat payment purchased memberships do not support downgrading.",
    platformNotSupported: "Platform does not currently support upgrade/downgrade operations.",
    paymentFailed: "Payment failed",
    upgradeTimeoutWarning: "Upgrade payment timeout. Please check your payment status.",
    upgradeStatusCheckFailed: "Failed to check upgrade status.",
    getSubscriptionFailed: "Upgrade failed. Unable to get subscription information.",
    upgradePaymentFailed: "Upgrade Payment Failed",
    iUnderstand: "I Understand",
    whatYouCanDo: "What you can do:",
    insufficientFunds: "Upgrade failed: Insufficient funds. Please check your card balance and try again.",
    cardDeclined: "Upgrade failed: Card declined. Please contact your bank or try a different payment method.",
    authenticationRequired: "Upgrade failed: Authentication required. Please complete 3D Secure verification.",
    expiredCard: "Upgrade failed: Card expired. Please update your payment method.",
    paymentMethodIssue: "Upgrade failed: Payment method issue detected.",
    invoiceUnpaid: "Upgrade failed: Invoice is unpaid.",
    contactSupport: "Upgrade failed. Please try again or contact support.",
    cancelMembershipSuccess: "Subscription cancelled successfully",
    benefits: {
      free: {
        newUserCredits: "1,000 Credits for new register user",
        dailyCredits: "0 daily credits",
        publicAgentsOnly: "Public Agents only",
        systemExperienceInvisible: "System Experience invisible",
        limitedChat: "Limited access to advanced models in Chat",
        limitedAgent: "Limited access to advanced models in Agent",
      },
      pro: {
        monthlyCredits: "19,000 Credits per Month",
        dailyCredits: "1,000 daily credits (up to 30,000/month)",
        privateAgents: "Private Agents",
        systemExperienceEditable: "System Experience editable",
        unlimitedChat: "Unlimited access to advanced models in Chat",
        unlimitedAgent: "Unlimited access to advanced models in Agent",
      },
      business: {
        monthlyCredits: "99,000 Credits per Month",
        dailyCredits: "1,000 daily credits (up to 30,000/month)",
        privateAgents: "Private Agents",
        systemExperienceEdit: "System Experience edit",
        unlimitedChat: "Unlimited access to advanced models in Chat",
        unlimitedAgent: "Unlimited access to advanced models in Agent",
        earlyAccess: "Early access to beta features",
        customDomains: "Custom domains",
        teamShare: "Team Share Agents",
      },
    },
  },payment: {
    stripe: {
      title: 'Stripe',
      description: 'Supports Visa / Mastercard / International Credit Cards'
    },
    wechat: {
      title: 'WeChat Pay',
      description: 'Scan to pay, instant confirmation, recommended for users in China'
    }
  },
  //ä¸»ç•Œé¢
  lemon: {
    // é¦–é¡µ
    welcome: {
      greeting: "Hello",
      question: "What can I do for you?",
      workMode: {
        twins: "One question, parallel thinking.",
        task: "Let's tackle your mission together.",
        chat: "I'm here for quick, accurate answers.",
        auto: "Our system intelligently routes your task to the best-suited mode."
      },
      tabs: {
        featured: "Featured",
        research: "Research",
        lifestyle: "Lifestyle",
        dataAnalysis: "Data analysis",
        education: "Education",
        productivity: "Productivity",
        other: "Other"
      },
      placeholders: {
        twins: "Enter one prompt. See a side-by-side comparison of our AI Chat and Evolving Agent.",
        task: "What's your mission in mind? Give me the idea and I'll handle the rest",
        chat: "What can I help you with?",
        auto: "Describe your task. I'll choose the best mode for you."
      },
      placeholder: "What can I do for you?",
      communityNote: "All tasks and websites displayed in the community are voluntarily shared by users. The platform will not display any content without the user's consent."
    },
    //å¯¹è¯å¤´éƒ¨
    chatHeader: {
      share: "Share",
      viewAllFiles: "View all files in this task",
      moreOptions: "More options",
      rename: "Rename",
      editTitle: "Edit title",
      enterNewTitle: "Enter new title",
      cancel: "Cancel",
      confirm: "Confirm",
      favorite: "Add to favorites",
      unfavorite: "Remove from favorites"
    },
    //æ¶ˆæ¯å¯¹è¯åˆ—è¡¨é¡µ
    message: {
      runCommand: "Run bash command",
      readFile: "Read file",
      editFile: "Edit file",
      browsing: "Browsing",
      searching: "Searching",
      minutesAgo: "minutes ago", // minutes ago
      secondsAgo: "seconds ago",
      hoursAgo: "hours ago", // hours ago
      daysAgo: "days ago", // days ago
      monthsAgo: "months ago", // months ago
      yearsAgo: "years ago", // years ago
      copySuccess: "Copy successful", // Copy successful
      copyError: "Copy failed", // Copy failed
      botInitialResponse: "Hello, I have received your request, I am analyzing this problem. Please wait.",
      botInitialPlan: "Planning in progress"
    },
    // è¾“å…¥æ¡†
    input: {
      chooseModel: "choose model",
    },
    // Model
    model: {
      requiresLogin: "Login Required",
      loginRequired: "Login Required",
      loginRequiredDescription: "This model requires login to use",
      pleaseLoginFirst: "Please login to your account first to use this feature",
      goToLogin: "Go to Login",
      models: "Models",
    },
    // Work Mode
    workMode: {
      title: "Mode",
      auto: {
        label: "Auto",
        description: "Automated multi-step chat"
      },
      agent: {
        label: "Task", 
        description: "Task-oriented chat with tools"
      },
      chat: {
        label: "Chat",
        description: "Simple conversation chat"
      }
    },
    //ä¾§è¾¹æ 
    sidebar: {
      newTask: "New task",
      shortcutKey: "T",
      moreOptions: "More options",
      share: "Share",
      rename: "Rename",
      collect: "Collect",
      delete: "Delete",
      confirmDelete: "Confirm delete",
      deleteConfirmation: "Are you sure you want to delete this conversation?",
      cancel: "Cancel",
      confirm: "Confirm",
      noChats: "Create a new task to start",
      searchPlaceholder: "Search tasks..."
    },
    //æ–‡ä»¶æŸ¥çœ‹å™¨
    fileExplorer: {
      allFilesInTask: "All files in this task",
      noContent: "No content",
      preview: "Preview",
      locateInChat: "Locate in chat",
      download: "Download",
      saveToGoogleDrive: "Save to Google Drive",
      selectAll: "Select all",
      cancel: "Cancel",
      batchDownload: "Batch download",
      fileTypes: {
        all: "All",
        document: "Document",
        image: "Image",
        codeFile: "Code file",
        link: "Link"
      },
      timeGroups: {
        today: "Today",
        yesterday: "Yesterday",
        earlier: "Earlier"
      },
      weekdays: {
        sunday: "Sunday",
        monday: "Monday",
        tuesday: "Tuesday",
        wednesday: "Wednesday",
        thursday: "Thursday",
        friday: "Friday",
        saturday: "Saturday"
      }
    },
    fullPreview: {
      download: "Download",
      exportToPDF: "Export to PDF",
      saveToGoogleDrive: "Save to Google Drive",
      maximize: "Maximize",
      minimize: "Minimize",
      previous: "Previous",
      next: "Next",
      copy: "Copy",
      code: "Code",
      preview: "Preview",
      close: "Close",
      fileTypePresentation: "Cannot preview",
      cannotPreviewFormat: "This format cannot be previewed.",
      downloadToView: "Please download the file to view the content.",
      noContentToCopy: "No content to copy.",
      clipboardNotSupported: "Current browser does not support clipboard operation, please manually copy.",
      contentCopied: "Content copied.",
      copyFailed: "Copy failed, please try again or manually copy.",
      exportPDFPending: "Export PDF successfully",
      saveToGoogleDrivePending: "Save to Google Drive feature is under development."
    },
    preview: {
      title: "Lemon's computer",
      openVsCode: "VS Code",
      using: "Lemon is using",
      performing: "Performing",
      previousStep: "Previous step",
      nextStep: "Next step",
      realtime: "Realtime",
      waitingForDevelopment: "Waiting for development...",
      browser: "Browser",
      browsing: "Browsing",
      editor: "Editor",
      editingFile: "Editing file",
      terminal: "Terminal",
      executingCommand: "Executing command",
      readingFile: "Reading file",
      search: "Search",
      searching: "Searching"
    }

  },
  //è®¾ç½®ç•Œé¢
  setting: {
    back: "Back",
    doneStep: "Done",
    prevStep: "Previous step",
    nextStep: "Next step",
    settingModel: "Settings",
    settingModelTips: "Click to set, jump to the setting page",
    tourHoverDescription: "Hover here to view menu, click Settings to go to settings page",
    tourClickSettingTitle: "Enter Settings",
    tourClickSettingDescription: "Click the \"Settings\" button to enter the settings page for model configuration",
    tourUnderstood: "Go to Settings",
    menu: {
      basic: "Basic settings",
      defaultModel: "Default model",
      modelService: "Model service",
      searchService: "Search service",
      mcpService: "MCP service",
      experience: 'Experience library',
      account: "Account",
      //ç§¯åˆ†ç®¡ç†
      integral: 'Integral',
      about: 'About',
    },
    basic: {
      title: "Basic settings",
      langTitle: "Language settings",
      languagePreference: "Language preference",
      lang: {
        en: "English",
        zh: "Chinese (Simplified)",
        de: "German",
        es: "Spanish",
        fr: "French",
        ja: "Japanese",
        kr: "Korean",
        tr: "Turkish",
        pt: "Portuguese",
        tw: "Chinese (Traditional)",
        vi: "Vietnamese"
      }
    },
    modelService: {
      modelService: "Model service",
      modelServiceTipsOne: "Step 1: Select model service provider",
      modelServiceTipsTwo: "Step 2: Set input API KEY",
      modelServiceTipsThree: "Step 3: Enable model service",
      title: "Model service",
      searchPlaceholder: "Search platform",
      defaultPlatform: "Default system platform",
      modelPlatform: "Model platform",
      statusOn: "On",
      addPlatform: "Add",
      save: "Save",
      defaultPlatformDescription: "Default platform model provided by the system, no configuration required",
      apiKey: "API key",
      apiKeyPlaceholder: "Please enter API key",
      ak: "Access Key",
      akPlaceholder: "Please enter Access Key",
      getApiKey: "Click here to get the key",
      check: "Check",
      selectCheckModel: "Please select the model to check",
      apiAddress: "API address",
      apiAddressPlaceholder: "Please enter API address",
      apiAddressTip: "End with / to ignore v1 version, end with # to force use input address",
      activateTime: "Activate time",
      activateTimePlaceholder: "Please enter activate time (minutes)",
      models: "Models",
      ungrouped: "Ungrouped",
      viewOfficialDocs: "View the official documentation of the platform for more information",
      add: "Add",
      confirmDeleteModel: "Are you sure you want to delete this model?",
      deleteModelSuccess: "Model deleted successfully",
      deleteModelFailed: "Model deletion failed",
      addModelSuccess: "Model added successfully",
      updateModelSuccess: "Model updated successfully",
      copySuccess: "Name copied",
      typeVision: "Vision",
      typeNetwork: "Network",
      typeEmbed: "Embed",
      typeReasoning: "Reasoning",
      typeTool: "Tool",
      addProvider: "Add provider",
      confirm: "Confirm",
      cancel: "Cancel",
      platformLogo: "Platform logo",
      providerName: "Provider name",
      namePlaceholder: "Name",
      providerType: "Provider type",
      typePlaceholder: "Type",
      enterName: "Please enter name",
      selectType: "Please select type",
      addPlatformSuccess: "Platform added successfully",
      formValidationFailed: "Form validation failed",
      addModel: "Add model",
      editModel: "Edit model",
      modelId: "Model ID",
      modelIdPlaceholder: "Please enter model ID",
      modelName: "Model name",
      modelNamePlaceholder: "Model name",
      groupName: "Group name",
      groupNamePlaceholder: "Group name",
      modelTypes: "Model types",
      enterModelId: "Please enter model ID",
      enterModelName: "Please enter model name",
      enterGroupName: "Please enter group name",
      selectModelType: "Please select at least one model type",
      editProvider: "Edit provider",
      updatePlatformSuccess: "Platform updated successfully",
      deletePlatformSuccess: "Platform deleted successfully",
      deletePlatformFailed: "Platform deletion failed",
      saveSuccess: "Save successfully",
      saveFailed: "Save failed",
      modelAlreadyExists: "Add failed,Model ID already exists",
      apiCallSucceeded: "LLM API call succeeded",
      apiCallFailed: "LLM API call failed",
      apiCallTimeout: "LLM API call timed out",
      unknownError: "unknown error",
      platforms: {
        Anthropic: "Anthropic",
        ModelScope: "ModelScope",
        Gemini: "Gemini",
        OpenAI: "OpenAI",
        Ollama: "Ollama",
        qiniu: "Qiniu",
        WanJieData: "WanJieData",
        PPIO: "PPIO",
        QianFan: "QianFan",
        SiliconFlow: "SiliconFlow",
        Volcengine: "Volcengine",
        DeepSeek: "DeepSeek",
        Bailian: "Bailian",
        OpenRouter: "OpenRouter",
        LMStudio: "LM Studio",
        Cloudsway: "Cloudsway",
        Lemon: "Lemon",

      },
      showMoreOptions: "Show more options",
      hideOptions: "Hide options",

    },
    defaultModel: {
      defaultModel: "Set default model",
      defaultModelTipsOne: "Click default model, jump to default model page",
      topicNamingModel: "Topic naming model",
      topicNamingModelTips: "Used to automatically name new topics",
      emptymodelTips: "Please enable the relevant platform in the model service",
      DefaultModelSetting: "Default model setting",
      defaultAssistantModel: "Default assistant model",
      assistantModelTips: "Model used to create assistants",
      translationModel: "Translation model",
      translationModelTips: "Model used for translation services",
      browserUseModel: "Browser service model",
      browserUseModelTips: "Model used for the built-in browser, must support tool and function calls",
      saveSuccess: "Settings saved successfully",
      assistantSettings: "Assistant settings",
      confirm: "Confirm",
      cancel: "Cancel",
      assistantName: "Assistant name",
      assistantNamePlaceholder: "Please enter assistant name",
      prompt: "Prompt",
      promptPlaceholder: "Please enter prompt",
      modelParameters: "Model parameters",
      temperature: "Temperature",
      topP: "Top P",
      maxTokens: "Max tokens",
      enableLengthLimit: "Enable length limit",
      topicNamingSettings: "Topic naming settings",
      topicAutoNaming: "Topic auto naming",
      topicNamingPrompt: "Topic naming prompt",
      translationSettings: "Translation settings",
      translationPrompt: "Translation prompt"
    },
    searchService: {
      searchService: "Search service",
      searchServiceTipsOne: "Click search service, jump to search service page",
      searchEngineTipsOne: "Step 1: Select search service provider",
      searchEngineTipsTwo: "Step 2: Set input API key",
      title: "Search service",
      blacklistSubscription: "Blacklist subscription",
      addSubscription: "Add subscription",
      updateNow: "Update now",
      deleteSubscription: "Delete subscription",
      confirm: "Confirm",
      cancel: "Cancel",
      subscriptionUrl: "Subscription URL",
      subscriptionUrlPlaceholder: "https://example/abcd",
      subscriptionName: "Subscription name",
      subscriptionNamePlaceholder: "The alternative name used when the downloaded subscription source has no name",
      name: "Name",
      url: "URL",
      addSubscriptionSuccess: "Subscription added successfully",
      deleteSubscriptionSuccess: "Subscription deleted successfully",
      deleteSubscriptionFailed: "Subscription deletion failed",
      saveConfigSuccess: "Configuration saved successfully",
      saveConfigFailed: "Configuration saving failed",
      loadConfigFailed: "Configuration loading failed",
      formValidationFailed: "Form validation failed",
      enterSubscriptionUrl: "Please enter subscription URL",
      invalidUrl: "Please enter a valid URL",
      enterSubscriptionName: "Please enter subscription name",
      noSubscriptionSelected: "No subscription selected",
      searchProvider: "Search provider",
      generalSettings: "General settings",
      includeDate: "Include date",
      includeServer: "Include server",
      searchEnhancement: "Search enhancement",
      searchResultCount: "Search result count",
      default: "Default",
      blacklist: "Blacklist",
      blacklistTips: "Enter the domain names to exclude from the search results",
      blacklistPlaceholder: "Enter one domain name per line",
      save: "Save",
      apiTips: "API configuration",
      apiKeyPlaceholder: "Enter your API key",
      apiKey: "API key",
      apiAddress: "API address",
      tavilyName: "Tavily (key)",
      baiduName: "Baidu (free)",
      bingName: "Bing (free)",
      couldswayName: "Cloudsway (key)",
      accessKey: "Access key",
      endPoint: "Endpoint",
      endpointPlaceholder: "Enter your endpoint",
      accessKeyPlaceholder: "Enter your access key",
      saveBlacklistSuccess: "Blacklist saved successfully",
      saveBlacklistFailed: "Blacklist saving failed",
      apiKeyRequired: "API key is empty",
      accessKeyRequired: "Access key is empty",
      endpointRequired: "Endpoint is empty",
      checkSearchEngineSuccess: "search successful",
      checkSearchEngineFailed: "search failed",
    },
    mcpService: {
      title: "MCP service",
      addServer: "Add server",
      save: "Save",
      name: "Name",
      namePlaceholder: "Please enter name",
      description: "Description",
      descriptionPlaceholder: "Description",
      type: "Type",
      stdio: "Standard input/output (stdio)",
      sse: "Server-sent events (sse)",
      streamableHttp: "Streamable HTTP (streamableHttp)",
      command: "Command",
      commandPlaceholder: "uvx or npx",
      packageSource: "Package source",
      default: "Default",
      taobaoNpmMirror: "Taobao NPM mirror",
      tsinghua: "Tsinghua",
      aliyun: "Aliyun",
      ustc: "USTC",
      huaweiCloud: "Huawei Cloud",
      tencentCloud: "Tencent Cloud",
      args: "Parameters",
      argsPlaceholder: "arg1\narg2",
      env: "Environment variables",
      envPlaceholder: "KEY1=VALUE1\nKEY2=VALUE2",
      mcpServer: "MCP server",
      deleteConfirmTitle: "Delete Confirmation",
      deleteConfirmContent: "Are you sure you want to delete this server?",
      noServerSelected: "No MCP Server Selected",
      importFromJson: "Import from JSON",
      addMcpServer: "Add MCP Server",
      importModalTitle: "Import from JSON",
      ok: "OK",
      cancel: "Cancel",
      importSuccess: "Successfully imported {count} MCP servers.",
      importSuccessSingle: "Successfully imported MCP server.",
      noValidServer: "No valid server configuration found in the imported data.",
      nameRequired: "Name is required.",
      invalidJson: "Invalid JSON format.",
      url: "URL",
      connectionFailed: "MCP connection failed",
      noServersAvailable: "No servers available",
      fetchFailed: "Failed to fetch servers",
      addSuccess: "Server added successfully",
      addFailed: "Failed to add server",
      updateSuccess: "Server updated successfully",
      updateFailed: "Failed to update server",
      deleteSuccess: "Server deleted successfully",
      deleteFailed: "Failed to delete server"
    },
    experience: {
      title: "Experience library",
      addExperience: "Add experience",
      editExperience: "Edit experience",
      close: "Close",
      titleLabel: "Title",
      titlePlaceholder: "Experience title",
      goalLabel: "Goal",
      goalPlaceholder: "The goal of the experience",
      contentLabel: "Content",
      contentPlaceholder: "Experience content",
      statusLabel: "Status",
      enabled: "Enabled",
      disabled: "Disabled",
      cancel: "Cancel",
      save: "Save",
      delete: "Delete",
      undoChanges: "Undo changes",
      deleteExperience: "Delete experience",
      deleteConfirm: "Are you sure you want to delete this experience?",
      totalExperience: "Total {count} experiences",
      tableTitle: "Title",
      tableContent: "Content",
      tableCreatedAt: "Created at",
      tableStatus: "Status",
      tableOperation: "Operation",
      filterAll: "All",
      deleteSuccess: "Delete successfully",
      deleteFailed: "Delete failed",
      createSuccess: "Add experience successfully",
      createFailed: "Add experience failed",
      updateSuccess: "Update successfully",
      updateFailed: "Update failed",
      updateFailedDataNotExist: "Update failed, current data does not exist",
      getDataError: "Get data error",
      systemExperienceRequiresUpgrade: "Viewing system experiences requires an upgrade",
      detect: "Intent detection",
      plan: "Task planning",
      action: "Task execution",
      sunday: "Sunday",
      monday: "Monday",
      tuesday: "Tuesday",
      wednesday: "Wednesday",
      thursday: "Thursday",
      friday: "Friday",
      saturday: "Saturday",
      earlier: "Earlier",
    },
    about: {
      title: "About",
      lemonAI: "LemonAI",
      checkUpdate: "Check update",
      officialWebsite: "Official website",
      view: "View",
      feedback: "Feedback",
      submitFeedback: "Feedback",
      license: "License",
      newVersionReleased: "WowğŸ”¥ New version released! ğŸš€",
      version: "Version",
      skipUpdate: "æš‚ä¸æ›´æ–°",
      viewDetails: "View details",
      alreadyLatest: "Already the latest version"
    }
  },
  thinking: "Thinking",
  task_error: "Task exception terminated",
  stop_task: "Task stopped",
  jump_to_result: "Jump to result",
  replay: "Replay",
  task_finished: "Task finished",
  task_playing: "Task playing",
  //ç‚¹å‡»æ­¤å¤„è·³è½¬åˆ°è®¾ç½®é¡µé¢
  click_here_to_go_to_settings: "Click here to go to settings",
  //è¯·é€‰æ‹© æ¨¡å‹
  please_select_model: "Please select model",
  //è®¾ç½®
  settings: "Settings",
  loadingTip: "Loading order information...",
  backHome: "Back to home",
  orderInfo: "Order information",
  orderId: "Order ID",
  paymentAmount: "Payment amount",
  orderStatus: "Order status",
  customerInfo: "Customer information",
  name: "Name",
  email: "Email",
  notProvided: "Not provided",
  unknown: "Unknown",
  unknownCurrency: "Unknown currency",
  loadFailed: "Order loading failed, please try again later.",
  fetchFailed: "Order fetching failed",
  status: {
    checking: "Checking order status...",
    paid: "Paid",
    pending: "Pending",
    cancelled: "Cancelled",
    failed: "Failed"
  },
  resultTitle: {
    paid: "Paid",
    pending: "Pending",
    cancelled: "Cancelled",
    failed: "Failed",
    checking: "Checking order information...",
    unknown: "Unknown order status"
  },
  resultSubtitle: {
    submitted: "Your order has been successfully submitted"
  }
}



================================================
FILE: frontend/src/locals/lang/es.js
================================================
export default {
  //ç™»å½•ç•Œé¢
  auth: {
    loginToLemonAI: "Iniciar sesiÃ³n en LemonAI",
    registerLemonAIAccount: "Registrar cuenta LemonAI",
    verifyEmail: "Verificar correo electrÃ³nico",
    resetPassword: "Restablecer contraseÃ±a",
    loginWithGoogle: "Iniciar sesiÃ³n con Google",
    registerWithGoogle: "Registrarse con Google",
    login: "Iniciar sesiÃ³n",
    register: "Registrarse",
    logOut: "Cerrar sesiÃ³n",
    forgotPassword: "OlvidÃ© mi contraseÃ±a",
    resetPasswordButton: "Restablecer contraseÃ±a",
    backToLogin: "Volver a iniciar sesiÃ³n",
    verifyEmailButton: "Verificar correo electrÃ³nico",
    resendCode: "Reenviar cÃ³digo",
    email: "Correo electrÃ³nico",
    password: "ContraseÃ±a",
    fullname: "Nombre completo",
    codeSentTo: "CÃ³digo enviado a",
    pleaseInputEmail: "Por favor, introduce tu correo electrÃ³nico",
    pleaseInputValidEmail: "Por favor, introduce un correo electrÃ³nico vÃ¡lido",
    pleaseInputPassword: "Por favor, introduce tu contraseÃ±a",
    pleaseInputFullname: "Por favor, introduce tu nombre completo",
    pleaseInputVerifyCode: "Por favor, introduce el cÃ³digo de verificaciÃ³n",
    pleaseInputNewPassword: "Por favor, introduce tu nueva contraseÃ±a",
    pleaseConfirmPassword: "Por favor, confirma tu contraseÃ±a",
    pleaseInput6DigitCode: "Por favor, introduce el cÃ³digo de 6 dÃ­gitos",
    or: "o",
    noAccount: "Â¿No tienes cuenta?",
    haveAccount: "Â¿Ya tienes cuenta?",
    notReceivedCode: "Â¿No recibiste el cÃ³digo?",
    codeSent: "CÃ³digo enviado",
    registrationSuccessful: "Registro exitoso, por favor inicia sesiÃ³n",
    verificationCodeError: "CÃ³digo de verificaciÃ³n incorrecto, por favor intÃ©ntalo de nuevo",
    doNotSendFrequently: "Por favor, no envÃ­es el cÃ³digo con demasiada frecuencia",
    codeResent: "CÃ³digo reenviado",
    loginSuccessful: "Inicio de sesiÃ³n exitoso",
    loginFailed: "Inicio de sesiÃ³n fallido, por favor verifica tu correo electrÃ³nico y contraseÃ±a",
    fillCompleteInfo: "Por favor, completa la informaciÃ³n de registro",
    pleaseEnterValidEmail: "Por favor, introduce una direcciÃ³n de correo electrÃ³nico vÃ¡lida",
    passwordTooShort: "La contraseÃ±a debe tener al menos 6 caracteres",
    registrationFailed: "Registro fallido, por favor verifica tus datos",
    pleaseInputCode: "Por favor, introduce el cÃ³digo",
    passwordsDoNotMatch: "Las contraseÃ±as no coinciden",
    passwordResetSuccessful: "ContraseÃ±a restablecida con Ã©xito, por favor inicia sesiÃ³n",
    passwordResetFailed: "Fallo al restablecer la contraseÃ±a, por favor verifica tus datos",
    googleLoginFailed: "Fallo al redirigir el inicio de sesiÃ³n de Google, por favor intÃ©ntalo de nuevo mÃ¡s tarde",
    appleLoginInProgress: "La funciÃ³n de inicio de sesiÃ³n de Apple estÃ¡ en desarrollo",
    googleRegisterInProgress: "La funciÃ³n de registro de Google estÃ¡ en desarrollo",
    appleRegisterInProgress: "La funciÃ³n de registro de Apple estÃ¡ en desarrollo",
    verifyingGoogleLogin: "Verificando inicio de sesiÃ³n de Google"
  },
  //ä¸»ç•Œé¢
  lemon: {
    // é¦–é¡µ
    welcome: {
      greeting: "Hola",
      question: "Â¿QuÃ© puedo hacer por ti?",
      tabs: {
        featured: "Destacado",
        research: "InvestigaciÃ³n",
        lifestyle: "Estilo de vida",
        dataAnalysis: "AnÃ¡lisis de datos",
        education: "EducaciÃ³n",
        productivity: "Productividad",
        other: "Otros"
      },
      placeholder: "Â¿En quÃ© puedo ayudarte?",
      communityNote: "Todas las tareas y sitios web mostrados en la comunidad son compartidos voluntariamente por los usuarios. La plataforma no mostrarÃ¡ ningÃºn contenido sin el consentimiento del usuario."
    },
    //å¯¹è¯å¤´éƒ¨
    chatHeader: {
      share: "Compartir",
      viewAllFiles: "Ver todos los archivos en esta tarea",
      moreOptions: "MÃ¡s opciones",
      rename: "Renombrar",
      editTitle: "Editar tÃ­tulo",
      enterNewTitle: "Introducir nuevo tÃ­tulo",
      cancel: "Cancelar",
      confirm: "Confirmar",
      favorite: "AÃ±adir a favoritos",
      unfavorite: "Eliminar de favoritos"
    },
    //æ¶ˆæ¯å¯¹è¯åˆ—è¡¨é¡µ
    message: {
      runCommand: "Ejecutar comando bash",
      readFile: "Leer archivo",
      editFile: "Editar archivo",
      Browse: "Navegando",
      searching: "Buscando",
      minutesAgo: "minutos atrÃ¡s",
      secondsAgo: "segundos atrÃ¡s",
      hoursAgo: "horas atrÃ¡s",
      daysAgo: "dÃ­as atrÃ¡s",
      monthsAgo: "meses atrÃ¡s",
      yearsAgo: "aÃ±os atrÃ¡s",
      copySuccess: "Copiado con Ã©xito",
      copyError: "Error al copiar",
      botInitialResponse: "Hola, he recibido tu solicitud, estoy analizando este problema. Por favor, espera.",
      botInitialPlan: "Elaborando plan"
    },
    //ä¾§è¾¹æ 
    sidebar: {
      newTask: "Nueva tarea",
      shortcutKey: "T",
      moreOptions: "MÃ¡s opciones",
      share: "Compartir",
      rename: "Renombrar",
      collect: "Coleccionar",
      delete: "Eliminar",
      confirmDelete: "Confirmar eliminaciÃ³n",
      deleteConfirmation: "Â¿EstÃ¡s seguro de que quieres eliminar esta conversaciÃ³n?",
      cancel: "Cancelar",
      confirm: "Confirmar",
      noChats: "Crea una nueva tarea para empezar",
      searchPlaceholder: "Buscar tareas..."
    },
    //æ–‡ä»¶æŸ¥çœ‹å™¨
    fileExplorer: {
      allFilesInTask: "Todos los archivos en esta tarea",
      noContent: "Sin contenido",
      preview: "Previsualizar",
      locateInChat: "Localizar en el chat",
      download: "Descargar",
      saveToGoogleDrive: "Guardar en Google Drive",
      selectAll: "Seleccionar todo",
      cancel: "Cancelar",
      batchDownload: "Descarga por lotes",
      fileTypes: {
        all: "Todos",
        document: "Documento",
        image: "Imagen",
        codeFile: "Archivo de cÃ³digo",
        link: "Enlace"
      },
      timeGroups: {
        today: "Hoy",
        yesterday: "Ayer",
        earlier: "Antes"
      },
      weekdays: {
        sunday: "Domingo",
        monday: "Lunes",
        tuesday: "Martes",
        wednesday: "MiÃ©rcoles",
        thursday: "Jueves",
        friday: "Viernes",
        saturday: "SÃ¡bado"
      }
    },
    fullPreview: {
      download: "Descargar",
      exportToPDF: "Exportar a PDF",
      saveToGoogleDrive: "Guardar en Google Drive",
      maximize: "Maximizar",
      minimize: "Minimizar",
      previous: "Anterior",
      next: "Siguiente",
      copy: "Copiar",
      code: "CÃ³digo",
      preview: "Previsualizar",
      close: "Cerrar",
      fileTypePresentation: "No se puede previsualizar",
      cannotPreviewFormat: "Este formato no se puede previsualizar.",
      downloadToView: "Por favor, descarga el archivo para ver el contenido.",
      noContentToCopy: "No hay contenido para copiar.",
      clipboardNotSupported: "El navegador actual no soporta operaciones de portapapeles, por favor copia manualmente.",
      contentCopied: "Contenido copiado.",
      copyFailed: "Error al copiar, por favor intÃ©ntalo de nuevo o copia manualmente.",
      exportPDFPending: "ExportaciÃ³n a PDF exitosa",
      saveToGoogleDrivePending: "La funciÃ³n de guardar en Google Drive estÃ¡ pendiente de implementaciÃ³n."
    },
    preview: {
      title: "La computadora de Lemon",
      openVsCode: "VS Code",
      using: "Lemon estÃ¡ usando",
      performing: "Realizando",
      previousStep: "Paso anterior",
      nextStep: "Siguiente paso",
      realtime: "Tiempo real",
      waitingForDevelopment: "Esperando desarrollo...",
      browser: "Navegador",
      Browse: "Navegando",
      editor: "Editor",
      editingFile: "Editando archivo",
      terminal: "Terminal",
      executingCommand: "Ejecutando comando",
      readingFile: "Leyendo archivo",
      search: "Buscar",
      searching: "Buscando"
    }
  },
  //è®¾ç½®ç•Œé¢
  setting: {
    back: "Volver",
    doneStep: "Terminado",
    prevStep: "Paso anterior",
    nextStep: "Siguiente paso",
    settingModel: "Configurar modelo",
    settingModelTips: "Haz clic en ConfiguraciÃ³n para ir a la pÃ¡gina de configuraciÃ³n",
    menu: {
      basic: "ConfiguraciÃ³n bÃ¡sica",
      defaultModel: "Modelo predeterminado",
      modelService: "Servicio de modelo",
      searchService: "Servicio de bÃºsqueda",
      mcpService: "Servicio MCP",
      experience: 'Biblioteca de experiencias'
    },
    basic: {
      title: "ConfiguraciÃ³n bÃ¡sica",
      langTitle: "ConfiguraciÃ³n de idioma",
      languagePreference: "Preferencia de idioma",
      lang: {
        en: "InglÃ©s",
        zh: "Chino (simplificado)",
        de: "AlemÃ¡n",
        es: "EspaÃ±ol",
        fr: "FrancÃ©s",
        ja: "JaponÃ©s",
        kr: "Coreano",
        tr: "Turco",
        pt: "PortuguÃ©s",
        tw: "Chino (tradicional)",
        vi: "Vietnamita"
      }
    },
    modelService: {
      modelService: "Servicio de Modelo",
      modelServiceTipsOne: "Paso uno: Seleccionar proveedor de modelo",
      modelServiceTipsTwo: "Paso dos: Configurar clave API de entrada",
      modelServiceTipsThree: "Paso tres: Habilitar servicio de modelo",
      title: "Servicio de Modelo",
      searchPlaceholder: "Buscar plataforma",
      defaultPlatform: "Plataforma de sistema predeterminada",
      modelPlatform:  "Plataforma de modelo",
      statusOn: "Activado",
      addPlatform: "AÃ±adir",
      save: "Guardar",
      defaultPlatformDescription: "Los modelos de plataforma predeterminados son proporcionados por el sistema, sin necesidad de configuraciÃ³n",
      apiKey: "Clave API",
      apiKeyPlaceholder: "Por favor, introduce la clave API",
      getApiKey: "Haz clic aquÃ­ para obtener la clave",
      check: "Verificar",
      selectCheckModel: "Por favor selecciona el modelo de verificaciÃ³n",      
      apiAddress: "DirecciÃ³n API",
      apiAddressPlaceholder: "Por favor, introduce la direcciÃ³n API",
      apiAddressTip: "Ignorar la versiÃ³n v1 si termina en /, forzar el uso de la direcciÃ³n introducida si termina en #",
      activateTime: "Tiempo de activaciÃ³n",
      activateTimePlaceholder: "Por favor, introduce el tiempo de activaciÃ³n (minutos)",
      models: "Modelos",
      ungrouped: "Sin agrupar",
      viewOfficialDocs: "Ver la documentaciÃ³n oficial de la plataforma para mÃ¡s informaciÃ³n",
      add: "AÃ±adir",
      confirmDeleteModel: "Â¿EstÃ¡s seguro de que quieres eliminar este modelo?",
      deleteModelSuccess: "Modelo eliminado con Ã©xito",
      deleteModelFailed: "Fallo al eliminar el modelo",
      addModelSuccess: "Modelo aÃ±adido con Ã©xito",
      updateModelSuccess: "Modelo actualizado con Ã©xito",
      copySuccess: "Nombre copiado",
      typeVision: "VisiÃ³n",
      typeNetwork: "Red",
      typeEmbed: "IncrustaciÃ³n",
      typeReasoning: "Razonamiento",
      typeTool: "Herramienta",
      addProvider: "AÃ±adir proveedor",
      confirm: "Confirmar",
      cancel: "Cancelar",
      platformLogo: "Logo de la plataforma",
      providerName: "Nombre del proveedor",
      namePlaceholder: "Nombre",
      providerType: "Tipo de proveedor",
      typePlaceholder: "Tipo",
      enterName: "Por favor, introduce el nombre",
      selectType: "Por favor, selecciona el tipo",
      addPlatformSuccess: "Plataforma aÃ±adida con Ã©xito",
      formValidationFailed: "Fallo en la validaciÃ³n del formulario",
      addModel: "AÃ±adir modelo",
      editModel: "Editar modelo",
      modelId: "ID del modelo",
      modelIdPlaceholder: "Por favor, introduce el ID del modelo",
      modelName: "Nombre del modelo",
      modelNamePlaceholder: "Nombre del modelo",
      groupName: "Nombre del grupo",
      groupNamePlaceholder: "Nombre del grupo",
      modelTypes: "Tipos de modelo",
      enterModelId: "Por favor, introduce el ID del modelo",
      enterModelName: "Por favor, introduce el nombre del modelo",
      enterGroupName: "Por favor, introduce el nombre del grupo",
      selectModelType: "Por favor, selecciona al menos un tipo de modelo",
      editProvider: "Editar proveedor",
      updatePlatformSuccess: "Plataforma actualizada con Ã©xito",
      deletePlatformSuccess: "Plataforma eliminada con Ã©xito",
      deletePlatformFailed: "Fallo al eliminar la plataforma",
      saveSuccess: "Guardado con Ã©xito",
      saveFailed: "Fallo al guardar",
      platforms:{
                Anthropic: "Anthropic",
                ModelScope: "ModelScope é­”å¡”",
                Gemini: "Gemini",
                OpenAI: "OpenAI",
                Ollama: "Ollama",
                qiniu: "ä¸ƒç‰›äº‘",
                WanJieData:  "ä¸‡ç•Œæ•°æ®",
                PPIO: "PPIO æ´¾æ¬§äº‘",
                QianFan: "ç™¾åº¦äº‘åƒå¸†",
                SiliconFlow: "ç¡…åŸºæµåŠ¨",
                Volcengine: "ç«å±±å¼•æ“",
                DeepSeek: "æ·±åº¦æ±‚ç´¢",
                Bailian: "é˜¿é‡Œäº‘ç™¾ç‚¼",
                OpenRouter: "OpenRouter",
                LMStudio: "LM Studio",
            }
    },
    defaultModel: {
      defaultModel: "Configurar modelo predeterminado",
      defaultModelTipsOne: "Haz clic en Modelo predeterminado para ir a la pÃ¡gina de Modelo predeterminado",
      topicNamingModel: "Modelo de nombramiento de temas",
      topicNamingModelTips: "Modelo utilizado para nombrar automÃ¡ticamente nuevos temas",
      emptymodelTips: "Por favor, habilita la plataforma relevante en el servicio de modelo",
      DefaultModelSetting: "ConfiguraciÃ³n de modelo predeterminado",
      defaultAssistantModel: "Modelo de asistente predeterminado",
      assistantModelTips: "Modelo utilizado al crear un asistente",
      topicNamingModel: "Modelo de nombramiento de temas",
      topicNamingModelTips: "Modelo utilizado para nombrar automÃ¡ticamente nuevos temas",
      translationModel: "Modelo de traducciÃ³n",
      translationModelTips: "Modelo utilizado para servicios de traducciÃ³n",
      browserUseModel: "Modelo de servicio de navegador",
      browserUseModelTips: "Modelo utilizado por el navegador integrado; debe soportar herramientas y llamadas de funciones",
      saveSuccess: "ConfiguraciÃ³n guardada con Ã©xito",
      assistantSettings: "ConfiguraciÃ³n del asistente",
      confirm: "Confirmar",
      cancel: "Cancelar",
      assistantName: "Nombre del asistente",
      assistantNamePlaceholder: "Por favor, introduce el nombre del asistente",
      prompt: "Prompt",
      promptPlaceholder: "Por favor, introduce el prompt",
      modelParameters: "ParÃ¡metros del modelo",
      temperature: "Temperatura",
      topP: "Top P",
      maxTokens: "Tokens mÃ¡ximos",
      enableLengthLimit: "Habilitar lÃ­mite de longitud",
      topicNamingSettings: "ConfiguraciÃ³n de nombramiento de temas",
      topicAutoNaming: "Nombramiento automÃ¡tico de temas",
      topicNamingPrompt: "Prompt de nombramiento de temas",
      translationSettings: "ConfiguraciÃ³n de traducciÃ³n",
      translationPrompt: "Prompt de traducciÃ³n"
    },
    searchService: {
      searchService: "Configurar servicio de bÃºsqueda",
      searchServiceTipsOne: "Haz clic en Servicio de bÃºsqueda para ir a la pÃ¡gina de Servicio de bÃºsqueda",
      searchEngineTipsOne: "Paso uno: Seleccionar proveedor de servicio de bÃºsqueda",
      searchEngineTipsTwo: "Paso dos: Configurar clave API de entrada",
      title: "Servicio de BÃºsqueda",
      blacklistSubscription: "SuscripciÃ³n de lista negra",
      addSubscription: "AÃ±adir suscripciÃ³n",
      updateNow: "Actualizar ahora",
      deleteSubscription: "Eliminar suscripciÃ³n",
      confirm: "Confirmar",
      cancel: "Cancelar",
      subscriptionUrl: "URL de suscripciÃ³n",
      subscriptionUrlPlaceholder: "https://example/abcd",
      subscriptionName: "Nombre de la suscripciÃ³n",
      subscriptionNamePlaceholder: "Nombre alternativo a usar cuando la fuente de suscripciÃ³n descargada no tiene nombre",
      name: "Nombre",
      url: "URL",
      addSubscriptionSuccess: "SuscripciÃ³n aÃ±adida con Ã©xito",
      deleteSubscriptionSuccess: "SuscripciÃ³n eliminada con Ã©xito",
      deleteSubscriptionFailed: "Fallo al eliminar la suscripciÃ³n",
      saveConfigSuccess: "ConfiguraciÃ³n guardada con Ã©xito",
      saveConfigFailed: "Fallo al guardar la configuraciÃ³n",
      loadConfigFailed: "Fallo al cargar la configuraciÃ³n",
      formValidationFailed: "Fallo en la validaciÃ³n del formulario",
      enterSubscriptionUrl: "Por favor, introduce la URL de suscripciÃ³n",
      invalidUrl: "Por favor, introduce una URL vÃ¡lida",
      enterSubscriptionName: "Por favor, introduce el nombre de la suscripciÃ³n",
      noSubscriptionSelected: "No se ha seleccionado ninguna suscripciÃ³n",
      searchProvider: "Proveedor de bÃºsqueda",
      generalSettings: "ConfiguraciÃ³n general",
      includeDate: "Incluir fecha",
      includeServer: "Incluir servidor",
      searchEnhancement: "Mejora de bÃºsqueda",
      searchResultCount: "Cantidad de resultados de bÃºsqueda",
      default: "Predeterminado",
      blacklist: "Lista negra",
      blacklistTips: "Introduce dominios para excluir de los resultados de bÃºsqueda",
      blacklistPlaceholder: "Introduce un dominio por lÃ­nea",
      save: "Guardar",
      apiTips: "ConfiguraciÃ³n API",
      apiKeyPlaceholder: "Introduce tu clave API",
      apiKey: "Clave API",
      apiAddress: "DirecciÃ³n API",
      tavilyName: "Tavily (Clave)",
      baiduName: "Baidu (Gratis)",
      bingName: "Bing (Gratis)",
      saveBlacklistSuccess: "Lista negra guardada con Ã©xito",
      saveBlacklistFailed: "Fallo al guardar la lista negra"
    },
    mcpService: {
      title: "Servicio MCP",
      addServer: "AÃ±adir servidor",
      save: "Guardar",
      name: "Nombre",
      namePlaceholder: "Por favor, introduce el nombre",
      description: "DescripciÃ³n",
      descriptionPlaceholder: "DescripciÃ³n",
      type: "Tipo",
      stdio: "Entrada/Salida EstÃ¡ndar (stdio)",
      sse: "Eventos Enviados por el Servidor (sse)",
      streamableHttp: "HTTP Transmitible (streamableHttp)",
      command: "Comando",
      commandPlaceholder: "uvx o npx",
      packageSource: "Fuente del paquete",
      default: "Predeterminado",
      taobaoNpmMirror: "Espejo NPM de Taobao",
      tsinghua: "Universidad de Tsinghua",
      aliyun: "Aliyun",
      ustc: "Universidad de Ciencia y TecnologÃ­a de China",
      huaweiCloud: "Huawei Cloud",
      tencentCloud: "Tencent Cloud",
      args: "Argumentos",
      argsPlaceholder: "arg1\narg2",
      env: "Variables de entorno",
      envPlaceholder: "KEY1=VALOR1\nKEY2=VALOR2",
      mcpServer: "Servidor MCP"
    },
    experience: {
      title: "Biblioteca de experiencias",
      addExperience: "AÃ±adir experiencia",
      editExperience: "Editar experiencia",
      close: "Cerrar",
      titleLabel: "TÃ­tulo",
      titlePlaceholder: "TÃ­tulo de la experiencia",
      goalLabel: "Objetivo",
      goalPlaceholder: "El objetivo de esta experiencia",
      contentLabel: "Contenido",
      contentPlaceholder: "Contenido de la experiencia",
      statusLabel: "Estado",
      enabled: "Habilitado",
      disabled: "Deshabilitado",
      cancel: "Cancelar",
      save: "Guardar",
      delete: "Eliminar",
      undoChanges: "Deshacer cambios",
      deleteExperience: "Eliminar experiencia",
      deleteConfirm: "Â¿EstÃ¡s seguro de que quieres eliminar esta experiencia?",
      totalExperience: "Total de {count} experiencias",
      tableTitle: "TÃ­tulo",
      tableContent: "Contenido",
      tableCreatedAt: "Creado el",
      tableStatus: "Estado",
      tableOperation: "OperaciÃ³n",
      filterAll: "Todos",
      deleteSuccess: "Eliminado con Ã©xito",
      deleteFailed: "Fallo al eliminar",
      createSuccess: "Experiencia aÃ±adida con Ã©xito",
      createFailed: "Fallo al aÃ±adir experiencia",
      updateSuccess: "Actualizado con Ã©xito",
      updateFailed: "Fallo al actualizar",
      updateFailedDataNotExist: "Fallo al actualizar, los datos actuales no existen",
      getDataError: "Error al obtener datos",
      detect: "DetecciÃ³n de intenciÃ³n",
      plan: "PlanificaciÃ³n de tareas",
      action: "EjecuciÃ³n de tareas",
      sunday: "Domingo",
      monday: "Lunes",
      tuesday: "Martes",
      wednesday: "MiÃ©rcoles",
      thursday: "Jueves",
      friday: "Viernes",
      saturday: "SÃ¡bado",
      earlier: "Antes",
    },
  },
  thinking: "Pensando",
  task_error: "Tarea terminada con error",
  stop_task: "Tarea detenida",
  jump_to_result: "Ir al resultado",
  replay: "Reproducir",
  task_finished: "Tarea completada",
  task_playing: "Tarea en progreso",
  click_here_to_go_to_settings:  "Haz clic aquÃ­ para ir a la configuraciÃ³n",
}


================================================
FILE: frontend/src/locals/lang/fr.js
================================================
export default {
  //ç™»å½•ç•Œé¢
  auth: {
    loginToLemonAI: "Se connecter Ã  LemonAI",
    registerLemonAIAccount: "CrÃ©er un compte LemonAI",
    verifyEmail: "VÃ©rifier l'e-mail",
    resetPassword: "RÃ©initialiser le mot de passe",
    loginWithGoogle: "Se connecter avec Google",
    registerWithGoogle: "S'inscrire avec Google",
    login: "Se connecter",
    register: "S'inscrire",
    logOut: "Se dÃ©connecter",
    forgotPassword: "Mot de passe oubliÃ©",
    resetPasswordButton: "RÃ©initialiser le mot de passe",
    backToLogin: "Retour Ã  la connexion",
    verifyEmailButton: "VÃ©rifier l'e-mail",
    resendCode: "Renvoyer le code",
    email: "E-mail",
    password: "Mot de passe",
    fullname: "Nom complet",
    codeSentTo: "Code envoyÃ© Ã ",
    pleaseInputEmail: "Veuillez saisir votre e-mail",
    pleaseInputValidEmail: "Veuillez saisir un e-mail valide",
    pleaseInputPassword: "Veuillez saisir votre mot de passe",
    pleaseInputFullname: "Veuillez saisir votre nom complet",
    pleaseInputVerifyCode: "Veuillez saisir le code de vÃ©rification",
    pleaseInputNewPassword: "Veuillez saisir votre nouveau mot de passe",
    pleaseConfirmPassword: "Veuillez confirmer votre mot de passe",
    pleaseInput6DigitCode: "Veuillez saisir le code Ã  6 chiffres",
    or: "ou",
    noAccount: "Pas de compte ?",
    haveAccount: "DÃ©jÃ  un compte ?",
    notReceivedCode: "Code non reÃ§u ?",
    codeSent: "Code envoyÃ©",
    registrationSuccessful: "Inscription rÃ©ussie, veuillez vous connecter",
    verificationCodeError: "Code de vÃ©rification incorrect, veuillez rÃ©essayer",
    doNotSendFrequently: "Veuillez ne pas envoyer le code trop frÃ©quemment",
    codeResent: "Code renvoyÃ©",
    loginSuccessful: "Connexion rÃ©ussie",
    loginFailed: "Ã‰chec de la connexion, veuillez vÃ©rifier votre e-mail et votre mot de passe",
    fillCompleteInfo: "Veuillez remplir les informations d'inscription complÃ¨tes",
    pleaseEnterValidEmail: "Veuillez saisir une adresse e-mail valide",
    passwordTooShort: "Le mot de passe doit contenir au moins 6 caractÃ¨res",
    registrationFailed: "Ã‰chec de l'inscription, veuillez vÃ©rifier votre saisie",
    pleaseInputCode: "Veuillez saisir le code",
    passwordsDoNotMatch: "Les mots de passe ne correspondent pas",
    passwordResetSuccessful: "Mot de passe rÃ©initialisÃ© avec succÃ¨s, veuillez vous connecter",
    passwordResetFailed: "Ã‰chec de la rÃ©initialisation du mot de passe, veuillez vÃ©rifier votre saisie",
    googleLoginFailed: "Ã‰chec de la redirection de la connexion Google, veuillez rÃ©essayer plus tard",
    appleLoginInProgress: "La fonction de connexion Apple est en cours de dÃ©veloppement",
    googleRegisterInProgress: "La fonction d'inscription Google est en cours de dÃ©veloppement",
    appleRegisterInProgress: "La fonction d'inscription Apple est en cours de dÃ©veloppement",
    verifyingGoogleLogin: "VÃ©rification de la connexion Google en cours"
  },
  //ä¸»ç•Œé¢
  lemon: {
    // é¦–é¡µ
    welcome: {
      greeting: "Bonjour",
      question: "Que puis-je faire pour vous ?",
      tabs: {
        featured: "En vedette",
        research: "Recherche",
        lifestyle: "Mode de vie",
        dataAnalysis: "Analyse de donnÃ©es",
        education: "Ã‰ducation",
        productivity: "ProductivitÃ©",
        other: "Autre"
      },
      placeholder: "Comment puis-je vous aider ?",
      communityNote: "Toutes les tÃ¢ches et sites web affichÃ©s dans la communautÃ© sont partagÃ©s volontairement par les utilisateurs. La plateforme n'affichera aucun contenu sans le consentement de l'utilisateur."
    },
    //å¯¹è¯å¤´éƒ¨
    chatHeader: {
      share: "Partager",
      viewAllFiles: "Voir tous les fichiers de cette tÃ¢che",
      moreOptions: "Plus d'options",
      rename: "Renommer",
      editTitle: "Modifier le titre",
      enterNewTitle: "Saisir un nouveau titre",
      cancel: "Annuler",
      confirm: "Confirmer",
      favorite: "Ajouter aux favoris",
      unfavorite: "Supprimer des favoris"
    },
    //æ¶ˆæ¯å¯¹è¯åˆ—è¡¨é¡µ
    message: {
      runCommand: "ExÃ©cuter la commande bash",
      readFile: "Lire le fichier",
      editFile: "Modifier le fichier",
      Browse: "Navigation en cours",
      searching: "Recherche en cours",
      minutesAgo: "minutes auparavant",
      secondsAgo: "secondes auparavant",
      hoursAgo: "heures auparavant",
      daysAgo: "jours auparavant",
      monthsAgo: "mois auparavant",
      yearsAgo: "ans auparavant",
      copySuccess: "CopiÃ© avec succÃ¨s",
      copyError: "Ã‰chec de la copie",
      botInitialResponse: "Bonjour, j'ai reÃ§u votre demande et j'analyse le problÃ¨me. Veuillez patienter.",
      botInitialPlan: "Ã‰laboration du plan"
    },
    //ä¾§è¾¹æ 
    sidebar: {
      newTask: "Nouvelle tÃ¢che",
      shortcutKey: "T",
      moreOptions: "Plus d'options",
      share: "Partager",
      rename: "Renommer",
      collect: "Collecter",
      delete: "Supprimer",
      confirmDelete: "Confirmer la suppression",
      deleteConfirmation: "ÃŠtes-vous sÃ»r de vouloir supprimer cette conversation ?",
      cancel: "Annuler",
      confirm: "Confirmer",
      noChats: "CrÃ©ez une nouvelle tÃ¢che pour commencer",
      searchPlaceholder: "Rechercher des tÃ¢ches..."
    },
    //æ–‡ä»¶æŸ¥çœ‹å™¨
    fileExplorer: {
      allFilesInTask: "Tous les fichiers de cette tÃ¢che",
      noContent: "Pas de contenu",
      preview: "AperÃ§u",
      locateInChat: "Localiser dans le chat",
      download: "TÃ©lÃ©charger",
      saveToGoogleDrive: "Enregistrer sur Google Drive",
      selectAll: "Tout sÃ©lectionner",
      cancel: "Annuler",
      batchDownload: "TÃ©lÃ©chargement par lots",
      fileTypes: {
        all: "Tous",
        document: "Document",
        image: "Image",
        codeFile: "Fichier de code",
        link: "Lien"
      },
      timeGroups: {
        today: "Aujourd'hui",
        yesterday: "Hier",
        earlier: "Plus tÃ´t"
      },
      weekdays: {
        sunday: "Dimanche",
        monday: "Lundi",
        tuesday: "Mardi",
        wednesday: "Mercredi",
        thursday: "Jeudi",
        friday: "Vendredi",
        saturday: "Samedi"
      }
    },
    fullPreview: {
      download: "TÃ©lÃ©charger",
      exportToPDF: "Exporter en PDF",
      saveToGoogleDrive: "Enregistrer sur Google Drive",
      maximize: "Maximiser",
      minimize: "Minimiser",
      previous: "PrÃ©cÃ©dent",
      next: "Suivant",
      copy: "Copier",
      code: "Code",
      preview: "AperÃ§u",
      close: "Fermer",
      fileTypePresentation: "Impossible de prÃ©visualiser",
      cannotPreviewFormat: "Ce format ne peut pas Ãªtre prÃ©visualisÃ©.",
      downloadToView: "Veuillez tÃ©lÃ©charger le fichier pour voir le contenu.",
      noContentToCopy: "Aucun contenu Ã  copier.",
      clipboardNotSupported: "Le navigateur actuel ne prend pas en charge les opÃ©rations du presse-papiers, veuillez copier manuellement.",
      contentCopied: "Contenu copiÃ©.",
      copyFailed: "Ã‰chec de la copie, veuillez rÃ©essayer ou copier manuellement.",
      exportPDFPending: "Exportation PDF rÃ©ussie",
      saveToGoogleDrivePending: "La fonction d'enregistrement sur Google Drive est en attente de dÃ©veloppement."
    },
    preview: {
      title: "L'ordinateur de Lemon",
      openVsCode: "VS Code",
      using: "Lemon utilise",
      performing: "ExÃ©cution de",
      previousStep: "Ã‰tape prÃ©cÃ©dente",
      nextStep: "Ã‰tape suivante",
      realtime: "Temps rÃ©el",
      waitingForDevelopment: "En attente de dÃ©veloppement...",
      browser: "Navigateur",
      Browse: "Navigation",
      editor: "Ã‰diteur",
      editingFile: "Modification du fichier",
      terminal: "Terminal",
      executingCommand: "ExÃ©cution de la commande",
      readingFile: "Lecture du fichier",
      search: "Rechercher",
      searching: "Recherche"
    }
  },
  //è®¾ç½®ç•Œé¢
  setting: {
    back: "Retour",
    doneStep: "TerminÃ©",
    prevStep: "Ã‰tape prÃ©cÃ©dente",
    nextStep: "Ã‰tape suivante",
    settingModel: "ParamÃ©trer le modÃ¨le",
    settingModelTips: "Cliquez sur ParamÃ¨tres pour accÃ©der Ã  la page de paramÃ¨tres",
    menu: {
      basic: "ParamÃ¨tres de base",
      defaultModel: "ModÃ¨le par dÃ©faut",
      modelService: "Service de modÃ¨le",
      searchService: "Service de recherche",
      mcpService: "Service MCP",
      experience: 'BibliothÃ¨que d\'expÃ©riences'
    },
    basic: {
      title: "ParamÃ¨tres de base",
      langTitle: "ParamÃ¨tres linguistiques",
      languagePreference: "PrÃ©fÃ©rence linguistique",
      lang: {
        en: "Anglais",
        zh: "Chinois (simplifiÃ©)",
        de: "Allemand",
        es: "Espagnol",
        fr: "FranÃ§ais",
        ja: "Japonais",
        kr: "CorÃ©en",
        tr: "Turc",
        pt: "Portugais",
        tw: "Chinois (traditionnel)",
        vi: "Vietnamien"
      }
    },
    modelService: {
      modelService: "Service de modÃ¨le",
      modelServiceTipsOne: "PremiÃ¨re Ã©tape : choisir le fournisseur de modÃ¨le",
      modelServiceTipsTwo: "DeuxiÃ¨me Ã©tape : dÃ©finir la clÃ© API d'entrÃ©e",
      modelServiceTipsThree: "TroisiÃ¨me Ã©tape : activer le service de modÃ¨le",
      title: "Service de modÃ¨le",
      searchPlaceholder: "Rechercher une plateforme",
      defaultPlatform: "Plateforme systÃ¨me par dÃ©faut",
      modelPlatform:  "Plateforme de modÃ¨le",
      statusOn: "ActivÃ©",
      addPlatform: "Ajouter",
      save: "Enregistrer",
      defaultPlatformDescription: "Les modÃ¨les de plateforme par dÃ©faut sont fournis par le systÃ¨me et ne nÃ©cessitent aucune configuration",
      apiKey: "ClÃ© API",
      apiKeyPlaceholder: "Veuillez saisir la clÃ© API",
      getApiKey: "Cliquez ici pour obtenir la clÃ©",
      check: "VÃ©rifier",
      selectCheckModel: "Veuillez sÃ©lectionner le modÃ¨le de vÃ©rification",
      apiAddress: "Adresse API",
      apiAddressPlaceholder: "Veuillez saisir l'adresse API",
      apiAddressTip: "Ignorer la version v1 si se termine par /, forcer l'utilisation de l'adresse saisie si se termine par #",
      activateTime: "Temps d'activation",
      activateTimePlaceholder: "Veuillez saisir le temps d'activation (minutes)",
      models: "ModÃ¨les",
      ungrouped: "Non groupÃ©",
      viewOfficialDocs: "Consulter la documentation officielle de la plateforme pour plus d'informations",
      add: "Ajouter",
      confirmDeleteModel: "ÃŠtes-vous sÃ»r de vouloir supprimer ce modÃ¨le ?",
      deleteModelSuccess: "ModÃ¨le supprimÃ© avec succÃ¨s",
      deleteModelFailed: "Ã‰chec de la suppression du modÃ¨le",
      addModelSuccess: "ModÃ¨le ajoutÃ© avec succÃ¨s",
      updateModelSuccess: "ModÃ¨le mis Ã  jour avec succÃ¨s",
      copySuccess: "Nom copiÃ©",
      typeVision: "Vision",
      typeNetwork: "RÃ©seau",
      typeEmbed: "IntÃ©gration",
      typeReasoning: "Raisonnement",
      typeTool: "Outil",
      addProvider: "Ajouter un fournisseur",
      confirm: "Confirmer",
      cancel: "Annuler",
      platformLogo: "Logo de la plateforme",
      providerName: "Nom du fournisseur",
      namePlaceholder: "Nom",
      providerType: "Type de fournisseur",
      typePlaceholder: "Type",
      enterName: "Veuillez saisir un nom",
      selectType: "Veuillez sÃ©lectionner un type",
      addPlatformSuccess: "Plateforme ajoutÃ©e avec succÃ¨s",
      formValidationFailed: "Ã‰chec de la validation du formulaire",
      addModel: "Ajouter un modÃ¨le",
      editModel: "Modifier le modÃ¨le",
      modelId: "ID du modÃ¨le",
      modelIdPlaceholder: "Veuillez saisir l'ID du modÃ¨le",
      modelName: "Nom du modÃ¨le",
      modelNamePlaceholder: "Nom du modÃ¨le",
      groupName: "Nom du groupe",
      groupNamePlaceholder: "Nom du groupe",
      modelTypes: "Types de modÃ¨les",
      enterModelId: "Veuillez saisir l'ID du modÃ¨le",
      enterModelName: "Veuillez saisir le nom du modÃ¨le",
      enterGroupName: "Veuillez saisir le nom du groupe",
      selectModelType: "Veuillez sÃ©lectionner au moins un type de modÃ¨le",
      editProvider: "Modifier le fournisseur",
      updatePlatformSuccess: "Plateforme mise Ã  jour avec succÃ¨s",
      deletePlatformSuccess: "Plateforme supprimÃ©e avec succÃ¨s",
      deletePlatformFailed: "Ã‰chec de la suppression de la plateforme",
      saveSuccess: "EnregistrÃ© avec succÃ¨s",
      saveFailed: "Ã‰chec de l'enregistrement",
      platforms:{
                Anthropic: "Anthropic",
                ModelScope: "ModelScope é­”å¡”",
                Gemini: "Gemini",
                OpenAI: "OpenAI",
                Ollama: "Ollama",
                qiniu: "ä¸ƒç‰›äº‘",
                WanJieData:  "ä¸‡ç•Œæ•°æ®",
                PPIO: "PPIO æ´¾æ¬§äº‘",
                QianFan: "ç™¾åº¦äº‘åƒå¸†",
                SiliconFlow: "ç¡…åŸºæµåŠ¨",
                Volcengine: "ç«å±±å¼•æ“",
                DeepSeek: "æ·±åº¦æ±‚ç´¢",
                Bailian: "é˜¿é‡Œäº‘ç™¾ç‚¼",
                OpenRouter: "OpenRouter",
                LMStudio: "LM Studio",
            }
    },
    defaultModel: {
      defaultModel: "DÃ©finir le modÃ¨le par dÃ©faut",
      defaultModelTipsOne: "Cliquez sur ModÃ¨le par dÃ©faut pour accÃ©der Ã  la page ModÃ¨le par dÃ©faut",
      topicNamingModel: "ModÃ¨le de nommage de sujet",
      topicNamingModelTips: "ModÃ¨le utilisÃ© pour nommer automatiquement les nouveaux sujets",
      emptymodelTips: "Veuillez activer la plateforme pertinente dans le service de modÃ¨le",
      DefaultModelSetting: "ParamÃ¨tres du modÃ¨le par dÃ©faut",
      defaultAssistantModel: "ModÃ¨le d'assistant par dÃ©faut",
      assistantModelTips: "ModÃ¨le utilisÃ© lors de la crÃ©ation d'un assistant",
      topicNamingModel: "ModÃ¨le de nommage de sujet",
      topicNamingModelTips: "ModÃ¨le utilisÃ© pour nommer automatiquement les nouveaux sujets",
      translationModel: "ModÃ¨le de traduction",
      translationModelTips: "ModÃ¨le utilisÃ© pour les services de traduction",
      browserUseModel: "ModÃ¨le de service de navigateur",
      browserUseModelTips: "ModÃ¨le utilisÃ© par le navigateur intÃ©grÃ© ; doit prendre en charge les outils et les appels de fonction",
      saveSuccess: "ParamÃ¨tres enregistrÃ©s avec succÃ¨s",
      assistantSettings: "ParamÃ¨tres de l'assistant",
      confirm: "Confirmer",
      cancel: "Annuler",
      assistantName: "Nom de l'assistant",
      assistantNamePlaceholder: "Veuillez saisir le nom de l'assistant",
      prompt: "Prompt",
      promptPlaceholder: "Veuillez saisir le prompt",
      modelParameters: "ParamÃ¨tres du modÃ¨le",
      temperature: "TempÃ©rature",
      topP: "Top P",
      maxTokens: "Tokens maximum",
      enableLengthLimit: "Activer la limite de longueur",
      topicNamingSettings: "ParamÃ¨tres de nommage de sujet",
      topicAutoNaming: "Nommage automatique de sujet",
      topicNamingPrompt: "Prompt de nommage de sujet",
      translationSettings: "ParamÃ¨tres de traduction",
      translationPrompt: "Prompt de traduction"
    },
    searchService: {
      searchService: "ParamÃ©trer le service de recherche",
      searchServiceTipsOne: "Cliquez sur Service de recherche pour accÃ©der Ã  la page Service de recherche",
      searchEngineTipsOne: "PremiÃ¨re Ã©tape : choisir le fournisseur de service de recherche",
      searchEngineTipsTwo: "DeuxiÃ¨me Ã©tape : dÃ©finir la clÃ© API d'entrÃ©e",
      title: "Service de recherche",
      blacklistSubscription: "Abonnement liste noire",
      addSubscription: "Ajouter un abonnement",
      updateNow: "Mettre Ã  jour maintenant",
      deleteSubscription: "Supprimer l'abonnement",
      confirm: "Confirmer",
      cancel: "Annuler",
      subscriptionUrl: "URL d'abonnement",
      subscriptionUrlPlaceholder: "https://example/abcd",
      subscriptionName: "Nom de l'abonnement",
      subscriptionNamePlaceholder: "Nom de remplacement utilisÃ© lorsque la source d'abonnement tÃ©lÃ©chargÃ©e n'a pas de nom",
      name: "Nom",
      url: "URL",
      addSubscriptionSuccess: "Abonnement ajoutÃ© avec succÃ¨s",
      deleteSubscriptionSuccess: "Abonnement supprimÃ© avec succÃ¨s",
      deleteSubscriptionFailed: "Ã‰chec de la suppression de l'abonnement",
      saveConfigSuccess: "Configuration enregistrÃ©e avec succÃ¨s",
      saveConfigFailed: "Ã‰chec de l'enregistrement de la configuration",
      loadConfigFailed: "Ã‰chec du chargement de la configuration",
      formValidationFailed: "Ã‰chec de la validation du formulaire",
      enterSubscriptionUrl: "Veuillez saisir l'URL d'abonnement",
      invalidUrl: "Veuillez saisir une URL valide",
      enterSubscriptionName: "Veuillez saisir le nom de l'abonnement",
      noSubscriptionSelected: "Aucun abonnement sÃ©lectionnÃ©",
      searchProvider: "Fournisseur de recherche",
      generalSettings: "ParamÃ¨tres gÃ©nÃ©raux",
      includeDate: "Inclure la date",
      includeServer: "Inclure le serveur",
      searchEnhancement: "AmÃ©lioration de la recherche",
      searchResultCount: "Nombre de rÃ©sultats de recherche",
      default: "Par dÃ©faut",
      blacklist: "Liste noire",
      blacklistTips: "Saisissez les domaines Ã  exclure des rÃ©sultats de recherche",
      blacklistPlaceholder: "Saisissez un domaine par ligne",
      save: "Enregistrer",
      apiTips: "Configuration API",
      apiKeyPlaceholder: "Saisissez votre clÃ© API",
      apiKey: "ClÃ© API",
      apiAddress: "Adresse API",
      tavilyName: "Tavily (ClÃ©)",
      baiduName: "Baidu (Gratuit)",
      bingName: "Bing (Gratuit)",
      saveBlacklistSuccess: "Liste noire enregistrÃ©e avec succÃ¨s",
      saveBlacklistFailed: "Ã‰chec de l'enregistrement de la liste noire"
    },
    mcpService: {
      title: "Service MCP",
      addServer: "Ajouter un serveur",
      save: "Enregistrer",
      name: "Nom",
      namePlaceholder: "Veuillez saisir un nom",
      description: "Description",
      descriptionPlaceholder: "Description",
      type: "Type",
      stdio: "EntrÃ©e/Sortie Standard (stdio)",
      sse: "Ã‰vÃ©nements EnvoyÃ©s par le Serveur (sse)",
      streamableHttp: "HTTP Streamable (streamableHttp)",
      command: "Commande",
      commandPlaceholder: "uvx ou npx",
      packageSource: "Source du paquet",
      default: "Par dÃ©faut",
      taobaoNpmMirror: "Miroir NPM Taobao",
      tsinghua: "UniversitÃ© Tsinghua",
      aliyun: "Aliyun",
      ustc: "UniversitÃ© des Sciences et Technologies de Chine",
      huaweiCloud: "Huawei Cloud",
      tencentCloud: "Tencent Cloud",
      args: "Arguments",
      argsPlaceholder: "arg1\narg2",
      env: "Variables d'environnement",
      envPlaceholder: "CLÃ‰1=VALEUR1\nCLÃ‰2=VALEUR2",
      mcpServer: "Serveur MCP"
    },
    experience: {
      title: "BibliothÃ¨que d'expÃ©riences",
      addExperience: "Ajouter une expÃ©rience",
      editExperience: "Modifier l'expÃ©rience",
      close: "Fermer",
      titleLabel: "Titre",
      titlePlaceholder: "Titre de l'expÃ©rience",
      goalLabel: "Objectif",
      goalPlaceholder: "L'objectif de cette expÃ©rience",
      contentLabel: "Contenu",
      contentPlaceholder: "Contenu de l'expÃ©rience",
      statusLabel: "Statut",
      enabled: "ActivÃ©",
      disabled: "DÃ©sactivÃ©",
      cancel: "Annuler",
      save: "Enregistrer",
      delete: "Supprimer",
      undoChanges: "Annuler les modifications",
      deleteExperience: "Supprimer l'expÃ©rience",
      deleteConfirm: "ÃŠtes-vous sÃ»r de vouloir supprimer cette expÃ©rience ?",
      totalExperience: "Total de {count} expÃ©riences",
      tableTitle: "Titre",
      tableContent: "Contenu",
      tableCreatedAt: "CrÃ©Ã© le",
      tableStatus: "Statut",
      tableOperation: "OpÃ©ration",
      filterAll: "Tous",
      deleteSuccess: "SupprimÃ© avec succÃ¨s",
      deleteFailed: "Ã‰chec de la suppression",
      createSuccess: "ExpÃ©rience ajoutÃ©e avec succÃ¨s",
      createFailed: "Ã‰chec de l'ajout de l'expÃ©rience",
      updateSuccess: "Mis Ã  jour avec succÃ¨s",
      updateFailed: "Ã‰chec de la mise Ã  jour",
      updateFailedDataNotExist: "Ã‰chec de la mise Ã  jour, les donnÃ©es actuelles n'existent pas",
      getDataError: "Erreur lors de la rÃ©cupÃ©ration des donnÃ©es",
      detect: "DÃ©tection d'intention",
      plan: "Planification des tÃ¢ches",
      action: "ExÃ©cution des tÃ¢ches",
      sunday: "Dimanche",
      monday: "Lundi",
      tuesday: "Mardi",
      wednesday: "Mercredi",
      thursday: "Jeudi",
      friday: "Vendredi",
      saturday: "Samedi",
      earlier: "Plus tÃ´t",
    },
  },
  thinking: "RÃ©flexion en cours",
  task_error: "TÃ¢che terminÃ©e avec une erreur",
  stop_task: "TÃ¢che arrÃªtÃ©e",
  jump_to_result: "Aller au rÃ©sultat",
  replay: "Rejouer",
  task_finished: "TÃ¢che terminÃ©e",
  task_playing: "TÃ¢che en cours",
  click_here_to_go_to_settings:  "Cliquez ici pour accÃ©der aux paramÃ¨tres",
}


================================================
FILE: frontend/src/locals/lang/ja.js
================================================
export default {
  // ãƒ­ã‚°ã‚¤ãƒ³ç”»é¢
  auth: {
    loginToLemonAI: "LemonAIã«ãƒ­ã‚°ã‚¤ãƒ³",
    registerLemonAIAccount: "LemonAIã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’ç™»éŒ²",
    verifyEmail: "ãƒ¡ãƒ¼ãƒ«èªè¨¼",
    resetPassword: "ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã®ãƒªã‚»ãƒƒãƒˆ",
    loginWithGoogle: "Googleã§ãƒ­ã‚°ã‚¤ãƒ³",
    registerWithGoogle: "Googleã§ç™»éŒ²",
    login: "ãƒ­ã‚°ã‚¤ãƒ³",
    register: "ç™»éŒ²",
    logOut: "ãƒ­ã‚°ã‚¢ã‚¦ãƒˆ",
    forgotPassword: "ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å¿˜ã‚ŒãŸå ´åˆ",
    resetPasswordButton: "ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’ãƒªã‚»ãƒƒãƒˆ",
    backToLogin: "ãƒ­ã‚°ã‚¤ãƒ³ç”»é¢ã«æˆ»ã‚‹",
    verifyEmailButton: "ãƒ¡ãƒ¼ãƒ«èªè¨¼",
    resendCode: "èªè¨¼ã‚³ãƒ¼ãƒ‰ã‚’å†é€ä¿¡",
    email: "ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹",
    password: "ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰",
    fullname: "ãƒ•ãƒ«ãƒãƒ¼ãƒ ",
    codeSentTo: "èªè¨¼ã‚³ãƒ¼ãƒ‰ã‚’ä»¥ä¸‹ã«é€ä¿¡ã—ã¾ã—ãŸï¼š",
    pleaseInputEmail: "ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„",
    pleaseInputValidEmail: "æœ‰åŠ¹ãªãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„",
    pleaseInputPassword: "ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„",
    pleaseInputFullname: "ãƒ•ãƒ«ãƒãƒ¼ãƒ ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„",
    pleaseInputVerifyCode: "èªè¨¼ã‚³ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„",
    pleaseInputNewPassword: "æ–°ã—ã„ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„",
    pleaseConfirmPassword: "ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’ç¢ºèªã—ã¦ãã ã•ã„",
    pleaseInput6DigitCode: "6æ¡ã®èªè¨¼ã‚³ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„",
    or: "ã¾ãŸã¯",
    noAccount: "ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’ãŠæŒã¡ã§ãªã„ã§ã™ã‹ï¼Ÿ",
    haveAccount: "ã™ã§ã«ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’ãŠæŒã¡ã§ã™ã‹ï¼Ÿ",
    notReceivedCode: "èªè¨¼ã‚³ãƒ¼ãƒ‰ãŒå±Šã„ã¦ã„ã¾ã›ã‚“ã‹ï¼Ÿ",
    codeSent: "èªè¨¼ã‚³ãƒ¼ãƒ‰ã‚’é€ä¿¡ã—ã¾ã—ãŸ",
    registrationSuccessful: "ç™»éŒ²ãŒæˆåŠŸã—ã¾ã—ãŸã€‚ãƒ­ã‚°ã‚¤ãƒ³ã—ã¦ãã ã•ã„",
    verificationCodeError: "èªè¨¼ã‚³ãƒ¼ãƒ‰ãŒé–“é•ã£ã¦ã„ã¾ã™ã€‚ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„",
    doNotSendFrequently: "èªè¨¼ã‚³ãƒ¼ãƒ‰ã‚’é »ç¹ã«é€ä¿¡ã—ãªã„ã§ãã ã•ã„",
    codeResent: "èªè¨¼ã‚³ãƒ¼ãƒ‰ã‚’å†é€ä¿¡ã—ã¾ã—ãŸ",
    loginSuccessful: "ãƒ­ã‚°ã‚¤ãƒ³ã«æˆåŠŸã—ã¾ã—ãŸ",
    loginFailed: "ãƒ­ã‚°ã‚¤ãƒ³ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã¨ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’ç¢ºèªã—ã¦ãã ã•ã„",
    fillCompleteInfo: "ç™»éŒ²æƒ…å ±ã‚’å…¨ã¦å…¥åŠ›ã—ã¦ãã ã•ã„",
    pleaseEnterValidEmail: "æœ‰åŠ¹ãªãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„",
    passwordTooShort: "ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã¯6æ–‡å­—ä»¥ä¸Šã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“",
    registrationFailed: "ç™»éŒ²ã«å¤±æ•—ã—ã¾ã—ãŸã€‚å…¥åŠ›å†…å®¹ã‚’ç¢ºèªã—ã¦ãã ã•ã„",
    pleaseInputCode: "èªè¨¼ã‚³ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„",
    passwordsDoNotMatch: "ç¢ºèªç”¨ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒä¸€è‡´ã—ã¾ã›ã‚“",
    passwordResetSuccessful: "ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã®ãƒªã‚»ãƒƒãƒˆã«æˆåŠŸã—ã¾ã—ãŸã€‚ãƒ­ã‚°ã‚¤ãƒ³ã—ã¦ãã ã•ã„",
    passwordResetFailed: "ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã®ãƒªã‚»ãƒƒãƒˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚å…¥åŠ›å†…å®¹ã‚’ç¢ºèªã—ã¦ãã ã•ã„",
    googleLoginFailed: "Googleãƒ­ã‚°ã‚¤ãƒ³ã«å¤±æ•—ã—ã¾ã—ãŸã€‚å¾Œã§ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„",
    appleLoginInProgress: "Appleãƒ­ã‚°ã‚¤ãƒ³æ©Ÿèƒ½ã¯é–‹ç™ºä¸­ã§ã™",
    googleRegisterInProgress: "Googleç™»éŒ²æ©Ÿèƒ½ã¯é–‹ç™ºä¸­ã§ã™",
    appleRegisterInProgress: "Appleç™»éŒ²æ©Ÿèƒ½ã¯é–‹ç™ºä¸­ã§ã™",
    verifyingGoogleLogin: "Googleãƒ­ã‚°ã‚¤ãƒ³ã‚’èªè¨¼ä¸­"
  },
  // ãƒ¡ã‚¤ãƒ³ç”»é¢
  lemon: {
    // ãƒ›ãƒ¼ãƒ 
    welcome: {
      greeting: "ã“ã‚“ã«ã¡ã¯",
      question: "ä½•ã‚’ã—ã¾ã—ã‚‡ã†ã‹ï¼Ÿ",
      tabs: {
        featured: "ãŠã™ã™ã‚",
        research: "ç ”ç©¶",
        lifestyle: "ãƒ©ã‚¤ãƒ•ã‚¹ã‚¿ã‚¤ãƒ«",
        dataAnalysis: "ãƒ‡ãƒ¼ã‚¿åˆ†æ",
        education: "æ•™è‚²",
        productivity: "ç”Ÿç”£æ€§",
        other: "ãã®ä»–"
      },
      placeholder: "ä½•ã‹ãŠæ‰‹ä¼ã„ã§ãã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã™ã‹ï¼Ÿ",
      communityNote: "ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ã§è¡¨ç¤ºã•ã‚Œã‚‹ã™ã¹ã¦ã®ã‚¿ã‚¹ã‚¯ã¨ã‚¦ã‚§ãƒ–ã‚µã‚¤ãƒˆã¯ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒè‡ªç™ºçš„ã«å…±æœ‰ã—ãŸã‚‚ã®ã§ã™ã€‚ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®åŒæ„ãªã—ã«ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã¯è¡¨ç¤ºã•ã‚Œã¾ã›ã‚“ã€‚"
    },
    // ãƒãƒ£ãƒƒãƒˆãƒ˜ãƒƒãƒ€ãƒ¼
    chatHeader: {
      share: "å…±æœ‰",
      viewAllFiles: "ã“ã®ã‚¿ã‚¹ã‚¯å†…ã®ã™ã¹ã¦ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’è¡¨ç¤º",
      moreOptions: "ãã®ä»–ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³",
      rename: "åå‰ã®å¤‰æ›´",
      editTitle: "ã‚¿ã‚¤ãƒˆãƒ«ã‚’ç·¨é›†",
      enterNewTitle: "æ–°ã—ã„ã‚¿ã‚¤ãƒˆãƒ«ã‚’å…¥åŠ›",
      cancel: "ã‚­ãƒ£ãƒ³ã‚»ãƒ«",
      confirm: "ç¢ºå®š",
      favorite: "ãŠæ°—ã«å…¥ã‚Šã«è¿½åŠ ",
      unfavorite: "ãŠæ°—ã«å…¥ã‚Šã‹ã‚‰å‰Šé™¤"
    },
    // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ä¼šè©±ãƒªã‚¹ãƒˆãƒšãƒ¼ã‚¸
    message: {
      runCommand: "bashã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œ",
      readFile: "ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚€",
      editFile: "ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç·¨é›†",
      browsing: "é–²è¦§ä¸­",
      searching: "æ¤œç´¢ä¸­",
      minutesAgo: "åˆ†å‰",
      secondsAgo: "ç§’å‰",
      hoursAgo: "æ™‚é–“å‰",
      daysAgo: "æ—¥å‰",
      monthsAgo: "ãƒ¶æœˆå‰",
      yearsAgo: "å¹´å‰",
      copySuccess: "ã‚³ãƒ”ãƒ¼ã«æˆåŠŸã—ã¾ã—ãŸ",
      copyError: "ã‚³ãƒ”ãƒ¼ã«å¤±æ•—ã—ã¾ã—ãŸ",
      botInitialResponse: "ã“ã‚“ã«ã¡ã¯ã€ã”ä¾é ¼ã‚’å—ã‘å–ã‚Šã¾ã—ãŸã€‚å•é¡Œã‚’åˆ†æä¸­ã§ã™ã€‚å°‘ã€…ãŠå¾…ã¡ãã ã•ã„ã€‚",
      botInitialPlan: "è¨ˆç”»ã‚’ç«‹æ¡ˆä¸­"
    },
    // ã‚µã‚¤ãƒ‰ãƒãƒ¼
    sidebar: {
      newTask: "æ–°è¦ã‚¿ã‚¹ã‚¯",
      shortcutKey: "T",
      moreOptions: "ãã®ä»–ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³",
      share: "å…±æœ‰",
      rename: "åå‰ã®å¤‰æ›´",
      collect: "ãŠæ°—ã«å…¥ã‚Š",
      delete: "å‰Šé™¤",
      confirmDelete: "å‰Šé™¤ã®ç¢ºèª",
      deleteConfirmation: "ã“ã®ä¼šè©±ã‚’å‰Šé™¤ã—ã¦ã‚‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ",
      cancel: "ã‚­ãƒ£ãƒ³ã‚»ãƒ«",
      confirm: "ç¢ºå®š",
      noChats: "ã‚¿ã‚¹ã‚¯ã‚’ä½œæˆã—ã¦é–‹å§‹",
      searchPlaceholder: "ã‚¿ã‚¹ã‚¯ã‚’æ¤œç´¢..."
    },
    // ãƒ•ã‚¡ã‚¤ãƒ«ã‚¨ã‚¯ã‚¹ãƒ—ãƒ­ãƒ¼ãƒ©ãƒ¼
    fileExplorer: {
      allFilesInTask: "ã“ã®ã‚¿ã‚¹ã‚¯å†…ã®ã™ã¹ã¦ã®ãƒ•ã‚¡ã‚¤ãƒ«",
      noContent: "ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãŒã‚ã‚Šã¾ã›ã‚“",
      preview: "ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼",
      locateInChat: "ãƒãƒ£ãƒƒãƒˆå†…ã§æ¤œç´¢",
      download: "ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰",
      saveToGoogleDrive: "Google Driveã«ä¿å­˜",
      selectAll: "ã™ã¹ã¦é¸æŠ",
      cancel: "ã‚­ãƒ£ãƒ³ã‚»ãƒ«",
      batchDownload: "ä¸€æ‹¬ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰",
      fileTypes: {
        all: "ã™ã¹ã¦",
        document: "ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ",
        image: "ç”»åƒ",
        codeFile: "ã‚³ãƒ¼ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ«",
        link: "ãƒªãƒ³ã‚¯"
      },
      timeGroups: {
        today: "ä»Šæ—¥",
        yesterday: "æ˜¨æ—¥",
        earlier: "ãã‚Œä»¥å‰"
      },
      weekdays: {
        sunday: "æ—¥æ›œæ—¥",
        monday: "æœˆæ›œæ—¥",
        tuesday: "ç«æ›œæ—¥",
        wednesday: "æ°´æ›œæ—¥",
        thursday: "æœ¨æ›œæ—¥",
        friday: "é‡‘æ›œæ—¥",
        saturday: "åœŸæ›œæ—¥"
      }
    },
    fullPreview: {
      download: "ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰",
      exportToPDF: "PDFã«ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ",
      saveToGoogleDrive: "Google Driveã«ä¿å­˜",
      maximize: "æœ€å¤§åŒ–",
      minimize: "æœ€å°åŒ–",
      previous: "å‰ã¸",
      next: "æ¬¡ã¸",
      copy: "ã‚³ãƒ”ãƒ¼",
      code: "ã‚³ãƒ¼ãƒ‰",
      preview: "ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼",
      close: "é–‰ã˜ã‚‹",
      fileTypePresentation: "ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ä¸å¯",
      cannotPreviewFormat: "ã“ã®å½¢å¼ã¯ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã§ãã¾ã›ã‚“ã€‚",
      downloadToView: "å†…å®¹ã‚’ç¢ºèªã™ã‚‹ã«ã¯ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„ã€‚",
      noContentToCopy: "ã‚³ãƒ”ãƒ¼å¯èƒ½ãªã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãŒã‚ã‚Šã¾ã›ã‚“ã€‚",
      clipboardNotSupported: "ç¾åœ¨ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰æ“ä½œã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã›ã‚“ã€‚æ‰‹å‹•ã§ã‚³ãƒ”ãƒ¼ã—ã¦ãã ã•ã„ã€‚",
      contentCopied: "ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸã€‚",
      copyFailed: "ã‚³ãƒ”ãƒ¼ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ã‚‚ã†ä¸€åº¦è©¦ã™ã‹ã€æ‰‹å‹•ã§ã‚³ãƒ”ãƒ¼ã—ã¦ãã ã•ã„ã€‚",
      exportPDFPending: "PDFã®ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã«æˆåŠŸã—ã¾ã—ãŸ",
      saveToGoogleDrivePending: "Google Driveã¸ã®ä¿å­˜æ©Ÿèƒ½ã¯æº–å‚™ä¸­ã§ã™ã€‚"
    },
    preview: {
      title: "Lemonã®ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿",
      openVsCode: "VS Code",
      using: "LemonãŒä½¿ç”¨ä¸­",
      performing: "å®Ÿè¡Œä¸­",
      previousStep: "å‰ã®ã‚¹ãƒ†ãƒƒãƒ—",
      nextStep: "æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—",
      realtime: "ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ",
      waitingForDevelopment: "é–‹ç™ºå¾…ã¡...",
      browser: "ãƒ–ãƒ©ã‚¦ã‚¶",
      browsing: "é–²è¦§",
      editor: "ã‚¨ãƒ‡ã‚£ã‚¿",
      editingFile: "ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç·¨é›†",
      terminal: "ã‚¿ãƒ¼ãƒŸãƒŠãƒ«",
      executingCommand: "ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œ",
      readingFile: "ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚€",
      search: "æ¤œç´¢",
      searching: "æ¤œç´¢"
    }
  },
  // è¨­å®šç”»é¢
  setting: {
    back: "æˆ»ã‚‹",
    doneStep: "çµ‚äº†",
    prevStep: "å‰ã®ã‚¹ãƒ†ãƒƒãƒ—",
    nextStep: "æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—",
    settingModel: "ãƒ¢ãƒ‡ãƒ«è¨­å®š",
    settingModelTips: "è¨­å®šã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦è¨­å®šãƒšãƒ¼ã‚¸ã«ç§»å‹•",
    menu: {
      basic: "åŸºæœ¬è¨­å®š",
      defaultModel: "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ¢ãƒ‡ãƒ«",
      modelService: "ãƒ¢ãƒ‡ãƒ«ã‚µãƒ¼ãƒ“ã‚¹",
      searchService: "æ¤œç´¢ã‚µãƒ¼ãƒ“ã‚¹",
      mcpService: "MCPã‚µãƒ¼ãƒ“ã‚¹",
      experience: "çµŒé¨“ãƒ©ã‚¤ãƒ–ãƒ©ãƒª"
    },
    basic: {
      title: "åŸºæœ¬è¨­å®š",
      langTitle: "è¨€èªè¨­å®š",
      languagePreference: "è¨€èªã®å„ªå…ˆé †ä½",
      lang: {
        en: "è‹±èª",
        zh: "ä¸­å›½èªï¼ˆç°¡ä½“ï¼‰",
        de: "ãƒ‰ã‚¤ãƒ„èª",
        es: "ã‚¹ãƒšã‚¤ãƒ³èª",
        fr: "ãƒ•ãƒ©ãƒ³ã‚¹èª",
        ja: "æ—¥æœ¬èª",
        kr: "éŸ“å›½èª",
        tr: "ãƒˆãƒ«ã‚³èª",
        pt: "ãƒãƒ«ãƒˆã‚¬ãƒ«èª",
        tw: "ä¸­å›½èªï¼ˆç¹ä½“ï¼‰",
        vi: "ãƒ™ãƒˆãƒŠãƒ èª"
      }
    },
    modelService: {
      modelService: "ãƒ¢ãƒ‡ãƒ«ã‚µãƒ¼ãƒ“ã‚¹",
      modelServiceTipsOne: "ã‚¹ãƒ†ãƒƒãƒ—1ï¼šãƒ¢ãƒ‡ãƒ«ã‚µãƒ¼ãƒ“ã‚¹ãƒ—ãƒ­ãƒã‚¤ãƒ€ã‚’é¸æŠ",
      modelServiceTipsTwo: "ã‚¹ãƒ†ãƒƒãƒ—2ï¼šAPIã‚­ãƒ¼ã®å…¥åŠ›è¨­å®š",
      modelServiceTipsThree: "ã‚¹ãƒ†ãƒƒãƒ—3ï¼šãƒ¢ãƒ‡ãƒ«ã‚µãƒ¼ãƒ“ã‚¹ã‚’æœ‰åŠ¹åŒ–",
      title: "ãƒ¢ãƒ‡ãƒ«ã‚µãƒ¼ãƒ“ã‚¹",
      searchPlaceholder: "ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã‚’æ¤œç´¢",
      defaultPlatform: "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ",
      modelPlatform: "ãƒ¢ãƒ‡ãƒ«ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ",
      statusOn: "æœ‰åŠ¹",
      addPlatform: "è¿½åŠ ",
      save: "ä¿å­˜",
      defaultPlatformDescription: "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ãƒ¢ãƒ‡ãƒ«ã¯ã‚·ã‚¹ãƒ†ãƒ ãŒæä¾›ã—ã€è¨­å®šã¯ä¸è¦ã§ã™",
      apiKey: "APIã‚­ãƒ¼",
      apiKeyPlaceholder: "APIã‚­ãƒ¼ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„",
      getApiKey: "ã“ã¡ã‚‰ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚­ãƒ¼ã‚’å–å¾—",
      check: "ãƒã‚§ãƒƒã‚¯",
      selectCheckModel: "æ¤œæŸ»ãƒ¢ãƒ‡ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„",
      apiAddress: "APIã‚¢ãƒ‰ãƒ¬ã‚¹",
      apiAddressPlaceholder: "APIã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„",
      apiAddressTip: "/ã§çµ‚ã‚ã‚‹å ´åˆã¯v1ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’ç„¡è¦–ã€#ã§çµ‚ã‚ã‚‹å ´åˆã¯å…¥åŠ›ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å¼·åˆ¶ä½¿ç”¨",
      activateTime: "ã‚¢ã‚¯ãƒ†ã‚£ãƒ–æ™‚é–“",
      activateTimePlaceholder: "ã‚¢ã‚¯ãƒ†ã‚£ãƒ–æ™‚é–“ï¼ˆåˆ†ï¼‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„",
      models: "ãƒ¢ãƒ‡ãƒ«",
      ungrouped: "æœªã‚°ãƒ«ãƒ¼ãƒ—åŒ–",
      viewOfficialDocs: "ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã®å…¬å¼ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’å‚ç…§ã—ã¦è©³ç´°ã‚’ç¢ºèª",
      add: "è¿½åŠ ",
      confirmDeleteModel: "ã“ã®ãƒ¢ãƒ‡ãƒ«ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ",
      deleteModelSuccess: "ãƒ¢ãƒ‡ãƒ«ã‚’å‰Šé™¤ã—ã¾ã—ãŸ",
      deleteModelFailed: "ãƒ¢ãƒ‡ãƒ«ã®å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ",
      addModelSuccess: "ãƒ¢ãƒ‡ãƒ«ã‚’è¿½åŠ ã—ã¾ã—ãŸ",
      updateModelSuccess: "ãƒ¢ãƒ‡ãƒ«ã‚’æ›´æ–°ã—ã¾ã—ãŸ",
      copySuccess: "åå‰ã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ",
      typeVision: "ãƒ“ã‚¸ãƒ§ãƒ³",
      typeNetwork: "ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯",
      typeEmbed: "åŸ‹ã‚è¾¼ã¿",
      typeReasoning: "æ¨è«–",
      typeTool: "ãƒ„ãƒ¼ãƒ«",
      addProvider: "ãƒ—ãƒ­ãƒã‚¤ãƒ€ã‚’è¿½åŠ ",
      confirm: "ç¢ºèª",
      cancel: "ã‚­ãƒ£ãƒ³ã‚»ãƒ«",
      platformLogo: "ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ãƒ­ã‚´",
      providerName: "ãƒ—ãƒ­ãƒã‚¤ãƒ€å",
      namePlaceholder: "åå‰",
      providerType: "ãƒ—ãƒ­ãƒã‚¤ãƒ€ã‚¿ã‚¤ãƒ—",
      typePlaceholder: "ã‚¿ã‚¤ãƒ—",
      enterName: "åå‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„",
      selectType: "ã‚¿ã‚¤ãƒ—ã‚’é¸æŠã—ã¦ãã ã•ã„",
      addPlatformSuccess: "ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã‚’è¿½åŠ ã—ã¾ã—ãŸ",
      formValidationFailed: "ãƒ•ã‚©ãƒ¼ãƒ ã®æ¤œè¨¼ã«å¤±æ•—ã—ã¾ã—ãŸ",
      addModel: "ãƒ¢ãƒ‡ãƒ«ã‚’è¿½åŠ ",
      editModel: "ãƒ¢ãƒ‡ãƒ«ã‚’ç·¨é›†",
      modelId: "ãƒ¢ãƒ‡ãƒ«ID",
      modelIdPlaceholder: "ãƒ¢ãƒ‡ãƒ«IDã‚’å…¥åŠ›ã—ã¦ãã ã•ã„",
      modelName: "ãƒ¢ãƒ‡ãƒ«å",
      modelNamePlaceholder: "ãƒ¢ãƒ‡ãƒ«å",
      groupName: "ã‚°ãƒ«ãƒ¼ãƒ—å",
      groupNamePlaceholder: "ã‚°ãƒ«ãƒ¼ãƒ—å",
      modelTypes: "ãƒ¢ãƒ‡ãƒ«ã‚¿ã‚¤ãƒ—",
      enterModelId: "ãƒ¢ãƒ‡ãƒ«IDã‚’å…¥åŠ›ã—ã¦ãã ã•ã„",
      enterModelName: "ãƒ¢ãƒ‡ãƒ«åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„",
      enterGroupName: "ã‚°ãƒ«ãƒ¼ãƒ—åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„",
      selectModelType: "å°‘ãªãã¨ã‚‚1ã¤ã®ãƒ¢ãƒ‡ãƒ«ã‚¿ã‚¤ãƒ—ã‚’é¸æŠã—ã¦ãã ã•ã„",
      editProvider: "ãƒ—ãƒ­ãƒã‚¤ãƒ€ã‚’ç·¨é›†",
      updatePlatformSuccess: "ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã‚’æ›´æ–°ã—ã¾ã—ãŸ",
      deletePlatformSuccess: "ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã‚’å‰Šé™¤ã—ã¾ã—ãŸ",
      deletePlatformFailed: "ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã®å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ",
      saveSuccess: "ä¿å­˜ã«æˆåŠŸã—ã¾ã—ãŸ",
      saveFailed: "ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ",
      platforms: {
        Anthropic: "Anthropic",
        ModelScope: "ModelScope é­”å¡”",
        Gemini: "Gemini",
        OpenAI: "OpenAI",
        Ollama: "Ollama",
        qiniu: "ä¸ƒç‰›ã‚¯ãƒ©ã‚¦ãƒ‰",
        WanJieData: "ä¸‡ç•Œãƒ‡ãƒ¼ã‚¿",
        PPIO: "PPIO æ´¾æ¬§ã‚¯ãƒ©ã‚¦ãƒ‰",
        QianFan: "ç™¾åº¦ã‚¯ãƒ©ã‚¦ãƒ‰åƒå¸†",
        SiliconFlow: "ã‚·ãƒªã‚³ãƒ³ãƒ•ãƒ­ãƒ¼",
        Volcengine: "ç«å±±ã‚¨ãƒ³ã‚¸ãƒ³",
        DeepSeek: "ãƒ‡ã‚£ãƒ¼ãƒ—ã‚·ãƒ¼ã‚¯",
        Bailian: "ã‚¢ãƒªãƒãƒã‚¯ãƒ©ã‚¦ãƒ‰ç™¾éŒ¬",
        OpenRouter: "OpenRouter",
        LMStudio: "LM Studio"
      }
    },
    defaultModel: {
      defaultModel: "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ¢ãƒ‡ãƒ«ã‚’è¨­å®š",
      defaultModelTipsOne: "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ¢ãƒ‡ãƒ«ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ¢ãƒ‡ãƒ«ãƒšãƒ¼ã‚¸ã«ç§»å‹•",
      topicNamingModel: "ãƒˆãƒ”ãƒƒã‚¯å‘½åãƒ¢ãƒ‡ãƒ«",
      topicNamingModelTips: "æ–°ã—ã„ãƒˆãƒ”ãƒƒã‚¯ã‚’è‡ªå‹•å‘½åã™ã‚‹ãŸã‚ã®ãƒ¢ãƒ‡ãƒ«",
      emptymodelTips: "ãƒ¢ãƒ‡ãƒ«ã‚µãƒ¼ãƒ“ã‚¹ã§é–¢é€£ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã‚’æœ‰åŠ¹ã«ã—ã¦ãã ã•ã„",
      DefaultModelSetting: "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ¢ãƒ‡ãƒ«è¨­å®š",
      defaultAssistantModel: "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆãƒ¢ãƒ‡ãƒ«",
      assistantModelTips: "ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆä½œæˆæ™‚ã«ä½¿ç”¨ã™ã‚‹ãƒ¢ãƒ‡ãƒ«",
      topicNamingModel: "ãƒˆãƒ”ãƒƒã‚¯å‘½åãƒ¢ãƒ‡ãƒ«",
      topicNamingModelTips: "æ–°ã—ã„ãƒˆãƒ”ãƒƒã‚¯ã‚’è‡ªå‹•å‘½åã™ã‚‹ãŸã‚ã®ãƒ¢ãƒ‡ãƒ«",
      translationModel: "ç¿»è¨³ãƒ¢ãƒ‡ãƒ«",
      translationModelTips: "ç¿»è¨³ã‚µãƒ¼ãƒ“ã‚¹ã«ä½¿ç”¨ã™ã‚‹ãƒ¢ãƒ‡ãƒ«",
      browserUseModel: "ãƒ–ãƒ©ã‚¦ã‚¶ã‚µãƒ¼ãƒ“ã‚¹ãƒ¢ãƒ‡ãƒ«",
      browserUseModelTips: "å†…è”µãƒ–ãƒ©ã‚¦ã‚¶ã«ä½¿ç”¨ã™ã‚‹ãƒ¢ãƒ‡ãƒ«ã€‚ãƒ„ãƒ¼ãƒ«ãŠã‚ˆã³é–¢æ•°å‘¼ã³å‡ºã—ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™",
      saveSuccess: "è¨­å®šã‚’ä¿å­˜ã—ã¾ã—ãŸ",
      assistantSettings: "ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆè¨­å®š",
      confirm: "ç¢ºèª",
      cancel: "ã‚­ãƒ£ãƒ³ã‚»ãƒ«",
      assistantName: "ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆå",
      assistantNamePlaceholder: "ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆåã‚’å…¥åŠ›ã—ã¦ãã ã•ã„",
      prompt: "ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ",
      promptPlaceholder: "ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’å…¥åŠ›ã—ã¦ãã ã•ã„",
      modelParameters: "ãƒ¢ãƒ‡ãƒ«ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿",
      temperature: "æ¸©åº¦",
      topP: "Top P",
      maxTokens: "æœ€å¤§ãƒˆãƒ¼ã‚¯ãƒ³æ•°",
      enableLengthLimit: "é•·ã•åˆ¶é™ã‚’æœ‰åŠ¹åŒ–",
      topicNamingSettings: "ãƒˆãƒ”ãƒƒã‚¯å‘½åè¨­å®š",
      topicAutoNaming: "ãƒˆãƒ”ãƒƒã‚¯è‡ªå‹•å‘½å",
      topicNamingPrompt: "ãƒˆãƒ”ãƒƒã‚¯å‘½åãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ",
      translationSettings: "ç¿»è¨³è¨­å®š",
      translationPrompt: "ç¿»è¨³ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ"
    },
    searchService: {
      searchService: "æ¤œç´¢ã‚µãƒ¼ãƒ“ã‚¹ã‚’è¨­å®š",
      searchServiceTipsOne: "æ¤œç´¢ã‚µãƒ¼ãƒ“ã‚¹ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦æ¤œç´¢ã‚µãƒ¼ãƒ“ã‚¹ãƒšãƒ¼ã‚¸ã«ç§»å‹•",
      searchEngineTipsOne: "ã‚¹ãƒ†ãƒƒãƒ—1ï¼šæ¤œç´¢ã‚µãƒ¼ãƒ“ã‚¹ãƒ—ãƒ­ãƒã‚¤ãƒ€ã‚’é¸æŠ",
      searchEngineTipsTwo: "ã‚¹ãƒ†ãƒƒãƒ—2ï¼šAPIã‚­ãƒ¼ã®å…¥åŠ›è¨­å®š",
      title: "æ¤œç´¢ã‚µãƒ¼ãƒ“ã‚¹",
      blacklistSubscription: "ãƒ–ãƒ©ãƒƒã‚¯ãƒªã‚¹ãƒˆè³¼èª­",
      addSubscription: "è³¼èª­ã‚’è¿½åŠ ",
      updateNow: "ä»Šã™ãæ›´æ–°",
      deleteSubscription: "è³¼èª­ã‚’å‰Šé™¤",
      confirm: "ç¢ºèª",
      cancel: "ã‚­ãƒ£ãƒ³ã‚»ãƒ«",
      subscriptionUrl: "è³¼èª­URL",
      subscriptionUrlPlaceholder: "https://example/abcd",
      subscriptionName: "è³¼èª­å",
      subscriptionNamePlaceholder: "ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ãŸè³¼èª­ã‚½ãƒ¼ã‚¹ã«åå‰ãŒãªã„å ´åˆã«ä½¿ç”¨ã™ã‚‹ä»£æ›¿å",
      name: "åå‰",
      url: "URL",
      addSubscriptionSuccess: "è³¼èª­ã‚’è¿½åŠ ã—ã¾ã—ãŸ",
      deleteSubscriptionSuccess: "è³¼èª­ã‚’å‰Šé™¤ã—ã¾ã—ãŸ",
      deleteSubscriptionFailed: "è³¼èª­ã®å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ",
      saveConfigSuccess: "è¨­å®šã‚’ä¿å­˜ã—ã¾ã—ãŸ",
      saveConfigFailed: "è¨­å®šã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ",
      loadConfigFailed: "è¨­å®šã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ",
      formValidationFailed: "ãƒ•ã‚©ãƒ¼ãƒ ã®æ¤œè¨¼ã«å¤±æ•—ã—ã¾ã—ãŸ",
      enterSubscriptionUrl: "è³¼èª­URLã‚’å…¥åŠ›ã—ã¦ãã ã•ã„",
      invalidUrl: "æœ‰åŠ¹ãªURLã‚’å…¥åŠ›ã—ã¦ãã ã•ã„",
      enterSubscriptionName: "è³¼èª­åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„",
      noSubscriptionSelected: "è³¼èª­ãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“",
      searchProvider: "æ¤œç´¢ãƒ—ãƒ­ãƒã‚¤ãƒ€",
      generalSettings: "ä¸€èˆ¬è¨­å®š",
      includeDate: "æ—¥ä»˜ã‚’å«ã‚ã‚‹",
      includeServer: "ã‚µãƒ¼ãƒãƒ¼ã‚’å«ã‚ã‚‹",
      searchEnhancement: "æ¤œç´¢å¼·åŒ–",
      searchResultCount: "æ¤œç´¢çµæœã®æ•°",
      default: "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ",
      blacklist: "ãƒ–ãƒ©ãƒƒã‚¯ãƒªã‚¹ãƒˆ",
      blacklistTips: "æ¤œç´¢çµæœã‹ã‚‰é™¤å¤–ã™ã‚‹ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚’å…¥åŠ›",
      blacklistPlaceholder: "1è¡Œã«1ã¤ã®ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚’å…¥åŠ›",
      save: "ä¿å­˜",
      apiTips: "APIè¨­å®š",
      apiKeyPlaceholder: "APIã‚­ãƒ¼ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„",
      apiKey: "APIã‚­ãƒ¼",
      apiAddress: "APIã‚¢ãƒ‰ãƒ¬ã‚¹",
      tavilyName: "Tavilyï¼ˆã‚­ãƒ¼ï¼‰",
      baiduName: "ç™¾åº¦ï¼ˆç„¡æ–™ï¼‰",
      bingName: "Bingï¼ˆç„¡æ–™ï¼‰",
      saveBlacklistSuccess: "ãƒ–ãƒ©ãƒƒã‚¯ãƒªã‚¹ãƒˆã‚’ä¿å­˜ã—ã¾ã—ãŸ",
      saveBlacklistFailed: "ãƒ–ãƒ©ãƒƒã‚¯ãƒªã‚¹ãƒˆã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ"
    },
    mcpService: {
      title: "MCPã‚µãƒ¼ãƒ“ã‚¹",
      addServer: "ã‚µãƒ¼ãƒãƒ¼ã‚’è¿½åŠ ",
      save: "ä¿å­˜",
      name: "åå‰",
      namePlaceholder: "åå‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„",
      description: "èª¬æ˜",
      descriptionPlaceholder: "èª¬æ˜",
      type: "ã‚¿ã‚¤ãƒ—",
      stdio: "æ¨™æº–å…¥å‡ºåŠ› (stdio)",
      sse: "ã‚µãƒ¼ãƒãƒ¼é€ä¿¡ã‚¤ãƒ™ãƒ³ãƒˆ (sse)",
      streamableHttp: "ã‚¹ãƒˆãƒªãƒ¼ãƒ å¯èƒ½ãªHTTP (streamableHttp)",
      command: "ã‚³ãƒãƒ³ãƒ‰",
      commandPlaceholder: "uvx ã¾ãŸã¯ npx",
      packageSource: "ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚½ãƒ¼ã‚¹",
      default: "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ",
      taobaoNpmMirror: "æ·˜å®NPMãƒŸãƒ©ãƒ¼",
      tsinghua: "æ¸…è¯å¤§å­¦",
      aliyun: "ã‚¢ãƒªãƒãƒã‚¯ãƒ©ã‚¦ãƒ‰",
      ustc: "ä¸­å›½ç§‘å­¦æŠ€è¡“å¤§å­¦",
      huaweiCloud: "ãƒ•ã‚¡ãƒ¼ã‚¦ã‚§ã‚¤ã‚¯ãƒ©ã‚¦ãƒ‰",
      tencentCloud: "ãƒ†ãƒ³ã‚»ãƒ³ãƒˆã‚¯ãƒ©ã‚¦ãƒ‰",
      args: "å¼•æ•°",
      argsPlaceholder: "arg1\narg2",
      env: "ç’°å¢ƒå¤‰æ•°",
      envPlaceholder: "KEY1=VALUE1\nKEY2=VALUE2",
      mcpServer: "MCPã‚µãƒ¼ãƒãƒ¼"
    },
    experience: {
      title: "çµŒé¨“ãƒ©ã‚¤ãƒ–ãƒ©ãƒª",
      addExperience: "çµŒé¨“ã‚’è¿½åŠ ",
      editExperience: "çµŒé¨“ã‚’ç·¨é›†",
      close: "é–‰ã˜ã‚‹",
      titleLabel: "ã‚¿ã‚¤ãƒˆãƒ«",
      titlePlaceholder: "çµŒé¨“ã®ã‚¿ã‚¤ãƒˆãƒ«",
      goalLabel: "ç›®çš„",
      goalPlaceholder: "ã“ã®çµŒé¨“ã®ç›®çš„",
      contentLabel: "å†…å®¹",
      contentPlaceholder: "çµŒé¨“ã®å†…å®¹",
      statusLabel: "çŠ¶æ…‹",
      enabled: "æœ‰åŠ¹",
      disabled: "ç„¡åŠ¹",
      cancel: "ã‚­ãƒ£ãƒ³ã‚»ãƒ«",
      save: "ä¿å­˜",
      delete: "å‰Šé™¤",
      undoChanges: "å¤‰æ›´ã‚’å…ƒã«æˆ»ã™",
      deleteExperience: "çµŒé¨“ã‚’å‰Šé™¤",
      deleteConfirm: "ã“ã®çµŒé¨“ã‚’å‰Šé™¤ã—ã¦ã‚‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ",
      totalExperience: "åˆè¨ˆ {count} ä»¶ã®çµŒé¨“",
      tableTitle: "ã‚¿ã‚¤ãƒˆãƒ«",
      tableContent: "å†…å®¹",
      tableCreatedAt: "ä½œæˆæ—¥",
      tableStatus: "çŠ¶æ…‹",
      tableOperation: "æ“ä½œ",
      filterAll: "ã™ã¹ã¦",
      deleteSuccess: "å‰Šé™¤ã«æˆåŠŸã—ã¾ã—ãŸ",
      deleteFailed: "å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ",
      createSuccess: "çµŒé¨“ã®è¿½åŠ ã«æˆåŠŸã—ã¾ã—ãŸ",
      createFailed: "çµŒé¨“ã®è¿½åŠ ã«å¤±æ•—ã—ã¾ã—ãŸ",
      updateSuccess: "æ›´æ–°ã«æˆåŠŸã—ã¾ã—ãŸ",
      updateFailed: "æ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸ",
      updateFailedDataNotExist: "æ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ç¾åœ¨ã®ãƒ‡ãƒ¼ã‚¿ãŒå­˜åœ¨ã—ã¾ã›ã‚“",
      getDataError: "ãƒ‡ãƒ¼ã‚¿å–å¾—ã‚¨ãƒ©ãƒ¼",
      detect: "æ„å›³èªè­˜",
      plan: "ã‚¿ã‚¹ã‚¯è¨ˆç”»",
      action: "ã‚¿ã‚¹ã‚¯å®Ÿè¡Œ",
      sunday: "æ—¥æ›œæ—¥",
      monday: "æœˆæ›œæ—¥",
      tuesday: "ç«æ›œæ—¥",
      wednesday: "æ°´æ›œæ—¥",
      thursday: "æœ¨æ›œæ—¥",
      friday: "é‡‘æ›œæ—¥",
      saturday: "åœŸæ›œæ—¥",
      earlier: "ãã‚Œä»¥å‰",
    },
  },
  thinking: "æ€è€ƒä¸­",
  task_error: "ã‚¿ã‚¹ã‚¯ãŒç•°å¸¸çµ‚äº†ã—ã¾ã—ãŸ",
  stop_task: "ã‚¿ã‚¹ã‚¯ã‚’åœæ­¢ã—ã¾ã—ãŸ",
  jump_to_result: "çµæœã«ã‚¸ãƒ£ãƒ³ãƒ—",
  replay: "å†ç”Ÿ",
  task_finished: "ã‚¿ã‚¹ã‚¯ãŒå®Œäº†ã—ã¾ã—ãŸ",
  task_playing: "ã‚¿ã‚¹ã‚¯å®Ÿè¡Œä¸­",
  click_here_to_go_to_settings:  "è¨­å®šç”»é¢ã«ç§»å‹•ã™ã‚‹ã«ã¯ã“ã“ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„",
}


================================================
FILE: frontend/src/locals/lang/kr.js
================================================
export default {
  // ë¡œê·¸ì¸ í™”ë©´
  auth: {
    loginToLemonAI: "LemonAIì— ë¡œê·¸ì¸",
    registerLemonAIAccount: "LemonAI ê³„ì • ë“±ë¡",
    verifyEmail: "ì´ë©”ì¼ ì¸ì¦",
    resetPassword: "ë¹„ë°€ë²ˆí˜¸ ì¬ì„¤ì •",
    loginWithGoogle: "Googleë¡œ ë¡œê·¸ì¸",
    registerWithGoogle: "Googleë¡œ ë“±ë¡",
    login: "ë¡œê·¸ì¸",
    register: "ë“±ë¡",
    logOut: "ë¡œê·¸ì•„ì›ƒ",
    forgotPassword: "ë¹„ë°€ë²ˆí˜¸ë¥¼ ìŠìœ¼ì…¨ë‚˜ìš”?",
    resetPasswordButton: "ë¹„ë°€ë²ˆí˜¸ ì¬ì„¤ì •",
    backToLogin: "ë¡œê·¸ì¸ìœ¼ë¡œ ëŒì•„ê°€ê¸°",
    verifyEmailButton: "ì´ë©”ì¼ ì¸ì¦",
    resendCode: "ì¸ì¦ ì½”ë“œ ì¬ì „ì†¡",
    email: "ì´ë©”ì¼",
    password: "ë¹„ë°€ë²ˆí˜¸",
    fullname: "ì´ë¦„",
    codeSentTo: "ì¸ì¦ ì½”ë“œê°€ ë‹¤ìŒìœ¼ë¡œ ì „ì†¡ë˜ì—ˆìŠµë‹ˆë‹¤:",
    pleaseInputEmail: "ì´ë©”ì¼ì„ ì…ë ¥í•´ì£¼ì„¸ìš”",
    pleaseInputValidEmail: "ìœ íš¨í•œ ì´ë©”ì¼ì„ ì…ë ¥í•´ì£¼ì„¸ìš”",
    pleaseInputPassword: "ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”",
    pleaseInputFullname: "ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”",
    pleaseInputVerifyCode: "ì¸ì¦ ì½”ë“œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”",
    pleaseInputNewPassword: "ìƒˆ ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”",
    pleaseInputConfirmPassword: "ë¹„ë°€ë²ˆí˜¸ë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”",
    pleaseInput6DigitCode: "6ìë¦¬ ì¸ì¦ ì½”ë“œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”",
    or: "ë˜ëŠ”",
    noAccount: "ê³„ì •ì´ ì—†ìœ¼ì‹ ê°€ìš”?",
    haveAccount: "ì´ë¯¸ ê³„ì •ì´ ìˆìœ¼ì‹ ê°€ìš”?",
    notReceivedCode: "ì¸ì¦ ì½”ë“œë¥¼ ë°›ì§€ ëª»í–ˆë‚˜ìš”?",
    codeSent: "ì¸ì¦ ì½”ë“œê°€ ì „ì†¡ë˜ì—ˆìŠµë‹ˆë‹¤",
    registrationSuccessful: "ë“±ë¡ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ë¡œê·¸ì¸í•´ì£¼ì„¸ìš”",
    verificationCodeError: "ì¸ì¦ ì½”ë“œê°€ ì˜ëª»ë˜ì—ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”",
    doNotSendFrequently: "ì¸ì¦ ì½”ë“œë¥¼ ìì£¼ ë³´ë‚´ì§€ ë§ˆì„¸ìš”",
    codeResent: "ì¸ì¦ ì½”ë“œê°€ ì¬ì „ì†¡ë˜ì—ˆìŠµë‹ˆë‹¤",
    loginSuccessful: "ë¡œê·¸ì¸ì— ì„±ê³µí–ˆìŠµë‹ˆë‹¤",
    loginFailed: "ë¡œê·¸ì¸ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ì´ë©”ì¼ê³¼ ë¹„ë°€ë²ˆí˜¸ë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”",
    fillCompleteInfo: "ë“±ë¡ ì •ë³´ë¥¼ ì™„ì „íˆ ì…ë ¥í•´ì£¼ì„¸ìš”",
    pleaseEnterValidEmail: "ìœ íš¨í•œ ì´ë©”ì¼ ì£¼ì†Œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”",
    passwordTooShort: "ë¹„ë°€ë²ˆí˜¸ëŠ” 6ì ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤",
    registrationFailed: "ë“±ë¡ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ì…ë ¥ ë‚´ìš©ì„ í™•ì¸í•´ì£¼ì„¸ìš”",
    pleaseInputCode: "ì¸ì¦ ì½”ë“œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”",
    passwordsDoNotMatch: "í™•ì¸ ë¹„ë°€ë²ˆí˜¸ê°€ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤",
    passwordResetSuccessful: "ë¹„ë°€ë²ˆí˜¸ ì¬ì„¤ì •ì— ì„±ê³µí–ˆìŠµë‹ˆë‹¤. ë¡œê·¸ì¸í•´ì£¼ì„¸ìš”",
    passwordResetFailed: "ë¹„ë°€ë²ˆí˜¸ ì¬ì„¤ì •ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ì…ë ¥ ë‚´ìš©ì„ í™•ì¸í•´ì£¼ì„¸ìš”",
    googleLoginFailed: "Google ë¡œê·¸ì¸ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”",
    appleLoginInProgress: "Apple ë¡œê·¸ì¸ ê¸°ëŠ¥ì€ ê°œë°œ ì¤‘ì…ë‹ˆë‹¤",
    googleRegisterInProgress: "Google ë“±ë¡ ê¸°ëŠ¥ì€ ê°œë°œ ì¤‘ì…ë‹ˆë‹¤",
    appleRegisterInProgress: "Apple ë“±ë¡ ê¸°ëŠ¥ì€ ê°œë°œ ì¤‘ì…ë‹ˆë‹¤",
    verifyingGoogleLogin: "Google ë¡œê·¸ì¸ ì¸ì¦ ì¤‘"
  },
  // ë©”ì¸ í™”ë©´
  lemon: {
    // í™ˆ
    welcome: {
      greeting: "ì•ˆë…•í•˜ì„¸ìš”",
      question: "ë¬´ì—‡ì— ëŒ€í•´ ì´ì•¼ê¸°í•˜ê³  ì‹¶ìœ¼ì‹ ê°€ìš”?",
      tabs: {
        featured: "ì¶”ì²œ",
        research: "ì—°êµ¬",
        lifestyle: "ë¼ì´í”„ìŠ¤íƒ€ì¼",
        dataAnalysis: "ë°ì´í„° ë¶„ì„",
        education: "êµìœ¡",
        productivity: "ìƒì‚°ì„±",
        other: "ê¸°íƒ€"
      },
      placeholder: "ë„ì›€ì´ í•„ìš”í•œ ê²ƒì´ ìˆìœ¼ì‹ ê°€ìš”?",
      communityNote: "ì»¤ë®¤ë‹ˆí‹°ì— í‘œì‹œëœ ëª¨ë“  ì‘ì—…ê³¼ ì›¹ì‚¬ì´íŠ¸ëŠ” ì‚¬ìš©ìê°€ ìë°œì ìœ¼ë¡œ ê³µìœ í•œ ê²ƒì…ë‹ˆë‹¤. ì‚¬ìš©ìì˜ ë™ì˜ ì—†ì´ ì½˜í…ì¸ ê°€ í‘œì‹œë˜ì§€ ì•ŠìŠµë‹ˆë‹¤."
    },
    // ì±„íŒ… í—¤ë”
    chatHeader: {
      share: "ê³µìœ ",
      viewAllFiles: "ì´ ì‘ì—…ì˜ ëª¨ë“  íŒŒì¼ ë³´ê¸°",
      moreOptions: "ì¶”ê°€ ì˜µì…˜",
      rename: "ì´ë¦„ ë³€ê²½",
      editTitle: "ì œëª© í¸ì§‘",
      enterNewTitle: "ìƒˆ ì œëª© ì…ë ¥",
      cancel: "ì·¨ì†Œ",
      confirm: "í™•ì¸",
      favorite: "ì¦ê²¨ì°¾ê¸°ì— ì¶”ê°€",
      unfavorite: "ì¦ê²¨ì°¾ê¸°ì—ì„œ ì œê±°"
    },
    // ë©”ì‹œì§€ ëŒ€í™” ëª©ë¡ í˜ì´ì§€
    message: {
      runCommand: "bash ëª…ë ¹ì–´ ì‹¤í–‰",
      readFile: "íŒŒì¼ ì½ê¸°",
      editFile: "íŒŒì¼ í¸ì§‘",
      browsing: "ë¸Œë¼ìš°ì§• ì¤‘",
      searching: "ê²€ìƒ‰ ì¤‘",
      minutesAgo: "ë¶„ ì „",
      secondsAgo: "ì´ˆ ì „",
      hoursAgo: "ì‹œê°„ ì „",
      daysAgo: "ì¼ ì „",
      monthsAgo: "ê°œì›” ì „",
      yearsAgo: "ë…„ ì „",
      copySuccess: "ë³µì‚¬ ì„±ê³µ",
      copyError: "ë³µì‚¬ ì‹¤íŒ¨",
      botInitialResponse: "ì•ˆë…•í•˜ì„¸ìš”, ìš”ì²­ì„ ë°›ì•˜ìŠµë‹ˆë‹¤. ë¬¸ì œë¥¼ ë¶„ì„ ì¤‘ì…ë‹ˆë‹¤. ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”.",
      botInitialPlan: "ê³„íš ìˆ˜ë¦½ ì¤‘"
    },
    // ì‚¬ì´ë“œë°”
    sidebar: {
      newTask: "ìƒˆ ì‘ì—…",
      shortcutKey: "T",
      moreOptions: "ì¶”ê°€ ì˜µì…˜",
      share: "ê³µìœ ",
      rename: "ì´ë¦„ ë³€ê²½",
      collect: "ì¦ê²¨ì°¾ê¸°",
      delete: "ì‚­ì œ",
      confirmDelete: "ì‚­ì œ í™•ì¸",
      deleteConfirmation: "ì´ ëŒ€í™”ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?",
      cancel: "ì·¨ì†Œ",
      confirm: "í™•ì¸",
      noChats: "ìƒˆ ì‘ì—…ì„ ë§Œë“¤ì–´ ì‹œì‘í•˜ì„¸ìš”",
      searchPlaceholder: "ì‘ì—… ê²€ìƒ‰..."
    },
    // íŒŒì¼ íƒìƒ‰ê¸°
    fileExplorer: {
      allFilesInTask: "ì´ ì‘ì—…ì˜ ëª¨ë“  íŒŒì¼",
      noContent: "ì½˜í…ì¸  ì—†ìŒ",
      preview: "ë¯¸ë¦¬ë³´ê¸°",
      locateInChat: "ì±„íŒ…ì—ì„œ ì°¾ê¸°",
      download: "ë‹¤ìš´ë¡œë“œ",
      saveToGoogleDrive: "Google Driveì— ì €ì¥",
      selectAll: "ëª¨ë‘ ì„ íƒ",
      cancel: "ì·¨ì†Œ",
      batchDownload: "ì¼ê´„ ë‹¤ìš´ë¡œë“œ",
      fileTypes: {
        all: "ëª¨ë‘",
        document: "ë¬¸ì„œ",
        image: "ì´ë¯¸ì§€",
        codeFile: "ì½”ë“œ íŒŒì¼",
        link: "ë§í¬"
      },
      timeGroups: {
        today: "ì˜¤ëŠ˜",
        yesterday: "ì–´ì œ",
        earlier: "ì´ì „"
      },
      weekdays: {
        sunday: "ì¼ìš”ì¼",
        monday: "ì›”ìš”ì¼",
        tuesday: "í™”ìš”ì¼",
        wednesday: "ìˆ˜ìš”ì¼",
        thursday: "ëª©ìš”ì¼",
        friday: "ê¸ˆìš”ì¼",
        saturday: "í† ìš”ì¼"
      }
    },
    fullPreview: {
      download: "ë‹¤ìš´ë¡œë“œ",
      exportToPDF: "PDFë¡œ ë‚´ë³´ë‚´ê¸°",
      saveToGoogleDrive: "Google Driveì— ì €ì¥",
      maximize: "ìµœëŒ€í™”",
      minimize: "ìµœì†Œí™”",
      previous: "ì´ì „",
      next: "ë‹¤ìŒ",
      copy: "ë³µì‚¬",
      code: "ì½”ë“œ",
      preview: "ë¯¸ë¦¬ë³´ê¸°",
      close: "ë‹«ê¸°",
      fileTypePresentation: "ë¯¸ë¦¬ë³´ê¸° ë¶ˆê°€",
      cannotPreviewFormat: "ì´ í˜•ì‹ì€ ë¯¸ë¦¬ë³¼ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
      downloadToView: "ì½˜í…ì¸ ë¥¼ ë³´ë ¤ë©´ íŒŒì¼ì„ ë‹¤ìš´ë¡œë“œí•˜ì„¸ìš”.",
      noContentToCopy: "ë³µì‚¬í•  ì½˜í…ì¸ ê°€ ì—†ìŠµë‹ˆë‹¤.",
      clipboardNotSupported: "í˜„ì¬ ë¸Œë¼ìš°ì €ëŠ” í´ë¦½ë³´ë“œ ì‘ì—…ì„ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ìˆ˜ë™ìœ¼ë¡œ ë³µì‚¬í•´ì£¼ì„¸ìš”.",
      contentCopied: "ì½˜í…ì¸ ê°€ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤.",
      copyFailed: "ë³µì‚¬ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•˜ê±°ë‚˜ ìˆ˜ë™ìœ¼ë¡œ ë³µì‚¬í•´ì£¼ì„¸ìš”.",
      exportPDFPending: "PDF ë‚´ë³´ë‚´ê¸° ì„±ê³µ",
      saveToGoogleDrivePending: "Google Drive ì €ì¥ ê¸°ëŠ¥ì€ ì¤€ë¹„ ì¤‘ì…ë‹ˆë‹¤."
    },
    preview: {
      title: "Lemonì˜ ì»´í“¨í„°",
      openVsCode: "VS Code",
      using: "Lemon ì‚¬ìš© ì¤‘",
      performing: "ì‹¤í–‰ ì¤‘",
      previousStep: "ì´ì „ ë‹¨ê³„",
      nextStep: "ë‹¤ìŒ ë‹¨ê³„",
      realtime: "ì‹¤ì‹œê°„",
      waitingForDevelopment: "ê°œë°œ ëŒ€ê¸° ì¤‘...",
      browser: "ë¸Œë¼ìš°ì €",
      browsing: "ë¸Œë¼ìš°ì§•",
      editor: "ì—ë””í„°",
      editingFile: "íŒŒì¼ í¸ì§‘",
      terminal: "í„°ë¯¸ë„",
      executingCommand: "ëª…ë ¹ì–´ ì‹¤í–‰",
      readingFile: "íŒŒì¼ ì½ê¸°",
      search: "ê²€ìƒ‰",
      searching: "ê²€ìƒ‰"
    }
  },
  // ì„¤ì • í™”ë©´
  setting: {
    back: "ë’¤ë¡œ",
    doneStep: "ì™„ë£Œ",
    prevStep: "ì´ì „ ë‹¨ê³„",
    nextStep: "ë‹¤ìŒ ë‹¨ê³„",
    settingModel: "ëª¨ë¸ ì„¤ì •",
    settingModelTips: "ì„¤ì •ì„ í´ë¦­í•˜ì—¬ ì„¤ì • í˜ì´ì§€ë¡œ ì´ë™",
    menu: {
      basic: "ê¸°ë³¸ ì„¤ì •",
      defaultModel: "ê¸°ë³¸ ëª¨ë¸",
      modelService: "ëª¨ë¸ ì„œë¹„ìŠ¤",
      searchService: "ê²€ìƒ‰ ì„œë¹„ìŠ¤",
      mcpService: "MCP ì„œë¹„ìŠ¤",
      experience: "ê²½í—˜ ë¼ì´ë¸ŒëŸ¬ë¦¬"
    },
    basic: {
      title: "ê¸°ë³¸ ì„¤ì •",
      langTitle: "ì–¸ì–´ ì„¤ì •",
      languagePreference: "ì–¸ì–´ ì„ í˜¸ë„",
      lang: {
        en: "ì˜ì–´",
        zh: "ì¤‘êµ­ì–´(ê°„ì²´)",
        de: "ë…ì¼ì–´",
        es: "ìŠ¤í˜ì¸ì–´",
        fr: "í”„ë‘ìŠ¤ì–´",
        ja: "ì¼ë³¸ì–´",
        kr: "í•œêµ­ì–´",
        tr: "í„°í‚¤ì–´",
        pt: "í¬ë¥´íˆ¬ê°ˆì–´",
        tw: "ì¤‘êµ­ì–´(ë²ˆì²´)",
        vi: "ë² íŠ¸ë‚¨ì–´"
      }
    },
    modelService: {
      modelService: "ëª¨ë¸ ì„œë¹„ìŠ¤",
      modelServiceTipsOne: "1ë‹¨ê³„: ëª¨ë¸ ì„œë¹„ìŠ¤ ì œê³µì ì„ íƒ",
      modelServiceTipsTwo: "2ë‹¨ê³„: API í‚¤ ì…ë ¥ ì„¤ì •",
      modelServiceTipsThree: "3ë‹¨ê³„: ëª¨ë¸ ì„œë¹„ìŠ¤ í™œì„±í™”",
      title: "ëª¨ë¸ ì„œë¹„ìŠ¤",
      searchPlaceholder: "í”Œë«í¼ ê²€ìƒ‰",
      defaultPlatform: "ê¸°ë³¸ ì‹œìŠ¤í…œ í”Œë«í¼",
      modelPlatform: "ëª¨ë¸ í”Œë«í¼",
      statusOn: "í™œì„±í™”",
      addPlatform: "ì¶”ê°€",
      save: "ì €ì¥",
      defaultPlatformDescription: "ê¸°ë³¸ í”Œë«í¼ ëª¨ë¸ì€ ì‹œìŠ¤í…œì—ì„œ ì œê³µí•˜ë©° ì„¤ì •ì´ í•„ìš” ì—†ìŠµë‹ˆë‹¤",
      apiKey: "API í‚¤",
      apiKeyPlaceholder: "API í‚¤ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”",
      getApiKey: "ì—¬ê¸°ë¥¼ í´ë¦­í•˜ì—¬ í‚¤ë¥¼ íšë“",
      check: "í™•ì¸",
      selectCheckModel: "ê²€ì‚¬ ëª¨ë¸ì„ ì„ íƒí•˜ì„¸ìš”",
      apiAddress: "API ì£¼ì†Œ",
      apiAddressPlaceholder: "API ì£¼ì†Œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”",
      apiAddressTip: "/ë¡œ ëë‚˜ë©´ v1 ë²„ì „ì„ ë¬´ì‹œí•˜ê³ , #ë¡œ ëë‚˜ë©´ ì…ë ¥ëœ ì£¼ì†Œë¥¼ ê°•ì œë¡œ ì‚¬ìš©",
      activateTime: "í™œì„±í™” ì‹œê°„",
      activateTimePlaceholder: "í™œì„±í™” ì‹œê°„(ë¶„)ì„ ì…ë ¥í•´ì£¼ì„¸ìš”",
      models: "ëª¨ë¸",
      ungrouped: "ê·¸ë£¹í™”ë˜ì§€ ì•ŠìŒ",
      viewOfficialDocs: "í”Œë«í¼ì˜ ê³µì‹ ë¬¸ì„œë¥¼ í™•ì¸í•˜ì—¬ ìì„¸í•œ ì •ë³´ë¥¼ ì–»ìœ¼ì„¸ìš”",
      add: "ì¶”ê°€",
      confirmDeleteModel: "ì´ ëª¨ë¸ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?",
      deleteModelSuccess: "ëª¨ë¸ ì‚­ì œ ì„±ê³µ",
      deleteModelFailed: "ëª¨ë¸ ì‚­ì œ ì‹¤íŒ¨",
      addModelSuccess: "ëª¨ë¸ ì¶”ê°€ ì„±ê³µ",
      updateModelSuccess: "ëª¨ë¸ ì—…ë°ì´íŠ¸ ì„±ê³µ",
      copySuccess: "ì´ë¦„ì´ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤",
      typeVision: "ë¹„ì „",
      typeNetwork: "ë„¤íŠ¸ì›Œí¬",
      typeEmbed: "ì„ë² ë”©",
      typeReasoning: "ì¶”ë¡ ",
      typeTool: "ë„êµ¬",
      addProvider: "ì œê³µì ì¶”ê°€",
      confirm: "í™•ì¸",
      cancel: "ì·¨ì†Œ",
      platformLogo: "í”Œë«í¼ ë¡œê³ ",
      providerName: "ì œê³µì ì´ë¦„",
      namePlaceholder: "ì´ë¦„",
      providerType: "ì œê³µì ìœ í˜•",
      typePlaceholder: "ìœ í˜•",
      enterName: "ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”",
      selectType: "ìœ í˜•ì„ ì„ íƒí•´ì£¼ì„¸ìš”",
      addPlatformSuccess: "í”Œë«í¼ ì¶”ê°€ ì„±ê³µ",
      formValidationFailed: "í¼ ìœ íš¨ì„± ê²€ì‚¬ ì‹¤íŒ¨",
      addModel: "ëª¨ë¸ ì¶”ê°€",
      editModel: "ëª¨ë¸ í¸ì§‘",
      modelId: "ëª¨ë¸ ID",
      modelIdPlaceholder: "ëª¨ë¸ IDë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”",
      modelName: "ëª¨ë¸ ì´ë¦„",
      modelNamePlaceholder: "ëª¨ë¸ ì´ë¦„",
      groupName: "ê·¸ë£¹ ì´ë¦„",
      groupNamePlaceholder: "ê·¸ë£¹ ì´ë¦„",
      modelTypes: "ëª¨ë¸ ìœ í˜•",
      enterModelId: "ëª¨ë¸ IDë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”",
      enterModelName: "ëª¨ë¸ ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”",
      enterGroupName: "ê·¸ë£¹ ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”",
      selectModelType: "ìµœì†Œ í•œ ê°€ì§€ ëª¨ë¸ ìœ í˜•ì„ ì„ íƒí•´ì£¼ì„¸ìš”",
      editProvider: "ì œê³µì í¸ì§‘",
      updatePlatformSuccess: "í”Œë«í¼ ì—…ë°ì´íŠ¸ ì„±ê³µ",
      deletePlatformSuccess: "í”Œë«í¼ ì‚­ì œ ì„±ê³µ",
      deletePlatformFailed: "í”Œë«í¼ ì‚­ì œ ì‹¤íŒ¨",
      saveSuccess: "ì €ì¥ ì„±ê³µ",
      saveFailed: "ì €ì¥ ì‹¤íŒ¨",
      platforms: {
        Anthropic: "Anthropic",
        ModelScope: "ModelScope ë§ˆíƒ‘",
        Gemini: "Gemini",
        OpenAI: "OpenAI",
        Ollama: "Ollama",
        qiniu: "ì¹˜ë‹ˆìš° í´ë¼ìš°ë“œ",
        WanJieData: "ë§Œê³„ ë°ì´í„°",
        PPIO: "PPIO íŒŒì´ì˜¤ í´ë¼ìš°ë“œ",
        QianFan: "ë°”ì´ë‘ í´ë¼ìš°ë“œ ì²¸íŒ",
        SiliconFlow: "ì‹¤ë¦¬ì½˜ í”Œë¡œìš°",
        Volcengine: "í™”ì‚° ì—”ì§„",
        DeepSeek: "ë”¥ì‹œí¬",
        Bailian: "ì•Œë¦¬ë°”ë°” í´ë¼ìš°ë“œ ë°±ë ¨",
        OpenRouter: "OpenRouter",
        LMStudio: "LM Studio"
      }
    },
    defaultModel: {
      defaultModel: "ê¸°ë³¸ ëª¨ë¸ ì„¤ì •",
      defaultModelTipsOne: "ê¸°ë³¸ ëª¨ë¸ì„ í´ë¦­í•˜ì—¬ ê¸°ë³¸ ëª¨ë¸ í˜ì´ì§€ë¡œ ì´ë™",
      topicNamingModel: "í† í”½ ëª…ëª… ëª¨ë¸",
      topicNamingModelTips: "ìƒˆ í† í”½ì„ ìë™ìœ¼ë¡œ ëª…ëª…í•˜ëŠ” ë° ì‚¬ìš©ë˜ëŠ” ëª¨ë¸",
      emptymodelTips: "ëª¨ë¸ ì„œë¹„ìŠ¤ì—ì„œ ê´€ë ¨ í”Œë«í¼ì„ í™œì„±í™”í•´ì£¼ì„¸ìš”",
      DefaultModelSetting: "ê¸°ë³¸ ëª¨ë¸ ì„¤ì •",
      defaultAssistantModel: "ê¸°ë³¸ ì–´ì‹œìŠ¤í„´íŠ¸ ëª¨ë¸",
      assistantModelTips: "ì–´ì‹œìŠ¤í„´íŠ¸ ìƒì„± ì‹œ ì‚¬ìš©ë˜ëŠ” ëª¨ë¸",
      topicNamingModel: "í† í”½ ëª…ëª… ëª¨ë¸",
      topicNamingModelTips: "ìƒˆ í† í”½ì„ ìë™ìœ¼ë¡œ ëª…ëª…í•˜ëŠ” ë° ì‚¬ìš©ë˜ëŠ” ëª¨ë¸",
      translationModel: "ë²ˆì—­ ëª¨ë¸",
      translationModelTips: "ë²ˆì—­ ì„œë¹„ìŠ¤ì— ì‚¬ìš©ë˜ëŠ” ëª¨ë¸",
      browserUseModel: "ë¸Œë¼ìš°ì € ì„œë¹„ìŠ¤ ëª¨ë¸",
      browserUseModelTips: "ë‚´ì¥ ë¸Œë¼ìš°ì €ì— ì‚¬ìš©ë˜ëŠ” ëª¨ë¸. ë„êµ¬ ë° í•¨ìˆ˜ í˜¸ì¶œì„ ì§€ì›í•´ì•¼ í•©ë‹ˆë‹¤",
      saveSuccess: "ì„¤ì • ì €ì¥ ì„±ê³µ",
      assistantSettings: "ì–´ì‹œìŠ¤í„´íŠ¸ ì„¤ì •",
      confirm: "í™•ì¸",
      cancel: "ì·¨ì†Œ",
      assistantName: "ì–´ì‹œìŠ¤í„´íŠ¸ ì´ë¦„",
      assistantNamePlaceholder: "ì–´ì‹œìŠ¤í„´íŠ¸ ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”",
      prompt: "í”„ë¡¬í”„íŠ¸",
      promptPlaceholder: "í”„ë¡¬í”„íŠ¸ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”",
      modelParameters: "ëª¨ë¸ íŒŒë¼ë¯¸í„°",
      temperature: "ì˜¨ë„",
      topP: "Top P",
      maxTokens: "ìµœëŒ€ í† í° ìˆ˜",
      enableLengthLimit: "ê¸¸ì´ ì œí•œ í™œì„±í™”",
      topicNamingSettings: "í† í”½ ëª…ëª… ì„¤ì •",
      topicAutoNaming: "í† í”½ ìë™ ëª…ëª…",
      topicNamingPrompt: "í† í”½ ëª…ëª… í”„ë¡¬í”„íŠ¸",
      translationSettings: "ë²ˆì—­ ì„¤ì •",
      translationPrompt: "ë²ˆì—­ í”„ë¡¬í”„íŠ¸"
    },
    searchService: {
      searchService: "ê²€ìƒ‰ ì„œë¹„ìŠ¤ ì„¤ì •",
      searchServiceTipsOne: "ê²€ìƒ‰ ì„œë¹„ìŠ¤ë¥¼ í´ë¦­í•˜ì—¬ ê²€ìƒ‰ ì„œë¹„ìŠ¤ í˜ì´ì§€ë¡œ ì´ë™",
      searchEngineTipsOne: "1ë‹¨ê³„: ê²€ìƒ‰ ì„œë¹„ìŠ¤ ì œê³µì ì„ íƒ",
      searchEngineTipsTwo: "2ë‹¨ê³„: API í‚¤ ì…ë ¥ ì„¤ì •",
      title: "ê²€ìƒ‰ ì„œë¹„ìŠ¤",
      blacklistSubscription: "ë¸”ë™ë¦¬ìŠ¤íŠ¸ êµ¬ë…",
      addSubscription: "êµ¬ë… ì¶”ê°€",
      updateNow: "ì§€ê¸ˆ ì—…ë°ì´íŠ¸",
      deleteSubscription: "êµ¬ë… ì‚­ì œ",
      confirm: "í™•ì¸",
      cancel: "ì·¨ì†Œ",
      subscriptionUrl: "êµ¬ë… URL",
      subscriptionUrlPlaceholder: "https://example/abcd",
      subscriptionName: "êµ¬ë… ì´ë¦„",
      subscriptionNamePlaceholder: "ë‹¤ìš´ë¡œë“œí•œ êµ¬ë… ì†ŒìŠ¤ì— ì´ë¦„ì´ ì—†ì„ ë•Œ ì‚¬ìš©ë˜ëŠ” ëŒ€ì²´ ì´ë¦„",
      name: "ì´ë¦„",
      url: "URL",
      addSubscriptionSuccess: "êµ¬ë… ì¶”ê°€ ì„±ê³µ",
      deleteSubscriptionSuccess: "êµ¬ë… ì‚­ì œ ì„±ê³µ",
      deleteSubscriptionFailed: "êµ¬ë… ì‚­ì œ ì‹¤íŒ¨",
      saveConfigSuccess: "ì„¤ì • ì €ì¥ ì„±ê³µ",
      saveConfigFailed: "ì„¤ì • ì €ì¥ ì‹¤íŒ¨",
      loadConfigFailed: "ì„¤ì • ë¡œë“œ ì‹¤íŒ¨",
      formValidationFailed: "í¼ ìœ íš¨ì„± ê²€ì‚¬ ì‹¤íŒ¨",
      enterSubscriptionUrl: "êµ¬ë… URLì„ ì…ë ¥í•´ì£¼ì„¸ìš”",
      invalidUrl: "ìœ íš¨í•œ URLì„ ì…ë ¥í•´ì£¼ì„¸ìš”",
      enterSubscriptionName: "êµ¬ë… ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”",
      noSubscriptionSelected: "êµ¬ë…ì´ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤",
      searchProvider: "ê²€ìƒ‰ ì œê³µì",
      generalSettings: "ì¼ë°˜ ì„¤ì •",
      includeDate: "ë‚ ì§œ í¬í•¨",
      includeServer: "ì„œë²„ í¬í•¨",
      searchEnhancement: "ê²€ìƒ‰ ê°•í™”",
      searchResultCount: "ê²€ìƒ‰ ê²°ê³¼ ìˆ˜",
      default: "ê¸°ë³¸",
      blacklist: "ë¸”ë™ë¦¬ìŠ¤íŠ¸",
      blacklistTips: "ê²€ìƒ‰ ê²°ê³¼ì—ì„œ ì œì™¸í•  ë„ë©”ì¸ì„ ì…ë ¥í•˜ì„¸ìš”",
      blacklistPlaceholder: "í•œ ì¤„ì— í•˜ë‚˜ì˜ ë„ë©”ì¸ ì…ë ¥",
      save: "ì €ì¥",
      apiTips: "API ì„¤ì •",
      apiKeyPlaceholder: "API í‚¤ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”",
      apiKey: "API í‚¤",
      apiAddress: "API ì£¼ì†Œ",
      tavilyName: "Tavily(í‚¤)",
      baiduName: "ë°”ì´ë‘(ë¬´ë£Œ)",
      bingName: "Bing(ë¬´ë£Œ)",
      saveBlacklistSuccess: "ë¸”ë™ë¦¬ìŠ¤íŠ¸ ì €ì¥ ì„±ê³µ",
      saveBlacklistFailed: "ë¸”ë™ë¦¬ìŠ¤íŠ¸ ì €ì¥ ì‹¤íŒ¨"
    },
    mcpService: {
      title: "MCP ì„œë¹„ìŠ¤",
      addServer: "ì„œë²„ ì¶”ê°€",
      save: "ì €ì¥",
      name: "ì´ë¦„",
      namePlaceholder: "ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”",
      description: "ì„¤ëª…",
      descriptionPlaceholder: "ì„¤ëª…",
      type: "ìœ í˜•",
      stdio: "í‘œì¤€ ì…ì¶œë ¥ (stdio)",
      sse: "ì„œë²„ ì „ì†¡ ì´ë²¤íŠ¸ (sse)",
      streamableHttp: "ìŠ¤íŠ¸ë¦¬ë° ê°€ëŠ¥í•œ HTTP (streamableHttp)",
      command: "ëª…ë ¹ì–´",
      commandPlaceholder: "uvx ë˜ëŠ” npx",
      packageSource: "íŒ¨í‚¤ì§€ ì†ŒìŠ¤",
      default: "ê¸°ë³¸",
      taobaoNpmMirror: "íƒ€ì˜¤ë°”ì˜¤ NPM ë¯¸ëŸ¬",
      tsinghua: "ì¹­í™”ëŒ€í•™êµ",
      aliyun: "ì•Œë¦¬ë°”ë°” í´ë¼ìš°ë“œ",
      ustc: "ì¤‘êµ­ ê³¼í•™ê¸°ìˆ ëŒ€í•™êµ",
      huaweiCloud: "í™”ì›¨ì´ í´ë¼ìš°ë“œ",
      tencentCloud: "í…ì„¼íŠ¸ í´ë¼ìš°ë“œ",
      args: "ì¸ìˆ˜",
      argsPlaceholder: "arg1\narg2",
      env: "í™˜ê²½ ë³€ìˆ˜",
      envPlaceholder: "KEY1=VALUE1\nKEY2=VALUE2",
      mcpServer: "MCP ì„œë²„"
    },
    experience: {
      title: "ê²½í—˜ ë¼ì´ë¸ŒëŸ¬ë¦¬",
      addExperience: "ê²½í—˜ ì¶”ê°€",
      editExperience: "ê²½í—˜ í¸ì§‘",
      close: "ë‹«ê¸°",
      titleLabel: "ì œëª©",
      titlePlaceholder: "ê²½í—˜ ì œëª©",
      goalLabel: "ëª©í‘œ",
      goalPlaceholder: "ì´ ê²½í—˜ì˜ ëª©í‘œ",
      contentLabel: "ë‚´ìš©",
      contentPlaceholder: "ê²½í—˜ ë‚´ìš©",
      statusLabel: "ìƒíƒœ",
      enabled: "í™œì„±í™”",
      disabled: "ë¹„í™œì„±í™”",
      cancel: "ì·¨ì†Œ",
      save: "ì €ì¥",
      delete: "ì‚­ì œ",
      undoChanges: "ë³€ê²½ ì·¨ì†Œ",
      deleteExperience: "ê²½í—˜ ì‚­ì œ",
      deleteConfirm: "ì´ ê²½í—˜ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?",
      totalExperience: "ì´ {count}ê°œì˜ ê²½í—˜",
      tableTitle: "ì œëª©",
      tableContent: "ë‚´ìš©",
      tableCreatedAt: "ìƒì„±ì¼",
      tableStatus: "ìƒíƒœ",
      tableOperation: "ì‘ì—…",
      filterAll: "ëª¨ë‘",
      deleteSuccess: "ì‚­ì œ ì„±ê³µ",
      deleteFailed: "ì‚­ì œ ì‹¤íŒ¨",
      createSuccess: "ê²½í—˜ ì¶”ê°€ ì„±ê³µ",
      createFailed: "ê²½í—˜ ì¶”ê°€ ì‹¤íŒ¨",
      updateSuccess: "ì—…ë°ì´íŠ¸ ì„±ê³µ",
      updateFailed: "ì—…ë°ì´íŠ¸ ì‹¤íŒ¨",
      updateFailedDataNotExist: "ì—…ë°ì´íŠ¸ ì‹¤íŒ¨, í˜„ì¬ ë°ì´í„°ê°€ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤",
      getDataError: "ë°ì´í„° ê°€ì ¸ì˜¤ê¸° ì˜¤ë¥˜",
      detect: "ì˜ë„ ì¸ì‹",
      plan: "ì‘ì—… ê³„íš",
      action: "ì‘ì—… ì‹¤í–‰",
      sunday: "ì¼ìš”ì¼",
      monday: "ì›”ìš”ì¼",
      tuesday: "í™”ìš”ì¼",
      wednesday: "ìˆ˜ìš”ì¼",
      thursday: "ëª©ìš”ì¼",
      friday: "ê¸ˆìš”ì¼",
      saturday: "í† ìš”ì¼",
      earlier: "ì´ì „",
    },
  },
  thinking: "ìƒê° ì¤‘",
  task_error: "ì‘ì—…ì´ ë¹„ì •ìƒì ìœ¼ë¡œ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤",
  stop_task: "ì‘ì—…ì´ ì¤‘ì§€ë˜ì—ˆìŠµë‹ˆë‹¤",
  jump_to_result: "ê²°ê³¼ë¡œ ì´ë™",
  replay: "ë‹¤ì‹œ ë³´ê¸°",
  task_finished: "ì‘ì—… ì™„ë£Œ",
  task_playing: "ì‘ì—… ì§„í–‰ ì¤‘",
  click_here_to_go_to_settings: "ì„¤ì •ìœ¼ë¡œ ì´ë™í•˜ë ¤ë©´ ì—¬ê¸°ë¥¼ í´ë¦­í•˜ì„¸ìš”",
}


================================================
FILE: frontend/src/locals/lang/pt.js
================================================
export default {
  // Interface de Login
  auth: {
    loginToLemonAI: "Entrar no LemonAI",
    registerLemonAIAccount: "Registrar uma conta LemonAI",
    verifyEmail: "Verificar e-mail",
    resetPassword: "Redefinir senha",
    loginWithGoogle: "Entrar com Google",
    registerWithGoogle: "Registrar com Google",
    login: "Entrar",
    register: "Registrar",
    logOut: "Sair",
    forgotPassword: "Esqueceu a senha?",
    resetPasswordButton: "Redefinir senha",
    backToLogin: "Voltar para o login",
    verifyEmailButton: "Verificar e-mail",
    resendCode: "Reenviar cÃ³digo de verificaÃ§Ã£o",
    email: "E-mail",
    password: "Senha",
    fullname: "Nome completo",
    codeSentTo: "CÃ³digo de verificaÃ§Ã£o enviado para",
    pleaseInputEmail: "Por favor, insira o e-mail",
    pleaseInputValidEmail: "Por favor, insira um e-mail vÃ¡lido",
    pleaseInputPassword: "Por favor, insira a senha",
    pleaseInputFullname: "Por favor, insira o nome completo",
    pleaseInputVerifyCode: "Por favor, insira o cÃ³digo de verificaÃ§Ã£o",
    pleaseInputNewPassword: "Por favor, insira a nova senha",
    pleaseConfirmPassword: "Por favor, confirme a senha",
    pleaseInput6DigitCode: "Por favor, insira o cÃ³digo de 6 dÃ­gitos",
    or: "ou",
    noAccount: "NÃ£o tem uma conta?",
    haveAccount: "JÃ¡ tem uma conta?",
    notReceivedCode: "NÃ£o recebeu o cÃ³digo?",
    codeSent: "CÃ³digo de verificaÃ§Ã£o enviado",
    registrationSuccessful: "Registro bem-sucedido, por favor, faÃ§a login",
    verificationCodeError: "CÃ³digo de verificaÃ§Ã£o incorreto, tente novamente",
    doNotSendFrequently: "NÃ£o envie o cÃ³digo de verificaÃ§Ã£o com frequÃªncia",
    codeResent: "CÃ³digo de verificaÃ§Ã£o reenviado",
    loginSuccessful: "Login bem-sucedido",
    loginFailed: "Falha no login, verifique o e-mail e a senha",
    fillCompleteInfo: "Por favor, preencha todas as informaÃ§Ãµes de registro",
    pleaseEnterValidEmail: "Por favor, insira um endereÃ§o de e-mail vÃ¡lido",
    passwordTooShort: "A senha deve ter no mÃ­nimo 6 caracteres",
    registrationFailed: "Falha no registro, verifique as informaÃ§Ãµes inseridas",
    pleaseInputCode: "Por favor, insira o cÃ³digo de verificaÃ§Ã£o",
    passwordsDoNotMatch: "As senhas nÃ£o coincidem",
    passwordResetSuccessful: "RedefiniÃ§Ã£o de senha bem-sucedida, faÃ§a login",
    passwordResetFailed: "Falha na redefiniÃ§Ã£o de senha, verifique as informaÃ§Ãµes",
    googleLoginFailed: "Falha na transiÃ§Ã£o para login com Google, tente novamente mais tarde",
    appleLoginInProgress: "Funcionalidade de login com Apple em desenvolvimento",
    googleRegisterInProgress: "Funcionalidade de registro com Google em desenvolvimento",
    appleRegisterInProgress: "Funcionalidade de registro com Apple em desenvolvimento",
    verifyingGoogleLogin: "Verificando login com Google"
  },
  // Interface Principal
  lemon: {
    // PÃ¡gina Inicial
    welcome: {
      greeting: "OlÃ¡",
      question: "O que posso fazer por vocÃª?",
      tabs: {
        featured: "Destaques",
        research: "Pesquisa",
        lifestyle: "Estilo de Vida",
        dataAnalysis: "AnÃ¡lise de Dados",
        education: "EducaÃ§Ã£o",
        productivity: "Produtividade",
        other: "Outros"
      },
      placeholder: "Como posso ajudar vocÃª?",
      communityNote: "Todas as tarefas e sites exibidos na comunidade sÃ£o compartilhados voluntariamente pelos usuÃ¡rios. A plataforma nÃ£o exibe nenhum conteÃºdo sem o consentimento do usuÃ¡rio."
    },
    // CabeÃ§alho de Conversa
    chatHeader: {
      share: "Compartilhar",
      viewAllFiles: "Ver todos os arquivos desta tarefa",
      moreOptions: "Mais opÃ§Ãµes",
      rename: "Renomear",
      editTitle: "Editar tÃ­tulo",
      enterNewTitle: "Inserir novo tÃ­tulo",
      cancel: "Cancelar",
      confirm: "Confirmar",
      favorite: "Adicionar aos favoritos",
      unfavorite: "Remover dos favoritos"
    },
    // PÃ¡gina de Lista de Conversas
    message: {
      runCommand: "Executar comando bash",
      readFile: "Ler arquivo",
      editFile: "Editar arquivo",
      browsing: "Navegando",
      searching: "Pesquisando",
      minutesAgo: "minutos atrÃ¡s",
      secondsAgo: "segundos atrÃ¡s",
      hoursAgo: "horas atrÃ¡s",
      daysAgo: "dias atrÃ¡s",
      monthsAgo: "meses atrÃ¡s",
      yearsAgo: "anos atrÃ¡s",
      copySuccess: "Copiado com sucesso",
      copyError: "Falha ao copiar",
      botInitialResponse: "OlÃ¡, recebi sua solicitaÃ§Ã£o. Estou analisando o problema. Por favor, aguarde.",
      botInitialPlan: "Planejando"
    },
    // Barra Lateral
    sidebar: {
      newTask: "Nova tarefa",
      shortcutKey: "T",
      moreOptions: "Mais opÃ§Ãµes",
      share: "Compartilhar",
      rename: "Renomear",
      collect: "Favoritar",
      delete: "Excluir",
      confirmDelete: "Confirmar exclusÃ£o",
      deleteConfirmation: "Tem certeza de que deseja excluir esta conversa?",
      cancel: "Cancelar",
      confirm: "Confirmar",
      noChats: "Crie uma nova tarefa para comeÃ§ar",
      searchPlaceholder: "Pesquisar tarefas..."
    },
    // Explorador de Arquivos
    fileExplorer: {
      allFilesInTask: "Todos os arquivos desta tarefa",
      noContent: "Sem conteÃºdo",
      preview: "Visualizar",
      locateInChat: "Localizar no chat",
      download: "Baixar",
      saveToGoogleDrive: "Salvar no Google Drive",
      selectAll: "Selecionar tudo",
      cancel: "Cancelar",
      batchDownload: "Download em lote",
      fileTypes: {
        all: "Todos",
        document: "Documento",
        image: "Imagem",
        codeFile: "Arquivo de cÃ³digo",
        link: "Link"
      },
      timeGroups: {
        today: "Hoje",
        yesterday: "Ontem",
        earlier: "Anterior"
      },
      weekdays: {
        sunday: "Domingo",
        monday: "Segunda-feira",
        tuesday: "TerÃ§a-feira",
        wednesday: "Quarta-feira",
        thursday: "Quinta-feira",
        friday: "Sexta-feira",
        saturday: "SÃ¡bado"
      }
    },
    fullPreview: {
      download: "Baixar",
      exportToPDF: "Exportar para PDF",
      saveToGoogleDrive: "Salvar no Google Drive",
      maximize: "Maximizar",
      minimize: "Minimizar",
      previous: "Anterior",
      next: "PrÃ³ximo",
      copy: "Copiar",
      code: "CÃ³digo",
      preview: "Visualizar",
      close: "Fechar",
      fileTypePresentation: "NÃ£o Ã© possÃ­vel visualizar",
      cannotPreviewFormat: "Este formato nÃ£o pode ser visualizado.",
      downloadToView: "Baixe o arquivo para visualizar o conteÃºdo.",
      noContentToCopy: "Nenhum conteÃºdo para copiar.",
      clipboardNotSupported: "O navegador atual nÃ£o suporta operaÃ§Ãµes de Ã¡rea de transferÃªncia, copie manualmente.",
      contentCopied: "ConteÃºdo copiado.",
      copyFailed: "Falha ao copiar, tente novamente ou copie manualmente.",
      exportPDFPending: "ExportaÃ§Ã£o para PDF bem-sucedida",
      saveToGoogleDrivePending: "Funcionalidade de salvar no Google Drive em desenvolvimento."
    },
    preview: {
      title: "Computador do Lemon",
      openVsCode: "VS Code",
      using: "Lemon estÃ¡ usando",
      performing: "Executando",
      previousStep: "Etapa anterior",
      nextStep: "PrÃ³xima etapa",
      realtime: "Em tempo real",
      waitingForDevelopment: "Aguardando desenvolvimento...",
      browser: "Navegador",
      browsing: "Navegando",
      editor: "Editor",
      editingFile: "Editando arquivo",
      terminal: "Terminal",
      executingCommand: "Executando comando",
      readingFile: "Lendo arquivo",
      search: "Pesquisar",
      searching: "Pesquisando"
    }
  },
  // Interface de ConfiguraÃ§Ãµes
  setting: {
    back: "Voltar",
    doneStep: "ConcluÃ­do",
    prevStep: "Etapa anterior",
    nextStep: "PrÃ³xima etapa",
    settingModel: "Configurar modelo",
    settingModelTips: "Clique em configurar para ir Ã  pÃ¡gina de configuraÃ§Ãµes",
    menu: {
      basic: "ConfiguraÃ§Ãµes bÃ¡sicas",
      defaultModel: "Modelo padrÃ£o",
      modelService: "ServiÃ§o de modelo",
      searchService: "ServiÃ§o de pesquisa",
      mcpService: "ServiÃ§o MCP",
      experience: "Biblioteca de experiÃªncias"
    },
    basic: {
      title: "ConfiguraÃ§Ãµes bÃ¡sicas",
      langTitle: "ConfiguraÃ§Ãµes de idioma",
      languagePreference: "PreferÃªncia de idioma",
      lang: {
        en: "InglÃªs",
        zh: "ChinÃªs (Simplificado)",
        de: "AlemÃ£o",
        es: "Espanhol",
        fr: "FrancÃªs",
        ja: "JaponÃªs",
        kr: "Coreano",
        tr: "Turco",
        pt: "PortuguÃªs",
        tw: "ChinÃªs (Tradicional)",
        vi: "Vietnamita"
      }
    },
    modelService: {
      modelService: "ServiÃ§o de modelo",
      modelServiceTipsOne: "Passo 1: Escolher o provedor de serviÃ§o de modelo",
      modelServiceTipsTwo: "Passo 2: Configurar a chave API",
      modelServiceTipsThree: "Passo 3: Ativar o serviÃ§o de modelo",
      title: "ServiÃ§o de modelo",
      searchPlaceholder: "Pesquisar plataforma",
      defaultPlatform: "Plataforma padrÃ£o do sistema",
      modelPlatform: "Plataforma de modelo",
      statusOn: "Ativado",
      addPlatform: "Adicionar",
      save: "Salvar",
      defaultPlatformDescription: "O modelo da plataforma padrÃ£o Ã© fornecido pelo sistema, sem necessidade de configuraÃ§Ã£o",
      apiKey: "Chave API",
      apiKeyPlaceholder: "Insira a chave API",
      getApiKey: "Clique aqui para obter a chave",
      check: "Verificar",
selectCheckModel: "Por favor, selecione o modelo de verificaÃ§Ã£o",
      apiAddress: "EndereÃ§o API",
      apiAddressPlaceholder: "Insira o endereÃ§o API",
      apiAddressTip: "Terminando com / ignora a versÃ£o v1, terminando com # forÃ§a o uso do endereÃ§o inserido",
      activateTime: "Tempo de ativaÃ§Ã£o",
      activateTimePlaceholder: "Insira o tempo de ativaÃ§Ã£o (minutos)",
      models: "Modelos",
      ungrouped: "NÃ£o agrupado",
      viewOfficialDocs: "Consulte a documentaÃ§Ã£o oficial da plataforma para mais informaÃ§Ãµes",
      add: "Adicionar",
      confirmDeleteModel: "Tem certeza de que deseja excluir este modelo?",
      deleteModelSuccess: "Modelo excluÃ­do com sucesso",
      deleteModelFailed: "Falha ao excluir o modelo",
      addModelSuccess: "Modelo adicionado com sucesso",
      updateModelSuccess: "Modelo atualizado com sucesso",
      copySuccess: "Nome copiado",
      typeVision: "VisÃ£o",
      typeNetwork: "Rede",
      typeEmbed: "IncorporaÃ§Ã£o",
      typeReasoning: "RaciocÃ­nio",
      typeTool: "Ferramenta",
      addProvider: "Adicionar provedor",
      confirm: "Confirmar",
      cancel: "Cancelar",
      platformLogo: "Logo da plataforma",
      providerName: "Nome do provedor",
      namePlaceholder: "Nome",
      providerType: "Tipo de provedor",
      typePlaceholder: "Tipo",
      enterName: "Insira o nome",
      selectType: "Selecione o tipo",
      addPlatformSuccess: "Plataforma adicionada com sucesso",
      formValidationFailed: "Falha na validaÃ§Ã£o do formulÃ¡rio",
      addModel: "Adicionar modelo",
      editModel: "Editar modelo",
      modelId: "ID do modelo",
      modelIdPlaceholder: "Insira o ID do modelo",
      modelName: "Nome do modelo",
      modelNamePlaceholder: "Nome do modelo",
      groupName: "Nome do grupo",
      groupNamePlaceholder: "Nome do grupo",
      modelTypes: "Tipos de modelo",
      enterModelId: "Insira o ID do modelo",
      enterModelName: "Insira o nome do modelo",
      enterGroupName: "Insira o nome do grupo",
      selectModelType: "Selecione pelo menos um tipo de modelo",
      editProvider: "Editar provedor",
      updatePlatformSuccess: "Plataforma atualizada com sucesso",
      deletePlatformSuccess: "Plataforma excluÃ­da com sucesso",
      deletePlatformFailed: "Falha ao excluir a plataforma",
      saveSuccess: "Salvo com sucesso",
      saveFailed: "Falha ao salvar",
      platforms: {
        Anthropic: "Anthropic",
        ModelScope: "ModelScope Magia",
        Gemini: "Gemini",
        OpenAI: "OpenAI",
        Ollama: "Ollama",
        qiniu: "Qiniu Cloud",
        WanJieData: "Dados WanJie",
        PPIO: "PPIO Cloud",
        QianFan: "Baidu Cloud QianFan",
        SiliconFlow: "Silicon Flow",
        Volcengine: "Volcengine",
        DeepSeek: "DeepSeek",
        Bailian: "Alibaba Cloud Bailian",
        OpenRouter: "OpenRouter",
        LMStudio: "LM Studio"
      }
    },
    defaultModel: {
      defaultModel: "Definir modelo padrÃ£o",
      defaultModelTipsOne: "Clique em modelo padrÃ£o para ir Ã  pÃ¡gina de modelo padrÃ£o",
      topicNamingModel: "Modelo de nomeaÃ§Ã£o de tÃ³picos",
      topicNamingTips: "Modelo usado para nomear automaticamente novos tÃ³picos",
      emptyModelTips: "Ative a plataforma correspondente no serviÃ§o de modelo",
      DefaultModelSetting: "ConfiguraÃ§Ã£o de modelo padrÃ£o",
      defaultAssistantModel: "Modelo de assistente padrÃ£o",
      assistantModelTips: "Modelo usado ao criar assistentes",
      topicNamingModel: "Modelo de nomeaÃ§Ã£o de tÃ³picos",
      topicNamingModelTips: "Modelo usado para nomear automaticamente novos tÃ³picos",
      translationModel: "Modelo de traduÃ§Ã£o",
      translationModelTips: "Modelo usado para serviÃ§os de traduÃ§Ã£o",
      browserUseModel: "Modelo de serviÃ§o de navegador",
      browserUseModelTips: "Modelo usado para o navegador integrado, deve suportar chamadas de ferramentas e funÃ§Ãµes",
      saveSuccess: "ConfiguraÃ§Ãµes salvas com sucesso",
      assistantSettings: "ConfiguraÃ§Ãµes do assistente",
      confirm: "Confirmar",
      cancel: "Cancelar",
      assistantName: "Nome do assistente",
      assistantNamePlaceholder: "Insira o nome do assistente",
      prompt: "Prompt",
      promptPlaceholder: "Insira o prompt",
      modelParameters: "ParÃ¢metros do modelo",
      temperature: "Temperatura",
      topP: "Top P",
      maxTokens: "MÃ¡ximo de tokens",
      enableLengthLimit: "Ativar limite de comprimento",
      topicNamingSettings: "ConfiguraÃ§Ãµes de nomeaÃ§Ã£o de tÃ³picos",
      topicAutoNaming: "NomeaÃ§Ã£o automÃ¡tica de tÃ³picos",
      topicNamingPrompt: "Prompt de nomeaÃ§Ã£o de tÃ³picos",
      translationSettings: "ConfiguraÃ§Ãµes de traduÃ§Ã£o",
      translationPrompt: "Prompt de traduÃ§Ã£o"
    },
    searchService: {
      searchService: "Configurar serviÃ§o de pesquisa",
      searchServiceTipsOne: "Clique em serviÃ§o de pesquisa para ir Ã  pÃ¡gina de serviÃ§o de pesquisa",
      searchEngineTipsOne: "Passo 1: Escolher o provedor de serviÃ§o de pesquisa",
      searchEngineTipsTwo: "Passo 2: Configurar a chave API",
      title: "ServiÃ§o de pesquisa",
      blacklistSubscription: "Assinatura de lista negra",
      addSubscription: "Adicionar assinatura",
      updateNow: "Atualizar agora",
      deleteSubscription: "Excluir assinatura",
      confirm: "Confirmar",
      cancel: "Cancelar",
      subscriptionUrl: "URL da assinatura",
      subscriptionUrlPlaceholder: "https://example/abcd",
      subscriptionName: "Nome da assinatura",
      subscriptionNamePlaceholder: "Nome alternativo usado quando a fonte de assinatura baixada nÃ£o tem nome",
      name: "Nome",
      url: "URL",
      addSubscriptionSuccess: "Assinatura adicionada com sucesso",
      deleteSubscriptionSuccess: "Assinatura excluÃ­da com sucesso",
      deleteSubscriptionFailed: "Falha ao excluir a assinatura",
      saveConfigSuccess: "ConfiguraÃ§Ã£o salva com sucesso",
      saveConfigFailed: "Falha ao salvar a configuraÃ§Ã£o",
      loadConfigFailed: "Falha ao carregar a configuraÃ§Ã£o",
      formValidationFailed: "Falha na validaÃ§Ã£o do formulÃ¡rio",
      enterSubscriptionUrl: "Insira o URL da assinatura",
      invalidUrl: "Insira um URL vÃ¡lido",
      enterSubscriptionName: "Insira o nome da assinatura",
      noSubscriptionSelected: "Nenhuma assinatura selecionada",
      searchProvider: "Provedor de pesquisa",
      generalSettings: "ConfiguraÃ§Ãµes gerais",
      includeDate: "Incluir data",
      includeServer: "Incluir servidor",
      searchEnhancement: "Aprimoramento de pesquisa",
      searchResultCount: "NÃºmero de resultados de pesquisa",
      default: "PadrÃ£o",
      blacklist: "Lista negra",
      blacklistTips: "Insira os domÃ­nios a serem excluÃ­dos dos resultados de pesquisa",
      blacklistPlaceholder: "Insira um domÃ­nio por linha",
      save: "Salvar",
      apiTips: "ConfiguraÃ§Ã£o de API",
      apiKeyPlaceholder: "Insira sua chave API",
      apiKey: "Chave API",
      apiAddress: "EndereÃ§o API",
      tavilyName: "Tavily (chave)",
      baiduName: "Baidu (grÃ¡tis)",
      bingName: "Bing (grÃ¡tis)",
      saveBlacklistSuccess: "Lista negra salva com sucesso",
      saveBlacklistFailed: "Falha ao salvar a lista negra"
    },
    mcpService: {
      title: "ServiÃ§o MCP",
      addServer: "Adicionar servidor",
      save: "Salvar",
      name: "Nome",
      namePlaceholder: "Insira o nome",
      description: "DescriÃ§Ã£o",
      descriptionPlaceholder: "DescriÃ§Ã£o",
      type: "Tipo",
      stdio: "Entrada/saÃ­da padrÃ£o (stdio)",
      sse: "Eventos enviados pelo servidor (sse)",
      streamableHttp: "HTTP streamÃ¡vel (streamableHttp)",
      command: "Comando",
      commandPlaceholder: "uvx ou npx",
      packageSource: "Fonte do pacote",
      default: "PadrÃ£o",
      taobaoNpmMirror: "Espelho NPM Taobao",
      tsinghua: "Universidade Tsinghua",
      aliyun: "Alibaba Cloud",
      ustc: "Universidade de CiÃªncia e Tecnologia da China",
      huaweiCloud: "Huawei Cloud",
      tencentCloud: "Tencent Cloud",
      args: "Argumentos",
      argsPlaceholder: "arg1\narg2",
      env: "VariÃ¡veis de ambiente",
      envPlaceholder: "KEY1=VALUE1\nKEY2=VALUE2",
      mcpServer: "Servidor MCP"
    },
    experience: {
      title: "Biblioteca de experiÃªncias",
      addExperience: "Adicionar experiÃªncia",
      editExperience: "Editar experiÃªncia",
      close: "Fechar",
      titleLabel: "TÃ­tulo",
      titlePlaceholder: "TÃ­tulo da experiÃªncia",
      goalLabel: "Objetivo",
      goalPlaceholder: "Objetivo desta experiÃªncia",
      contentLabel: "ConteÃºdo",
      contentPlaceholder: "ConteÃºdo da experiÃªncia",
      statusLabel: "Status",
      enabled: "Ativado",
      disabled: "Desativado",
      cancel: "Cancelar",
      save: "Salvar",
      delete: "Excluir",
      undoChanges: "Desfazer alteraÃ§Ãµes",
      deleteExperience: "Excluir experiÃªncia",
      deleteConfirm: "Tem certeza de que deseja excluir esta experiÃªncia?",
      totalExperience: "Total de {count} experiÃªncias",
      tableTitle: "TÃ­tulo",
      tableContent: "ConteÃºdo",
      tableCreatedAt: "Criado em",
      tableStatus: "Status",
      tableOperation: "OperaÃ§Ã£o",
      filterAll: "Todos",
      deleteSuccess: "ExcluÃ­do com sucesso",
      deleteFailed: "Falha ao excluir",
      createSuccess: "ExperiÃªncia adicionada com sucesso",
      createFailed: "Falha ao adicionar experiÃªncia",
      updateSuccess: "Atualizado com sucesso",
      updateFailed: "Falha ao atualizar",
      updateFailedDataNotExist: "Falha ao atualizar, os dados atuais nÃ£o existem",
      getDataError: "Erro ao obter dados",
      detect: "Reconhecimento de intenÃ§Ã£o",
      plan: "Planejamento de tarefas",
      action: "ExecuÃ§Ã£o de tarefas",
      sunday: "Domingo",
      monday: "Segunda-feira",
      tuesday: "TerÃ§a-feira",
      wednesday: "Quarta-feira",
      thursday: "Quinta-feira",
      friday: "Sexta-feira",
      saturday: "SÃ¡bado",
      earlier: "Anterior"
    },
  },
  thinking: "Pensando",
  task_error: "Tarefa terminada anormalmente",
  stop_task: "Tarefa interrompida",
  jump_to_result: "Ir para o resultado",
  replay: "Reproduzir",
  task_finished: "Tarefa concluÃ­da",
  task_playing: "Tarefa em andamento",
  click_here_to_go_to_settings:  "Clique aqui para ir para as configuraÃ§Ãµes",
}


================================================
FILE: frontend/src/locals/lang/tr.js
================================================
export default {
  // GiriÅŸ ArayÃ¼zÃ¼
  auth: {
    loginToLemonAI: "LemonAI'a GiriÅŸ Yap",
    registerLemonAIAccount: "LemonAI HesabÄ± Kaydol",
    verifyEmail: "E-posta DoÄŸrulama",
    resetPassword: "Åifre SÄ±fÄ±rlama",
    loginWithGoogle: "Google ile GiriÅŸ Yap",
    registerWithGoogle: "Google ile Kaydol",
    login: "GiriÅŸ Yap",
    register: "Kaydol",
    logOut: "Ã‡Ä±kÄ±ÅŸ Yap",
    forgotPassword: "Åifrenizi mi unuttunuz?",
    resetPasswordButton: "Åifreyi SÄ±fÄ±rla",
    backToLogin: "GiriÅŸe Geri DÃ¶n",
    verifyEmailButton: "E-postayÄ± DoÄŸrula",
    resendCode: "DoÄŸrulama Kodunu Yeniden GÃ¶nder",
    email: "E-posta",
    password: "Åifre",
    fullname: "Tam Ad",
    codeSentTo: "DoÄŸrulama kodu ÅŸu adrese gÃ¶nderildi:",
    pleaseInputEmail: "LÃ¼tfen e-posta adresinizi girin",
    pleaseInputValidEmail: "LÃ¼tfen geÃ§erli bir e-posta adresi girin",
    pleaseInputPassword: "LÃ¼tfen ÅŸifrenizi girin",
    pleaseInputFullname: "LÃ¼tfen tam adÄ±nÄ±zÄ± girin",
    pleaseInputVerifyCode: "LÃ¼tfen doÄŸrulama kodunu girin",
    pleaseInputNewPassword: "LÃ¼tfen yeni ÅŸifrenizi girin",
    pleaseConfirmPassword: "LÃ¼tfen ÅŸifreyi doÄŸrulayÄ±n",
    pleaseInput6DigitCode: "LÃ¼tfen 6 haneli doÄŸrulama kodunu girin",
    or: "veya",
    noAccount: "HesabÄ±nÄ±z yok mu?",
    haveAccount: "Zaten bir hesabÄ±nÄ±z var mÄ±?",
    notReceivedCode: "DoÄŸrulama kodu almadÄ±nÄ±z mÄ±?",
    codeSent: "DoÄŸrulama kodu gÃ¶nderildi",
    registrationSuccessful: "KayÄ±t baÅŸarÄ±lÄ±, lÃ¼tfen giriÅŸ yapÄ±n",
    verificationCodeError: "DoÄŸrulama kodu yanlÄ±ÅŸ, lÃ¼tfen tekrar deneyin",
    doNotSendFrequently: "DoÄŸrulama kodunu sÄ±k sÄ±k gÃ¶ndermeyin",
    codeResent: "DoÄŸrulama kodu yeniden gÃ¶nderildi",
    loginSuccessful: "GiriÅŸ baÅŸarÄ±lÄ±",
    loginFailed: "GiriÅŸ baÅŸarÄ±sÄ±z, lÃ¼tfen e-posta ve ÅŸifrenizi kontrol edin",
    fillCompleteInfo: "LÃ¼tfen tÃ¼m kayÄ±t bilgilerini doldurun",
    pleaseEnterValidEmail: "LÃ¼tfen geÃ§erli bir e-posta adresi girin",
    passwordTooShort: "Åifre en az 6 karakter olmalÄ±dÄ±r",
    registrationFailed: "KayÄ±t baÅŸarÄ±sÄ±z, lÃ¼tfen giriÅŸ bilgilerini kontrol edin",
    pleaseInputCode: "LÃ¼tfen doÄŸrulama kodunu girin",
    passwordsDoNotMatch: "Åifreler eÅŸleÅŸmiyor",
    passwordResetSuccessful: "Åifre sÄ±fÄ±rlama baÅŸarÄ±lÄ±, lÃ¼tfen giriÅŸ yapÄ±n",
    passwordResetFailed: "Åifre sÄ±fÄ±rlama baÅŸarÄ±sÄ±z, lÃ¼tfen giriÅŸ bilgilerini kontrol edin",
    googleLoginFailed: "Google ile giriÅŸ yÃ¶nlendirmesi baÅŸarÄ±sÄ±z, lÃ¼tfen daha sonra tekrar deneyin",
    appleLoginInProgress: "Apple ile giriÅŸ Ã¶zelliÄŸi geliÅŸtirme aÅŸamasÄ±nda",
    googleRegisterInProgress: "Google ile kayÄ±t Ã¶zelliÄŸi geliÅŸtirme aÅŸamasÄ±nda",
    appleRegisterInProgress: "Apple ile kayÄ±t Ã¶zelliÄŸi geliÅŸtirme aÅŸamasÄ±nda",
    verifyingGoogleLogin: "Google ile giriÅŸ doÄŸrulanÄ±yor"
  },
  // Ana ArayÃ¼z
  lemon: {
    // Ana Sayfa
    welcome: {
      greeting: "Merhaba",
      question: "Sizin iÃ§in ne yapabilirim?",
      tabs: {
        featured: "Ã–ne Ã‡Ä±kanlar",
        research: "AraÅŸtÄ±rma",
        lifestyle: "YaÅŸam TarzÄ±",
        dataAnalysis: "Veri Analizi",
        education: "EÄŸitim",
        productivity: "Verimlilik",
        other: "DiÄŸer"
      },
      placeholder: "Size nasÄ±l yardÄ±mcÄ± olabilirim?",
      communityNote: "Toplulukta gÃ¶sterilen tÃ¼m gÃ¶revler ve web siteleri, kullanÄ±cÄ±lar tarafÄ±ndan gÃ¶nÃ¼llÃ¼ olarak paylaÅŸÄ±lÄ±r. Platform, kullanÄ±cÄ± onayÄ± olmadan hiÃ§bir iÃ§eriÄŸi gÃ¶stermez."
    },
    // Sohbet BaÅŸlÄ±ÄŸÄ±
    chatHeader: {
      share: "PaylaÅŸ",
      viewAllFiles: "Bu gÃ¶revdeki tÃ¼m dosyalarÄ± gÃ¶rÃ¼ntÃ¼le",
      moreOptions: "Daha Fazla SeÃ§enek",
      rename: "Yeniden AdlandÄ±r",
      editTitle: "BaÅŸlÄ±ÄŸÄ± DÃ¼zenle",
      enterNewTitle: "Yeni baÅŸlÄ±k girin",
      cancel: "Ä°ptal",
      confirm: "Onayla",
      favorite: "Favorilere Ekle",
      unfavorite: "Favorilerden Ã‡Ä±kar"
    },
    // Mesaj Sohbet Listesi SayfasÄ±
    message: {
      runCommand: "Bash komutunu Ã§alÄ±ÅŸtÄ±r",
      readFile: "DosyayÄ± oku",
      editFile: "DosyayÄ± dÃ¼zenle",
      browsing: "Geziniyor",
      searching: "ArÄ±yor",
      minutesAgo: "dakika Ã¶nce",
      secondsAgo: "saniye Ã¶nce",
      hoursAgo: "saat Ã¶nce",
      daysAgo: "gÃ¼n Ã¶nce",
      monthsAgo: "ay Ã¶nce",
      yearsAgo: "yÄ±l Ã¶nce",
      copySuccess: "Kopyalama baÅŸarÄ±lÄ±",
      copyError: "Kopyalama baÅŸarÄ±sÄ±z",
      botInitialResponse: "Merhaba, talebinizi aldÄ±m. Sorunu analiz ediyorum, lÃ¼tfen bekleyin.",
      botInitialPlan: "Plan hazÄ±rlanÄ±yor"
    },
    // Yan Ã‡ubuk
    sidebar: {
      newTask: "Yeni GÃ¶rev",
      shortcutKey: "T",
      moreOptions: "Daha Fazla SeÃ§enek",
      share: "PaylaÅŸ",
      rename: "Yeniden AdlandÄ±r",
      collect: "Favorilere Ekle",
      delete: "Sil",
      confirmDelete: "Silmeyi Onayla",
      deleteConfirmation: "Bu sohbeti silmek istediÄŸinizden emin misiniz?",
      cancel: "Ä°ptal",
      confirm: "Onayla",
      noChats: "BaÅŸlamak iÃ§in yeni bir gÃ¶rev oluÅŸturun",
      searchPlaceholder: "GÃ¶revleri ara..."
    },
    // Dosya Gezgini
    fileExplorer: {
      allFilesInTask: "Bu gÃ¶revdeki tÃ¼m dosyalar",
      noContent: "Ä°Ã§erik yok",
      preview: "Ã–nizleme",
      locateInChat: "Sohbette bul",
      download: "Ä°ndir",
      saveToGoogleDrive: "Google Drive'a kaydet",
      selectAll: "TÃ¼mÃ¼nÃ¼ seÃ§",
      cancel: "Ä°ptal",
      batchDownload: "Toplu indirme",
      fileTypes: {
        all: "TÃ¼mÃ¼",
        document: "Belge",
        image: "Resim",
        codeFile: "Kod dosyasÄ±",
        link: "BaÄŸlantÄ±"
      },
      timeGroups: {
        today: "BugÃ¼n",
        yesterday: "DÃ¼n",
        earlier: "Daha Ã¶nce"
      },
      weekdays: {
        sunday: "Pazar",
        monday: "Pazartesi",
        tuesday: "SalÄ±",
        wednesday: "Ã‡arÅŸamba",
        thursday: "PerÅŸembe",
        friday: "Cuma",
        saturday: "Cumartesi"
      }
    },
    fullPreview: {
      download: "Ä°ndir",
      exportToPDF: "PDF olarak dÄ±ÅŸa aktar",
      saveToGoogleDrive: "Google Drive'a kaydet",
      maximize: "BÃ¼yÃ¼t",
      minimize: "KÃ¼Ã§Ã¼lt",
      previous: "Ã–nceki",
      next: "Sonraki",
      copy: "Kopyala",
      code: "Kod",
      preview: "Ã–nizleme",
      close: "Kapat",
      fileTypePresentation: "Ã–nizleme yapÄ±lamÄ±yor",
      cannotPreviewFormat: "Bu format Ã¶nizlenemez.",
      downloadToView: "Ä°Ã§eriÄŸi gÃ¶rÃ¼ntÃ¼lemek iÃ§in dosyayÄ± indirin.",
      noContentToCopy: "Kopyalanacak iÃ§erik yok.",
      clipboardNotSupported: "Mevcut tarayÄ±cÄ± pano iÅŸlemlerini desteklemiyor, lÃ¼tfen manuel kopyalayÄ±n.",
      contentCopied: "Ä°Ã§erik kopyalandÄ±.",
      copyFailed: "Kopyalama baÅŸarÄ±sÄ±z, lÃ¼tfen tekrar deneyin veya manuel kopyalayÄ±n.",
      exportPDFPending: "PDF dÄ±ÅŸa aktarma baÅŸarÄ±lÄ±",
      saveToGoogleDrivePending: "Google Drive'a kaydetme Ã¶zelliÄŸi geliÅŸtirme aÅŸamasÄ±nda."
    },
    preview: {
      title: "Lemon'un BilgisayarÄ±",
      openVsCode: "VS Code",
      using: "Lemon kullanÄ±yor",
      performing: "YÃ¼rÃ¼tÃ¼lÃ¼yor",
      previousStep: "Ã–nceki adÄ±m",
      nextStep: "Sonraki adÄ±m",
      realtime: "GerÃ§ek zamanlÄ±",
      waitingForDevelopment: "GeliÅŸtirme bekleniyor...",
      browser: "TarayÄ±cÄ±",
      browsing: "Geziniyor",
      editor: "EditÃ¶r",
      editingFile: "Dosya dÃ¼zenleniyor",
      terminal: "Terminal",
      executingCommand: "Komut yÃ¼rÃ¼tÃ¼lÃ¼yor",
      readingFile: "Dosya okunuyor",
      search: "Ara",
      searching: "ArÄ±yor"
    }
  },
  // Ayarlar ArayÃ¼zÃ¼
  setting: {
    back: "Geri",
    doneStep: "TamamlandÄ±",
    prevStep: "Ã–nceki adÄ±m",
    nextStep: "Sonraki adÄ±m",
    settingModel: "Modeli ayarla",
    settingModelTips: "Ayarlar sayfasÄ±na gitmek iÃ§in ayarlara tÄ±klayÄ±n",
    menu: {
      basic: "Temel Ayarlar",
      defaultModel: "VarsayÄ±lan Model",
      modelService: "Model Servisi",
      searchService: "Arama Servisi",
      mcpService: "MCP Servisi",
      experience: "Deneyim KÃ¼tÃ¼phanesi"
    },
    basic: {
      title: "Temel Ayarlar",
      langTitle: "Dil AyarlarÄ±",
      languagePreference: "Dil Tercihi",
      lang: {
        en: "Ä°ngilizce",
        zh: "Ã‡ince (BasitleÅŸtirilmiÅŸ)",
        de: "Almanca",
        es: "Ä°spanyolca",
        fr: "FransÄ±zca",
        ja: "Japonca",
        kr: "Korece",
        tr: "TÃ¼rkÃ§e",
        pt: "Portekizce",
        tw: "Ã‡ince (Geleneksel)",
        vi: "Vietnamca"
      }
    },
    modelService: {
      modelService: "Model Servisi",
      modelServiceTipsOne: "AdÄ±m 1: Model servis saÄŸlayÄ±cÄ±sÄ±nÄ± seÃ§in",
      modelServiceTipsTwo: "AdÄ±m 2: API anahtarÄ±nÄ± girin",
      modelServiceTipsThree: "AdÄ±m 3: Model servisini etkinleÅŸtirin",
      title: "Model Servisi",
      searchPlaceholder: "Platform ara",
      defaultPlatform: "VarsayÄ±lan sistem platformu",
      modelPlatform: "Model Platformu",
      statusOn: "Etkin",
      addPlatform: "Ekle",
      save: "Kaydet",
      defaultPlatformDescription: "VarsayÄ±lan platform modeli sistem tarafÄ±ndan saÄŸlanÄ±r, yapÄ±landÄ±rma gerekmez",
      apiKey: "API AnahtarÄ±",
      apiKeyPlaceholder: "API anahtarÄ±nÄ± girin",
      getApiKey: "AnahtarÄ± almak iÃ§in buraya tÄ±klayÄ±n",
      check: "Kontrol Et",
selectCheckModel: "LÃ¼tfen kontrol modelini seÃ§in",
      apiAddress: "API Adresi",
      apiAddressPlaceholder: "API adresini girin",
      apiAddressTip: "/ ile bitiyorsa v1 sÃ¼rÃ¼mÃ¼ yoksayÄ±lÄ±r, # ile bitiyorsa girilen adres zorunlu kullanÄ±lÄ±r",
      activateTime: "EtkinleÅŸtirme SÃ¼resi",
      activateTimePlaceholder: "EtkinleÅŸtirme sÃ¼resini (dakika) girin",
      models: "Modeller",
      ungrouped: "GruplandÄ±rÄ±lmamÄ±ÅŸ",
      viewOfficialDocs: "Daha fazla bilgi iÃ§in platformun resmi belgelerine bakÄ±n",
      add: "Ekle",
      confirmDeleteModel: "Bu modeli silmek istediÄŸinizden emin misiniz?",
      deleteModelSuccess: "Model baÅŸarÄ±yla silindi",
      deleteModelFailed: "Model silme baÅŸarÄ±sÄ±z",
      addModelSuccess: "Model baÅŸarÄ±yla eklendi",
      updateModelSuccess: "Model baÅŸarÄ±yla gÃ¼ncellendi",
      copySuccess: "Ä°sim kopyalandÄ±",
      typeVision: "GÃ¶rsel",
      typeNetwork: "AÄŸ",
      typeEmbed: "GÃ¶mme",
      typeReasoning: "Muhakeme",
it: "AraÃ§",
      addProvider: "SaÄŸlayÄ±cÄ± Ekle",
      confirm: "Onayla",
      cancel: "Ä°ptal",
      platformLogo: "Platform Logosu",
      providerName: "SaÄŸlayÄ±cÄ± AdÄ±",
      namePlaceholder: "Ad",
      providerType: "SaÄŸlayÄ±cÄ± TÃ¼rÃ¼",
      typePlaceholder: "TÃ¼r",
      enterName: "Ad girin",
      selectType: "TÃ¼r seÃ§in",
      addPlatformSuccess: "Platform baÅŸarÄ±yla eklendi",
      formValidationFailed: "Form doÄŸrulama baÅŸarÄ±sÄ±z",
      addModel: "Model Ekle",
      editModel: "Modeli DÃ¼zenle",
      modelId: "Model KimliÄŸi",
      modelIdPlaceholder: "Model kimliÄŸini girin",
      modelName: "Model AdÄ±",
      modelNamePlaceholder: "Model adÄ±",
      groupName: "Grup AdÄ±",
      groupNamePlaceholder: "Grup adÄ±",
      modelTypes: "Model TÃ¼rleri",
      enterModelId: "Model kimliÄŸini girin",
      enterModelName: "Model adÄ±nÄ± girin",
      enterGroupName: "Grup adÄ±nÄ± girin",
      selectModelType: "En az bir model tÃ¼rÃ¼ seÃ§in",
      editProvider: "SaÄŸlayÄ±cÄ±yÄ± DÃ¼zenle",
      updatePlatformSuccess: "Platform baÅŸarÄ±yla gÃ¼ncellendi",
      deletePlatformSuccess: "Platform baÅŸarÄ±yla silindi",
      deletePlatformFailed: "Platform silme baÅŸarÄ±sÄ±z",
      saveSuccess: "Kaydetme baÅŸarÄ±lÄ±",
      saveFailed: "Kaydetme baÅŸarÄ±sÄ±z",
      platforms: {
        Anthropic: "Anthropic",
        ModelScope: "ModelScope Sihir",
        Gemini: "Gemini",
        OpenAI: "OpenAI",
        Ollama: "Ollama",
        qiniu: "Qiniu Bulut",
        WanJieData: "WanJie Veri",
        PPIO: "PPIO Bulut",
        QianFan: "Baidu Bulut QianFan",
        SiliconFlow: "Silikon AkÄ±ÅŸÄ±",
        Volcengine: "Volcengine",
        DeepSeek: "DeepSeek",
        Bailian: "Alibaba Bulut Bailian",
        OpenRouter: "OpenRouter",
        LMStudio: "LM Studio"
      }
    },
    defaultModel: {
      defaultModel: "VarsayÄ±lan Modeli Ayarla",
      defaultModelTipsOne: "VarsayÄ±lan model sayfasÄ±na gitmek iÃ§in varsayÄ±lan modele tÄ±klayÄ±n",
      topicNamingModel: "Konu AdlandÄ±rma Modeli",
      topicNamingModelTips: "Yeni konularÄ± otomatik olarak adlandÄ±rmak iÃ§in kullanÄ±lan model",
      emptymodelTips: "Model servisinde ilgili platformu etkinleÅŸtirin",
      DefaultModelSetting: "VarsayÄ±lan Model AyarlarÄ±",
      defaultAssistantModel: "VarsayÄ±lan Asistan Modeli",
      assistantModelTips: "Asistan oluÅŸturulurken kullanÄ±lan model;",
      topicNamingModel: "Konu AdlandÄ±rma Modeli",
      topicNamingModelTips: "Yeni konularÄ± otomatik olarak adlandÄ±rmak iÃ§in kullanÄ±lan model",
      translationModel: "Ã‡eviri Modeli",
      translationModelTips: "Ã‡eviri hizmetleri iÃ§in kullanÄ±lan model",
      browserUseModel: "TarayÄ±cÄ± Servis Modeli",
      browserUseModelTips: "Dahili tarayÄ±cÄ±da kullanÄ±lan model, araÃ§ ve fonksiyon Ã§aÄŸrÄ±larÄ±nÄ± desteklemelidir",
      saveSuccess: "Ayarlar baÅŸarÄ±yla kaydedildi",
      assistantSettings: "Asistan AyarlarÄ±",
      confirm: "Onayla",
      cancel: "Ä°ptal",
      assistantName: "Asistan AdÄ±",
      assistantNamePlaceholder: "Asistan adÄ±nÄ± girin",
      prompt: "Komut Ä°stemi",
      promptPlaceholder: "Komut istemini girin",
      modelParameters: "Model Parametreleri",
      temperature: "SÄ±caklÄ±k",
      topP: "Top P",
      maxTokens: "Maksimum Jeton SayÄ±sÄ±",
      enableLengthLimit: "Uzunluk SÄ±nÄ±rÄ±nÄ± EtkinleÅŸtir",
      topicNamingSettings: "Konu AdlandÄ±rma AyarlarÄ±",
      topicAutoNaming: "Otomatik Konu AdlandÄ±rma",
      topicNamingPrompt: "Konu AdlandÄ±rma Komut Ä°stemi",
      translationSettings: "Ã‡eviri AyarlarÄ±",
      translationPrompt: "Ã‡eviri Komut Ä°stemi"
    },
    searchService: {
      searchService: "Arama Servisini Ayarla",
      searchServiceTipsOne: "Arama servisi sayfasÄ±na gitmek iÃ§in arama servisine tÄ±klayÄ±n",
      searchEngineTipsOne: "AdÄ±m 1: Arama servisi saÄŸlayÄ±cÄ±sÄ±nÄ± seÃ§in",
      searchEngineTipsTwo: "AdÄ±m 2: API anahtarÄ±nÄ± girin",
      title: "Arama Servisi",
      blacklistSubscription: "Kara Liste AboneliÄŸi",
      addSubscription: "Abonelik Ekle",
      updateNow: "Åimdi GÃ¼ncelle",
      deleteSubscription: "AboneliÄŸi Sil",
      confirm: "Onayla",
      cancel: "Ä°ptal",
      subscriptionUrl: "Abonelik URL'si",
      subscriptionUrlPlaceholder: "https://example/abcd",
      subscriptionName: "Abonelik AdÄ±",
      subscriptionNamePlaceholder: "Ä°ndirilen abonelik kaynaÄŸÄ±nda isim yoksa kullanÄ±lan alternatif isim",
      name: "Ad",
      url: "URL",
      addSubscriptionSuccess: "Abonelik baÅŸarÄ±yla eklendi",
      deleteSubscriptionSuccess: "Abonelik baÅŸarÄ±yla silindi",
      deleteSubscriptionFailed: "Abonelik silme baÅŸarÄ±sÄ±z",
      saveConfigSuccess: "YapÄ±landÄ±rma baÅŸarÄ±yla kaydedildi",
      saveConfigFailed: "YapÄ±landÄ±rma kaydetme baÅŸarÄ±sÄ±z",
      loadConfigFailed: "YapÄ±landÄ±rma yÃ¼kleme baÅŸarÄ±sÄ±z",
      formValidationFailed: "Form doÄŸrulama baÅŸarÄ±sÄ±z",
      enterSubscriptionUrl: "Abonelik URL'sini girin",
      invalidUrl: "GeÃ§erli bir URL girin",
      enterSubscriptionName: "Abonelik adÄ±nÄ± girin",
      noSubscriptionSelected: "Abonelik seÃ§ilmedi",
      searchProvider: "Arama SaÄŸlayÄ±cÄ±sÄ±",
      generalSettings: "Genel Ayarlar",
      includeDate: "Tarihi Dahil Et",
      includeServer: "Sunucuyu Dahil Et",
      searchEnhancement: "Arama GeliÅŸtirme",
      searchResultCount: "Arama SonuÃ§ SayÄ±sÄ±",
      default: "VarsayÄ±lan",
      blacklist: "Kara Liste",
      blacklistTips: "Arama sonuÃ§larÄ±ndan hariÃ§ tutulacak alan adlarÄ±nÄ± girin",
      blacklistPlaceholder: "Her satÄ±ra bir alan adÄ± girin",
      save: "Kaydet",
      apiTips: "API YapÄ±landÄ±rmasÄ±",
      apiKeyPlaceholder: "API anahtarÄ±nÄ±zÄ± girin",
      apiKey: "API AnahtarÄ±",
      apiAddress: "API Adresi",
      tavilyName: "Tavily (anahtar)",
      baiduName: "Baidu (Ã¼cretsiz)",
      bingName: "Bing (Ã¼cretsiz)",
      saveBlacklistSuccess: "Kara liste baÅŸarÄ±yla kaydedildi",
      saveBlacklistFailed: "Kara liste kaydetme baÅŸarÄ±sÄ±z"
    },
    mcpService: {
      title: "MCP Servisi",
      addServer: "Sunucu Ekle",
      save: "Kaydet",
      name: "Ad",
      namePlaceholder: "AdÄ± girin",
      description: "AÃ§Ä±klama",
      descriptionPlaceholder: "AÃ§Ä±klama",
      type: "TÃ¼r",
      stdio: "Standart GiriÅŸ/Ã‡Ä±kÄ±ÅŸ (stdio)",
      sse: "Sunucu GÃ¶nderilen Olaylar (sse)",
      streamableHttp: "AkÄ±ÅŸ YapÄ±labilir HTTP (streamableHttp)",
      command: "Komut",
      commandPlaceholder: "uvx veya npx",
      packageSource: "Paket KaynaÄŸÄ±",
      default: "VarsayÄ±lan",
      taobaoNpmMirror: "Taobao NPM AynasÄ±",
      tsinghua: "Tsinghua Ãœniversitesi",
      aliyun: "Alibaba Bulut",
      ustc: "Ã‡in Bilim ve Teknoloji Ãœniversitesi",
      huaweiCloud: "Huawei Bulut",
      tencentCloud: "Tencent Bulut",
      args: "ArgÃ¼manlar",
      argsPlaceholder: "arg1\narg2",
      env: "Ã‡evre DeÄŸiÅŸkenleri",
      envPlaceholder: "KEY1=VALUE1\nKEY2=VALUE2",
      mcpServer: "MCP Sunucusu"
    },
    experience: {
      title: "Deneyim KÃ¼tÃ¼phanesi",
      addExperience: "Deneyim Ekle",
      editExperience: "Deneyimi DÃ¼zenle",
      close: "Kapat",
      titleLabel: "BaÅŸlÄ±k",
      titlePlaceholder: "Deneyim baÅŸlÄ±ÄŸÄ±",
      goalLabel: "AmaÃ§",
      goalPlaceholder: "Bu deneyimin amacÄ±",
      contentLabel: "Ä°Ã§erik",
      contentPlaceholder: "Deneyim iÃ§eriÄŸi",
      statusLabel: "Durum",
      enabled: "Etkin",
      disabled: "Devre DÄ±ÅŸÄ±",
      cancel: "Ä°ptal",
      save: "Kaydet",
      delete: "Sil",
      undoChanges: "DeÄŸiÅŸiklikleri Geri Al",
      deleteExperience: "Deneyimi Sil",
      deleteConfirm: "Bu deneyimi silmek istediÄŸinizden emin misiniz?",
      totalExperience: "Toplam {count} deneyim",
      tableTitle: "BaÅŸlÄ±k",
      tableContent: "Ä°Ã§erik",
      tableCreatedAt: "OluÅŸturulma Tarihi",
      tableStatus: "Durum",
      tableOperation: "Ä°ÅŸlem",
      filterAll: "TÃ¼mÃ¼",
      deleteSuccess: "Silme baÅŸarÄ±lÄ±",
      deleteFailed: "Silme baÅŸarÄ±sÄ±z",
      createSuccess: "Deneyim baÅŸarÄ±yla eklendi",
      createFailed: "Deneyim ekleme baÅŸarÄ±sÄ±z",
      updateSuccess: "GÃ¼ncelleme baÅŸarÄ±lÄ±",
      updateFailed: "GÃ¼ncelleme baÅŸarÄ±sÄ±z",
      updateFailedDataNotExist: "GÃ¼ncelleme baÅŸarÄ±sÄ±z, mevcut veri bulunamadÄ±",
      getDataError: "Veri alma hatasÄ±",
      detect: "Niyet Tespiti",
      plan: "GÃ¶rev Planlama",
      action: "GÃ¶rev YÃ¼rÃ¼tme",
      sunday: "Pazar",
      monday: "Pazartesi",
      tuesday: "SalÄ±",
      wednesday: "Ã‡arÅŸamba",
      thursday: "PerÅŸembe",
      friday: "Cuma",
      saturday: "Cumartesi",
      earlier: "Daha Ã¶nce"
    },
  },
  thinking: "DÃ¼ÅŸÃ¼nÃ¼yor",
  task_error: "GÃ¶rev anormal ÅŸekilde sonlandÄ±",
  stop_task: "GÃ¶rev durduruldu",
  jump_to_result: "Sonuca git",
  replay: "Tekrar oynat",
  task_finished: "GÃ¶rev tamamlandÄ±",
  task_playing: "GÃ¶rev devam ediyor",
  click_here_to_go_to_settings: "Ayarlara gitmek iÃ§in buraya tÄ±kla",
}


================================================
FILE: frontend/src/locals/lang/tw.js
================================================
export default {
  // ç™»å…¥ä»‹é¢
  auth: {
    loginToLemonAI: "ç™»å…¥ LemonAI",
    registerLemonAIAccount: "è¨»å†Š LemonAI å¸³æˆ¶",
    verifyEmail: "é©—è­‰é›»å­éƒµä»¶",
    resetPassword: "é‡è¨­å¯†ç¢¼",
    loginWithGoogle: "ä½¿ç”¨ Google ç™»å…¥",
    registerWithGoogle: "ä½¿ç”¨ Google è¨»å†Š",
    login: "ç™»å…¥",
    register: "è¨»å†Š",
    logOut: "ç™»å‡º",
    forgotPassword: "å¿˜è¨˜å¯†ç¢¼",
    resetPasswordButton: "é‡è¨­å¯†ç¢¼",
    backToLogin: "è¿”å›ç™»å…¥",
    verifyEmailButton: "é©—è­‰é›»å­éƒµä»¶",
    resendCode: "é‡æ–°å‚³é€é©—è­‰ç¢¼",
    email: "é›»å­éƒµä»¶",
    password: "å¯†ç¢¼",
    fullname: "å…¨å",
    codeSentTo: "é©—è­‰ç¢¼å·²å‚³é€è‡³",
    pleaseInputEmail: "è«‹è¼¸å…¥é›»å­éƒµä»¶",
    pleaseInputValidEmail: "è«‹è¼¸å…¥æœ‰æ•ˆçš„é›»å­éƒµä»¶",
    pleaseInputPassword: "è«‹è¼¸å…¥å¯†ç¢¼",
    pleaseInputFullname: "è«‹è¼¸å…¥å…¨å",
    pleaseInputVerifyCode: "è«‹è¼¸å…¥é©—è­‰ç¢¼",
    pleaseInputNewPassword: "è«‹è¼¸å…¥æ–°å¯†ç¢¼",
    pleaseConfirmPassword: "è«‹ç¢ºèªå¯†ç¢¼",
    pleaseInput6DigitCode: "è«‹è¼¸å…¥ 6 ä½é©—è­‰ç¢¼",
    or: "æˆ–",
    noAccount: "æ²’æœ‰å¸³æˆ¶ï¼Ÿ",
    haveAccount: "å·²æœ‰å¸³æˆ¶ï¼Ÿ",
    notReceivedCode: "æœªæ”¶åˆ°é©—è­‰ç¢¼ï¼Ÿ",
    codeSent: "é©—è­‰ç¢¼å·²å‚³é€",
    registrationSuccessful: "è¨»å†ŠæˆåŠŸï¼Œè«‹ç™»å…¥",
    verificationCodeError: "é©—è­‰ç¢¼éŒ¯èª¤ï¼Œè«‹é‡è©¦",
    doNotSendFrequently: "è«‹å‹¿é »ç¹å‚³é€é©—è­‰ç¢¼",
    codeResent: "é©—è­‰ç¢¼å·²é‡æ–°å‚³é€",
    loginSuccessful: "ç™»å…¥æˆåŠŸ",
    loginFailed: "ç™»å…¥å¤±æ•—ï¼Œè«‹æª¢æŸ¥é›»å­éƒµä»¶å’Œå¯†ç¢¼",
    fillCompleteInfo: "è«‹å¡«å¯«å®Œæ•´çš„è¨»å†Šè³‡è¨Š",
    pleaseEnterValidEmail: "è«‹è¼¸å…¥æœ‰æ•ˆçš„é›»å­éƒµä»¶åœ°å€",
    passwordTooShort: "å¯†ç¢¼é•·åº¦ä¸å¾—å°‘æ–¼ 6 å€‹å­—å…ƒ",
    registrationFailed: "è¨»å†Šå¤±æ•—ï¼Œè«‹æª¢æŸ¥è¼¸å…¥",
    pleaseInputCode: "è«‹è¼¸å…¥é©—è­‰ç¢¼",
    passwordsDoNotMatch: "ç¢ºèªå¯†ç¢¼ä¸åŒ¹é…",
    passwordResetSuccessful: "å¯†ç¢¼é‡è¨­æˆåŠŸï¼Œè«‹ç™»å…¥",
    passwordResetFailed: "å¯†ç¢¼é‡è¨­å¤±æ•—ï¼Œè«‹æª¢æŸ¥è¼¸å…¥",
    googleLoginFailed: "Google ç™»å…¥è·³è½‰å¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦",
    appleLoginInProgress: "Apple ç™»å…¥åŠŸèƒ½æ­£åœ¨é–‹ç™¼ä¸­",
    googleRegisterInProgress: "Google è¨»å†ŠåŠŸèƒ½æ­£åœ¨é–‹ç™¼ä¸­",
    appleRegisterInProgress: "Apple è¨»å†ŠåŠŸèƒ½æ­£åœ¨é–‹ç™¼ä¸­",
    verifyingGoogleLogin: "æ­£åœ¨é©—è­‰ Google ç™»å…¥"
  },
  // ä¸»ä»‹é¢
  lemon: {
    // é¦–é 
    welcome: {
      greeting: "ä½ å¥½",
      question: "æˆ‘èƒ½ç‚ºä½ åšä»€éº¼ï¼Ÿ",
      tabs: {
        featured: "ç²¾é¸",
        research: "ç ”ç©¶",
        lifestyle: "ç”Ÿæ´»æ–¹å¼",
        dataAnalysis: "æ•¸æ“šåˆ†æ",
        education: "æ•™è‚²",
        productivity: "ç”Ÿç”¢åŠ›",
        other: "å…¶ä»–"
      },
      placeholder: "æœ‰ä»€éº¼æˆ‘èƒ½å¹«æ‚¨çš„å—ï¼Ÿ",
      communityNote: "ç¤¾ç¾¤ä¸­å±•ç¤ºçš„æ‰€æœ‰ä»»å‹™å’Œç¶²ç«™å‡ç”±ç”¨æˆ¶è‡ªé¡˜åˆ†äº«ã€‚å¹³å°ä¸æœƒåœ¨ç”¨æˆ¶ä¸åŒæ„çš„æƒ…æ³ä¸‹å±•ç¤ºä»»ä½•å…§å®¹ã€‚"
    },
    // å°è©±æ¨™é ­
    chatHeader: {
      share: "åˆ†äº«",
      viewAllFiles: "æŸ¥çœ‹æ­¤ä»»å‹™ä¸­çš„æ‰€æœ‰æª”æ¡ˆ",
      moreOptions: "æ›´å¤šé¸é …",
      rename: "é‡æ–°å‘½å",
      editTitle: "ç·¨è¼¯æ¨™é¡Œ",
      enterNewTitle: "è¼¸å…¥æ–°æ¨™é¡Œ",
      cancel: "å–æ¶ˆ",
      confirm: "ç¢ºèª",
      favorite: "åŠ å…¥æ”¶è—",
      unfavorite: "å–æ¶ˆæ”¶è—"
    },
    // è¨Šæ¯å°è©±åˆ—è¡¨é 
    message: {
      runCommand: "åŸ·è¡Œ bash æŒ‡ä»¤",
      readFile: "è®€å–æª”æ¡ˆ",
      editFile: "ç·¨è¼¯æª”æ¡ˆ",
      browsing: "æ­£åœ¨ç€è¦½",
      searching: "æ­£åœ¨æœå°‹",
      minutesAgo: "åˆ†é˜å‰",
      secondsAgo: "ç§’å‰",
      hoursAgo: "å°æ™‚å‰",
      daysAgo: "å¤©å‰",
      monthsAgo: "æœˆå‰",
      yearsAgo: "å¹´å‰",
      copySuccess: "è¤‡è£½æˆåŠŸ",
      copyError: "è¤‡è£½å¤±æ•—",
      botInitialResponse: "ä½ å¥½ï¼Œæˆ‘å·²æ”¶åˆ°ä½ çš„è«‹æ±‚ï¼Œæ­£åœ¨åˆ†æå•é¡Œã€‚è«‹ç¨ç­‰ã€‚",
      botInitialPlan: "åˆ¶å®šè¨ˆç•«ä¸­"
    },
    // å´é‚Šæ¬„
    sidebar: {
      newTask: "æ–°å»ºä»»å‹™",
      shortcutKey: "T",
      moreOptions: "æ›´å¤šé¸é …",
      share: "åˆ†äº«",
      rename: "é‡æ–°å‘½å",
      collect: "æ”¶è—",
      delete: "åˆªé™¤",
      confirmDelete: "ç¢ºèªåˆªé™¤",
      deleteConfirmation: "æ‚¨ç¢ºå®šè¦åˆªé™¤æ­¤å°è©±å—ï¼Ÿ",
      cancel: "å–æ¶ˆ",
      confirm: "ç¢ºå®š",
      noChats: "æ–°å»ºä¸€å€‹ä»»å‹™ä»¥é–‹å§‹",
      searchPlaceholder: "æœå°‹ä»»å‹™..."
    },
    // æª”æ¡ˆç€è¦½å™¨
    fileExplorer: {
      allFilesInTask: "æ­¤ä»»å‹™ä¸­çš„æ‰€æœ‰æª”æ¡ˆ",
      noContent: "æš«ç„¡å…§å®¹",
      preview: "é è¦½",
      locateInChat: "åœ¨èŠå¤©ä¸­å®šä½",
      download: "ä¸‹è¼‰",
      saveToGoogleDrive: "å„²å­˜è‡³ Google Drive",
      selectAll: "å…¨é¸",
      cancel: "å–æ¶ˆ",
      batchDownload: "æ‰¹é‡ä¸‹è¼‰",
      fileTypes: {
        all: "å…¨éƒ¨",
        document: "æ–‡ä»¶",
        image: "åœ–ç‰‡",
        codeFile: "ç¨‹å¼ç¢¼æª”æ¡ˆ",
        link: "é€£çµ"
      },
      timeGroups: {
        today: "ä»Šå¤©",
        yesterday: "æ˜¨å¤©",
        earlier: "æ›´æ—©"
      },
      weekdays: {
        sunday: "æ˜ŸæœŸæ—¥",
        monday: "æ˜ŸæœŸä¸€",
        tuesday: "æ˜ŸæœŸäºŒ",
        wednesday: "æ˜ŸæœŸä¸‰",
        thursday: "æ˜ŸæœŸå››",
        friday: "æ˜ŸæœŸäº”",
        saturday: "æ˜ŸæœŸå…­"
      }
    },
    fullPreview: {
      download: "ä¸‹è¼‰",
      exportToPDF: "åŒ¯å‡ºç‚º PDF",
      saveToGoogleDrive: "å„²å­˜è‡³ Google Drive",
      maximize: "æœ€å¤§åŒ–",
      minimize: "æœ€å°åŒ–",
      previous: "ä¸Šä¸€å€‹",
      next: "ä¸‹ä¸€å€‹",
      copy: "è¤‡è£½",
      code: "ç¨‹å¼ç¢¼",
      preview: "é è¦½",
      close: "é—œé–‰",
      fileTypePresentation: "ç„¡æ³•é è¦½",
      cannotPreviewFormat: "æ­¤æ ¼å¼ç„¡æ³•é è¦½ã€‚",
      downloadToView: "è«‹ä¸‹è¼‰æª”æ¡ˆä»¥æŸ¥çœ‹å…§å®¹ã€‚",
      noContentToCopy: "ç„¡å¯è¤‡è£½çš„å…§å®¹ã€‚",
      clipboardNotSupported: "ç›®å‰ç€è¦½å™¨ä¸æ”¯æ´å‰ªè²¼ç°¿æ“ä½œï¼Œè«‹æ‰‹å‹•è¤‡è£½ã€‚",
      contentCopied: "å…§å®¹å·²è¤‡è£½ã€‚",
      copyFailed: "è¤‡è£½å¤±æ•—ï¼Œè«‹é‡è©¦æˆ–æ‰‹å‹•è¤‡è£½ã€‚",
      exportPDFPending: "åŒ¯å‡º PDF æˆåŠŸ",
      saveToGoogleDrivePending: "å„²å­˜è‡³ Google Drive åŠŸèƒ½å¾…å¯¦ç¾ã€‚"
    },
    preview: {
      title: "Lemon çš„é›»è…¦",
      openVsCode: "VS Code",
      using: "Lemon æ­£åœ¨ä½¿ç”¨",
      performing: "æ­£åœ¨åŸ·è¡Œ",
      previousStep: "ä¸Šä¸€æ­¥",
      nextStep: "ä¸‹ä¸€æ­¥",
      realtime: "å³æ™‚",
      waitingForDevelopment: "ç­‰å¾…é–‹ç™¼...",
      browser: "ç€è¦½å™¨",
      browsing: "ç€è¦½",
      editor: "ç·¨è¼¯å™¨",
      editingFile: "ç·¨è¼¯æª”æ¡ˆ",
      terminal: "çµ‚ç«¯æ©Ÿ",
      executingCommand: "åŸ·è¡ŒæŒ‡ä»¤",
      readingFile: "è®€å–æª”æ¡ˆ",
      search: "æœå°‹",
      searching: "æœå°‹"
    }
  },
  // è¨­å®šä»‹é¢
  setting: {
    back: "è¿”å›",
    doneStep: "çµæŸ",
    prevStep: "ä¸Šä¸€æ­¥",
    nextStep: "ä¸‹ä¸€æ­¥",
    settingModel: "è¨­å®šæ¨¡å‹",
    settingModelTips: "é»æ“Šè¨­å®šï¼Œè·³è½‰åˆ°è¨­å®šé é¢",
    menu: {
      basic: "åŸºæœ¬è¨­å®š",
      defaultModel: "é è¨­æ¨¡å‹",
      modelService: "æ¨¡å‹æœå‹™",
      searchService: "æœå°‹æœå‹™",
      mcpService: "MCP æœå‹™",
      experience: "ç¶“é©—åº«"
    },
    basic: {
      title: "åŸºæœ¬è¨­å®š",
      langTitle: "èªè¨€è¨­å®š",
      languagePreference: "èªè¨€åå¥½",
      lang: {
        en: "è‹±æ–‡",
        zh: "ä¸­æ–‡ï¼ˆç°¡é«”ï¼‰",
        de: "å¾·èª",
        es: "è¥¿ç­ç‰™èª",
        fr: "æ³•èª",
        ja: "æ—¥èª",
        kr: "éŸ“èª",
        tr: "åœŸè€³å…¶èª",
        pt: "è‘¡è„ç‰™èª",
        tw: "ä¸­æ–‡ï¼ˆç¹é«”ï¼‰",
        vi: "è¶Šå—èª"
      }
    },
    modelService: {
      modelService: "æ¨¡å‹æœå‹™",
      modelServiceTipsOne: "ç¬¬ä¸€æ­¥ï¼šé¸æ“‡æ¨¡å‹æœå‹™æä¾›å•†",
      modelServiceTipsTwo: "ç¬¬äºŒæ­¥ï¼šè¨­å®šè¼¸å…¥ API å¯†é‘°",
      modelServiceTipsThree: "ç¬¬ä¸‰æ­¥ï¼šå•Ÿç”¨æ¨¡å‹æœå‹™",
      title: "æ¨¡å‹æœå‹™",
      searchPlaceholder: "æœå°‹å¹³å°",
      defaultPlatform: "é è¨­ç³»çµ±å¹³å°",
      modelPlatform: "æ¨¡å‹å¹³å°",
      statusOn: "é–‹å•Ÿ",
      addPlatform: "æ–°å¢",
      save: "å„²å­˜",
      defaultPlatformDescription: "é è¨­å¹³å°æ¨¡å‹ç”±ç³»çµ±æä¾›ï¼Œç„¡éœ€é…ç½®",
      apiKey: "API å¯†é‘°",
      apiKeyPlaceholder: "è«‹è¼¸å…¥ API å¯†é‘°",
      getApiKey: "é»æ“Šæ­¤è™•ç²å–å¯†é‘°",
      check: "æª¢æŸ¥",
      selectCheckModel: "è«‹é¸æ“‡æª¢æŸ¥æ¨¡å‹",
      apiAddress: "API åœ°å€",
      apiAddressPlaceholder: "è«‹è¼¸å…¥ API åœ°å€",
      apiAddressTip: "ä»¥ / çµå°¾å¿½ç•¥ v1 ç‰ˆæœ¬ï¼Œä»¥ # çµå°¾å¼·åˆ¶ä½¿ç”¨è¼¸å…¥åœ°å€",
      activateTime: "å•Ÿç”¨æ™‚é–“",
      activateTimePlaceholder: "è«‹è¼¸å…¥å•Ÿç”¨æ™‚é–“ï¼ˆåˆ†é˜ï¼‰",
      models: "æ¨¡å‹",
      ungrouped: "æœªåˆ†çµ„",
      viewOfficialDocs: "æŸ¥çœ‹å¹³å°çš„å®˜æ–¹æ–‡ä»¶ä»¥ç²å–æ›´å¤šè³‡è¨Š",
      add: "æ–°å¢",
      confirmDeleteModel: "ç¢ºå®šè¦åˆªé™¤æ­¤æ¨¡å‹å—ï¼Ÿ",
      deleteModelSuccess: "æ¨¡å‹åˆªé™¤æˆåŠŸ",
      deleteModelFailed: "æ¨¡å‹åˆªé™¤å¤±æ•—",
      addModelSuccess: "æ¨¡å‹æ–°å¢æˆåŠŸ",
      updateModelSuccess: "æ¨¡å‹æ›´æ–°æˆåŠŸ",
      copySuccess: "åç¨±å·²è¤‡è£½",
      typeVision: "è¦–è¦º",
      typeNetwork: "ç¶²è·¯",
      typeEmbed: "åµŒå…¥",
      typeReasoning: "æ¨ç†",
      typeTool: "å·¥å…·",
      addProvider: "æ–°å¢æä¾›å•†",
      confirm: "ç¢ºèª",
      cancel: "å–æ¶ˆ",
      platformLogo: "å¹³å°æ¨™èªŒ",
      providerName: "æä¾›å•†åç¨±",
      namePlaceholder: "åç¨±",
      providerType: "æä¾›å•†é¡å‹",
      typePlaceholder: "é¡å‹",
      enterName: "è«‹è¼¸å…¥åç¨±",
      selectType: "è«‹é¸æ“‡é¡å‹",
      addPlatformSuccess: "å¹³å°æ–°å¢æˆåŠŸ",
      formValidationFailed: "è¡¨å–®é©—è­‰å¤±æ•—",
      addModel: "æ–°å¢æ¨¡å‹",
      editModel: "ç·¨è¼¯æ¨¡å‹",
      modelId: "æ¨¡å‹ ID",
      modelIdPlaceholder: "è«‹è¼¸å…¥æ¨¡å‹ ID",
      modelName: "æ¨¡å‹åç¨±",
      modelNamePlaceholder: "æ¨¡å‹åç¨±",
      groupName: "çµ„åç¨±",
      groupNamePlaceholder: "çµ„åç¨±",
      modelTypes: "æ¨¡å‹é¡å‹",
      enterModelId: "è«‹è¼¸å…¥æ¨¡å‹ ID",
      enterModelName: "è«‹è¼¸å…¥æ¨¡å‹åç¨±",
      enterGroupName: "è«‹è¼¸å…¥çµ„åç¨±",
      selectModelType: "è«‹è‡³å°‘é¸æ“‡ä¸€ç¨®æ¨¡å‹é¡å‹",
      editProvider: "ç·¨è¼¯æä¾›å•†",
      updatePlatformSuccess: "å¹³å°æ›´æ–°æˆåŠŸ",
      deletePlatformSuccess: "å¹³å°åˆªé™¤æˆåŠŸ",
      deletePlatformFailed: "å¹³å°åˆªé™¤å¤±æ•—",
      saveSuccess: "å„²å­˜æˆåŠŸ",
      saveFailed: "å„²å­˜å¤±æ•—",
      platforms: {
        Anthropic: "Anthropic",
        ModelScope: "ModelScope é­”å¡”",
        Gemini: "Gemini",
        OpenAI: "OpenAI",
        Ollama: "Ollama",
        qiniu: "ä¸ƒç‰›é›²",
        WanJieData: "è¬ç•Œæ•¸æ“š",
        PPIO: "PPIO æ´¾æ­é›²",
        QianFan: "ç™¾åº¦é›²åƒå¸†",
        SiliconFlow: "çŸ½åŸºæµå‹•",
        Volcengine: "ç«å±±å¼•æ“",
        DeepSeek: "æ·±åº¦æ±‚ç´¢",
        Bailian: "é˜¿é‡Œé›²ç™¾éŠ",
        OpenRouter: "OpenRouter",
        LMStudio: "LM Studio"
      }
    },
    defaultModel: {
      defaultModel: "è¨­å®šé è¨­æ¨¡å‹",
      defaultModelTipsOne: "é»æ“Šé è¨­æ¨¡å‹ï¼Œè·³è½‰åˆ°é è¨­æ¨¡å‹é é¢",
      topicNamingModel: "ä¸»é¡Œå‘½åæ¨¡å‹",
      topicNamingModelTips: "ç”¨æ–¼è‡ªå‹•å‘½åæ–°ä¸»é¡Œçš„æ¨¡å‹",
      emptymodelTips: "è«‹åœ¨æ¨¡å‹æœå‹™ä¸­å•Ÿç”¨ç›¸é—œå¹³å°",
      DefaultModelSetting: "é è¨­æ¨¡å‹è¨­å®š",
      defaultAssistantModel: "é è¨­åŠ©ç†æ¨¡å‹",
      assistantModelTips: "å‰µå»ºåŠ©ç†æ™‚ä½¿ç”¨çš„æ¨¡å‹",
      topicNamingModel: "ä¸»é¡Œå‘½åæ¨¡å‹",
      topicNamingModelTips: "ç”¨æ–¼è‡ªå‹•å‘½åæ–°ä¸»é¡Œçš„æ¨¡å‹",
      translationModel: "ç¿»è­¯æ¨¡å‹",
      translationModelTips: "ç”¨æ–¼ç¿»è­¯æœå‹™çš„æ¨¡å‹",
      browserUseModel: "ç€è¦½å™¨æœå‹™æ¨¡å‹",
      browserUseModelTips: "ç”¨æ–¼å…§å»ºç€è¦½å™¨ä½¿ç”¨çš„æ¨¡å‹ï¼Œå¿…é ˆæ”¯æ´å·¥å…·å’Œå‡½æ•¸èª¿ç”¨",
      saveSuccess: "è¨­å®šå„²å­˜æˆåŠŸ",
      assistantSettings: "åŠ©ç†è¨­å®š",
      confirm: "ç¢ºèª",
      cancel: "å–æ¶ˆ",
      assistantName: "åŠ©ç†åç¨±",
      assistantNamePlaceholder: "è«‹è¼¸å…¥åŠ©ç†åç¨±",
      prompt: "æç¤ºè©",
      promptPlaceholder: "è«‹è¼¸å…¥æç¤ºè©",
      modelParameters: "æ¨¡å‹åƒæ•¸",
      temperature: "æº«åº¦",
      topP: "Top P",
      maxTokens: "æœ€å¤§ä»¤ç‰Œæ•¸",
      enableLengthLimit: "å•Ÿç”¨é•·åº¦é™åˆ¶",
      topicNamingSettings: "ä¸»é¡Œå‘½åè¨­å®š",
      topicAutoNaming: "ä¸»é¡Œè‡ªå‹•å‘½å",
      topicNamingPrompt: "ä¸»é¡Œå‘½åæç¤ºè©",
      translationSettings: "ç¿»è­¯è¨­å®š",
      translationPrompt: "ç¿»è­¯æç¤ºè©"
    },
    searchService: {
      searchService: "è¨­å®šæœå°‹æœå‹™",
      searchServiceTipsOne: "é»æ“Šæœå°‹æœå‹™ï¼Œè·³è½‰åˆ°æœå°‹æœå‹™é é¢",
      searchEngineTipsOne: "ç¬¬ä¸€æ­¥ï¼šé¸æ“‡æœå°‹æœå‹™æä¾›å•†",
      searchEngineTipsTwo: "ç¬¬äºŒæ­¥ï¼šè¨­å®šè¼¸å…¥ API å¯†é‘°",
      title: "æœå°‹æœå‹™",
      blacklistSubscription: "é»‘åå–®è¨‚é–±",
      addSubscription: "æ–°å¢è¨‚é–±",
      updateNow: "ç«‹å³æ›´æ–°",
      deleteSubscription: "åˆªé™¤è¨‚é–±",
      confirm: "ç¢ºèª",
      cancel: "å–æ¶ˆ",
      subscriptionUrl: "è¨‚é–± URL",
      subscriptionUrlPlaceholder: "https://example/abcd",
      subscriptionName: "è¨‚é–±åç¨±",
      subscriptionNamePlaceholder: "ç•¶ä¸‹è¼‰çš„è¨‚é–±æºç„¡åç¨±æ™‚ä½¿ç”¨çš„æ›¿ä»£åç¨±",
      name: "åç¨±",
      url: "URL",
      addSubscriptionSuccess: "è¨‚é–±æ–°å¢æˆåŠŸ",
      deleteSubscriptionSuccess: "è¨‚é–±åˆªé™¤æˆåŠŸ",
      deleteSubscriptionFailed: "è¨‚é–±åˆªé™¤å¤±æ•—",
      saveConfigSuccess: "é…ç½®å„²å­˜æˆåŠŸ",
      saveConfigFailed: "é…ç½®å„²å­˜å¤±æ•—",
      loadConfigFailed: "è¼‰å…¥é…ç½®å¤±æ•—",
      formValidationFailed: "è¡¨å–®é©—è­‰å¤±æ•—",
      enterSubscriptionUrl: "è«‹è¼¸å…¥è¨‚é–± URL",
      invalidUrl: "è«‹è¼¸å…¥æœ‰æ•ˆ URL",
      enterSubscriptionName: "è«‹è¼¸å…¥è¨‚é–±åç¨±",
      noSubscriptionSelected: "æœªé¸æ“‡è¨‚é–±",
      searchProvider: "æœå°‹æä¾›å•†",
      generalSettings: "ä¸€èˆ¬è¨­å®š",
      includeDate: "åŒ…å«æ—¥æœŸ",
      includeServer: "åŒ…å«ä¼ºæœå™¨",
      searchEnhancement: "æœå°‹å¢å¼·",
      searchResultCount: "æœå°‹çµæœæ•¸é‡",
      default: "é è¨­",
      blacklist: "é»‘åå–®",
      blacklistTips: "è¼¸å…¥è¦å¾æœå°‹çµæœä¸­æ’é™¤çš„åŸŸå",
      blacklistPlaceholder: "æ¯è¡Œè¼¸å…¥ä¸€å€‹åŸŸå",
      save: "å„²å­˜",
      apiTips: "API é…ç½®",
      apiKeyPlaceholder: "è¼¸å…¥æ‚¨çš„ API å¯†é‘°",
      apiKey: "API å¯†é‘°",
      apiAddress: "API åœ°å€",
      tavilyName: "Tavilyï¼ˆå¯†é‘°ï¼‰",
      baiduName: "ç™¾åº¦ï¼ˆå…è²»ï¼‰",
      bingName: "å¿…æ‡‰ï¼ˆå…è²»ï¼‰",
      saveBlacklistSuccess: "é»‘åå–®å„²å­˜æˆåŠŸ",
      saveBlacklistFailed: "é»‘åå–®å„²å­˜å¤±æ•—"
    },
    mcpService: {
      title: "MCP æœå‹™",
      addServer: "æ–°å¢ä¼ºæœå™¨",
      save: "å„²å­˜",
      name: "åç¨±",
      namePlaceholder: "è«‹è¼¸å…¥åç¨±",
      description: "æè¿°",
      descriptionPlaceholder: "æè¿°",
      type: "é¡å‹",
      stdio: "æ¨™æº–è¼¸å…¥/è¼¸å‡º (stdio)",
      sse: "ä¼ºæœå™¨å‚³é€äº‹ä»¶ (sse)",
      streamableHttp: "å¯ä¸²æµå‚³è¼¸çš„ HTTP (streamableHttp)",
      command: "æŒ‡ä»¤",
      commandPlaceholder: "uvx æˆ– npx",
      packageSource: "å¥—ä»¶ä¾†æº",
      default: "é è¨­",
      taobaoNpmMirror: "æ·˜å¯¶ NPM é¡åƒ",
      tsinghua: "æ¸…è¯å¤§å­¸",
      aliyun: "é˜¿é‡Œé›²",
      ustc: "ä¸­åœ‹ç§‘å­¸æŠ€è¡“å¤§å­¸",
      huaweiCloud: "è¯ç‚ºé›²",
      tencentCloud: "é¨°è¨Šé›²",
      args: "åƒæ•¸",
      argsPlaceholder: "arg1\narg2",
      env: "ç’°å¢ƒè®Šæ•¸",
      envPlaceholder: "KEY1=VALUE1\nKEY2=VALUE2",
      mcpServer: "MCP ä¼ºæœå™¨"
    },
    experience: {
      title: "ç¶“é©—åº«",
      addExperience: "æ–°å¢ç¶“é©—",
      editExperience: "ç·¨è¼¯ç¶“é©—",
      close: "é—œé–‰",
      titleLabel: "æ¨™é¡Œ",
      titlePlaceholder: "ç¶“é©—æ¨™é¡Œ",
      goalLabel: "ç›®çš„",
      goalPlaceholder: "è©²ç¶“é©—çš„ç›®çš„",
      contentLabel: "å…§å®¹",
      contentPlaceholder: "ç¶“é©—å…§å®¹",
      statusLabel: "ç‹€æ…‹",
      enabled: "å·²å•Ÿç”¨",
      disabled: "å·²åœç”¨",
      cancel: "å–æ¶ˆ",
      save: "å„²å­˜",
      delete: "åˆªé™¤",
      undoChanges: "æ’¤éŠ·æ›´æ”¹",
      deleteExperience: "åˆªé™¤ç¶“é©—",
      deleteConfirm: "ä½ ç¢ºå®šè¦åˆªé™¤é€™æ¢ç¶“é©—å—ï¼Ÿ",
      totalExperience: "å…± {count} æ¢ç¶“é©—",
      tableTitle: "æ¨™é¡Œ",
      tableContent: "å…§å®¹",
      tableCreatedAt: "å‰µå»ºæ–¼",
      tableStatus: "ç‹€æ…‹",
      tableOperation: "æ“ä½œ",
      filterAll: "å…¨éƒ¨",
      deleteSuccess: "åˆªé™¤æˆåŠŸ",
      deleteFailed: "åˆªé™¤å¤±æ•—",
      createSuccess: "æ–°å¢ç¶“é©—æˆåŠŸ",
      createFailed: "æ–°å¢ç¶“é©—å¤±æ•—",
      updateSuccess: "æ›´æ–°æˆåŠŸ",
      updateFailed: "æ›´æ–°å¤±æ•—",
      updateFailedDataNotExist: "æ›´æ–°å¤±æ•—ï¼Œç•¶å‰è³‡æ–™ä¸å­˜åœ¨",
      getDataError: "ç²å–è³‡æ–™éŒ¯èª¤",
      detect: "æ„åœ–è­˜åˆ¥",
      plan: "ä»»å‹™è¦åŠƒ",
      action: "ä»»å‹™åŸ·è¡Œ",
      sunday: "æ˜ŸæœŸæ—¥",
      monday: "æ˜ŸæœŸä¸€",
      tuesday: "æ˜ŸæœŸäºŒ",
      wednesday: "æ˜ŸæœŸä¸‰",
      thursday: "æ˜ŸæœŸå››",
      friday: "æ˜ŸæœŸäº”",
      saturday: "æ˜ŸæœŸå…­",
      earlier: "æ›´æ—©"
    },
  },
  thinking: "æ€è€ƒä¸­",
  task_error: "ä»»å‹™ç•°å¸¸çµ‚æ­¢",
  stop_task: "å·²åœæ­¢ä»»å‹™",
  jump_to_result: "è·³è½‰åˆ°çµæœ",
  replay: "é‡æ’­",
  task_finished: "ä»»å‹™å®Œæˆ",
  task_playing: "ä»»å‹™é€²è¡Œä¸­",
  click_here_to_go_to_settings:  "é»æ“Šé€™è£¡é€²å…¥è¨­å®š",
}


================================================
FILE: frontend/src/locals/lang/vi.js
================================================
export default {
  auth: {
    loginToLemonAI: "ÄÄƒng nháº­p vÃ o LemonAI",
    registerLemonAIAccount: "ÄÄƒng kÃ½ tÃ i khoáº£n LemonAI",
    verifyEmail: "XÃ¡c minh email",
    resetPassword: "Äáº·t láº¡i máº­t kháº©u",
    loginWithGoogle: "ÄÄƒng nháº­p báº±ng Google",
    registerWithGoogle: "ÄÄƒng kÃ½ báº±ng Google",
    login: "ÄÄƒng nháº­p",
    register: "ÄÄƒng kÃ½",
    forgotPassword: "QuÃªn máº­t kháº©u?",
    resetPasswordButton: "Äáº·t láº¡i máº­t kháº©u",
    backToLogin: "Trá»Ÿ láº¡i Ä‘Äƒng nháº­p",
    verifyEmailButton: "XÃ¡c minh email",
    resendCode: "Gá»­i láº¡i mÃ£",
    email: "Email",
    password: "Máº­t kháº©u",
    fullname: "TÃªn Ä‘áº§y Ä‘á»§",
    codeSentTo: "MÃ£ Ä‘Ã£ gá»­i Ä‘áº¿n",
    pleaseInputEmail: "Vui lÃ²ng nháº­p email",
    pleaseInputValidEmail: "Vui lÃ²ng nháº­p email há»£p lá»‡",
    pleaseInputPassword: "Vui lÃ²ng nháº­p máº­t kháº©u",
    pleaseInputFullname: "Vui lÃ²ng nháº­p tÃªn Ä‘áº§y Ä‘á»§",
    pleaseInputVerifyCode: "Vui lÃ²ng nháº­p mÃ£ xÃ¡c minh",
    pleaseInputNewPassword: "Vui lÃ²ng nháº­p máº­t kháº©u má»›i",
    pleaseConfirmPassword: "Vui lÃ²ng xÃ¡c nháº­n máº­t kháº©u",
    pleaseInput6DigitCode: "Vui lÃ²ng nháº­p mÃ£ 6 chá»¯ sá»‘",
    or: "hoáº·c",
    noAccount: "KhÃ´ng cÃ³ tÃ i khoáº£n?",
    haveAccount: "Báº¡n Ä‘Ã£ cÃ³ tÃ i khoáº£n?",
    notReceivedCode: "ChÆ°a nháº­n Ä‘Æ°á»£c mÃ£?",
    codeSent: "MÃ£ Ä‘Ã£ Ä‘Æ°á»£c gá»­i",
    registrationSuccessful: "ÄÄƒng kÃ½ thÃ nh cÃ´ng, vui lÃ²ng Ä‘Äƒng nháº­p",
    verificationCodeError: "Lá»—i mÃ£ xÃ¡c minh, vui lÃ²ng thá»­ láº¡i",
    doNotSendFrequently: "Vui lÃ²ng khÃ´ng gá»­i mÃ£ xÃ¡c minh quÃ¡ thÆ°á»ng xuyÃªn",
    codeResent: "MÃ£ xÃ¡c minh Ä‘Ã£ Ä‘Æ°á»£c gá»­i láº¡i",
    loginSuccessful: "ÄÄƒng nháº­p thÃ nh cÃ´ng",
    loginFailed: "ÄÄƒng nháº­p tháº¥t báº¡i, vui lÃ²ng kiá»ƒm tra email vÃ  máº­t kháº©u",
    fillCompleteInfo: "Vui lÃ²ng Ä‘iá»n Ä‘áº§y Ä‘á»§ thÃ´ng tin Ä‘Äƒng kÃ½",
    pleaseEnterValidEmail: "Vui lÃ²ng nháº­p Ä‘á»‹a chá»‰ email há»£p lá»‡",
    passwordTooShort: "Äá»™ dÃ i máº­t kháº©u khÃ´ng Ä‘Æ°á»£c Ã­t hÆ¡n 6 kÃ½ tá»±",
    registrationFailed: "ÄÄƒng kÃ½ tháº¥t báº¡i, vui lÃ²ng kiá»ƒm tra Ä‘áº§u vÃ o",
    pleaseInputCode: "Vui lÃ²ng nháº­p mÃ£ xÃ¡c minh",
    passwordsDoNotMatch: "Máº­t kháº©u xÃ¡c nháº­n khÃ´ng khá»›p",
    passwordResetSuccessful: "Äáº·t láº¡i máº­t kháº©u thÃ nh cÃ´ng, vui lÃ²ng Ä‘Äƒng nháº­p",
    passwordResetFailed: "Äáº·t láº¡i máº­t kháº©u tháº¥t báº¡i, vui lÃ²ng kiá»ƒm tra Ä‘áº§u vÃ o",
    googleLoginFailed: "Chuyá»ƒn hÆ°á»›ng Ä‘Äƒng nháº­p Google tháº¥t báº¡i, vui lÃ²ng thá»­ láº¡i sau",
    appleLoginInProgress: "Chá»©c nÄƒng Ä‘Äƒng nháº­p Apple Ä‘ang phÃ¡t triá»ƒn",
    googleRegisterInProgress: "Chá»©c nÄƒng Ä‘Äƒng kÃ½ Google Ä‘ang phÃ¡t triá»ƒn",
    appleRegisterInProgress: "Chá»©c nÄƒng Ä‘Äƒng kÃ½ Apple Ä‘ang phÃ¡t triá»ƒn",
    verifyingGoogleLogin: "Äang xÃ¡c minh Ä‘Äƒng nháº­p Google"
  },

  //setting

  setting: {
    back: "Quay láº¡i",
    prevStep: "BÆ°á»›c trÆ°á»›c",
    nextStep: "BÆ°á»›c tiáº¿p theo",
    doneStep: "HoÃ n táº¥t",
    settingModel: "CÃ i Ä‘áº·t MÃ´ hÃ¬nh",
    settingModelTipsOne: "BÆ°á»›c 1: Chá»n MÃ´ hÃ¬nh",
    settingModelTipsTwo: "BÆ°á»›c 2: Nháº­p KhÃ³a API",
    settingModelTipsThree: "BÆ°á»›c 3: Báº­t MÃ´ hÃ¬nh",
    menu: {
      basic: "CÃ i Ä‘áº·t CÆ¡ báº£n",
      defaultModel: "MÃ´ hÃ¬nh Máº·c Ä‘á»‹nh",
      modelService: "Dá»‹ch vá»¥ MÃ´ hÃ¬nh",
      searchService: "Dá»‹ch vá»¥ TÃ¬m kiáº¿m",
      mcpService: "Dá»‹ch vá»¥ MCP"
    },
    basic: {
      title: "CÃ i Ä‘áº·t CÆ¡ báº£n",
      langTitle: "CÃ i Ä‘áº·t NgÃ´n ngá»¯",
      languagePreference: "TÃ¹y chá»n NgÃ´n ngá»¯",
      lang: {
        en: "Tiáº¿ng Anh",
        zh: "Tiáº¿ng Trung (Giáº£n thá»ƒ)",
        de: "Tiáº¿ng Äá»©c",
        es: "Tiáº¿ng TÃ¢y Ban Nha",
        fr: "Tiáº¿ng PhÃ¡p",
        ja: "Tiáº¿ng Nháº­t",
        kr: "Tiáº¿ng HÃ n",
        tr: "Tiáº¿ng Thá»• NhÄ© Ká»³",
        pt: "Tiáº¿ng Bá»“ ÄÃ o Nha",
        tw: "Tiáº¿ng Trung (Phá»“n thá»ƒ)",
        vi: "Tiáº¿ng Viá»‡t"
      }
    },
    modelService: {
      modelService: "Dá»‹ch vá»¥ MÃ´ hÃ¬nh",
      modelServiceTipsOne: "BÆ°á»›c 1: Chá»n NhÃ  cung cáº¥p Dá»‹ch vá»¥ MÃ´ hÃ¬nh",
      modelServiceTipsTwo: "BÆ°á»›c 2: Nháº­p KhÃ³a API",
      modelServiceTipsThree: "BÆ°á»›c 3: Báº­t Dá»‹ch vá»¥ MÃ´ hÃ¬nh",
      title: "Dá»‹ch vá»¥ MÃ´ hÃ¬nh",
      searchPlaceholder: "TÃ¬m kiáº¿m Ná»n táº£ng",
      defaultPlatform: "Ná»n táº£ng Há»‡ thá»‘ng Máº·c Ä‘á»‹nh",
      statusOn: "Báº¬T",
      addPlatform: "ThÃªm",
      save: "LÆ°u",
      defaultPlatformDescription: "CÃ¡c mÃ´ hÃ¬nh ná»n táº£ng máº·c Ä‘á»‹nh Ä‘Æ°á»£c cung cáº¥p bá»Ÿi há»‡ thá»‘ng, khÃ´ng cáº§n cáº¥u hÃ¬nh",
      apiKey: "KhÃ³a API",
      apiKeyPlaceholder: "Vui lÃ²ng nháº­p khÃ³a API",
      getApiKey: "Nháº¥p vÃ o Ä‘Ã¢y Ä‘á»ƒ láº¥y khÃ³a",
      check: "Kiá»ƒm tra",
      selectCheckModel: "Vui lÃ²ng chá»n mÃ´ hÃ¬nh kiá»ƒm tra",
      apiAddress: "Äá»‹a chá»‰ API",
      apiAddressPlaceholder: "Vui lÃ²ng nháº­p Ä‘á»‹a chá»‰ API",
      apiAddressTip: "/ á»Ÿ cuá»‘i bá» qua phiÃªn báº£n v1, # á»Ÿ cuá»‘i buá»™c sá»­ dá»¥ng Ä‘á»‹a chá»‰ Ä‘Ã£ nháº­p",
      activateTime: "Thá»i gian KÃ­ch hoáº¡t",
      activateTimePlaceholder: "Vui lÃ²ng nháº­p thá»i gian kÃ­ch hoáº¡t (phÃºt)",
      models: "MÃ´ hÃ¬nh",
      ungrouped: "KhÃ´ng Ä‘Æ°á»£c nhÃ³m",
      viewOfficialDocs: "Xem tÃ i liá»‡u chÃ­nh thá»©c cá»§a ná»n táº£ng Ä‘á»ƒ biáº¿t thÃªm thÃ´ng tin",
      add: "ThÃªm",
      confirmDeleteModel: "Báº¡n cÃ³ cháº¯c cháº¯n muá»‘n xÃ³a mÃ´ hÃ¬nh nÃ y khÃ´ng?",
      deleteModelSuccess: "MÃ´ hÃ¬nh Ä‘Ã£ Ä‘Æ°á»£c xÃ³a thÃ nh cÃ´ng",
      deleteModelFailed: "XÃ³a mÃ´ hÃ¬nh tháº¥t báº¡i",
      addModelSuccess: "MÃ´ hÃ¬nh Ä‘Ã£ Ä‘Æ°á»£c thÃªm thÃ nh cÃ´ng",
      updateModelSuccess: "MÃ´ hÃ¬nh Ä‘Ã£ Ä‘Æ°á»£c cáº­p nháº­t thÃ nh cÃ´ng",
      copySuccess: "TÃªn Ä‘Ã£ Ä‘Æ°á»£c sao chÃ©p",
      typeVision: "Táº§m nhÃ¬n",
      typeNetwork: "Máº¡ng",
      typeEmbed: "NhÃºng",
      typeReasoning: "Suy luáº­n",
      typeTool: "CÃ´ng cá»¥",
      addProvider: "ThÃªm NhÃ  cung cáº¥p",
      confirm: "XÃ¡c nháº­n",
      cancel: "Há»§y",
      platformLogo: "Logo Ná»n táº£ng",
      providerName: "TÃªn NhÃ  cung cáº¥p",
      namePlaceholder: "TÃªn",
      providerType: "Loáº¡i NhÃ  cung cáº¥p",
      typePlaceholder: "Loáº¡i",
      enterName: "Vui lÃ²ng nháº­p tÃªn",
      selectType: "Vui lÃ²ng chá»n loáº¡i",
      addPlatformSuccess: "Ná»n táº£ng Ä‘Ã£ Ä‘Æ°á»£c thÃªm thÃ nh cÃ´ng",
      formValidationFailed: "XÃ¡c thá»±c biá»ƒu máº«u tháº¥t báº¡i",
      addModel: "ThÃªm MÃ´ hÃ¬nh",
      editModel: "Chá»‰nh sá»­a MÃ´ hÃ¬nh",
      modelId: "ID MÃ´ hÃ¬nh",
      modelIdPlaceholder: "Vui lÃ²ng nháº­p ID mÃ´ hÃ¬nh",
      modelName: "TÃªn MÃ´ hÃ¬nh",
      modelNamePlaceholder: "TÃªn mÃ´ hÃ¬nh",
      groupName: "TÃªn NhÃ³m",
      groupNamePlaceholder: "TÃªn nhÃ³m",
      modelTypes: "Loáº¡i MÃ´ hÃ¬nh",
      enterModelId: "Vui lÃ²ng nháº­p ID mÃ´ hÃ¬nh",
      enterModelName: "Vui lÃ²ng nháº­p tÃªn mÃ´ hÃ¬nh",
      enterGroupName: "Vui lÃ²ng nháº­p tÃªn nhÃ³m",
      selectModelType: "Vui lÃ²ng chá»n Ã­t nháº¥t má»™t loáº¡i mÃ´ hÃ¬nh",
      editProvider: "Chá»‰nh sá»­a NhÃ  cung cáº¥p",
      updatePlatformSuccess: "Ná»n táº£ng Ä‘Ã£ Ä‘Æ°á»£c cáº­p nháº­t thÃ nh cÃ´ng",
      deletePlatformSuccess: "Ná»n táº£ng Ä‘Ã£ Ä‘Æ°á»£c xÃ³a thÃ nh cÃ´ng",
      deletePlatformFailed: "XÃ³a ná»n táº£ng tháº¥t báº¡i",
      saveSuccess: "LÆ°u thÃ nh cÃ´ng",
      saveFailed: "LÆ°u tháº¥t báº¡i"
    },
    defaultModel: {
      defaultModel: "CÃ i Ä‘áº·t MÃ´ hÃ¬nh Máº·c Ä‘á»‹nh",
      defaultModelTipsOne: "BÆ°á»›c 1: Chá»n MÃ´ hÃ¬nh Máº·c Ä‘á»‹nh",
      topicNamingModel: "MÃ´ hÃ¬nh Äáº·t tÃªn Chá»§ Ä‘á»",
      topicNamingModelTips: "MÃ´ hÃ¬nh Ä‘Æ°á»£c sá»­ dá»¥ng Ä‘á»ƒ tá»± Ä‘á»™ng Ä‘áº·t tÃªn cho cÃ¡c chá»§ Ä‘á» má»›i",
      emptymodelTips: "Vui lÃ²ng báº­t ná»n táº£ng liÃªn quan trong Dá»‹ch vá»¥ MÃ´ hÃ¬nh",
      DefaultModelSetting: "CÃ i Ä‘áº·t MÃ´ hÃ¬nh Máº·c Ä‘á»‹nh",
      defaultAssistantModel: "MÃ´ hÃ¬nh Trá»£ lÃ½ Máº·c Ä‘á»‹nh",
      assistantModelTips: "MÃ´ hÃ¬nh Ä‘Æ°á»£c sá»­ dá»¥ng khi táº¡o trá»£ lÃ½",
      topicNamingModel: "MÃ´ hÃ¬nh Äáº·t tÃªn Chá»§ Ä‘á»",
      topicNamingModelTips: "MÃ´ hÃ¬nh Ä‘Æ°á»£c sá»­ dá»¥ng Ä‘á»ƒ tá»± Ä‘á»™ng Ä‘áº·t tÃªn cho cÃ¡c chá»§ Ä‘á» má»›i",
      translationModel: "MÃ´ hÃ¬nh Dá»‹ch thuáº­t",
      translationModelTips: "MÃ´ hÃ¬nh Ä‘Æ°á»£c sá»­ dá»¥ng cho cÃ¡c dá»‹ch vá»¥ dá»‹ch thuáº­t",
      saveSuccess: "CÃ i Ä‘áº·t Ä‘Ã£ Ä‘Æ°á»£c lÆ°u thÃ nh cÃ´ng",
      assistantSettings: "CÃ i Ä‘áº·t Trá»£ lÃ½",
      confirm: "XÃ¡c nháº­n",
      cancel: "Há»§y",
      assistantName: "TÃªn Trá»£ lÃ½",
      assistantNamePlaceholder: "Vui lÃ²ng nháº­p tÃªn trá»£ lÃ½",
      prompt: "Lá»i nháº¯c",
      promptPlaceholder: "Vui lÃ²ng nháº­p lá»i nháº¯c",
      modelParameters: "Tham sá»‘ MÃ´ hÃ¬nh",
      temperature: "Nhiá»‡t Ä‘á»™",
      topP: "Top P",
      maxTokens: "Sá»‘ Token Tá»‘i Ä‘a",
      enableLengthLimit: "KÃ­ch hoáº¡t Giá»›i háº¡n Äá»™ dÃ i",
      topicNamingSettings: "CÃ i Ä‘áº·t Äáº·t tÃªn Chá»§ Ä‘á»",
      topicAutoNaming: "Äáº·t tÃªn Chá»§ Ä‘á» Tá»± Ä‘á»™ng",
      topicNamingPrompt: "Lá»i nháº¯c Äáº·t tÃªn Chá»§ Ä‘á»",
      translationSettings: "CÃ i Ä‘áº·t Dá»‹ch thuáº­t",
      translationPrompt: "Lá»i nháº¯c Dá»‹ch thuáº­t"
    },
    searchService: {
      searchService: "CÃ i Ä‘áº·t Dá»‹ch vá»¥ TÃ¬m kiáº¿m",
      searchServiceTipsOne: "Nháº¥p vÃ o dá»‹ch vá»¥ tÃ¬m kiáº¿m, chuyá»ƒn Ä‘áº¿n trang dá»‹ch vá»¥ tÃ¬m kiáº¿m",
      searchEngineTipsOne: "BÆ°á»›c 1: Chá»n NhÃ  cung cáº¥p Dá»‹ch vá»¥ TÃ¬m kiáº¿m",
      searchEngineTipsTwo: "BÆ°á»›c 2: Nháº­p KhÃ³a API",
      title: "Dá»‹ch vá»¥ TÃ¬m kiáº¿m",
      searchProvider: "NhÃ  cung cáº¥p Dá»‹ch vá»¥ TÃ¬m kiáº¿m",
      generalSettings: "CÃ i Ä‘áº·t Chung",
      includeDate: "Bao gá»“m NgÃ y trong TÃ¬m kiáº¿m",
      includeServer: "Bao gá»“m TÃ¬m kiáº¿m NhÃ  cung cáº¥p",
      searchEnhancement: "Cháº¿ Ä‘á»™ TÄƒng cÆ°á»ng TÃ¬m kiáº¿m",
      searchResultCount: "Sá»‘ lÆ°á»£ng Káº¿t quáº£ TÃ¬m kiáº¿m",
      default: "Máº·c Ä‘á»‹nh",
      blacklist: "Danh sÃ¡ch Äen",
      blacklistTips: "CÃ¡c káº¿t quáº£ sau sáº½ khÃ´ng xuáº¥t hiá»‡n trong káº¿t quáº£ tÃ¬m kiáº¿m",
      blacklistPlaceholder: "Vui lÃ²ng sá»­ dá»¥ng Ä‘á»‹nh dáº¡ng sau (phÃ¢n tÃ¡ch báº±ng dÃ²ng má»›i)\nMáº«u khá»›p: *://*.example.com/*\nBiá»ƒu thá»©c chÃ­nh quy: /example\\.(net|org)/",
      save: "LÆ°u",
      blacklistSubscription: "ÄÄƒng kÃ½ Danh sÃ¡ch Äen",
      addSubscription: "ThÃªm ÄÄƒng kÃ½",
      updateNow: "Cáº­p nháº­t Ngay",
      deleteSubscription: "XÃ³a ÄÄƒng kÃ½",
      confirm: "XÃ¡c nháº­n",
      cancel: "Há»§y",
      subscriptionUrl: "URL ÄÄƒng kÃ½",
      subscriptionUrlPlaceholder: "https://example/abcd",
      subscriptionName: "TÃªn ÄÄƒng kÃ½",
      subscriptionNamePlaceholder: "TÃªn thay tháº¿ Ä‘Æ°á»£c sá»­ dá»¥ng khi nguá»“n Ä‘Äƒng kÃ½ táº£i xuá»‘ng khÃ´ng cÃ³ tÃªn",
      name: "TÃªn",
      url: "URL",
      apiKey: "KhÃ³a API",
      apiAddress: "Äá»‹a chá»‰ API",
      saveBlacklistSuccess: "Danh sÃ¡ch Ä‘en Ä‘Ã£ Ä‘Æ°á»£c lÆ°u thÃ nh cÃ´ng",
      saveBlacklistFailed: "LÆ°u danh sÃ¡ch Ä‘en tháº¥t báº¡i",
      addSubscriptionSuccess: "ÄÄƒng kÃ½ Ä‘Ã£ Ä‘Æ°á»£c thÃªm thÃ nh cÃ´ng",
      deleteSubscriptionSuccess: "ÄÄƒng kÃ½ Ä‘Ã£ Ä‘Æ°á»£c xÃ³a thÃ nh cÃ´ng",
      deleteSubscriptionFailed: "XÃ³a Ä‘Äƒng kÃ½ tháº¥t báº¡i",
      saveConfigSuccess: "Cáº¥u hÃ¬nh Ä‘Ã£ Ä‘Æ°á»£c lÆ°u thÃ nh cÃ´ng",
      saveConfigFailed: "LÆ°u cáº¥u hÃ¬nh tháº¥t báº¡i",
      loadConfigFailed: "Táº£i cáº¥u hÃ¬nh tháº¥t báº¡i",
      formValidationFailed: "XÃ¡c thá»±c biá»ƒu máº«u tháº¥t báº¡i",
      enterSubscriptionUrl: "Vui lÃ²ng nháº­p URL Ä‘Äƒng kÃ½",
      invalidUrl: "Vui lÃ²ng nháº­p URL há»£p lá»‡",
      enterSubscriptionName: "Vui lÃ²ng nháº­p tÃªn Ä‘Äƒng kÃ½",
      noSubscriptionSelected: "KhÃ´ng cÃ³ Ä‘Äƒng kÃ½ nÃ o Ä‘Æ°á»£c chá»n"
    },
    mcpService: {
      title: "Dá»‹ch vá»¥ MCP",
      addServer: "ThÃªm MÃ¡y chá»§",
      save: "LÆ°u",
      name: "TÃªn",
      namePlaceholder: "Vui lÃ²ng nháº­p tÃªn",
      description: "MÃ´ táº£",
      descriptionPlaceholder: "MÃ´ táº£",
      type: "Loáº¡i",
      stdio: "Äáº§u vÃ o/Äáº§u ra Chuáº©n (stdio)",
      sse: "Sá»± kiá»‡n Gá»­i tá»« MÃ¡y chá»§ (sse)",
      streamableHttp: "HTTP CÃ³ thá»ƒ PhÃ¡t trá»±c tuyáº¿n (streamableHttp)",
      command: "Lá»‡nh",
      commandPlaceholder: "uvx hoáº·c npx",
      packageSource: "Nguá»“n GÃ³i",
      default: "Máº·c Ä‘á»‹nh",
      taobaoNpmMirror: "GÆ°Æ¡ng NPM Taobao",
      tsinghua: "Äáº¡i há»c Thanh Hoa",
      aliyun: "Aliyun",
      ustc: "Äáº¡i há»c Khoa há»c vÃ  CÃ´ng nghá»‡ Trung Quá»‘c",
      huaweiCloud: "Huawei Cloud",
      tencentCloud: "Tencent Cloud",
      args: "Tham sá»‘",
      argsPlaceholder: "arg1\narg2",
      env: "Biáº¿n MÃ´i trÆ°á»ng",
      envPlaceholder: "KEY1=VALUE1\nKEY2=VALUE2",
      mcpServer: "MÃ¡y chá»§ MCP"
    },
  },
  thinking: "Äang suy nghÄ©",
  task_error: "Lá»—i nhiá»‡m vá»¥",
  stop_task: "ÄÃ£ dá»«ng nhiá»‡m vá»¥",
  jump_to_result: "Chuyá»ƒn Ä‘áº¿n káº¿t quáº£",
  replay: "Xem láº¡i",
  task_finished: "Nhiá»‡m vá»¥ hoÃ n táº¥t",
  task_playing: "Äang cháº¡y nhiá»‡m vá»¥",
  click_here_to_go_to_settings: "Nháº¥n vÃ o Ä‘Ã¢y Ä‘á»ƒ chuyá»ƒn Ä‘áº¿n cÃ i Ä‘áº·t"
}


================================================
FILE: frontend/src/locals/lang/zh.js
================================================
export default {
  // é€šç”¨
  common: {
    cancel: "å–æ¶ˆ",
  },
  //ç™»å½•ç•Œé¢
  account: {
    usernameLabel: 'ç”¨æˆ·åï¼š',
    edit: 'ç¼–è¾‘',
    passwordLabel: 'å¯†ç ',
    resetPassword: 'é‡ç½®å¯†ç ',
    editUsernameTitle: 'ç¼–è¾‘ç”¨æˆ·å',
    newUsernamePlaceholder: 'è¯·è¾“å…¥æ–°ç”¨æˆ·å',
    cancel: 'å–æ¶ˆ',
    save: 'ä¿å­˜',
    resetPasswordTitle: 'é‡ç½®å¯†ç ',
    newPasswordPlaceholder: 'è¯·è¾“å…¥å¯†ç ',
    updateSuccess: 'æ›´æ–°æˆåŠŸ',
    ordersTitle: 'è®¢å•',
    table: {
      orderId: 'è®¢å•ç¼–å·',
      orderAmount: 'è®¢å•é‡‘é¢',
      time: 'æ—¶é—´',
      status: 'è®¢å•çŠ¶æ€',
    },
    orderStatus: {
      pending: 'å¾…æ”¯ä»˜',
      paid: 'å·²æ”¯ä»˜',
      cancelled: 'å·²å–æ¶ˆ',
      failed: 'æ”¯ä»˜å¤±è´¥',
      unknown: 'æœªçŸ¥',
    },
  },
  auth: {
    loginToLemonAI: "ç™»å½• LemonAI",
    registerLemonAIAccount: "æ³¨å†Œ LemonAI è´¦æˆ·",
    verifyEmail: "éªŒè¯é‚®ç®±",
    resetPassword: "é‡ç½®å¯†ç ",
    loginWithGoogle: "ä½¿ç”¨ Google ç™»å½•",
    registerWithGoogle: "ä½¿ç”¨ Google æ³¨å†Œ",
    login: "ç™»å½•",
    register: "æ³¨å†Œ",
    logOut: "é€€å‡ºç™»å½•",
    forgotPassword: "å¿˜è®°å¯†ç ",
    resetPasswordButton: "é‡ç½®å¯†ç ",
    backToLogin: "è¿”å›ç™»å½•",
    verifyEmailButton: "éªŒè¯é‚®ç®±",
    resendCode: "é‡æ–°å‘é€éªŒè¯ç ",
    email: "é‚®ç®±",
    password: "å¯†ç ",
    fullname: "å…¨å",
    codeSentTo: "éªŒè¯ç å·²å‘é€è‡³",
    pleaseInputEmail: "è¯·è¾“å…¥é‚®ç®±",
    smsCode: "çŸ­ä¿¡éªŒè¯ç ",
    sendCode: "å‘é€éªŒè¯ç ",
    pleaseInputSMSCode: "è¯·è¾“å…¥çŸ­ä¿¡éªŒè¯ç ",
    pleaseInputValidEmail: "è¯·è¾“å…¥æœ‰æ•ˆçš„é‚®ç®±",
    pleaseInputValidPassword: "è¯·è¾“å…¥æœ‰æ•ˆçš„å¯†ç ",
    pleaseInputFullname: "è¯·è¾“å…¥å…¨å",
    pleaseInputVerifyCode: "è¯·è¾“å…¥éªŒè¯ç ",
    pleaseInputNewPassword: "è¯·è¾“å…¥æ–°å¯†ç ",
    pleaseConfirmPassword: "è¯·ç¡®è®¤å¯†ç ",
    pleaseInput6DigitCode: "è¯·è¾“å…¥ 6 ä½éªŒè¯ç ",
    or: "æˆ–",
    noAccount: "æ²¡æœ‰è´¦æˆ·ï¼Ÿ",
    keepOffline: "ä¿æŒç¦»çº¿",
    haveAccount: "å·²æœ‰è´¦æˆ·ï¼Ÿ",
    notReceivedCode: "æœªæ”¶åˆ°éªŒè¯ç ï¼Ÿ",
    codeSent: "éªŒè¯ç å·²å‘é€",
    registrationSuccessful: "æ³¨å†ŒæˆåŠŸï¼Œè¯·ç™»å½•",
    verificationCodeError: "éªŒè¯ç é”™è¯¯ï¼Œè¯·é‡è¯•",
    doNotSendFrequently: "è¯·å‹¿é¢‘ç¹å‘é€éªŒè¯ç ",
    codeResent: "éªŒè¯ç å·²é‡æ–°å‘é€",
    loginSuccessful: "ç™»å½•æˆåŠŸ",
    loginFailed: "ç™»å½•å¤±è´¥ï¼Œè¯·æ£€æŸ¥é‚®ç®±å’Œå¯†ç ",
    fillCompleteInfo: "è¯·å¡«å†™å®Œæ•´çš„æ³¨å†Œä¿¡æ¯",
    pleaseEnterValidEmail: "è¯·è¾“å…¥æœ‰æ•ˆçš„é‚®ç®±åœ°å€",
    passwordTooShort: "å¯†ç é•¿åº¦ä¸èƒ½å°‘äº 6 ä¸ªå­—ç¬¦",
    registrationFailed: "æ³¨å†Œå¤±è´¥ï¼Œè¯·æ£€æŸ¥è¾“å…¥",
    pleaseInputCode: "è¯·è¾“å…¥éªŒè¯ç ",
    passwordsDoNotMatch: "ç¡®è®¤å¯†ç ä¸åŒ¹é…",
    passwordResetSuccessful: "å¯†ç é‡ç½®æˆåŠŸï¼Œè¯·ç™»å½•",
    passwordResetFailed: "å¯†ç é‡ç½®å¤±è´¥ï¼Œè¯·æ£€æŸ¥è¾“å…¥",
    googleLoginFailed: "Google ç™»å½•è·³è½¬å¤±è´¥ï¼Œè¯·ç¨åå†è¯•",
    appleLoginInProgress: "Apple ç™»å½•åŠŸèƒ½æ­£åœ¨å¼€å‘ä¸­",
    googleRegisterInProgress: "Google æ³¨å†ŒåŠŸèƒ½æ­£åœ¨å¼€å‘ä¸­",
    appleRegisterInProgress: "Apple æ³¨å†ŒåŠŸèƒ½æ­£åœ¨å¼€å‘ä¸­",
    verifyingGoogleLogin: "æ­£åœ¨éªŒè¯ Google ç™»å½•",
    loginWithPhone: "ä½¿ç”¨æ‰‹æœºå·ç™»å½•",
    verifyCode: "éªŒè¯ç ",
    smsCode: "çŸ­ä¿¡éªŒè¯ç ",
    sendCode: "å‘é€éªŒè¯ç ",
    phone: "æ‰‹æœºå·",
    pleaseInputValidPhone: "è¯·è¾“å…¥æœ‰æ•ˆçš„æ‰‹æœºå·",
    pleaseInputPassword: "è¯·è¾“å…¥å¯†ç ",
    pleaseInputSMSCode: "è¯·è¾“å…¥çŸ­ä¿¡éªŒè¯ç ",
    confirmPassword: "ç¡®è®¤å¯†ç ",
    pleaseInputPhone: "è¯·è¾“å…¥æ‰‹æœºå·",
    keepOffline: "ä¿æŒç¦»çº¿",
    otherLogin: "é€‰æ‹©å…¶ä»–ç™»å½•æ–¹å¼",
    subscribeModel: "æ‚¨å½“å‰é€‰æ‹©æ˜¯è®¢é˜…æ¨¡å‹ï¼Œè¯·å‰å¾€ç™»å½•åä½¿ç”¨ æˆ– é€‰æ‹©å…¶å®ƒæ¨¡å‹",
    //æ‚¨å½“å‰é€‰æ‹©æœç´¢æœåŠ¡æ˜¯è®¢é˜…æœåŠ¡ï¼Œè¯·å‰å¾€ç™»å½•åä½¿ç”¨ æˆ– é€‰æ‹©å…¶å®ƒæœåŠ¡
    subscribeService: "æ‚¨é€‰æ‹©çš„æœç´¢æœåŠ¡å±äºè®¢é˜…æœåŠ¡ï¼Œè¯·ç™»å½•åä½¿ç”¨ï¼Œæˆ–æ›´æ¢ä¸ºå…¶ä»–æœåŠ¡",
    insufficientPoints: "ç§¯åˆ†ä¸è¶³",
    insufficientPointsPleaseGoToUpgradeOrPurchase: "æ‚¨æ­£åœ¨ä½¿ç”¨è®¢é˜…æ¨¡å‹æˆ–è®¢é˜…æœç´¢æœåŠ¡ï¼Œä½†å½“å‰ç§¯åˆ†ä¸è¶³ï¼Œè¯·å‰å¾€å‡çº§æˆ–è´­ä¹°",
  },
  //ä¼šå‘˜
  member: {
    selectPaymentMethod: "é€‰æ‹©æ”¯ä»˜æ–¹å¼",
    payWithCard: "ä½¿ç”¨é“¶è¡Œå¡ / Stripe æ”¯ä»˜",
    payWithWeChat: "ä½¿ç”¨å¾®ä¿¡æ”¯ä»˜",
    freePlan: 'å…è´¹',
    expirationDate: 'åˆ°æœŸæ—¶é—´ï¼š',
    upgrade: 'å‡çº§',
    purchasePoints: 'è´­ä¹°ç§¯åˆ†',
    points: 'ç§¯åˆ†',
    pointsUnit: 'ç§¯åˆ†',
    pointsUsageHistory: 'ç§¯åˆ†ä½¿ç”¨è®°å½•',
    noPackagesAvailable: 'æš‚æ— å¯ç”¨çš„ç§¯åˆ†å¥—é¤',
    buyNow: 'ç«‹å³è´­ä¹°',
    wechatScanToPay: 'å¾®ä¿¡æ‰«ç æ”¯ä»˜',
    wechatScanPrompt: 'è¯·ä½¿ç”¨å¾®ä¿¡æ‰«ç å®Œæˆæ”¯ä»˜',
    paymentSuccess: 'æ”¯ä»˜æˆåŠŸï¼',
    paymentTimeout: 'æ”¯ä»˜è¶…æ—¶ï¼Œè¯·é‡æ–°ä¸‹å•',
    qrCodeGenerationFailed: 'ç”ŸæˆäºŒç»´ç å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•',
    pointsType: {
      free: 'å…è´¹ç§¯åˆ†',
      monthly: 'æœˆåº¦ç§¯åˆ†',
      purchasedAddon: 'è´­ä¹°é™„åŠ ç§¯åˆ†',
      giftedAddon: 'èµ é€é™„åŠ ç§¯åˆ†',
      feedbackAddon: 'åé¦ˆçš„é™„åŠ ç§¯åˆ†',
    },
    table: {
      details: 'è¯¦æƒ…',
      time: 'æ—¶é—´',
      pointsChange: 'ç§¯åˆ†å˜åŠ¨',
      conversation_title: 'æ ‡é¢˜',
    },
    pricing: "å®šä»·",
    mostPopular: "æœ€å—æ¬¢è¿",
    recommended: "æ¨è",
    discount: "æŠ˜æ‰£",
    annual: "å¹´ä»˜",
    points: "ç§¯åˆ†",
    month: "æœˆ",
    select: "é€‰æ‹©",
    paySuccess: "æ”¯ä»˜æˆåŠŸï¼",
    payFailed: "æ”¯ä»˜å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•",
    payCancel: "æ”¯ä»˜å–æ¶ˆ",
    payTimeout: "æ”¯ä»˜è¶…æ—¶ï¼Œè¯·é‡æ–°ä¸‹å•",
    qrTitle: "å¾®ä¿¡æ‰«ç æ”¯ä»˜",
    qrTip: "è¯·ä½¿ç”¨å¾®ä¿¡æ‰«ç å®Œæˆæ”¯ä»˜",
    billingMonthly: "æœˆä»˜",
    billingYearly: "å¹´ä»˜",
    qrError: "ç”ŸæˆäºŒç»´ç å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•",
    noPlanForBilling: "æš‚æ— è¯¥è®¡è´¹æ–¹å¼çš„äº§å“",
    alreadyCurrentMember: "å·²å¼€é€šè¯¥ä¼šå‘˜",
    loadPlansFailed: "åŠ è½½å¥—é¤å¤±è´¥",
    cancelMembership: "å–æ¶ˆè®¢é˜…",
    confirmCancelTitle: "ç¡®è®¤å–æ¶ˆ",
    cancelDowngrade: "å–æ¶ˆé™çº§",
    unavailable: "ä¸å¯ç”¨",
    reactivatePlan: "é‡æ–°æ¿€æ´»å¥—é¤",
    upgradeTo: "å‡çº§è‡³",
    downgradeTo: "é™çº§è‡³",
    save: "èŠ‚çœ",
    year: "å¹´",
    monthlyBilling: "/ æœˆ",
    yearlyBilling: "/ å¹´",
    confirmUpgrade: "ç¡®è®¤å‡çº§",
    cancel: "å–æ¶ˆ",
    confirmDowngrade: "ç¡®è®¤é™çº§",
    confirmDowngradeMessage: "æ‚¨ç¡®å®šè¦ä»",
    to: "é™çº§è‡³",
    effectAtPeriodEnd: "æ­¤æ›´æ”¹å°†åœ¨å½“å‰è®¡è´¹å‘¨æœŸç»“æŸæ—¶ç”Ÿæ•ˆ",
    upgradePreviewTitle: "å‡çº§é¢„è§ˆ",
    upgradeSummary: "å‡çº§æ‘˜è¦",
    from: "ä»ï¼š",
    paymentRequired: "éœ€è¦æ”¯ä»˜",
    upgradePrice: "å‡çº§ä»·æ ¼ï¼š",
    confirmCancelMessage: "æ‚¨ç¡®å®šè¦å–æ¶ˆè®¢é˜…å—ï¼Ÿ",
    confirm: "ç¡®è®¤",
    downgradeNotice: "æ‚¨çš„ {planName} ä¼šå‘˜å°†åœ¨ {date} é™çº§è‡³ {targetPlan}ã€‚",
    reactivateSuccess: "é‡æ–°æ¿€æ´»è®¢é˜…æˆåŠŸ",
    cancelDowngradeSuccess: "å–æ¶ˆé™çº§æˆåŠŸ",
    cancelDowngradeFailed: "å–æ¶ˆé™çº§å¤±è´¥ã€‚è¯·é‡è¯•ã€‚",
    downgradeScheduledSuccess: "é™çº§è®¡åˆ’æˆåŠŸï¼",
    downgradeNotSupported: "æŠ±æ­‰ï¼Œæš‚ä¸æ”¯æŒå¾®ä¿¡æ”¯ä»˜çš„é™çº§ã€‚",
    downgradeFailed: "é™çº§å¤±è´¥ã€‚è¯·é‡è¯•ã€‚",
    cancelPleaseFirst: "åœ¨å¯¹è®¢é˜…è¿›è¡Œä»»ä½•æ›´æ”¹ä¹‹å‰ï¼Œè¯·å…ˆå–æ¶ˆé™çº§ã€‚",
    processingUpgrade: "æ­£åœ¨å¤„ç†å‡çº§æ”¯ä»˜...",
    upgradeSuccessful: "å‡çº§æˆåŠŸï¼",
    upgradeFailed: "å‡çº§å¤±è´¥ã€‚è¯·é‡è¯•ã€‚",
    upgradePreviewFailed: "åŠ è½½å‡çº§é¢„è§ˆå¤±è´¥ã€‚è¯·é‡è¯•ã€‚",
    switchNotSupported: "æš‚ä¸æ”¯æŒä»å¹´ä»˜å¥—é¤åˆ‡æ¢åˆ°æœˆä»˜å¥—é¤ã€‚",
    wechatDowngradeNotSupported: "å¾®ä¿¡æ”¯ä»˜è´­ä¹°çš„ä¼šå‘˜ä¸æ”¯æŒé™çº§ã€‚",
    platformNotSupported: "å¹³å°ç›®å‰ä¸æ”¯æŒå‡çº§/é™çº§æ“ä½œã€‚",
    paymentFailed: "æ”¯ä»˜å¤±è´¥",
    upgradeTimeoutWarning: "å‡çº§æ”¯ä»˜è¶…æ—¶ã€‚è¯·æ£€æŸ¥æ‚¨çš„æ”¯ä»˜çŠ¶æ€ã€‚",
    upgradeStatusCheckFailed: "æ£€æŸ¥å‡çº§çŠ¶æ€å¤±è´¥ã€‚",
    getSubscriptionFailed: "å‡çº§å¤±è´¥ã€‚æ— æ³•è·å–è®¢é˜…ä¿¡æ¯ã€‚",
    upgradePaymentFailed: "å‡çº§æ”¯ä»˜å¤±è´¥",
    iUnderstand: "æˆ‘æ˜ç™½äº†",
    whatYouCanDo: "æ‚¨å¯ä»¥ï¼š",
    insufficientFunds: "å‡çº§å¤±è´¥ï¼šä½™é¢ä¸è¶³ã€‚è¯·æ£€æŸ¥æ‚¨çš„å¡ä½™é¢å¹¶é‡è¯•ã€‚",
    cardDeclined: "å‡çº§å¤±è´¥ï¼šé“¶è¡Œå¡è¢«æ‹’ç»ã€‚è¯·è”ç³»æ‚¨çš„é“¶è¡Œæˆ–å°è¯•å…¶ä»–æ”¯ä»˜æ–¹å¼ã€‚",
    authenticationRequired: "å‡çº§å¤±è´¥ï¼šéœ€è¦èº«ä»½éªŒè¯ã€‚è¯·å®Œæˆ 3D Secure éªŒè¯ã€‚",
    expiredCard: "å‡çº§å¤±è´¥ï¼šé“¶è¡Œå¡å·²è¿‡æœŸã€‚è¯·æ›´æ–°æ‚¨çš„æ”¯ä»˜æ–¹å¼ã€‚",
    paymentMethodIssue: "å‡çº§å¤±è´¥ï¼šæ£€æµ‹åˆ°æ”¯ä»˜æ–¹å¼é—®é¢˜ã€‚",
    invoiceUnpaid: "å‡çº§å¤±è´¥ï¼šå‘ç¥¨æœªæ”¯ä»˜ã€‚",
    contactSupport: "å‡çº§å¤±è´¥ã€‚è¯·é‡è¯•æˆ–è”ç³»æ”¯æŒã€‚",
    cancelMembershipSuccess: "å–æ¶ˆè®¢é˜…æˆåŠŸ",
    benefits: {
      free: {
        newUserCredits: "æ–°ç”¨æˆ·èµ é€ 1,000 ç§¯åˆ†",
        dailyCredits: "æ¯æ—¥ 0 ç§¯åˆ†",
        publicAgentsOnly: "ä»…é™å…¬å¼€ Agents",
        systemExperienceInvisible: "ç³»ç»Ÿä½“éªŒä¸å¯è§",
        limitedChat: "å¯¹è¯ä¸­é™åˆ¶ä½¿ç”¨é«˜çº§æ¨¡å‹",
        limitedAgent: "Agent ä¸­é™åˆ¶ä½¿ç”¨é«˜çº§æ¨¡å‹",
      },
      pro: {
        monthlyCredits: "æ¯æœˆ 19,000 ç§¯åˆ†",
        dailyCredits: "æ¯æ—¥ 1,000 ç§¯åˆ†ï¼ˆæœ€é«˜ 30,000/æœˆï¼‰",
        privateAgents: "ç§æœ‰ Agents",
        systemExperienceEditable: "ç³»ç»Ÿä½“éªŒå¯ç¼–è¾‘",
        unlimitedChat: "å¯¹è¯ä¸­æ— é™ä½¿ç”¨é«˜çº§æ¨¡å‹",
        unlimitedAgent: "Agent ä¸­æ— é™ä½¿ç”¨é«˜çº§æ¨¡å‹",
      },
      business: {
        monthlyCredits: "æ¯æœˆ 99,000 ç§¯åˆ†",
        dailyCredits: "æ¯æ—¥ 1,000 ç§¯åˆ†ï¼ˆæœ€é«˜ 30,000/æœˆï¼‰",
        privateAgents: "ç§æœ‰ Agents",
        systemExperienceEdit: "ç³»ç»Ÿä½“éªŒå¯ç¼–è¾‘",
        unlimitedChat: "å¯¹è¯ä¸­æ— é™ä½¿ç”¨é«˜çº§æ¨¡å‹",
        unlimitedAgent: "Agent ä¸­æ— é™ä½¿ç”¨é«˜çº§æ¨¡å‹",
        earlyAccess: "æŠ¢å…ˆä½“éªŒ Beta åŠŸèƒ½",
        customDomains: "è‡ªå®šä¹‰åŸŸå",
        teamShare: "å›¢é˜Ÿå…±äº« Agents",
      },
    },
  },
  payment: {
    stripe: {
      title: 'Stripe',
      description: 'æ”¯æŒ Visa / Mastercard / å›½é™…ä¿¡ç”¨å¡'
    },
    wechat: {
      title: 'å¾®ä¿¡æ”¯ä»˜',
      description: 'æ‰«ç æ”¯ä»˜ï¼Œå®æ—¶åˆ°è´¦ï¼Œæ¨èå›½å†…ç”¨æˆ·'
    }
  },
  //ä¸»ç•Œé¢
  lemon: {
    // é¦–é¡µ
    welcome: {
      greeting: "ä½ å¥½",
      question: "æˆ‘èƒ½ä¸ºä½ åšä»€ä¹ˆï¼Ÿ",
      workMode: {
        twins: "åŒæ¨¡å¯¹æ¯”ï¼Œä¸€æ¬¡è¾“å…¥ï¼Œä¸¤ç§æ€ç»´å¹¶è¡Œå‘ˆç°",
        task: "è¿›åŒ–å‹æ™ºèƒ½ä½“ Â· ä»»åŠ¡æ‰§è¡Œä¸­",
        chat: "æ™ºèƒ½å¯¹è¯ Â· éšé—®éšç­”",
        auto: "è‡ªé€‚åº”æ¨¡å¼ Â· æ™ºèƒ½è·¯ç”±ä¸­"
      },
      tabs: {
        featured: "ç²¾é€‰",
        research: "ç ”ç©¶",
        lifestyle: "ç”Ÿæ´»æ–¹å¼",
        dataAnalysis: "æ•°æ®åˆ†æ",
        education: "æ•™è‚²",
        productivity: "ç”Ÿäº§åŠ›",
        other: "å…¶ä»–"
      },
      placeholders: {
        twins: "åŒæ—¶è§‚çœ‹ AI Chat ä¸ Evolving Agent çš„æ€è€ƒä¸å›ç­”",
        task: "è¯·å‘Šè¯‰æˆ‘æ‚¨çš„ä»»åŠ¡ç›®æ ‡ï¼Œæˆ‘å°†æŒç»­å­¦ä¹ å¹¶æ‰§è¡Œ",
        chat: "æœ‰ä»€ä¹ˆæˆ‘å¯ä»¥å¸®æ‚¨è§£ç­”çš„ï¼Ÿ",
        auto: "è¯·å‘Šè¯‰æˆ‘æ‚¨çš„éœ€æ±‚ï¼Œæˆ‘å°†è‡ªåŠ¨é€‰æ‹©æœ€é€‚åˆçš„å¤„ç†æ–¹å¼"
      },
      placeholder: "æœ‰ä»€ä¹ˆæˆ‘èƒ½å¸®æ‚¨çš„å—?",
      communityNote: "ç¤¾åŒºä¸­å±•ç¤ºçš„æ‰€æœ‰ä»»åŠ¡å’Œç½‘ç«™å‡ç”±ç”¨æˆ·è‡ªæ„¿åˆ†äº«ã€‚å¹³å°ä¸ä¼šåœ¨ç”¨æˆ·ä¸åŒæ„çš„æƒ…å†µä¸‹å±•ç¤ºä»»ä½•å†…å®¹ã€‚"
    },
    //å¯¹è¯å¤´éƒ¨
    chatHeader: {
      share: "åˆ†äº«",
      viewAllFiles: "æŸ¥çœ‹æ­¤ä»»åŠ¡ä¸­çš„æ‰€æœ‰æ–‡ä»¶",
      moreOptions: "æ›´å¤šé€‰é¡¹",
      rename: "é‡å‘½å",
      editTitle: "ç¼–è¾‘æ ‡é¢˜",
      enterNewTitle: "è¾“å…¥æ–°æ ‡é¢˜",
      cancel: "å–æ¶ˆ",
      confirm: "ç¡®è®¤",
      favorite: "æ·»åŠ åˆ°æ”¶è—",
      unfavorite: "å–æ¶ˆæ”¶è—"
    },
    // è¾“å…¥æ¡†
    input: {
      chooseModel: "é€‰æ‹©æ¨¡å‹",
    },
    // æ¨¡å‹
    model: {
      requiresLogin: "éœ€è¦ç™»å½•",
      loginRequired: "éœ€è¦ç™»å½•",
      loginRequiredDescription: "æ­¤æ¨¡å‹éœ€è¦ç™»å½•åæ‰èƒ½ä½¿ç”¨",
      pleaseLoginFirst: "è¯·å…ˆç™»å½•æ‚¨çš„è´¦æˆ·ä»¥ä½¿ç”¨è¯¥åŠŸèƒ½",
      goToLogin: "å»ç™»å½•",
      models: "æ¨¡å‹",
    },
    // å·¥ä½œæ¨¡å¼
    workMode: {
      title: "æ¨¡å¼",
      auto: {
        label: "è‡ªåŠ¨",
        description: "è‡ªåŠ¨é€‰æ‹©å¯¹è¯æ¨¡å¼"
      },
      agent: {
        label: "ä»»åŠ¡",
        description: "ä½¿ç”¨æ™ºèƒ½ä½“æ¨¡å¼è¿›è¡Œå¯¹è¯"
      },
      chat: {
        label: "èŠå¤©",
        description: "ä½¿ç”¨ä¼šè¯æ¨¡å¼è¿›è¡Œå¯¹è¯"
      }
    },
    //æ¶ˆæ¯å¯¹è¯åˆ—è¡¨é¡µ
    message: {
      runCommand: "æ‰§è¡Œ bash å‘½ä»¤",
      readFile: "è¯»å–æ–‡ä»¶",
      editFile: "ç¼–è¾‘æ–‡ä»¶",
      browsing: "æ­£åœ¨æµè§ˆ",
      searching: "æ­£åœ¨æœç´¢",
      minutesAgo: "åˆ†é’Ÿå‰", // minutes ago
      secondsAgo: "ç§’å‰",
      hoursAgo: "å°æ—¶å‰", // hours ago
      daysAgo: "å¤©å‰", // days ago
      monthsAgo: "æœˆå‰", // months ago
      yearsAgo: "å¹´å‰", // years ago
      copySuccess: "å¤åˆ¶æˆåŠŸ", // Copy successful
      copyError: "å¤åˆ¶å¤±è´¥", // Copy failed
      botInitialResponse: "ä½ å¥½æˆ‘å·²ç»æ”¶åˆ°ä½ çš„è¯·æ±‚ï¼Œæˆ‘æ­£åœ¨åˆ†æè¿™ä¸ªé—®é¢˜ã€‚è¯·ç¨ç­‰ã€‚",
      botInitialPlan: "åˆ¶å®šè®¡åˆ’ä¸­"
    },
    //ä¾§è¾¹æ 
    sidebar: {
      newTask: "æ–°å»ºä»»åŠ¡",
      shortcutKey: "T",
      moreOptions: "æ›´å¤šé€‰é¡¹",
      share: "åˆ†äº«",
      rename: "é‡å‘½å",
      collect: "æ”¶è—",
      delete: "åˆ é™¤",
      confirmDelete: "ç¡®è®¤åˆ é™¤",
      deleteConfirmation: "æ‚¨ç¡®å®šè¦åˆ é™¤æ­¤å¯¹è¯å—ï¼Ÿ",
      cancel: "å–æ¶ˆ",
      confirm: "ç¡®å®š",
      noChats: "æ–°å»ºä¸€ä¸ªä»»åŠ¡ä»¥å¼€å§‹",
      searchPlaceholder: "æœç´¢ä»»åŠ¡..."
    },
    //æ–‡ä»¶æŸ¥çœ‹å™¨
    fileExplorer: {
      allFilesInTask: "æ­¤ä»»åŠ¡ä¸­çš„æ‰€æœ‰æ–‡ä»¶",
      noContent: "æš‚æ— å†…å®¹",
      preview: "é¢„è§ˆ",
      locateInChat: "åœ¨èŠå¤©ä¸­å®šä½",
      download: "ä¸‹è½½",
      saveToGoogleDrive: "ä¿å­˜åˆ°Google Drive",
      selectAll: "å…¨é€‰",
      cancel: "å–æ¶ˆ",
      batchDownload: "æ‰¹é‡ä¸‹è½½",
      fileTypes: {
        all: "å…¨éƒ¨",
        document: "æ–‡æ¡£",
        image: "å›¾ç‰‡",
        codeFile: "ä»£ç æ–‡ä»¶",
        link: "é“¾æ¥"
      },
      timeGroups: {
        today: "ä»Šå¤©",
        yesterday: "æ˜¨å¤©",
        earlier: "æ›´æ—©"
      },
      weekdays: {
        sunday: "æ˜ŸæœŸæ—¥",
        monday: "æ˜ŸæœŸä¸€",
        tuesday: "æ˜ŸæœŸäºŒ",
        wednesday: "æ˜ŸæœŸä¸‰",
        thursday: "æ˜ŸæœŸå››",
        friday: "æ˜ŸæœŸäº”",
        saturday: "æ˜ŸæœŸå…­"
      }
    },
    fullPreview: {
      download: "ä¸‹è½½",
      exportToPDF: "å¯¼å‡ºä¸ºPDF",
      saveToGoogleDrive: "ä¿å­˜åˆ°Google Drive",
      maximize: "æœ€å¤§åŒ–",
      minimize: "æœ€å°åŒ–",
      previous: "ä¸Šä¸€ä¸ª",
      next: "ä¸‹ä¸€ä¸ª",
      copy: "å¤åˆ¶",
      code: "ä»£ç ",
      preview: "é¢„è§ˆ",
      close: "å…³é—­",
      fileTypePresentation: "æ— æ³•é¢„è§ˆ",
      cannotPreviewFormat: "æ­¤æ ¼å¼æ— æ³•é¢„è§ˆã€‚",
      downloadToView: "è¯·ä¸‹è½½æ–‡ä»¶ä»¥æŸ¥çœ‹å†…å®¹ã€‚",
      noContentToCopy: "æ²¡æœ‰å¯å¤åˆ¶çš„å†…å®¹ã€‚",
      clipboardNotSupported: "å½“å‰æµè§ˆå™¨ä¸æ”¯æŒå‰ªè´´æ¿æ“ä½œï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶ã€‚",
      contentCopied: "å†…å®¹å·²å¤åˆ¶ã€‚",
      copyFailed: "å¤åˆ¶å¤±è´¥ï¼Œè¯·é‡è¯•æˆ–æ‰‹åŠ¨å¤åˆ¶ã€‚",
      exportPDFPending: "å¯¼å‡ºPDFæˆåŠŸ",
      saveToGoogleDrivePending: "ä¿å­˜åˆ°Google DriveåŠŸèƒ½å¾…å®ç°ã€‚"
    },
    preview: {
      title: "Lemonçš„ç”µè„‘",
      openVsCode: "VS Code",
      using: "Lemon æ­£åœ¨ä½¿ç”¨",
      performing: "æ­£åœ¨æ‰§è¡Œ",
      previousStep: "ä¸Šä¸€æ­¥",
      nextStep: "ä¸‹ä¸€æ­¥",
      realtime: "å®æ—¶",
      waitingForDevelopment: "ç­‰å¾…å¼€å‘...",
      browser: "æµè§ˆå™¨",
      browsing: "æµè§ˆ",
      editor: "ç¼–è¾‘å™¨",
      editingFile: "ç¼–è¾‘æ–‡ä»¶",
      terminal: "ç»ˆç«¯",
      executingCommand: "æ‰§è¡Œå‘½ä»¤",
      readingFile: "è¯»å–æ–‡ä»¶",
      search: "æœç´¢",
      searching: "æœç´¢"
    }

  },
  //è®¾ç½®ç•Œé¢
  setting: {
    back: "è¿”å›",
    doneStep: "ç»“æŸ",
    prevStep: "ä¸Šä¸€æ­¥",
    nextStep: "ä¸‹ä¸€æ­¥",
    settingModel: "è®¾ç½®",
    settingModelTips: "ç‚¹å‡»è®¾ç½®, è·³è½¬åˆ°è®¾ç½®é¡µé¢",
    tourHoverDescription: "é¼ æ ‡æ‚¬æµ®æ­¤å¤„æŸ¥çœ‹èœå•ï¼Œç‚¹å‡»è®¾ç½®å‰å¾€è®¾ç½®é¡µé¢",
    tourClickSettingTitle: "è¿›å…¥è®¾ç½®",
    tourClickSettingDescription: "ç‚¹å‡»\"è®¾ç½®\"æŒ‰é’®è¿›å…¥è®¾ç½®é¡µé¢è¿›è¡Œæ¨¡å‹é…ç½®",
    tourUnderstood: "å‰å¾€è®¾ç½®",
    menu: {
      basic: "åŸºæœ¬è®¾ç½®",
      defaultModel: "é»˜è®¤æ¨¡å‹",
      modelService: "æ¨¡å‹æœåŠ¡",
      searchService: "æœç´¢æœåŠ¡",
      mcpService: "MCPæœåŠ¡",
      experience: 'ç»éªŒåº“',
      account: "è´¦æˆ·ç®¡ç†",
      //ç§¯åˆ†ç®¡ç†
      integral: 'ç§¯åˆ†ç®¡ç†',
      about: 'å…³äº',
    },
    basic: {
      title: "åŸºæœ¬è®¾ç½®",
      langTitle: "è¯­è¨€è®¾ç½®",
      languagePreference: "è¯­è¨€åå¥½",
      lang: {
        en: "è‹±æ–‡",
        zh: "ä¸­æ–‡ï¼ˆç®€ä½“ï¼‰",
        de: "å¾·è¯­",
        es: "è¥¿ç­ç‰™è¯­",
        fr: "æ³•è¯­",
        ja: "æ—¥è¯­",
        kr: "éŸ©è¯­",
        tr: "åœŸè€³å…¶è¯­",
        pt: "è‘¡è„ç‰™è¯­",
        tw: "ä¸­æ–‡ï¼ˆç¹ä½“ï¼‰",
        vi: "è¶Šå—è¯­"
      }
    },
    modelService: {
      modelService: "æ¨¡å‹æœåŠ¡",
      modelServiceTipsOne: "ç¬¬ä¸€æ­¥:é€‰æ‹©æ¨¡å‹æœåŠ¡å•†",
      modelServiceTipsTwo: "ç¬¬äºŒæ­¥:è®¾ç½®è¾“å…¥API KEY",
      modelServiceTipsThree: "ç¬¬ä¸‰æ­¥:å¯ç”¨æ¨¡å‹æœåŠ¡",
      title: "æ¨¡å‹æœåŠ¡",
      searchPlaceholder: "æœç´¢å¹³å°",
      defaultPlatform: "é»˜è®¤ç³»ç»Ÿå¹³å°",
      modelPlatform: "æ¨¡å‹å¹³å°",
      statusOn: "å¼€å¯",
      addPlatform: "æ·»åŠ ",
      save: "ä¿å­˜",
      defaultPlatformDescription: "é»˜è®¤å¹³å°æ¨¡å‹ç”±ç³»ç»Ÿæä¾›ï¼Œæ— éœ€é…ç½®",
      apiKey: "API å¯†é’¥",
      apiKeyPlaceholder: "è¯·è¾“å…¥APIå¯†é’¥",
      ak: "Access å¯†é’¥",
      akPlaceholder: "è¯·è¾“å…¥ Access å¯†é’¥",
      getApiKey: "ç‚¹å‡»æ­¤å¤„è·å–å¯†é’¥",
      check: "æ£€æŸ¥",
      selectCheckModel: "è¯·é€‰æ‹©æ£€æŸ¥çš„æ¨¡å‹",
      apiAddress: "APIåœ°å€",
      apiAddressPlaceholder: "è¯·è¾“å…¥APIåœ°å€",
      apiAddressTip: "ä»¥/ç»“å°¾å¿½ç•¥v1ç‰ˆæœ¬ï¼Œä»¥#ç»“å°¾å¼ºåˆ¶ä½¿ç”¨è¾“å…¥åœ°å€",
      activateTime: "æ¿€æ´»æ—¶é—´",
      activateTimePlaceholder: "è¯·è¾“å…¥æ¿€æ´»æ—¶é—´ï¼ˆåˆ†é’Ÿï¼‰",
      models: "æ¨¡å‹",
      ungrouped: "æœªåˆ†ç»„",
      viewOfficialDocs: "æŸ¥çœ‹å¹³å°çš„å®˜æ–¹æ–‡æ¡£ä»¥è·å–æ›´å¤šä¿¡æ¯",
      add: "æ·»åŠ ",
      confirmDeleteModel: "ç¡®å®šè¦åˆ é™¤æ­¤æ¨¡å‹å—ï¼Ÿ",
      deleteModelSuccess: "æ¨¡å‹åˆ é™¤æˆåŠŸ",
      deleteModelFailed: "æ¨¡å‹åˆ é™¤å¤±è´¥",
      addModelSuccess: "æ¨¡å‹æ·»åŠ æˆåŠŸ",
      updateModelSuccess: "æ¨¡å‹æ›´æ–°æˆåŠŸ",
      copySuccess: "åç§°å·²å¤åˆ¶",
      typeVision: "è§†è§‰",
      typeNetwork: "ç½‘ç»œ",
      typeEmbed: "åµŒå…¥",
      typeReasoning: "æ¨ç†",
      typeTool: "å·¥å…·",
      addProvider: "æ·»åŠ æä¾›å•†",
      confirm: "ç¡®è®¤",
      cancel: "å–æ¶ˆ",
      platformLogo: "å¹³å°æ ‡å¿—",
      providerName: "æä¾›å•†åç§°",
      namePlaceholder: "åç§°",
      providerType: "æä¾›å•†ç±»å‹",
      typePlaceholder: "ç±»å‹",
      enterName: "è¯·è¾“å…¥åç§°",
      selectType: "è¯·é€‰æ‹©ç±»å‹",
      addPlatformSuccess: "å¹³å°æ·»åŠ æˆåŠŸ",
      formValidationFailed: "è¡¨å•éªŒè¯å¤±è´¥",
      addModel: "æ·»åŠ æ¨¡å‹",
      editModel: "ç¼–è¾‘æ¨¡å‹",
      modelId: "æ¨¡å‹ID",
      modelIdPlaceholder: "è¯·è¾“å…¥æ¨¡å‹ID",
      modelName: "æ¨¡å‹åç§°",
      modelNamePlaceholder: "æ¨¡å‹åç§°",
      groupName: "ç»„åç§°",
      groupNamePlaceholder: "ç»„åç§°",
      modelTypes: "æ¨¡å‹ç±»å‹",
      enterModelId: "è¯·è¾“å…¥æ¨¡å‹ID",
      enterModelName: "è¯·è¾“å…¥æ¨¡å‹åç§°",
      enterGroupName: "è¯·è¾“å…¥ç»„åç§°",
      selectModelType: "è¯·è‡³å°‘é€‰æ‹©ä¸€ç§æ¨¡å‹ç±»å‹",
      editProvider: "ç¼–è¾‘æä¾›å•†",
      updatePlatformSuccess: "å¹³å°æ›´æ–°æˆåŠŸ",
      deletePlatformSuccess: "å¹³å°åˆ é™¤æˆåŠŸ",
      deletePlatformFailed: "å¹³å°åˆ é™¤å¤±è´¥",
      saveSuccess: "ä¿å­˜æˆåŠŸ",
      saveFailed: "ä¿å­˜å¤±è´¥",
      modelAlreadyExists: "æ·»åŠ å¤±è´¥,æ¨¡å‹IDå·²å­˜åœ¨",
      apiCallSucceeded: "è¿æ¥æµ‹è¯•æˆåŠŸ",
      apiCallFailed: "è¿æ¥æµ‹è¯•å¤±è´¥",
      apiCallTimeout: "è¿æ¥æµ‹è¯•è¶…æ—¶",
      unknownError: "æœªçŸ¥é”™è¯¯",
      platforms: {
        Anthropic: "Anthropic",
        ModelScope: "ModelScope é­”æ­",
        Gemini: "Gemini",
        OpenAI: "OpenAI",
        Ollama: "Ollama",
        qiniu: "ä¸ƒç‰›äº‘",
        WanJieData: "ä¸‡ç•Œæ•°æ®",
        PPIO: "PPIO æ´¾æ¬§äº‘",
        QianFan: "ç™¾åº¦äº‘åƒå¸†",
        SiliconFlow: "ç¡…åŸºæµåŠ¨",
        Volcengine: "ç«å±±å¼•æ“",
        DeepSeek: "æ·±åº¦æ±‚ç´¢",
        Bailian: "é˜¿é‡Œäº‘ç™¾ç‚¼",
        OpenRouter: "OpenRouter",
        LMStudio: "LM Studio",
        Cloudsway: "Cloudsway",
        Lemon: "Lemon",

      },
      showMoreOptions: " æ›´å¤šé€‰é¡¹",
      hideOptions: "æ›´å¤šé€‰é¡¹",

    },
    defaultModel: {
      defaultModel: "è®¾ç½®é»˜è®¤æ¨¡å‹",
      defaultModelTipsOne: "ç‚¹å‡»é»˜è®¤æ¨¡å‹, è·³è½¬åˆ°é»˜è®¤æ¨¡å‹é¡µé¢",
      topicNamingModel: "ä¸»é¢˜å‘½åæ¨¡å‹",
      topicNamingModelTips: "ç”¨äºè‡ªåŠ¨å‘½åæ–°ä¸»é¢˜çš„æ¨¡å‹",
      emptymodelTips: "è¯·åœ¨æ¨¡å‹æœåŠ¡ä¸­å¯ç”¨ç›¸å…³å¹³å°",
      DefaultModelSetting: "é»˜è®¤æ¨¡å‹è®¾ç½®",
      defaultAssistantModel: "é»˜è®¤åŠ©æ‰‹æ¨¡å‹",
      assistantModelTips: "åˆ›å»ºåŠ©æ‰‹æ—¶ä½¿ç”¨çš„æ¨¡å‹",
      translationModel: "ç¿»è¯‘æ¨¡å‹",
      translationModelTips: "ç”¨äºç¿»è¯‘æœåŠ¡çš„æ¨¡å‹",
      browserUseModel: "æµè§ˆå™¨æœåŠ¡æ¨¡å‹",
      browserUseModelTips: "ç”¨äºå†…ç½®æµè§ˆå™¨ä½¿ç”¨çš„æ¨¡å‹, å¿…é¡»æ”¯æŒå·¥å…·å’Œå‡½æ•°è°ƒç”¨",
      saveSuccess: "è®¾ç½®ä¿å­˜æˆåŠŸ",
      assistantSettings: "åŠ©æ‰‹è®¾ç½®",
      confirm: "ç¡®è®¤",
      cancel: "å–æ¶ˆ",
      assistantName: "åŠ©æ‰‹åç§°",
      assistantNamePlaceholder: "è¯·è¾“å…¥åŠ©æ‰‹åç§°",
      prompt: "æç¤ºè¯",
      promptPlaceholder: "è¯·è¾“å…¥æç¤ºè¯",
      modelParameters: "æ¨¡å‹å‚æ•°",
      temperature: "æ¸©åº¦",
      topP: "Top P",
      maxTokens: "æœ€å¤§ä»¤ç‰Œæ•°",
      enableLengthLimit: "å¯ç”¨é•¿åº¦é™åˆ¶",
      topicNamingSettings: "ä¸»é¢˜å‘½åè®¾ç½®",
      topicAutoNaming: "ä¸»é¢˜è‡ªåŠ¨å‘½å",
      topicNamingPrompt: "ä¸»é¢˜å‘½åæç¤ºè¯",
      translationSettings: "ç¿»è¯‘è®¾ç½®",
      translationPrompt: "ç¿»è¯‘æç¤ºè¯"
    },
    searchService: {
      searchService: "è®¾ç½®æœç´¢æœåŠ¡",
      searchServiceTipsOne: "ç‚¹å‡»æœç´¢æœåŠ¡ï¼Œè·³è½¬åˆ°æœç´¢æœåŠ¡é¡µé¢",
      searchEngineTipsOne: "ç¬¬ä¸€æ­¥ï¼šé€‰æ‹©æœç´¢æœåŠ¡å•†",
      searchEngineTipsTwo: "ç¬¬äºŒæ­¥ï¼šè®¾ç½®è¾“å…¥APIå¯†é’¥",
      title: "æœç´¢æœåŠ¡",
      blacklistSubscription: "é»‘åå•è®¢é˜…",
      addSubscription: "æ·»åŠ è®¢é˜…",
      updateNow: "ç«‹å³æ›´æ–°",
      deleteSubscription: "åˆ é™¤è®¢é˜…",
      confirm: "ç¡®è®¤",
      cancel: "å–æ¶ˆ",
      subscriptionUrl: "è®¢é˜…URL",
      subscriptionUrlPlaceholder: "https://example/abcd",
      subscriptionName: "è®¢é˜…åç§°",
      subscriptionNamePlaceholder: "å½“ä¸‹è½½çš„è®¢é˜…æºæ— åç§°æ—¶ä½¿ç”¨çš„æ›¿ä»£åç§°",
      name: "åç§°",
      url: "URL",
      addSubscriptionSuccess: "è®¢é˜…æ·»åŠ æˆåŠŸ",
      deleteSubscriptionSuccess: "è®¢é˜…åˆ é™¤æˆåŠŸ",
      deleteSubscriptionFailed: "è®¢é˜…åˆ é™¤å¤±è´¥",
      saveConfigSuccess: "é…ç½®ä¿å­˜æˆåŠŸ",
      saveConfigFailed: "é…ç½®ä¿å­˜å¤±è´¥",
      loadConfigFailed: "åŠ è½½é…ç½®å¤±è´¥",
      formValidationFailed: "è¡¨å•éªŒè¯å¤±è´¥",
      enterSubscriptionUrl: "è¯·è¾“å…¥è®¢é˜…URL",
      invalidUrl: "è¯·è¾“å…¥æœ‰æ•ˆURL",
      enterSubscriptionName: "è¯·è¾“å…¥è®¢é˜…åç§°",
      noSubscriptionSelected: "æœªé€‰æ‹©è®¢é˜…",
      searchProvider: "æœç´¢æä¾›å•†",
      generalSettings: "å¸¸è§„è®¾ç½®",
      includeDate: "åŒ…å«æ—¥æœŸ",
      includeServer: "åŒ…å«æœåŠ¡å™¨",
      searchEnhancement: "æœç´¢å¢å¼º",
      searchResultCount: "æœç´¢ç»“æœæ•°é‡",
      default: "é»˜è®¤",
      blacklist: "é»‘åå•",
      blacklistTips: "è¾“å…¥è¦ä»æœç´¢ç»“æœä¸­æ’é™¤çš„åŸŸå",
      blacklistPlaceholder: "æ¯è¡Œè¾“å…¥ä¸€ä¸ªåŸŸå",
      save: "ä¿å­˜",
      apiTips: "APIé…ç½®",
      apiKeyPlaceholder: "è¾“å…¥æ‚¨çš„APIå¯†é’¥",
      apiKey: "APIå¯†é’¥",
      apiAddress: "APIåœ°å€",
      tavilyName: "Tavilyï¼ˆå¯†é’¥ï¼‰",
      baiduName: "ç™¾åº¦ï¼ˆå…è´¹ï¼‰",
      bingName: "å¿…åº”ï¼ˆå…è´¹ï¼‰",
      couldswayName: "Cloudswayï¼ˆå¯†é’¥ï¼‰",
      accessKey: "è®¿é—®å¯†é’¥",
      endPoint: "ç«¯ç‚¹",
      endpointPlaceholder: "è¾“å…¥æ‚¨çš„endpoint",
      accessKeyPlaceholder: "è¾“å…¥æ‚¨çš„è®¿é—®å¯†é’¥",
      saveBlacklistSuccess: "é»‘åå•ä¿å­˜æˆåŠŸ",
      saveBlacklistFailed: "é»‘åå•ä¿å­˜å¤±è´¥",
      apiKeyRequired: "APIå¯†é’¥ä¸ºç©º",
      accessKeyRequired: "è®¿é—®å¯†é’¥ä¸ºç©º",
      endpointRequired: "endpoint ä¸ºç©º",
      checkSearchEngineSuccess: "æœç´¢æµ‹è¯•æˆåŠŸ",
      checkSearchEngineFailed: "æœç´¢æµ‹è¯•å¤±è´¥",
    },
    mcpService: {
      title: "MCPæœåŠ¡",
      addServer: "æ·»åŠ æœåŠ¡å™¨",
      save: "ä¿å­˜",
      name: "åç§°",
      namePlaceholder: "è¯·è¾“å…¥åç§°",
      description: "æè¿°",
      descriptionPlaceholder: "æè¿°",
      type: "ç±»å‹",
      stdio: "æ ‡å‡†è¾“å…¥/è¾“å‡º (stdio)",
      sse: "æœåŠ¡å™¨å‘é€äº‹ä»¶ (sse)",
      streamableHttp: "å¯æµå¼ä¼ è¾“çš„HTTP (streamableHttp)",
      command: "å‘½ä»¤",
      commandPlaceholder: "uvx æˆ– npx",
      packageSource: "åŒ…ç®¡ç†æº",
      default: "é»˜è®¤",
      taobaoNpmMirror: "æ·˜å®NPMé•œåƒ",
      tsinghua: "æ¸…åå¤§å­¦",
      aliyun: "é˜¿é‡Œäº‘",
      ustc: "ä¸­å›½ç§‘å­¦æŠ€æœ¯å¤§å­¦",
      huaweiCloud: "åä¸ºäº‘",
      tencentCloud: "è…¾è®¯äº‘",
      args: "å‚æ•°",
      argsPlaceholder: "arg1\narg2",
      env: "ç¯å¢ƒå˜é‡",
      envPlaceholder: "KEY1=VALUE1\nKEY2=VALUE2",
      mcpServer: "MCPæœåŠ¡å™¨",
      import: "ä» JSON å¯¼å…¥",
      importServer: "æœåŠ¡å™¨ JSON é…ç½®",
      deleteConfirmTitle: "åˆ é™¤ç¡®è®¤",
      deleteConfirmContent: "ç¡®å®šè¦åˆ é™¤è¿™ä¸ªæœåŠ¡å™¨å—",
      noServerSelected: "å½“å‰æ²¡æœ‰é€‰ä¸­çš„æœåŠ¡å™¨",
      importFromJson: "ä» JSON å¯¼å…¥",
      addMcpServer: "æ·»åŠ MCPæœåŠ¡å™¨",
      importModalTitle: "ä» JSON å¯¼å…¥",
      ok: "ç¡®å®š",
      cancel: "å–æ¶ˆ",
      importSuccess: "æˆåŠŸå¯¼å…¥ {count} ä¸ªMCPæœåŠ¡å™¨ã€‚",
      importSuccessSingle: "æˆåŠŸå¯¼å…¥MCPæœåŠ¡å™¨ã€‚",
      noValidServer: "åœ¨å¯¼å…¥çš„æ•°æ®ä¸­æœªæ‰¾åˆ°æœ‰æ•ˆçš„æœåŠ¡å™¨é…ç½®ã€‚",
      nameRequired: "åç§°æ˜¯å¿…å¡«é¡¹ã€‚",
      invalidJson: "æ— æ•ˆçš„JSONæ ¼å¼ã€‚",
      url: "åœ°å€",
      connectionFailed: "MCP è¿æ¥å¤±è´¥",
      noServersAvailable: "æš‚æ— å¯ç”¨æœåŠ¡å™¨",
      fetchFailed: "è·å–æœåŠ¡å™¨åˆ—è¡¨å¤±è´¥",
      addSuccess: "æœåŠ¡å™¨æ·»åŠ æˆåŠŸ",
      addFailed: "æ·»åŠ æœåŠ¡å™¨å¤±è´¥",
      updateSuccess: "æœåŠ¡å™¨æ›´æ–°æˆåŠŸ",
      updateFailed: "æ›´æ–°æœåŠ¡å™¨å¤±è´¥",
      deleteSuccess: "æœåŠ¡å™¨åˆ é™¤æˆåŠŸ",
      deleteFailed: "åˆ é™¤æœåŠ¡å™¨å¤±è´¥",
    },
    experience: {
      title: "ç»éªŒåº“",
      addExperience: "æ·»åŠ ç»éªŒ",
      editExperience: "ç¼–è¾‘ç»éªŒ",
      close: "å…³é—­",
      titleLabel: "æ ‡é¢˜",
      titlePlaceholder: "ç»éªŒæ ‡é¢˜",
      goalLabel: "ç›®çš„",
      goalPlaceholder: "è¯¥ç»éªŒçš„ç›®çš„",
      contentLabel: "å†…å®¹",
      contentPlaceholder: "ç»éªŒå†…å®¹",
      statusLabel: "çŠ¶æ€",
      enabled: "å·²å¯ç”¨",
      disabled: "å·²ç¦ç”¨",
      cancel: "å–æ¶ˆ",
      save: "ä¿å­˜",
      delete: "åˆ é™¤",
      undoChanges: "æ’¤é”€æ›´æ”¹",
      deleteExperience: "åˆ é™¤ç»éªŒ",
      deleteConfirm: "ä½ ç¡®å®šè¦åˆ é™¤è¿™æ¡ç»éªŒå—ï¼Ÿ",
      totalExperience: "å…± {count} æ¡ç»éªŒ",
      tableTitle: "æ ‡é¢˜",
      tableContent: "å†…å®¹",
      tableCreatedAt: "åˆ›å»ºäº",
      tableStatus: "çŠ¶æ€",
      tableOperation: "æ“ä½œ",
      filterAll: "å…¨éƒ¨",
      deleteSuccess: "åˆ é™¤æˆåŠŸ",
      deleteFailed: "åˆ é™¤å¤±è´¥",
      createSuccess: "æ·»åŠ ç»éªŒæˆåŠŸ",
      createFailed: "æ·»åŠ ç»éªŒå¤±è´¥",
      updateSuccess: "æ›´æ–°æˆåŠŸ",
      updateFailed: "æ›´æ–°å¤±è´¥",
      updateFailedDataNotExist: "æ›´æ–°å¤±è´¥ï¼Œå½“å‰æ•°æ®ä¸å­˜åœ¨",
      getDataError: "è·å–æ•°æ®é”™è¯¯",
      systemExperienceRequiresUpgrade: "æŸ¥çœ‹ç³»ç»Ÿç»éªŒéœ€è¦å‡çº§",
      detect: "æ„å›¾è¯†åˆ«",
      plan: "ä»»åŠ¡è§„åˆ’",
      action: "ä»»åŠ¡æ‰§è¡Œ",
      sunday: "æ˜ŸæœŸæ—¥",
      monday: "æ˜ŸæœŸä¸€",
      tuesday: "æ˜ŸæœŸäºŒ",
      wednesday: "æ˜ŸæœŸä¸‰",
      thursday: "æ˜ŸæœŸå››",
      friday: "æ˜ŸæœŸäº”",
      saturday: "æ˜ŸæœŸå…­",
      earlier: "æ›´æ—©",
    },
    about: {
      title: "å…³äº",
      lemonAI: "LemonAI",
      checkUpdate: "æ£€æŸ¥æ›´æ–°",
      officialWebsite: "å®˜æ–¹ç½‘ç«™",
      view: "æŸ¥çœ‹",
      feedback: "æ„è§åé¦ˆ",
      submitFeedback: "åé¦ˆ",
      license: "è®¸å¯è¯",
      newVersionReleased: "WowğŸ”¥ æ–°ç‰ˆæœ¬å·²å‘å¸ƒï¼ğŸš€",
      version: "ç‰ˆæœ¬",
      skipUpdate: "æš‚ä¸æ›´æ–°",
      viewDetails: "æŸ¥çœ‹è¯¦æƒ…",
      alreadyLatest: "å½“å‰å·²ç»æ˜¯æœ€æ–°ç‰ˆæœ¬"
    }
  },
  thinking: "æ€è€ƒä¸­",
  task_error: "ä»»åŠ¡å¼‚å¸¸ç»ˆæ­¢",
  stop_task: "å·²åœæ­¢ä»»åŠ¡",
  jump_to_result: "è·³è½¬åˆ°ç»“æœ",
  replay: "é‡çœ‹",
  task_finished: "ä»»åŠ¡å®Œæˆ",
  task_playing: "ä»»åŠ¡è¿›è¡Œä¸­",
  //ç‚¹å‡»æ­¤å¤„è·³è½¬åˆ°è®¾ç½®é¡µé¢
  click_here_to_go_to_settings: "ç‚¹å‡»æ­¤å¤„è·³è½¬åˆ°è®¾ç½®é¡µé¢",
  //è¯·é€‰æ‹© æ¨¡å‹
  please_select_model: "è¯·é€‰æ‹©æ¨¡å‹",
  //è®¾ç½®
  settings: "è®¾ç½®",
  loadingTip: "æ­£åœ¨è·å–è®¢å•ä¿¡æ¯ä¸­...",
  backHome: "è¿”å›é¦–é¡µ",
  orderInfo: "è®¢å•ä¿¡æ¯",
  orderId: "è®¢å•å·",
  paymentAmount: "æ”¯ä»˜é‡‘é¢",
  orderStatus: "è®¢å•çŠ¶æ€",
  customerInfo: "å®¢æˆ·ä¿¡æ¯",
  name: "å§“å",
  email: "é‚®ç®±",
  notProvided: "æœªæä¾›",
  unknown: "æœªçŸ¥",
  unknownCurrency: "æœªçŸ¥å¸ç§",
  loadFailed: "è®¢å•åŠ è½½å¤±è´¥ï¼Œè¯·ç¨åå†è¯•ã€‚",
  fetchFailed: "è·å–è®¢å•å¤±è´¥",
  status: {
    checking: "æ­£åœ¨è·å–è®¢å•çŠ¶æ€...",
    paid: "æ”¯ä»˜æˆåŠŸ",
    pending: "è®¢å•å¾…å¤„ç†",
    cancelled: "è®¢å•å·²å–æ¶ˆ",
    failed: "æ”¯ä»˜å¤±è´¥"
  },
  resultTitle: {
    paid: "æ”¯ä»˜æˆåŠŸ",
    pending: "è®¢å•å¾…å¤„ç†",
    cancelled: "è®¢å•å·²å–æ¶ˆ",
    failed: "æ”¯ä»˜å¤±è´¥",
    checking: "æ­£åœ¨è·å–è®¢å•ä¿¡æ¯ä¸­...",
    unknown: "è®¢å•çŠ¶æ€æœªçŸ¥"
  },
  resultSubtitle: {
    submitted: "æ‚¨çš„è®¢å•å·²ç»æˆåŠŸæäº¤"
  }
}



================================================
FILE: frontend/src/locals/utils/index.js
================================================
export const initDictionary = (list) => {
  let obj = {};
  list.forEach(item => {
    obj[item.source_text] = item.target_text || "";
  });
  localStorage.setItem('dictionary', JSON.stringify(obj));
};

export const translateFunc = (key) => {
  const list = JSON.parse(localStorage.getItem('dictionary')) || {}
  return list[key] || key;
};

export default {
  initDictionary,
  translateFunc,
};



================================================
FILE: frontend/src/router/index.js
================================================
import path from 'path';
import { createRouter, createWebHashHistory, createWebHistory } from 'vue-router'

const routes = [
  {
    path: "/",
    component: () => import(/* webpackChunkName: "lemon" */ "@/view/lemon/index.vue"),
    meta: { verify: true },
    redirect: { name: "lemon" },
    children: [
      {
        path: "lemon/:agentId?/:id?",
        name: "lemon",
        component: () => import(/* webpackChunkName: "lemon" */ "@/view/lemon/components/ChatPanel.vue"),
        meta: { verify: true }
      }
    ]
  },
  {
    path:"/share/:id?",
    name: "share",
    component: () => import(/* webpackChunkName: "lemon" */ "@/view/share/index.vue"),
    meta: { verify: true }
  },
  {
    path: "/auth",
    name: "login",
    component: () => import(/* webpackChunkName: "auth" */ "@/view/auth/index.vue"),
  },
  {
    path: "/auth/google",
    name: "google",
    component: () => import(/* webpackChunkName: "auth" */ "@/view/auth/GoogleCallback.vue"),
  },
  {
    path: "/demo",
    name: "demo",
    component: () => import(/* webpackChunkName: "demo" */ "@/view/demo/index.vue"),
    meta: { verify: true }
  },{
    path: "/pricing",
    name: "pricing",
    component: () => import("@/view/pay/pricing.vue"),
    meta: { verify: true }
  },
  {
    path: "/pay/success",
    name: "paySuccess",
    component: () => import("@/view/pay/paySuccess.vue"),
    meta: { verify: true }
  },
  {
    //desktop é‡å®šå‘
    path: "/desktop/redirect",
    name: "desktopRedirect",
    component: () => import("@/view/desktop/redirect.vue"),
    meta: { verify: true }
  },
  {
    path: "/setting",
    component: () => import("@/view/setting/index.vue"),
    meta: { verify: true },
    children: [
      {
        path: "basic",
        component: () => import("@/view/setting/basic.vue"),
        meta: { verify: true }
      },
      {
        path: "default-model",
        component: () => import("@/view/setting/default-model.vue"),
        meta: { verify: true }
      },
      {
        path: "default-model-setting",
        component: () => import("@/view/setting/defaultModelSetting.vue"),
        meta: { verify: true }
      },
      {
        path: "model-service",
        component: () => import("@/view/setting/model.vue"),
        meta: { verify: true }
      },
      {
        path: "search-service",
        component: () => import("@/view/setting/search.vue"),
        meta: { verify: true }

      },
      {
        path: "mcp-service",
        component: () => import("@/view/setting/mcp.vue"),
        meta: { verify: true }
      },
      {
        path: "about",
        component: () => import("@/view/setting/about.vue"),
        meta: { verify: true }
      },{
        path:"usage",
        component: () => import("@/view/auth/usage.vue"),
        meta: { verify: true }
      },{
        //UserProfile.vue
        path: "profile",
        component: () => import("@/view/auth/UserProfile.vue"),
        meta: { verify: true }
      }
    ]
  }
]


const router = createRouter({
  //åˆ¤æ–­æ˜¯ä¸æ˜¯ å®¢æˆ·ç«¯ å¦‚æœæ˜¯å®¢æˆ·ç«¯åˆ™ä½¿ç”¨ createWebHashHistory å¦åˆ™ä½¿ç”¨ createWebHistory
  history: import.meta.env.VITE_IS_CLIENT === 'true' ? createWebHashHistory() : createWebHistory(),
  routes,
});

router.beforeEach((to, from, next) => {
  const token = localStorage.getItem('access_token');
  console.log("import.meta.env.VITE_IS_CLIENT === ",import.meta.env.VITE_IS_CLIENT);
  const { meta = {} } = to;
  // If route requires authentication and no token exists, redirect to login
  // if (meta.verify && !token) {
  //   console.log("Authentication failed, redirecting to login");
  //   next({ name: 'login' });
  //   return;
  // }
  next();
})

export default router


================================================
FILE: frontend/src/services/agent.js
================================================
import http from "@/utils/http.js";

const uri = `/api/agent`;

const service = {
  //è·å–å…¨éƒ¨ get /
  getList(){
    return http.get(uri);
  },
  //è·å–å•ä¸ª :id
  getById(id){
    return http.get(`${uri}/${id}`);
  },
  //æ›´æ–° :id
  update(id, name, describe, mcp_server_ids,is_public){
    return http.put(`${uri}/${id}`, {
      name: name,
      describe: describe,
      mcp_server_ids: mcp_server_ids,
      is_public:is_public
    });
  },
  //æ–°å¢ post  name, describe='', mcp_server_ids = []
  create(name, describe, mcp_server_ids,is_public){
    return http.post(uri, {
      name: name,
      describe: describe,
      mcp_server_ids: mcp_server_ids,
      is_public:is_public
    });
  },
  //åˆ é™¤ :id
  delete(id){
    return http.del(`${uri}/${id}`);
  },
  generate(question,conversation_id,is_public){
    return http.post(`${uri}/generate`, {
      question: question,
      conversation_id: conversation_id,
      is_public:is_public
    });
  }
};

export default service;


================================================
FILE: frontend/src/services/auth.js
================================================
import http from "@/utils/http.js";
import md5 from "md5";
import { useUserStore } from "@/store/modules/user";
const userStore = useUserStore();

const service = {
  async login(email, password,phone) {
    try {
      // å¯¹å¯†ç è¿›è¡ŒMD5åŠ å¯†
      const hashedPassword = md5(password);
      
      // è°ƒç”¨ç™»å½•API
      const uri = "/api/users/login";
      const response = await http.post(uri, {
        email,
        password: hashedPassword,
        phone
      });
      
      // ä¿å­˜ç”¨æˆ·ä¿¡æ¯å’Œtoken
      if (response.data && response.data.access_token) {
        
        localStorage.setItem('access_token', response.data.access_token);

        console.log('Login successful:', response.data);
        userStore.setUser(response.data.userInfo);
      }
      
      return response.data || {};
    } catch (error) {
      console.error('Login error:', error);
      throw error;
    }
  },
  async getUserInfo(){
    let res =  await http.get('/api/users/userinfo');
    console.log("== getUserInfo ==",res);
    return res;
  },
  async loginSMSCode(phone,smsCode){
    try {
      // è°ƒç”¨ç™»å½•API
      const uri = "/api/users/login-sms-code";
      const response = await http.post(uri, {
        phone,
        smsCode
      });
      
      // ä¿å­˜ç”¨æˆ·ä¿¡æ¯å’Œtoken
      if (response.data && response.data.access_token) {
        
        localStorage.setItem('access_token', response.data.access_token);

        console.log('Login successful:', response.data);
        userStore.setUser(response.data.userInfo);
      }
      
      return response.data || {};
    } catch (error) {
      console.error('Login error:', error);
      throw error;
    }
  },
  
  async register(name, email, password,phone) {
    try {
      // å¯¹å¯†ç è¿›è¡ŒMD5åŠ å¯†
      const hashedPassword = md5(password);
      
      // è°ƒç”¨æ³¨å†ŒAPI
      const uri = "/api/users/register";
      const response = await http.post(uri, {
        name,
        email,
        phone,
        password: hashedPassword
      });
      
      return response.data || {};
    } catch (error) {
      console.error('Register error:', error);
      throw error;
    }
  },
  async sendEmailVerification(email) {
    try {
      const uri = "/api/users/sendEmailVerifyCode";
      const response = await http.post(uri, { email });
      return response.data || {};
    } catch (error) {
      console.error('Send email verification error:', error);
      throw error;
    }
  },
  async verifyEmailVerifyCode(email, code) {
    try {
      const uri = "/api/users/verifyEmailVerifyCode";
      const response = await http.post(uri, { email, code });
      return response.data || {};
    } catch (error) {
      console.error('Verify email verify code error:', error);
      throw error;
    }
  },
  async verifySmsVerifyCode(phone, code) {
    try {
      const uri = "/api/users/verifySmsVerifyCode";
      const response = await http.post(uri, { phone, code });
      return response.data || {};
    } catch (error) {
      console.error('Verify sms code error:', error);
      throw error;
    }
  },
  //updateUsername
  async updateUsername(username) {
    try {
      const uri = "/api/users/updateUsername";
      const response = await http.post(uri, { username });
      return response.data || {};
    } catch (error) {
      console.error('Update username error:', error);
      throw error;
    }
  },
  //resetPassword
  async resetPassword(email, password,phone) {
    try {
      const uri = "/api/users/resetPassword";
      const hashedPassword = md5(password);
      const response = await http.post(uri, { email, password: hashedPassword,phone });
      return response.data || {};
    } catch (error) {
      console.error('Reset password error:', error);
      throw error;
    }
  },
  
  logout() {
    localStorage.removeItem('access_token');
    localStorage.removeItem('lastSendTime');
    localStorage.removeItem('user');
    userStore.clear();
  },
  
  getCurrentUser() {
    const userStr = localStorage.getItem('user');
    if (userStr) {
      return JSON.parse(userStr);
    }
    return null;
  },
  
  isLoggedIn() {
    return !!localStorage.getItem('token');
  },

  //è¯·æ±‚è°·æ­Œ æ ¡éªŒ code
  async googleAuth(code, redirect_uri) {
    try {
      const uri = "/api/users/google-auth";
      const response = await http.post(uri, { code, redirect_uri });
      
      if (response.data && response.data.access_token) {
        localStorage.setItem('access_token', response.data.access_token);
        userStore.setUser(response.data.userInfo);
        // localStorage.setItem('user', JSON.stringify(response.data.user));
      }
      
      return response.data || {};
    } catch (error) {
      console.error('Google auth error:', error);
      throw error;
    }
  },
  //å‘é€çŸ­ä¿¡éªŒè¯ç 
  async sendSmsCode(phone) {
    const response = await http.post("/api/users/send-sms-code", {
      phone,
    });
    return response.data || {};
  },
};

export default service;


================================================
FILE: frontend/src/services/chat.js
================================================
import http from "@/utils/http.js";
let lastController = null;
const SHARE_TOKEN = import.meta.env.VITE_SHARE_TOKEN || '';

const service = {
  async list(modeType = 'task', agent_id = null) {
    const params = new URLSearchParams({ mode_type: modeType, agent_id: agent_id });
    const uri = `/api/conversation?${params.toString()}`;
    const res = await http.get(uri);
    return res || {};
  },
  async create(message, modeType = 'task', agent_id = null, model_id = null) {
    const uri = "/api/conversation";
    const response = await http.post(uri, {
      content: message,
      mode_type: modeType,
      agent_id: agent_id,
      model_id: model_id
    });
    return response || {};
  },
  //PATCH
  async update(conversationId, title = "") {
    const uri = `/api/conversation/${conversationId}`;
    const response = await http.put(uri, {
      title: title
    });
    return response || {};
  },
  // ä¿®æ”¹ä¼šè¯å¯è§æ€§
  async updateVisibility(conversationId, is_public) {
    const uri = `/api/conversation/visibility/${conversationId}`;
    const response = await http.put(uri, {
      is_public: is_public
    });
    return response || {};
  },
  async get(conversationId) {
    const uri = `/api/conversation/${conversationId}`;
    const response = await http.get(uri);
    return response || {};
  },
  async remove(conversationId) {
    const uri = `/api/conversation/${conversationId}`;
    const response = await http.del(uri);
    return response || {};
  },
  //query
  async query(query) {
    const uri = `/api/conversation/query`;
    const response = await http.post(uri, {
      query: query
    });
    return response || {};
  },
  //favorite
  async favorite(conversationId) {
    const uri = `/api/conversation/favorite`;
    const response = await http.post(uri, {
      conversation_id: conversationId
    });
    return response || {};
  },
  //unfavorite
  async unfavorite(conversationId) {
    const uri = `/api/conversation/unfavorite`;
    const response = await http.post(uri, {
      conversation_id: conversationId
    });
    return response || {};
  },
  async messageList(conversationId) {
    // å¦‚æœæœ‰ä¸Šä¸€ä¸ªè¯·æ±‚åœ¨è¿›è¡Œï¼Œç›´æ¥å–æ¶ˆ
    if (lastController) {
      console.log("cancel previous request");
      lastController.abort();
    }

    // åˆ›å»ºæ–°çš„ controller
    const controller = new AbortController();
    lastController = controller;

    const uri = `/api/message/list?conversation_id=${conversationId}`;
    let accessToken = localStorage.getItem('access_token');
    if (!accessToken && SHARE_TOKEN) {
      accessToken = SHARE_TOKEN;
    }
    try {
      const response = await fetch(uri, {
        method: "GET",
        signal: controller.signal,
        headers: {
          'Authorization': `Bearer ${accessToken}`
        }
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();
      console.log('response', data);
      return data.data || [];
    } catch (err) {
      if (err.name === "AbortError") {
        console.log("è¯·æ±‚è¢«ä¸»åŠ¨å–æ¶ˆ");
        return []; // å¯é€‰ï¼šå–æ¶ˆæ—¶è¿”å›ç©ºæ•°ç»„
      } else {
        throw err;
      }
    } finally {
      // åªæœ‰å½“å½“å‰çš„ controller è¿˜æ˜¯æœ€åä¸€æ¬¡çš„ï¼Œæ‰æ¸…æ‰
      if (lastController === controller) {
        lastController = null;
      }
    }
  },
  async stop(conversationId) {
    const uri = `/api/agent/stop`;
    const response = await http.post(uri, {
      conversation_id: conversationId
    });
    return response || {};
  },
  async stopCoding(conversationId) {
    const uri = `/api/agent/coding/stop`;
    const response = await http.post(uri, {
      conversation_id: conversationId
    });
    return response || {};
  },
  //chat stop stop_chat
  async stopChat(conversationId) {
    const uri = `/api/agent/stop_chat`;
    const response = await http.post(uri, {
      conversation_id: conversationId
    });
    return response || {};
  },

  //change chat 
  async changeChat(conversationId, pid, new_message_id) {
    const uri = `/api/agent/change`;
    const response = await http.post(uri, {
      conversation_id: conversationId,
      pid: pid,
      new_message_id: new_message_id
    });
    return response || {};
  },
  //localhost:3000/api/agent_store?page=1&page_size=20&order_by=create_at&order=DESC
  async agentStoreList(page = 1, page_size = 20, order_by = "create_at", order = "DESC", name) {
    const params = new URLSearchParams({ page: page, page_size: page_size, order_by: order_by, order: order, name: name });
    const uri = `/api/agent_store?${params.toString()}`;
    const res = await http.get(uri);
    return res || {};
  },
  // è·å–æ‰€æœ‰ agent çš„ id å’Œ nameï¼ˆä¸åˆ†é¡µï¼‰
  async agentStoreAll(name) {
    const params = new URLSearchParams();
    if (name) {
      params.append('name', name);
    }
    const uri = `/api/agent_store/all${params.toString() ? '?' + params.toString() : ''}`;
    const res = await http.get(uri);
    return res || {};
  },
  ///last/:agent_id
  async last(agent_id) {
    const uri = `/api/agent_store/last/${agent_id}`;
    const res = await http.get(uri);
    return res || {};
  },
  // var settings = {
  //   "url": "http://localhost:3000/api/agent_store/remix",
  //   "method": "POST",
  //   "data": JSON.stringify({
  //     "agent_id": 7
  //   }),
  // };
  async remix(agent_id) {
    const uri = `/api/agent_store/remix`;
    const res = await http.post(uri, {
      agent_id: agent_id
    });
    return res || {};
  },
  async userCaseList(page = 1, page_size = 20, order_by = "create_at", order = "DESC", name, agent_id) {
    const params = new URLSearchParams({ 
      page: page, 
      page_size: page_size, 
      order_by: order_by, 
      order: order,
      name: name || ''
    });
    
    // å¦‚æœæä¾›äº† agent_idï¼Œåˆ™æ·»åŠ åˆ°å‚æ•°ä¸­
    if (agent_id) {
      params.append('agent_id', agent_id);
    }
    
    const uri = `/api/user_case?${params.toString()}`;
    const res = await http.get(uri);
    return res || {};
  },
  // Twins conversation management
  async handleTwins(conversationId) {
    const uri = "/api/conversation/twins";
    const response = await http.post(uri, {
      conversation_id: conversationId
    });
    return response || {};
  },
  // è·å– twins conversation çš„ token ä¿¡æ¯
  async getTwinsTokens(conversationId) {
    const uri = `/api/conversation/twins/tokens/${conversationId}`;
    const response = await http.get(uri);
    return response || {};
  },
}

export default service;



================================================
FILE: frontend/src/services/default-model-setting.js
================================================
import http from '@/utils/http.js'


const service = {
    // è·å–å¯é€‰æ¨¡å‹ä¿¡æ¯
    async getModels() {
        const uri = `/api/model/enabled`
        const response = await http.get(uri)
        return response || {};
    },

    // è·å–ç±»å‹æ¨¡å‹ä¿¡æ¯
    async getModelBySetting() {
        const uri = `/api/default_model_setting`
        const response = await http.get(uri)
        return response || {};
    },
    //æ›´æ–°æ¨¡å‹
    async updateModel(data) {
        const uri = `/api/default_model_setting`
        const response = await http.put(uri, data)
        return response.data || {};
    },
    //api/default_model_setting/check
    async checkModel() {
        const uri = `/api/default_model_setting/check`
        const response = await http.get(uri)
        return response || {};
    },

}
export default service


================================================
FILE: frontend/src/services/editor.js
================================================
import http from "@/utils/http.js";

const uri = `/api/file/editor`;

const service = {
  // ä¿å­˜æ–‡ä»¶å†…å®¹å¹¶åˆ›å»ºç‰ˆæœ¬
  saveFile(data) {
    return http.put(`${uri}`, data);
  },

  // è¯»å–æ–‡ä»¶å†…å®¹
  readFile(data) {
    return http.post(`${uri}/read`, data);
  },

  // è·å–æ–‡ä»¶ç‰ˆæœ¬åˆ—è¡¨
  getVersions(data) {
    return http.post(`${uri}/versions`, data);
  },

  // è·å–ç‰¹å®šç‰ˆæœ¬çš„å†…å®¹
  getVersionContent(id) {
    return http.get(`${uri}/version/${id}`);
  },

  // åˆ‡æ¢åˆ°æŒ‡å®šç‰ˆæœ¬
  switchVersion(data) {
    return http.post(`${uri}/switch-version`, data);
  },

  // æ‰¹é‡æ“ä½œ
  async saveAndGetVersions(filepath, content, conversation_id) {
    const saveResult = await this.saveFile({
      path: filepath,
      content,
      conversation_id
    });

    if (saveResult.data.code === 0) {
      const versionsResult = await this.getVersions({
        conversation_id,
        filepath
      });
      return versionsResult;
    }
    return saveResult;
  }
};

export default service;


================================================
FILE: frontend/src/services/experience.js
================================================
import http from '@/utils/http.js'

const service = {
    async getExperienceByType(type) {
        const uri = `/api/experience/list`
        const params = {
            type: type
        }
        const response = await http.get(uri, params)
        return response || {};
    },
    async createExperience(params) {
        const uri = `/api/experience`
        const response = await http.post(uri, params)
        return response || {};
    },
    async updateExperience(params) {
        const uri = `/api/experience`
        const response = await http.put(uri, params)
        return response || {};
    },
    async deleteExperience(id) {
        const uri = `/api/experience`
        const params = {
            id: id
        }
        const response = await http.del(uri,params)
        return response || {};
    }
}

export default service


================================================
FILE: frontend/src/services/files.js
================================================
import http from "@/utils/http.js";

const service = {

  ///api/file/upload
  async uploadFile(formData) {
    const uri = `/api/file/upload`;
    return http.post(uri, formData);
  },
  ///api/file put
  async putFile(id, conversation_id) {
    const uri = `/api/file`;
    return http.put(uri, {
      id: id,
      conversation_id: conversation_id
    });
  },
  // delete
  async deleteFile(id, conversation_id) {
    let uri = `/api/file/delete/${id}`;
    if (conversation_id != null) {  // åˆ¤æ–­ä¸ä¸º null æˆ– undefined
      uri += `?conversation_id=${conversation_id}`;
    }
    return http.del(uri);
  },

  async getFileByPath(path) {
    const uri = `/api/file/editor/read`;
    return http.post(uri, {
      path: path
    });
  },
  async saveFileByPath(path, content, conversation_id) {
    const uri = `/api/file/editor`;
    return http.put(uri, {
      path: path,
      content: content,
      conversation_id: conversation_id
    });
  },
  async getFile(conversationId, file) {
    const uri = `/api/conversations/${conversationId}/files_manager/select-file?file=${file}`;
    // å¤„ç† access_token
    const accessToken = localStorage.getItem('access_token');
    const response = await fetch(uri, {
      headers: {
        'Authorization': `Bearer ${accessToken}`
      }
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const blob = await response.blob(); // è·å– blob æ•°æ®

    // æ‰“å°æ–‡ä»¶å†…å®¹å¹¶è§£æä¸ºå¯è¯»æ ¼å¼
    const fileContent = await this.parseFileContent(blob, file);

    return fileContent; // è¿”å›æ–‡ä»¶å†…å®¹
  },

  parseFileContent(blob, fileName) {
    return new Promise((resolve, reject) => {
      const fileType = blob.type;

      if (fileType.startsWith('text/') || fileType === 'application/octet-stream') {
        // å°è¯•è¯»å–ä¸ºæ–‡æœ¬
        const reader = new FileReader();
        reader.onload = () => {
          console.log(`File content of ${fileName}:`, reader.result);
          resolve(reader.result); // è¿”å›æ–‡æœ¬å†…å®¹
        };
        reader.onerror = () => {
          console.error('Error reading file:', reader.error);
          reject(reader.error); // è¿”å›é”™è¯¯ä¿¡æ¯
        };
        reader.readAsText(blob); // å¼ºåˆ¶è¯»å–ä¸ºæ–‡æœ¬
      } else if (fileType.startsWith('image/')) {
        // å›¾ç‰‡æ–‡ä»¶å¤„ç†é€»è¾‘
        const imageUrl = URL.createObjectURL(blob);
        console.log(`Image URL of ${fileName}:`, imageUrl);
        resolve(imageUrl); // è¿”å›å›¾ç‰‡çš„ URL
      } else {
        console.log(`Unsupported file type: ${fileType}`);
        resolve(null); // ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹è¿”å› null
      }
    });
  }
};

export default service;


================================================
FILE: frontend/src/services/knowledge.js
================================================
import http from "@/utils/http.js";

const uri = `/api/knowledge`;

const service = {
  //æ–°å¢ content = '', category = '', agent_id
  create(content, category, agent_id){
    return http.post(uri, {
      content,
      category,
      agent_id
    });
  },
  //è·å– agent_id
  getList(agent_id){
    return http.get(uri, {
      agent_id
    });
  },
  //è·å–å•ä¸ª /detail/:id
  getById(id){
    return http.get(`${uri}/detail/${id}`);
  },
  //æ›´æ–° /:id
  update(id, content, category){
    return http.put(`${uri}/${id}`, {
      content,
      category
    });
  },
  //åˆ é™¤ /:id
  delete(id){
    return http.del(`${uri}/${id}`);
  },
  //è·å– category åˆ—è¡¨
  getCategoryList(){
    return http.get(`/api/knowledge/categories`);
  }
};

export default service;


================================================
FILE: frontend/src/services/mcp.js
================================================
import http from "@/utils/http.js";

const service = {
  connect(server){
    const uri = `/api/mcp_server/connect`;
    return http.post(uri, server);
  },
  activate_servers(){
    const uri = `/api/mcp_server/active`;
    return http.get(uri);
  }
};

export default service;


================================================
FILE: frontend/src/services/membership.js
================================================
import http from '@/utils/http.js'

const service = {
  async getList() {
    const uri = '/api/membership_plan/list'
    const res = await http.get(uri)
    return res
  },

  ///api/payment/create_mambership_plan_order
  async createOrder(planId) {
    const uri = '/api/payment/create_mambership_plan_order'
    const res = await http.post(uri, {
      membership_plan_id: planId
    })
    return res
  },
  //create_point_purchase_order
  async createPointPurchaseOrder(product_id) {
    const uri = '/api/payment/create_point_purchase_order'
    const res = await http.post(uri, {
      product_id: product_id
    })
    return res
  },

  ///strip/create_point_purchase_order
  async createStripeOrder(planId) {
    const uri = '/api/payment/strip/create_mambership_plan_order'
    const res = await http.post(uri, {
      membership_plan_id:planId,
      from_client: "web"
    })
    return res
  },
  //stripe/create_point_purchase_order
  async createStripePointPurchaseOrder(product_id) {
    const uri = '/api/payment/strip/create_point_purchase_order'
    const res = await http.post(uri, {
      product_id: product_id,
      from_client: "web"
    })
    return res
  },
  ///strip/checkout-session
  async createStripeCheckoutSession(sessionId) {
    const uri = '/api/payment/strip/checkout-session'
    const res = await http.get(uri, {
      session_id: sessionId
    })
    return res
  },
  ////check_order_status?order_sn
  async checkOrderStatus(orderSn) {
    const uri = '/api/payment/check_order_status'
    const res = await http.get(uri, {
      order_sn: orderSn
    })
    return res
  },
  //check_order_status_by_id
  async checkOrderStatusById(orderId) {
    const uri = '/api/payment/check_order_status_by_id'
    const res = await http.get(uri, {
      order_id: orderId
    })
    return res
  },
  //points_transaction
  async getPointsTransactionList(Query) {
    const uri = '/api/points_transaction/list'
    const res = await http.get(uri,Query)
    return res
  },
  //order list
  async getOrderList(Query) {
    const uri = '/api/order/list'
    const res = await http.get(uri,Query)
    return res
  },
  //recharge_product/list
  async getRechargeProductList() {
    const uri = '/api/recharge_product/list'
    const res = await http.get(uri)
    return res
  },
  //get_subscription_info
  async getSubscriptionInfo() {
    const uri = '/api/payment/strip/get_subscription_info'
    const res = await http.get(uri)
    return res
  },
  //strip/cancel_subscription
  async cancelSubscription(params) {
    const uri = '/api/payment/strip/cancel_subscription'
    const res = await http.post(uri,params)
    return res
  },
  //strip/reactivate_subscription
  async reactivateSubscription(params) {
    const uri = '/api/payment/strip/reactivate_subscription'
    const res = await http.post(uri,params)
    return res
  },
  //upgrade_subscription
  async upgradeSubscription(params) {
    const uri = '/api/payment/strip/upgrade_subscription'
    const res = await http.post(uri,params)
    return res
  },
  //downgrade_subscription
  async downgradeSubscription(params) {
    const uri = '/api/payment/stripe/downgrade_subscription'
    const res = await http.post(uri,params)
    return res
  },

  //stripe/cancel_downgrade
  async cancelDowngrade(params) {
    const uri = '/api/payment/stripe/cancel_downgrade'
    const res = await http.post(uri,params)
    return res
  },

  //strip/preview_upgrade
  async previewUpgrade(params) {
    const uri = '/api/payment/strip/preview_upgrade'
    const res = await http.post(uri,params)
    return res
  },

  //create_membership_upgrade_order
  async createMembershipUpgradeOrder(params) {
    const uri = '/api/payment/create_membership_upgrade_order'
    const res = await http.post(uri,params)
    return res
  },

  //stripe/payment_failure_reason - æŸ¥è¯¢æ”¯ä»˜å¤±è´¥åŸå› 
  async getPaymentFailureReason(subscriptionId) {
    const uri = '/api/payment/stripe/payment_failure_reason'
    const res = await http.get(uri, {
      subscription_id: subscriptionId
    })
    return res
  },

  //stripe/debug_subscription - è°ƒè¯•è®¢é˜…çŠ¶æ€
  async debugSubscription(subscriptionId = null) {
    const uri = '/api/payment/stripe/debug_subscription'
    const params = subscriptionId ? { subscription_id: subscriptionId } : {}
    const res = await http.get(uri, params)
    return res
  },

  //stripe/cleanup_pending_items - æ¸…ç† pending InvoiceItems
  async cleanupPendingItems() {
    const uri = '/api/payment/stripe/cleanup_pending_items'
    const res = await http.post(uri, {})
    return res
  },

  //stripe/reset_customer_balance - é‡ç½®å®¢æˆ·ä½™é¢
  async resetCustomerBalance() {
    const uri = '/api/payment/stripe/reset_customer_balance'
    const res = await http.post(uri, {})
    return res
  },
  
}

export default service


================================================
FILE: frontend/src/services/message.js
================================================
import { v4 as uuid } from 'uuid';
import i18n from '@/locals';

let messageStatus = "running";
// å¤„ç†æ¶ˆæ¯
function handleMessage(message, messages) {
    if (message.meta && typeof message.meta === 'string') {
        message.meta = JSON.parse(message.meta);
    }

    if(message.meta.action_type == ""){
        return
    }

    if (!message.meta || !message.meta.action_type) {
        return messages.push(message);
    }

    const { action_type } = message.meta;
    console.log("handleMessage", message)
    if (messageStatus == "stop" && action_type != "question" && action_type != "auto_reply") {
        return
    }

    switch (action_type) {
        case "chat":
            return handleChatMessage(message, messages);
        case "auto_reply":
            messageStatus = "running"
            return handleAutoReply(message, messages);
        case "plan":
            return handlePlan(message, messages);
        case "question":
            messageStatus = "running"
            return handleQuestion(message, messages);
        case "finish_summery":
        case 'progress':
        case 'coding':
            return handleFinishSummaryAddId(message, messages);
        case "stop":
            return handleStop(message, messages);
        case "error":
            return handleStop(message, messages);
        case "finish":
            return
        case "task":
            return updateTask(message, messages);

        default:
            // é»˜è®¤ä¹Ÿæ‰§è¡Œæ›´æ–°ä»»åŠ¡
            return updateAction(message, messages);
    }
}

function handleStop(message, messages) {
    messages.push(message);
    // messageStatus = "stop";
    console.log('handleStop', messages);
    //æ‰¾åˆ° meta.action_type æ˜¯ plan çš„
    //åˆ é™¤ action_type : "update_status"
    for (let i = messages.length - 1; i >= 0; i--) {
        if (messages[i].meta?.action_type === "update_status") {
            messages.splice(i, 1); // åŸåœ°åˆ é™¤å…ƒç´ 
        }
    }
    messages.forEach((message) => {
        if (message.meta?.action_type === 'plan') {
            // // ç¡®ä¿ meta.json å­˜åœ¨ä¸”æ˜¯æ•°ç»„
            if (Array.isArray(message.meta.json)) {
                // éå† meta.json
                message.meta.json.forEach((jsonItem) => {
                    if (jsonItem.status == "running") {
                        jsonItem.status = "success"
                    }
                    let actions = jsonItem.actions;
                    if (actions?.length > 0) {
                        actions.forEach(action => {
                            if (action.status == "running") {
                                action.status = "success"
                            }
                        })
                    }
                })
            }
        }
        return message
    })
    return
}
function handleFinishSummaryAddId(message, messages) {
    let fileList = message.meta.json;
    for (let i = 0; i < fileList.length; i++) {
        const element = fileList[i];
        element.id = uuid()
    }
    // console.log('fileList by id',fileList);
    messages.push(message);

}
// åˆ æ‰ä¸´æ—¶message update_status
function deleteTempMessage(messages) {
    //!message.is_temp && message.meta.action_type !== "update_status" åˆ é™¤
    for (let i = messages.length - 1; i >= 0; i--) {
        const message = messages[i];
        if (message?.meta?.action_type == "update_status") {
            messages.splice(i, 1);
        }
    }
}

function handlePlan(message, messages) {
    deleteTempMessage(messages);
    console.log('plan', message);
    //å°†ç¬¬ä¸€taskçš„ä»»åŠ¡è®¾ç½®ä¸ºå¼€å§‹
    // item.is_collapse = true
    message.meta.json.forEach(item => {
        item.is_collapse = true
    });
    message.meta.json[0].status = 'running';
    messages.push(message);
    //update_status
}

//å¤„ç†è‡ªåŠ¨å›å¤
function handleAutoReply(message, messages) {
    messages.push(message);
    //update_status
    messages.push(
        {
            content: i18n.global.t('lemon.message.botInitialPlan'),
            role: 'assistant',
            is_temp: true,
            meta: {
                action_type: "update_status",
            },
        }
    )
}
function handleChatMessage(message, messages) {
    console.log('handleChatMessage', message);
    messages.push(message);
}

//å¤„ç†question
function handleQuestion(message, messages) {
    console.log('handleQuestion', message);
    //åˆ¤æ–­ messages ä¸­ æœ‰æ²¡æœ‰  role: 'user', is_temp: true, çš„æ•°æ® å¦‚æœæœ‰åˆ™æ›¿æ¢ å¦‚æœæ²¡æœ‰ åˆ™æ·»åŠ 
    let user_message_index = messages.findLastIndex(messageInfo => messageInfo.role === 'user' && messageInfo.is_temp);
    if (user_message_index !== -1) {
        messages[user_message_index] = message;
        messages[user_message_index].files = message.meta.json;
    } else {
        messages.push(message);
    }
}

//æ›´æ–°ä»»åŠ¡
function updateTask(message, messages) {
    const task_id = message.meta.task_id;
    //æ ¹æ® task_id æ‰¾åˆ°å¯¹åº”çš„ä»»åŠ¡
    //ç¬¬ä¸€æ­¥ æ‰¾åˆ° plan_message 
    let plan_message_index = messages.findLastIndex(messageInfo => messageInfo.meta && messageInfo.meta.action_type === 'plan');
    //è·å– plan çš„ actions
    let plan = messages[plan_message_index];

    //æ ¹æ®plan çš„ json æ‰¾åˆ°å½“å‰çš„task

    let task_index = plan.meta.json.findIndex(task => task.id === task_id);
    // console.log('task_index',task_index);
    if (task_index !== -1) {
        // console.log('plan.meta.json[task_index]',plan.meta.json[task_index]);
        plan.meta.json[task_index].status = message.meta.json.status || message.status;
        plan.meta.json[task_index].meta = message.meta;

        //å¦‚æœtask çš„ status ä¸º failure åˆ™æ›¿æ¢
        let status = message.meta.json.status || message.status;
        if (status === 'failure') {
            //å°†å½“å‰task  let actions = plan.meta.json[task_index].actions; 
            let actions = plan.meta.json[task_index].actions || [];
            //åˆ é™¤ çŠ¶æ€ä¸º running çš„ä»»åŠ¡
            actions = actions.filter(action => action.status !== 'running');
            plan.meta.json[task_index].actions = actions;
        }
        //åªæœ‰ä»»åŠ¡æˆåŠŸäº† æ‰æ‰§è¡Œä¸‹ä¸€ä¸ªtask å¦‚æœå¤±è´¥äº† åˆ™ä¸æ‰§è¡Œä¸‹ä¸€ä¸ªtask
        if (status === 'success' || status === 'completed') {
            //æ‰¾åˆ°ä¸‹ä¸€ä¸ªtask
            if (plan.meta.json[task_index + 1]) {
                plan.meta.json[task_index + 1].status = 'running';
            }
        }
    }
}


// æ›´æ–° action
function updateAction(message, messages) {
    const task_id = message.meta.task_id;
    const uuid = message.uuid;

    if (message.meta.action_type === 'terminal_run') {
        message.content = [message.content]
    }

    //ç¬¬ä¸€æ­¥ æ‰¾åˆ° plan_message 
    let plan_message_index = messages.findLastIndex(messageInfo => messageInfo.meta && messageInfo.meta.action_type === 'plan');
    //è·å– plan çš„ actions
    let plan = messages[plan_message_index];

    //æ ¹æ®plan çš„ json æ‰¾åˆ°å½“å‰çš„task

    let task_index = plan.meta.json.findIndex(task => task.id === task_id);

    //å¦‚æœtask_index ä¸º -1 åˆ™æŸ¥è¯¢å½“å‰  status:"pending"
    if (task_index === -1) {
        task_index = plan.meta.json.findIndex(task => task.status === 'running');
        if (task_index === -1) {
            task_index = Math.max(0, plan.meta.json.length - 1);
        }
    }

    if (!plan.meta.json[task_index].actions) {
        plan.meta.json[task_index].actions = [];
    }
    let actions = plan.meta.json[task_index].actions;

    //åˆ¤æ–­å½“å‰uuid åœ¨ actions ä¸­æ˜¯å¦å­˜åœ¨ å¦‚æœå­˜åœ¨åˆ™æ›´æ–°çŠ¶æ€ å¦‚æœä¸å­˜åœ¨åˆ™æ·»åŠ 
    let action_index = actions.findIndex(action => action.uuid === uuid);
    //  console.log('action_index',action_index);
    if (action_index !== -1) {
        actions[action_index].status = message.status;
        actions[action_index].meta = message.meta;
        console.log('message.action_type', message.meta.action_type)
        if (message.meta.action_type === 'terminal_run') {
            actions[action_index].content = [actions[action_index].content[0], message.content[0]];
        }
        if (message.meta.action_type === 'mcp_tool') {
            actions[action_index].meta.content = message.content
        }
    } else {
        actions.push(message);
    }

}

export default {
    handleMessage
}


================================================
FILE: frontend/src/services/platforms.js
================================================
[Binary file]


================================================
FILE: frontend/src/services/resume.js
================================================
import http from "@/utils/http.js";

const service = {
  async uploadFile(form) {
    const uri = "/chain/api/resume/upload";
    const res = await http.post(uri, form, {
      "Content-Type": "multipart/form-data"
    });
    return res.data || {};
  }
}

export default service;


================================================
FILE: frontend/src/services/search-engine.js
================================================
import http from "@/utils/http";


const service = {
    async getSearchEngineConfig() {
        const url = "/api/search_provider_setting"
        const response = await http.get(url)
        return response || {}
    },
    async getSearchEngineTemplates() {
        const url = "/api/search_provider_setting/templates"
        const response = await http.get(url)
        return response || {} 
    },
    async getSearchEngineConfigs() {
        const url = "/api/search_provider_setting/configs"
        const response = await http.get(url)
        return response || {} 
    },
    async updateSearchEngineConfig(config) {
        const url = "/api/search_provider_setting/"
        const response = await http.put(url, config)
        return response.data || {}
    },
    async checkSearchProvider(config) {
        const url = "/api/search_provider_setting/check_search_provider"
        const response = await http.post(url, config)
        return response || {}
    },
    //<span>/api<wbr>/search_provider_setting<wbr>/check_search_provider</span>
}

export default service;






================================================
FILE: frontend/src/services/see-agent.js
================================================
//å¼•ç”¨sse
import sse from '@/services/sse';
import fileServices from '@/services/files';
import { useChatStore } from '@/store/modules/chat';
import messageFun from './message';
import userService from '@/services/auth'
import chatService from '@/services/chat'

import { storeToRefs } from 'pinia';
import { useUserStore } from '@/store/modules/user.js'
const userStore = useUserStore();
const { user, membership, points } = storeToRefs(userStore);
import { v4 as uuid } from 'uuid';
import i18n from '@/locals';


// è·å–ç”¨æˆ·ä¿¡æ¯ getUserInfo
async function getUserInfo() {
    // æ£€æŸ¥ access_tokenï¼Œå¦‚æœæ²¡æœ‰åˆ™ä¸è°ƒç”¨æ¥å£
    const access_token = localStorage.getItem('access_token');
    if (!access_token) {
        return;
    }

    // is_subscribe
    // è·å–ç¼“å­˜ä¸­çš„ model_info
    const model_info = localStorage.getItem('model_info');
    if (model_info) {
        const model = JSON.parse(model_info);
        if (!model.is_subscribe) {
            //ä¸è°ƒç”¨æ¥å£
            return;
        }
    }
    let res = await userService.getUserInfo();
    //è®¾ç½®ç¼“å­˜
    membership.value = res.membership;
    points.value = res.points;
}

const chatStore = useChatStore();
const { chatInfo, messages, mode, model_id, agent } = storeToRefs(chatStore)
//å¤„ç†files çš„ conversation_id
const fileConversationId = async (files, conversation_id) => {
    //putFile
    files.forEach(async (file) => {
        await fileServices.putFile(file.id, conversation_id)
    });
};

const onOpenStream = (pending) => {
    pending = true;
};

const throttledScrollToBottom = () => {
    console.log('throttledScrollToBottom');
};

let pending = false;

async function sendMessage(question, conversationId, files, mcp_server_ids = [], workMode = "auto") {
    console.log('sendMessage ======> å¼€å§‹è°ƒç”¨  run.js');
    if (workMode == "twins") {
        return await sendTwinsMessage(question, conversationId, files, mcp_server_ids);
    }
    const abortController = new AbortController();
    let fileIds = files.map(file => file.id);
    //åˆ¤æ–­å½“å‰ä¼šè¯æ˜¯å¦å­˜åœ¨
    let chat = chatStore.list.find((c) => c.conversation_id == conversationId);
    if (chat) {
        //ä¿®æ”¹çŠ¶æ€
        chat.status = 'running';
    }
    //åˆå§‹åŒ–ç¬¬ä¸€æ¡æ¶ˆæ¯
    chatStore.handleInitMessage(question, files);
    let baseURL = ""
    //åˆ¤æ–­æ˜¯ä¸æ˜¯å¼€å‘ç¯å¢ƒ
    if (import.meta.env.DEV) {
        baseURL = ""
    } else {
        baseURL = import.meta.env.VITE_SERVICE_URL || 'http://localhost:3000';
    }
    let uri = `${baseURL}/api/agent/run`;
    let options = {
        question: question,
        conversation_id: conversationId,
        fileIds,
        mcp_server_ids,
        agent_id: agent.value.id,
        model_id: model_id.value,
        mode: workMode
    };

    console.log("mode.value", mode.value)
    console.log("chatInfo.value", chatInfo.value)
    let pending = false;
    let currentMode = null; // ç”¨äºè®°å½•å½“å‰æµçš„æ¨¡å¼

    const onTokenStream = (answer, ch, conversationId) => {
        let chat = chatStore.list.find((c) => c.conversation_id == conversationId);
        if (chat && chat.status === 'done') {
            return;
        }

        const currentConversationId = chatStore.conversationId
        // console.log('onTokenStream', ch)

        // æ£€æŸ¥æ˜¯å¦æ˜¯æ¨¡å¼æ ‡è¯†
        if (ch.startsWith('__lemon_mode__')) {
            try {
                const modeStr = ch.substring('__lemon_mode__'.length);
                const modeData = JSON.parse(modeStr);
                currentMode = modeData.mode;
                // console.log('Stream mode detected:', currentMode);

                // æ‰¾åˆ°æœ€åä¸€æ¡ role: 'assistant' ä¸” is_temp: true çš„æ¶ˆæ¯
                const lastTempAssistantIndex = chatStore.messages.findLastIndex(
                    msg => msg.role === 'assistant' && msg.is_temp === true
                );
                console.log('lastTempAssistantIndex', lastTempAssistantIndex);
                if (lastTempAssistantIndex !== -1) {
                    const lastTempMessage = chatStore.messages[lastTempAssistantIndex];
                    if (currentMode == "chat") {
                        lastTempMessage.meta = { "action_type": "chat" };
                        lastTempMessage.content = "";
                    } else {
                        lastTempMessage.content = i18n.global.t('lemon.message.botInitialResponse');
                    }
                } else {
                    // å¦‚æœæ²¡æœ‰æ‰¾åˆ°ï¼Œåˆ™åˆ›å»ºæ–°çš„æ¶ˆæ¯
                    console.log('No temp assistant message found, creating a new one...');
                    if (currentMode == "chat") {
                        const bot_message = {
                            content: "",
                            role: 'assistant',
                            meta: { "action_type": "chat" },
                            is_temp: true,
                        }
                        chatStore.messages.push(bot_message);
                    } else {
                        const bot_message = {
                            content: i18n.global.t('lemon.message.botInitialResponse'),
                            role: 'assistant',
                            is_temp: true,
                        }
                        chatStore.messages.push(bot_message);
                    }
                }
                return;
            } catch (e) {
                console.error('Failed to parse mode data:', e);
                return;
            }
        }

        // æ ¹æ®å½“å‰æ¨¡å¼å¤„ç†æ•°æ®
        if (currentMode === 'chat') {
            updateChatToken(ch);
        } else if (currentMode === 'agent') {
            if (ch && ch.startsWith('{') && ch.endsWith('}')) {
                if (currentConversationId === conversationId) {
                    update(ch, conversationId);
                }
            }
        }
    }

    const answer = '';

    sse(uri, options, onTokenStream, onOpenStream(pending), answer, throttledScrollToBottom, abortController, conversationId).then((res) => {
        return res;
    }).catch((error) => {
        console.error(error);
        return '';
    }).finally(() => {
        chatStore.list.find((c) => c.conversation_id == conversationId).status = 'done';
        getUserInfo();
    });

}

// Chat æ¨¡å¼ sendMessage



async function sendChatMessage(question, conversationId, agentConversationId, files, mcp_server_ids = [], workMode = "chat", testMode = false, testDataStream = []) {
    const abortController = new AbortController();
    let  fileIds = files.map(file => file.id);
    // ç›´æ¥æ›´æ–° twinsConversationList ä¸­çš„çŠ¶æ€ï¼ˆconversationId å°±æ˜¯ twins_idï¼‰
    const twinsInfo = chatStore.twinsConversationList[conversationId] || { status: 'done', input_tokens: 0, output_tokens: 0, total: 0 };
    twinsInfo.status = 'running';
    chatStore.twinsConversationList[conversationId] = twinsInfo;
    //åˆå§‹åŒ–ç¬¬ä¸€æ¡æ¶ˆæ¯
    chatStore.handleInitTwinsMessage(question, files);
    let baseURL = ""
    //åˆ¤æ–­æ˜¯ä¸æ˜¯å¼€å‘ç¯å¢ƒ
    if (import.meta.env.DEV) {
        baseURL = ""
    } else {
        baseURL = import.meta.env.VITE_SERVICE_URL || 'http://localhost:3000';
    }
    let uri = `${baseURL}/api/agent/run`;
    let options = {
        question: question,
        conversation_id: conversationId,
        fileIds,
        mcp_server_ids,
        agent_id: agent.value.id,
        model_id: model_id.value,
        mode: workMode
    };
    let pending = false;
    let currentMode = null; // ç”¨äºè®°å½•å½“å‰æµçš„æ¨¡å¼

    const onTokenStream = (answer, ch, conversationId, agentConversationId) => {
        // æ£€æŸ¥ twinsConversationList ä¸­çš„çŠ¶æ€ï¼ˆconversationId å°±æ˜¯ twins_idï¼‰
        const twinsInfo = chatStore.twinsConversationList[conversationId];
        if (twinsInfo && twinsInfo.status === 'done') {
            return;
        }
        // å¦‚æœçŠ¶æ€ä¸å­˜åœ¨ï¼Œå¯èƒ½æ˜¯æ–°åˆ›å»ºçš„ twins ä¼šè¯ï¼Œç»§ç»­æ‰§è¡Œ
        // console.log('onTokenStream', ch)

        // è§£ææ¨¡å¼
        if (ch.startsWith('__lemon_mode__')) {
            try {
                const modeStr = ch.substring('__lemon_mode__'.length);
                const modeData = JSON.parse(modeStr);
                currentMode = modeData.mode;
                console.log('Stream mode detected:', currentMode);

                // æ‰¾åˆ°æœ€åä¸€æ¡ role: 'assistant' ä¸” is_temp: true çš„æ¶ˆæ¯
                const lastTempAssistantIndex = chatStore.twinsChatMessages.findLastIndex(
                    msg => msg.role === 'assistant' && msg.is_temp === true
                );
                console.log('lastTempAssistantIndex', lastTempAssistantIndex);
                if (lastTempAssistantIndex !== -1) {
                    const lastTempMessage = chatStore.twinsChatMessages[lastTempAssistantIndex];
                    if (currentMode == "chat") {
                        lastTempMessage.meta = { "action_type": "chat" };
                        lastTempMessage.content = "";
                    } else {
                        lastTempMessage.content = i18n.global.t('lemon.message.botInitialResponse');
                    }
                } else {
                    // å¦‚æœæ²¡æœ‰æ‰¾åˆ°ï¼Œåˆ™åˆ›å»ºæ–°çš„æ¶ˆæ¯
                    console.log('No temp assistant message found, creating a new one...');
                    if (currentMode == "chat") {
                        const bot_message = {
                            content: "",
                            role: 'assistant',
                            meta: { "action_type": "chat" },
                            is_temp: true,
                        }
                        chatStore.twinsChatMessages.push(bot_message);
                    }
                }
                return;
            } catch (e) {
                console.error('Failed to parse mode data:', e);
                return;
            }
        }
        console.log('Twins Chat Test Info ==> currentMode', currentMode)
        console.log('Twins Chat Test Info ==> chatStore.chat', chatStore.chat)
        console.log('Twins Chat Test Info ==> chatStore.chat.twins_id', chatStore.chat.twins_id)
        console.log('Twins Chat Test Info ==> conversationId', conversationId)
        console.log('Twins Chat Test Info ==> agentConversationId', agentConversationId)
        console.log('Twins Chat Test Info ==> chatStore.chat.conversation_id', chatStore.chat.conversation_id)
        // æ ¹æ®å½“å‰æ¨¡å¼å¤„ç†æ•°æ®
        if (currentMode === 'chat') {
            //conversationId åˆ¤æ–­è¿™ä¸ª conversationId æ˜¯ä¸æ˜¯å½“å‰  conversation çš„ 
            if (chatStore.chat.conversation_id !== agentConversationId) { return; }
            console.log("======> æ¸²æŸ“ <======= ch",ch);
            updateTwinsChatToken(ch);
        }
    }

    const answer = '';

    // æµ‹è¯•æ¨¡å¼ï¼šä½¿ç”¨é¢„å®šä¹‰çš„æ•°æ®æµæ¨¡æ‹Ÿæµå¼å“åº”
    if (testMode && testDataStream.length > 0) {
        console.log('=== æµ‹è¯•æ¨¡å¼å¯åŠ¨ ===');
        console.log('æ•°æ®æµåˆ—è¡¨:', testDataStream);

        // Base64 è§£ç è¾…åŠ©å‡½æ•° (ä¸ sse.js ä¸­çš„è§£ç æ–¹å¼ä¿æŒä¸€è‡´ï¼Œæ”¯æŒ UTF-8 ä¸­æ–‡)
        const decodeBase64 = (encodedString) => {
            try {
                const decodedString = decodeURIComponent(
                    atob(encodedString)
                        .split("")
                        .map(function (char) {
                            return "%" + ("00" + char.charCodeAt(0).toString(16)).slice(-2);
                        })
                        .join("")
                );
                return decodedString;
            } catch (e) {
                console.error('Base64è§£ç å¤±è´¥:', e);
                return encodedString; // å¦‚æœè§£ç å¤±è´¥ï¼Œè¿”å›åŸå­—ç¬¦ä¸²
            }
        };

        // æ£€æµ‹æ˜¯å¦ä¸º Base64 ç¼–ç 
        const isBase64 = (str) => {
            // Base64 å­—ç¬¦ä¸²çš„ç‰¹å¾ï¼šåªåŒ…å« A-Z, a-z, 0-9, +, /, = ä¸”é•¿åº¦æ˜¯4çš„å€æ•°
            const base64Regex = /^[A-Za-z0-9+/]*={0,2}$/;
            return base64Regex.test(str) && str.length % 4 === 0;
        };

        // æ¨¡æ‹Ÿæµå¼è¿”å›
        const simulateStream = async () => {
            for (let i = 0; i < testDataStream.length; i++) {
                const data = testDataStream[i];
                // æ¨¡æ‹Ÿå»¶è¿Ÿï¼ˆå¯ä»¥æ ¹æ®éœ€è¦è°ƒæ•´ï¼‰
                await new Promise(resolve => setTimeout(resolve, data.delay || 50));

                // å¤„ç†å†…å®¹ï¼šè‡ªåŠ¨æ£€æµ‹å¹¶è§£ç  Base64
                let content = data.content;
                if (data.isBase64 || (typeof content === 'string' && isBase64(content) && content.length > 20)) {
                    const decoded = decodeBase64(content);
                    console.log(`[${i + 1}/${testDataStream.length}] Base64è§£ç :`, content, '->', decoded);
                    content = decoded;
                }

                // è°ƒç”¨ onTokenStream å›è°ƒ
                onTokenStream(answer, content, conversationId);
                console.log(`[${i + 1}/${testDataStream.length}] å·²å‘é€:`, content);
            }
        };

        simulateStream().then(() => {
            console.log('=== æµ‹è¯•æ¨¡å¼å®Œæˆ ===');
            return '';
        }).catch((error) => {
            console.error('æµ‹è¯•æ¨¡å¼é”™è¯¯:', error);
            return '';
        }).finally(async () => {
            // æ›´æ–° twins conversation çš„ token ä¿¡æ¯
            try {
                const tokenInfo = await chatService.getTwinsTokens(conversationId);
                if (tokenInfo) {
                    const twinsInfo = chatStore.twinsConversationList[conversationId] || { status: 'done', input_tokens: 0, output_tokens: 0, total: 0 };
                    twinsInfo.input_tokens = tokenInfo.input_tokens || 0;
                    twinsInfo.output_tokens = tokenInfo.output_tokens || 0;
                    twinsInfo.total = tokenInfo.total || 0;
                    twinsInfo.status = 'done';
                    chatStore.twinsConversationList[conversationId] = twinsInfo;
                    console.log('Updated twins token info:', conversationId, twinsInfo);
                }
            } catch (error) {
                console.error('Error updating twins token info:', error);
            }

            getUserInfo();
        });
        return;
    }

    // æ­£å¸¸æ¨¡å¼ï¼šè°ƒç”¨çœŸå®çš„ SSE æ¥å£
    sse(uri, options, onTokenStream, onOpenStream(pending), answer, throttledScrollToBottom, abortController, conversationId, agentConversationId).then((res) => {
        return res;
    }).catch((error) => {
        console.error(error);
        return '';
    }).finally(async () => {
        // æ›´æ–° twins conversation çš„ token ä¿¡æ¯
        try {
            const tokenInfo = await chatService.getTwinsTokens(conversationId);
            if (tokenInfo) {
                const twinsInfo = chatStore.twinsConversationList[conversationId] || { status: 'done', input_tokens: 0, output_tokens: 0, total: 0 };
                twinsInfo.input_tokens = tokenInfo.input_tokens || 0;
                twinsInfo.output_tokens = tokenInfo.output_tokens || 0;
                twinsInfo.total = tokenInfo.total || 0;
                twinsInfo.status = 'done';
                chatStore.twinsConversationList[conversationId] = twinsInfo;
                console.log('Updated twins token info:', conversationId, twinsInfo);
            }
        } catch (error) {
            console.error('Error updating twins token info:', error);
        }

        getUserInfo();
    });
}

//Twins æ¨¡å¼ sendMessage
async function sendTwinsMessage(question, conversationId, files, mcp_server_ids = []) {
    try {
        // ç¬¬ä¸€æ­¥ æ ¹æ® conversationId æŸ¥è¯¢å½“å‰ conversation çš„ twins_idï¼Œå¦‚æœæ²¡æœ‰åˆ™åˆ›å»º twins conversation
        const twinsResult = await chatService.handleTwins(conversationId);

        if (twinsResult) {
            const chatConversationId = twinsResult.conversation_id;
            //æ›´æ–° let chat = chatStore.list.find((c) => c.conversation_id == conversationId);
            let chat = chatStore.list.find((c) => c.conversation_id == conversationId);
            console.log('Twins Test Info => twinsResult :', chat);
            if (chat) {
                chat.twins_id = chatConversationId;
                if (chatStore.chat.conversation_id == conversationId) {
                    chatStore.chat.twins_id = chatConversationId;
                }
            }
            // ç¬¬äºŒæ­¥ Twins æ¨¡å¼ ä¸‹ ä¼šåŒæ—¶è¯·æ±‚ agent å’Œ chat ,ä¸¤ä¸ªåˆ†åˆ«ç”¨è‡ªå·±çš„ conversationId
            // agent çš„è¯·æ±‚ å‚è€ƒ sendMessage - ä½¿ç”¨ä¼ å…¥çš„ conversationId
            const agentPromise = sendMessage(question, conversationId, files, mcp_server_ids, "task");

            // chat çš„è¯·æ±‚ ä½¿ç”¨å°è£…çš„ sendChatMessage æ–¹æ³• - ä½¿ç”¨ twins conversation ID
            const chatPromise = sendChatMessage(question, chatConversationId, conversationId, files, mcp_server_ids, "chat");

            // åŒæ—¶æ‰§è¡Œä¸¤ä¸ªè¯·æ±‚
            const [agentResult, chatResult] = await Promise.all([agentPromise, chatPromise]);

            return {
                agent: agentResult,
                chat: chatResult,
                agentConversationId: conversationId,
                chatConversationId: chatConversationId
            };
        } else {
            throw new Error('Failed to handle twins conversation');
        }
    } catch (error) {
        console.error('Error in sendTwinsMessage:', error);
        throw error;
    }
}

// é‡æ–°å›ç­” re_chat

async function reAnswer(pid, content, conversationId, assistantKey) {
    console.log("reAnswer", pending)
    if (pending) return;
    pending = true;

    let chat = chatStore.list.find((c) => c.conversation_id == conversationId);
    if (chat) {
        //ä¿®æ”¹çŠ¶æ€
        chat.status = 'running';
    }

    const abortController = new AbortController();

    let baseURL = ""
    //åˆ¤æ–­æ˜¯ä¸æ˜¯å¼€å‘ç¯å¢ƒ
    if (import.meta.env.DEV) {
        baseURL = ""
    } else {
        baseURL = import.meta.env.VITE_SERVICE_URL || 'http://localhost:3000';
    }

    let uri = `${baseURL}/api/agent/re_chat`;
    let options = {
        pid,
        conversation_id: conversationId,
        model_id: model_id.value
    };

    const onTokenStream = (answer, ch, conversationId) => {
        let chat = chatStore.list.find((c) => c.conversation_id == conversationId);
        console.log("chat", chat)
        console.log("mode.value", mode.value)
        if (chat && chat.status === 'done') return;

        if (mode.value === 'task' && ch.startsWith('{') && ch.endsWith('}')) {
            if (chatStore.conversationId === conversationId) {
                update(ch, conversationId);
            }
        }
        if (mode.value === 'chat') {
            if (ch.startsWith('__lemon_out_end__')) {
                updateUserAndAssistantMessage(ch, pid, assistantKey);
                //ä¼šè¯åœæ­¢
                chatStore.list.find((c) => c.conversation_id == conversationId).status = 'done';
                return true;
            }
            updateChatToken(ch, assistantKey);
        }
    };

    try {
        await sse(uri, options, onTokenStream, onOpenStream(pending), '', throttledScrollToBottom, abortController, conversationId);
    } catch (err) {
        console.error(err);
    } finally {
        pending = false;
    }
}


function update(ch, conversationId) {
    let json;
    try {
        json = JSON.parse(ch);
    } catch (e) {
        console.error('Failed to parse JSON:', ch);
        return;
    }
    console.log('=== ch === ', json);

    const messages = chatStore.messages;
    const tempMessageIndex = findTemporaryAssistantMessage(messages);

    if (tempMessageIndex !== -1) {
        //åˆ æ‰ä¸´æ—¶çš„åŠ©æ‰‹æ¶ˆæ¯
        messages.splice(tempMessageIndex, 1);
    }
    // messages.push(json);
    messageFun.handleMessage(json, messages);

    //å¦‚æœæ¶ˆæ¯ç±»å‹ä¸º finish_summery åˆ™åˆå§‹åŒ– æ¶ˆæ¯ é˜²æ­¢è¯„åˆ†çš„æ—¶å€™ ç¼ºå°‘ID
    if (json.meta && typeof json.meta === 'string') {
        json.meta = JSON.parse(message.meta);
    }
    //å»¶è¿Ÿ 500ms
    // setTimeout(() => {
    //     if (json.meta.action_type === 'finish_summery') {
    //         chatStore.initConversation(conversationId);
    //     }
    // }, 500);
    chatStore.scrollToBottom()
}
function updateChatToken(token) {
    console.log("updateChatToken", token)
    processToken(token, chatStore.messages, () => chatStore.scrollToBottom());
}

// å¤„ç†æœç´¢ç»“æœçš„å…±åŒé€»è¾‘
function processSearchResults(token, lastMessage) {
    console.log("<==== lastMessage ====>", lastMessage)
    try {
        const startMarker = '__lemon_chat_SEARCH_start__';
        const endMarker = '__lemon_chat_SEARCH_end__';

        const startIndex = token.indexOf(startMarker);
        const endIndex = token.indexOf(endMarker);

        if (startIndex == 0 && endIndex) {
            const jsonString = token.substring(startIndex + startMarker.length, endIndex).trim();
            console.log("chat jsonString:", jsonString);
            const searchResults = JSON.parse(jsonString);
            lastMessage.meta.json = searchResults.json;
            lastMessage.meta.content = searchResults.content;

            console.log("chat æœç´¢ç»“æœè§£ææˆåŠŸ:", searchResults);
        } else {
            console.warn("æ— æ³•æ‰¾åˆ°æœ‰æ•ˆçš„æœç´¢ç»“æœæ•°æ®");
        }
    } catch (error) {
        console.error("è§£ææœç´¢ç»“æœJSONå¤±è´¥:", error);
    }
}

// å¤„ç†æ–‡æ¡£ç»“æœçš„å…±åŒé€»è¾‘
function processDocumentResults(token, lastMessage) {
    try {
        const startMarker = '__lemon_chat_DOCUMENT_start__';
        const endMarker = '__lemon_chat_DOCUMENT_end__';
        const startIndex = token.indexOf(startMarker);
        const endIndex = token.indexOf(endMarker);
        if (startIndex == 0 && endIndex) {
            const jsonString = token.substring(startIndex + startMarker.length, endIndex).trim();
            console.log("chat jsonString:", jsonString);
            const documentResults = JSON.parse(jsonString);
            lastMessage.meta.json = documentResults.json;
            lastMessage.meta.content = documentResults.content;

            console.log("chat æ–‡æ¡£ç»“æœè§£ææˆåŠŸ:", documentResults);
        }
    } catch (error) {
        console.error("è§£ææœç´¢ç»“æœJSONå¤±è´¥:", error);
    }
}

// é€šç”¨çš„ token å¤„ç†é€»è¾‘
function processToken(token, messages, scrollFunction) {
    console.log("processToken", token)
    console.log("processToken messages", messages)
    if (messages.length > 0) {
        const lastMessage = messages[messages.length - 1];

        // å¤„ç†ç»“æŸæ ‡è®°
        if (token.includes('__lemon_out_end__')) {
            lastMessage.is_temp = false;
            return;
        }

        // å¤„ç†æœç´¢ç»“æœ
        if (token.includes('__lemon_chat_SEARCH_start__') && token.includes('__lemon_chat_SEARCH_end__')) {
            processSearchResults(token, lastMessage);
            return;
        }

        // å¤„ç†æ–‡æ¡£ç»“æœ
        if (token.includes('__lemon_chat_DOCUMENT_start__') && token.includes('__lemon_chat_DOCUMENT_end__')) {
            processDocumentResults(token, lastMessage);
            return;
        }

        // è¿½åŠ æ™®é€šå†…å®¹
        if (lastMessage) {
            lastMessage.content = (lastMessage.content || '') + token;
        }
    }
    scrollFunction();
}

function updateTwinsChatToken(token) {
    // console.log("updateTwinsChatToken", token)
    // ç‰¹æ®Šå¤„ç†ï¼šåœ¨ç»“æŸæ—¶æ·»åŠ é¢å¤–çš„æ—¥å¿—
    if (token.includes('__lemon_out_end__')) {
        console.log("chat ç»“æŸäº†")
    }
    processToken(token, chatStore.twinsChatMessages, () => chatStore.scrollToBottomLeft());
}
function updateUserAndAssistantMessage(ch, userKey, assistantKey) {
    //__lemon_out_end__{"message_id":4985}

    try {
        // ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼æå– uid å’Œ aid
        const match = ch.match(/__lemon_out_end__\{"message_id":"(\d+)","pid":"(\d+)"\}/);
        if (!match) {
            throw new Error("Invalid message format");
        }

        const jsonParse = {
            uid: parseInt(match[1]),
            pid: parseInt(match[2])
        };


        // æŸ¥æ‰¾ user å’Œ assistant æ¶ˆæ¯çš„ç´¢å¼•
        const userIndex = chatInfo.value.msgList.findIndex(item => item.id === userKey);
        const assistantIndex = chatInfo.value.msgList.findIndex(item => item.id === assistantKey);

        // ç¡®ä¿æ‰¾åˆ°æœ‰æ•ˆçš„ç´¢å¼•
        if (userIndex === -1 || assistantIndex === -1) {
            console.error("User or Assistant message not found in msgList");
            return;
        }
        // æ›´æ–°æ¶ˆæ¯ä¿¡æ¯
        chatInfo.value.msgList[userIndex].id = jsonParse.pid;
        chatInfo.value.msgList[assistantIndex].id = jsonParse.uid;
        chatInfo.value.msgList[assistantIndex].meta = JSON.stringify({ pid: jsonParse.pid, is_active: true });
        chatInfo.value.cursorKey = ''; // reset cursor key
        chatInfo.value.pid = jsonParse.uid;
    } catch (error) {
        console.error("Failed to parse message or update messages:", error);
    }
}

// æŸ¥æ‰¾ä¸´æ—¶çš„åŠ©æ‰‹æ¶ˆæ¯
function findTemporaryAssistantMessage(messages) {
    return messages.findIndex(message => message.is_temp === true && message.role === 'assistant');
}



export default {
    sendMessage,
    sendChatMessage,
    sendTwinsMessage,
    reAnswer
};



================================================
FILE: frontend/src/services/setting.js
================================================
import http from '@/utils/http.js'

const service = {
  async get() {
    const uri = '/api/settings'
    const res = await http.get(uri)
    return {
      modelName: res.data?.llm_model || 'GPT-4',
      modelUrl: res.data?.llm_base_url || '',
      apiKey: res.data?.llm_api_key || ''
    }
  },

  async save(settings) {
    const uri = '/api/settings'
    await http.post(uri, {
      llm_model: settings.modelName,
      llm_base_url: settings.modelUrl,
      llm_api_key: settings.apiKey
    })
  }
}

export default service


================================================
FILE: frontend/src/services/sse-coding.js
================================================
//å¼•ç”¨sse
import sse from '@/services/sse';
import fileServices from '@/services/files';
import messageFun from './message';
import userService from '@/services/auth'
import i18n from '@/locals';

import { storeToRefs } from 'pinia';
import { useUserStore } from '@/store/modules/user.js'
const userStore = useUserStore();

import { useChatStore } from '@/store/modules/chat';
const chatStore = useChatStore();
const { chatInfo, mode, model_id, agent } = storeToRefs(chatStore)
const { membership, points } = storeToRefs(userStore);

import { useEditorStore } from '@/store/modules/editor';
const editorStore = useEditorStore();

import emitter from "@/utils/emitter";

// è·å–ç”¨æˆ·ä¿¡æ¯ getUserInfo
async function getUserInfo() {
  // è·å–ç¼“å­˜ä¸­çš„ model_info
  const model_info = localStorage.getItem('model_info');
  if (model_info) {
    const model = JSON.parse(model_info);
    if (!model.is_subscribe) {
      // ä¸è°ƒç”¨æ¥å£
      return;
    }
  }
  let res = await userService.getUserInfo();
  // è®¾ç½®ç¼“å­˜
  membership.value = res.membership;
  points.value = res.points;
}



// å¤„ç†files çš„ conversation_id
const fileConversationId = async (files, conversation_id) => {
  // putFile
  files.forEach(async (file) => {
    await fileServices.putFile(file.id, conversation_id)
  });
};

const onOpenStream = (pending) => {
  pending = true;
};

const throttledScrollToBottom = () => {
  console.log('throttledScrollToBottom');
};

const sendMessage = async (question, conversationId, files, mcp_server_ids = [], workMode = "auto") => {
  const abortController = new AbortController();
  let fileIds = [];
  if (files && files.length > 0) {
    fileIds = files.map(file => file.id);
    // Modify files to include filepath
    files = files.map(file => {
      const filepath = `${file.workspace_dir}/Conversation_${conversationId.slice(0, 6)}/upload/${file.name}`;
      const filename = file.name;
      return { ...file, filepath, filename };
    });
    await fileConversationId(files, conversationId)
  }
  // åˆ¤æ–­å½“å‰ä¼šè¯æ˜¯å¦å­˜åœ¨
  let chat = chatStore.list.find((c) => c.conversation_id == conversationId);
  if (chat) {
    chat.status = 'running';
  }

  const selection = editorStore.selectedHtml;
  const filepath = editorStore.selectedPath;
  const screenshot = editorStore.selectedScreenshot;

  // åˆå§‹åŒ–ç¬¬ä¸€æ¡æ¶ˆæ¯
  chatStore.handleInitMessage(question, files, screenshot, filepath);

  let uri = `/api/agent/coding/sse`;
  let options = {
    requirement: question,
    selection: selection,
    screenshot: screenshot,
    filepath: filepath,
    agent_id: agent.value.id,
    conversation_id: conversationId,
    fileIds,
    mcp_server_ids,
    model_id: model_id.value,
    mode: workMode
  };
  console.log("options", options)
  console.log("mode.value", mode.value)
  console.log("chatInfo.value", chatInfo.value)

  let pending = false;
  let currentMode = null; // ç”¨äºè®°å½•å½“å‰æµçš„æ¨¡å¼

  const onTokenStream = (answer, ch, conversationId) => {
    let chat = chatStore.list.find((c) => c.conversation_id == conversationId);
    if (chat && chat.status === 'done') {
      return;
    }

    const currentConversationId = chatStore.conversationId
    console.log('onTokenStream', ch)

    // æ£€æŸ¥æ˜¯å¦æ˜¯æ¨¡å¼æ ‡è¯†
    if (ch.startsWith('__lemon_mode__')) {
      try {
        const modeStr = ch.substring('__lemon_mode__'.length);
        const modeData = JSON.parse(modeStr);
        currentMode = modeData.mode;
        const lastTempAssistantIndex = chatStore.messages.findLastIndex(
          msg => msg.role === 'assistant' && msg.is_temp === true
        );
        if (lastTempAssistantIndex !== -1) {
          const lastTempMessage = chatStore.messages[lastTempAssistantIndex];
          if (currentMode == "chat") {
            lastTempMessage.meta = { "action_type": "chat" };
            lastTempMessage.content = "";
          } else {
            lastTempMessage.content = i18n.global.t('lemon.message.botInitialResponse');
          }
        } else {
          if (currentMode == "chat") {
            const bot_message = {
              content: "",
              role: 'assistant',
              meta: { "action_type": "chat" },
              is_temp: true,
            }
            chatStore.messages.push(bot_message);
          } else {
            const bot_message = {
              content: i18n.global.t('lemon.message.botInitialResponse'),
              role: 'assistant',
              is_temp: true,
            }
            chatStore.messages.push(bot_message);
          }
        }
        return;
      } catch (e) {
        console.error('Failed to parse mode data:', e);
        return;
      }
    }

    if (ch && ch.startsWith('{') && ch.endsWith('}')) {
      if (currentConversationId === conversationId) {
        update(ch, conversationId);
      }
    }
  }

  const answer = '';

  sse(uri, options, onTokenStream, onOpenStream(pending), answer, throttledScrollToBottom, abortController, conversationId).then((res) => {
    return res;
  }).catch((error) => {
    console.error(error);
    return '';
  }).finally(() => {
    emitter.emit("coding-message-sent", { conversationId });
    chatStore.list.find((c) => c.conversation_id == conversationId).status = 'done';
    getUserInfo();
  });
}

function update(ch, conversationId) {
  let json;
  try {
    json = JSON.parse(ch);
  } catch (e) {
    console.error('Failed to parse JSON:', ch);
    return;
  }
  console.log('=== ch === ', json);

  const messages = chatStore.messages;
  const tempMessageIndex = findTemporaryAssistantMessage(messages);

  if (tempMessageIndex !== -1) {
    // åˆ æ‰ä¸´æ—¶çš„åŠ©æ‰‹æ¶ˆæ¯
    messages.splice(tempMessageIndex, 1);
  }
  // messages.push(json);
  messageFun.handleMessage(json, messages);
  chatStore.scrollToBottom()
}


// æŸ¥æ‰¾ä¸´æ—¶çš„åŠ©æ‰‹æ¶ˆæ¯
function findTemporaryAssistantMessage(messages) {
  return messages.findIndex(message => message.is_temp === true && message.role === 'assistant');
}

export default {
  sendMessage,
};



================================================
FILE: frontend/src/services/sse.js
================================================
import { fetchEventSource } from '@microsoft/fetch-event-source';
import base64 from "@/utils/base64.js";
const env = import.meta.env;
const sse = (uri, options, onTokenStream = (answer, ch,conversation_id) => { }, onOpenStream = () => { }, answer, throttledScrollToBottom = () => { }, abortController = new AbortController(),conversationId,agentConversationId = null) => {
  const nodeToken = localStorage.getItem('node_token');
  return new Promise((resolve, reject) => {

    let content = ''
    const fes = fetchEventSource(uri, {
      method: 'POST',
      body: JSON.stringify(options),
      headers: {
        'Content-Type': 'application/json',
        'node-token': nodeToken || '',
      },
      openWhenHidden: true,
      signal: abortController.signal,
      onopen(response) {
        if (response.ok) {
          onOpenStream(answer, response);
          return; // ev
        }
      },
      onmessage(ev) {
        const ch = decodeBase64(ev.data);
        content += ch;
        onTokenStream(answer, ch,conversationId,agentConversationId); // å›è°ƒå¤„ç†æµå¼æ¶ˆæ¯
        throttledScrollToBottom();
      },
      onerror(err) {
        console.log('è§¦å‘äº† ============ sse.error ============ ', err);
        abortController.abort();
        //æŠ›å‡ºå¼‚å¸¸
        reject(err);
        throw err;
      }
    });

    fes.then((response) => {
      console.log('fes.response', response);
      resolve(content);
    }).catch((error) => {
      abortController.abort();
      reject(error);
    })
  })
}


const decodeBase64 = (encodedString) => {
  const decodedString = decodeURIComponent(
    atob(encodedString)
      .split("")
      .map(function (char) {
        return "%" + ("00" + char.charCodeAt(0).toString(16)).slice(-2);
      })
      .join("")
  );
  return decodedString;
};

export default sse;


================================================
FILE: frontend/src/services/version.js
================================================
import http from '@/utils/http.js'

const service = {
  async getVersionInfo() {
    const uri = `/api/version/`
    const response = await http.get(uri)
    return response || {};
  }
}

export default service


================================================
FILE: frontend/src/services/workspace.js
================================================
import http from '@/utils/http.js'
import fileUtils from '@/utils/file'

const service = {
  // è·å–vscodeåœ°å€
  async getVsCodeUrl(conversationId) {
    const uri = `/api/runtime/vscode-url`
    const response = await http.get(uri,  { conversation_id: conversationId })
    return response || {};
  },

  // è·å–æ–‡ä»¶åˆ—è¡¨
  async getFiles(conversationId,path){
    const baseUrl = `/api/conversations/${conversationId}/list-files`;
    const url = path ? `${baseUrl}?path=${encodeURIComponent(path)}` : baseUrl;
    const response = await http.get(url);
    return response.data || [];
  },

   // è·å–æ–‡ä»¶å†…å®¹
   async getFile(path) {
    const baseUrl = `/api/file/read`;
    const responseType = fileUtils.getFileReponseTypeByName(path)
    const response = await http.post(baseUrl, {
      path: path
    },{},responseType);
    // console.log(response)
    return response.data|| '';
  }

}




export default service


================================================
FILE: frontend/src/services/wx-client.js
================================================
import { ref, reactive, computed } from 'vue';
import { useWebSocket } from '@vueuse/core';

export class WebSocketClient {
  constructor(baseUrl) {
    this.baseUrl = baseUrl || import.meta.env.VITE_WS_API_URL || 'ws://localhost:3002';
    this.connectionRef = ref(null);
    this.events = reactive(new Map());
    this.currentConversationId = ref(null);
  }

  connect(conversationId) {
    console.trace('WebSocket connect called from:');
    console.log('Connecting to conversation:', conversationId);

    // Close any existing connection
    if (this.connectionRef.value) {
      this.disconnect();
    }

    this.currentConversationId.value = conversationId;
    const wsUrl = `${this.baseUrl}/socket.io/?latest_event_id=-1&conversation_id=${conversationId}&EIO=4&transport=websocket`;
    console.log('connect to conversation', wsUrl);

    const { status, data, send, open, close, ws } = useWebSocket(wsUrl, {
      autoReconnect: {
        retries: 5,
        delay: 2000,
        onFailed: () => {
          console.error('Failed to reconnect WebSocket after 5 retries');
        }
      },
      onConnected: () => {
        this._emitEvent('connected', { conversationId });
      },
      onDisconnected: (_, event) => {
        this._emitEvent('disconnected', { conversationId, event });
      },
      onError: (_, event) => {
        this._emitEvent('error', { conversationId, event });
      },
      onMessage: (_, event) => {
        try {
          console.log('onMessage', event.data);
          this._emitEvent('message', event.data);
        } catch (error) {
          console.error('Error parsing WebSocket message:', error);
          this._emitEvent('error', { error, data: event.data });
        }
      }
    });

    this.connectionRef.value = {
      status,
      data,
      send: (message) => {
        // Automatically stringify objects
        const payload = typeof message === 'object'
          ? JSON.stringify(message)
          : message;
        return send(payload);
      },
      close,
      open,
      ws
    };

    return this.connectionRef.value;
  }

  disconnect() {
    if (this.connectionRef.value) {
      this.connectionRef.value.close();
      this.connectionRef.value = null;
      this.currentConversationId.value = null;
    }
  }

  isConnected() {
    return this.connectionRef.value?.status.value === 'OPEN';
  }

  on(eventName, callback) {
    if (!this.events.has(eventName)) {
      this.events.set(eventName, []);
    }
    this.events.get(eventName).push(callback);

    // Return unsubscribe function
    return () => {
      const callbacks = this.events.get(eventName);
      const index = callbacks.indexOf(callback);
      if (index !== -1) {
        callbacks.splice(index, 1);
      }
    };
  }

  off(eventName, callback) {
    if (this.events.has(eventName)) {
      if (callback) {
        const callbacks = this.events.get(eventName);
        const index = callbacks.indexOf(callback);
        if (index !== -1) {
          callbacks.splice(index, 1);
        }
      } else {
        // Remove all callbacks for this event
        this.events.delete(eventName);
      }
    }
  }

  send(message) {
    if (!this.isConnected()) {
      console.error('Cannot send message: WebSocket is not connected');
      return false;
    }

    return this.connectionRef.value.send(message);
  }

  _emitEvent(eventName, data) {
    if (this.events.has(eventName)) {
      this.events.get(eventName).forEach(callback => {
        try {
          callback(data);
        } catch (error) {
          console.error(`Error in ${eventName} event handler:`, error);
        }
      });
    }
  }
}

// Create a singleton instance
const wsClient = new WebSocketClient();
export default wsClient;


================================================
FILE: frontend/src/store/index.js
================================================
/**
 * @author YuGao 540846283@qq.com
 */
// https://pinia.vuejs.org/zh/core-concepts/
import { createPinia } from 'pinia'
// https://prazdevs.github.io/pinia-plugin-persistedstate/zh/guide/
import { createPersistedState } from 'pinia-plugin-persistedstate'

const pinia = createPinia()
pinia.use(createPersistedState())

export default pinia;



================================================
FILE: frontend/src/store/modules/chat.js
================================================
import { defineStore } from 'pinia'
import { io } from "socket.io-client";
import chat from '@/services/chat';
const baseUrl = import.meta.env.VITE_WS_API_URL;

import emitter from '@/utils/emitter';
import messageFun from '@/services/message';
import i18n from '@/locals';


export const useChatStore = defineStore('chat', {
  state: () => ({
    list: [],
    chat: {},
    messages: [],
    twinsChatMessages: [],
    twinsConversationList: {}, // twins_id -> { status, input_tokens, output_tokens }
    events: [],
    agent: {},
    status: 'done',
    conversationId: null,
    socket: null,
    baseUrl: baseUrl,
    commands: [],
    isScrolledToBottom: true,
    updateTitle: true,
    //åœæ­¢å›æ”¾
    stopReplay: false,
    replayStatus: 'done',
    mode: 'task',
    mode_editor: false,
    model_id: '',
    chatInfo: {
      pid: -1,
      msgList: [],
      cursorKey: '',
    }
  }),
  actions: {
    async init(mode = 'task') {
      //åˆå§‹åŒ– chat list
      this.mode = mode;
      const res = await chat.list(mode, this.agent.id)
      //å¤„ç†ä¸€ä¸‹æ’åº æœ€è¿‘çš„æ’åœ¨å‰é¢
      let data = res || [];
      data.sort((a, b) => {
        return new Date(b.update_at) - new Date(a.update_at);
      });
      this.list = data;

      // ç”Ÿæˆ twinsConversationList
      this.generateTwinsConversationList();
    },
    //é€‰æ‹©ç¬¬ä¸€ä¸ª 
    async selectFirst() {
      if (this.mode == 'task' && this.list.length > 0) {
        console.log(' é»˜è®¤é€‰æ‹©ç¬¬ä¸€ä¸ª selectFirst');
        //é»˜è®¤é€‰æ‹©ç¬¬ä¸€ä¸ª
        this.conversationId = this.list[0].conversation_id;
        this.clearMessages();
        this.chat = this.list[0];
        this.initConversation(this.conversationId);

        console.log('this.chat', this.chat);
      } else {
        this.clearMessages();
        this.chat = {};
        this.conversationId = null;
      }
    },
    async handleStop() {
      // æŸ¥è¯¢å¹¶æ›´æ–° claude çš„æœ€æ–°å¸‚å€¼æ•°æ®
      if (this.mode_editor) {
        await chat.stopCoding(this.conversationId)
      } else if (this.mode === 'task') {
        await chat.stop(this.conversationId)
      } else {
        this.chatInfo.cursorKey = '';
        await chat.stopChat(this.conversationId)
      }

      // æŸ¥æ‰¾å½“å‰ä¼šè¯æ˜¯å¦æœ‰ twins_id
      const currentConversation = this.list.find(item => item.conversation_id === this.conversationId);
      if (currentConversation && currentConversation.twins_id) {
        // å¦‚æœæœ‰ twins_idï¼Œä¹Ÿéœ€è¦åœæ­¢ twins ä¼šè¯
        try {
          await chat.stop(currentConversation.twins_id)
          // æ›´æ–° twinsConversationList ä¸­çš„çŠ¶æ€
          const twinsInfo = this.twinsConversationList[currentConversation.twins_id] || { status: 'done', input_tokens: 0, output_tokens: 0, total: 0 };
          twinsInfo.status = 'done';
          this.twinsConversationList[currentConversation.twins_id] = twinsInfo;
        } catch (error) {
          console.error('Error stopping twins conversation:', error);
        }
      }

      this.list.find(item => item.conversation_id === this.conversationId).status = 'done';
      this.chat.status = 'done'
      this.status = 'done'
    },
    clearMessages() {
      this.messages = [];
      this.twinsChatMessages = [];
      this.isScrolledToBottom = true;
      this.status == "done";
      this.chatInfo.pid = -1;
    },
    clearAgent() {
      this.agent = {};
      this.list = [];
      this.twinsChatMessages = [];
      console.log('clearAgent', this.agent);
    },
    async initConversation(conversationId) {
      await this.resetChatInfo()
      let res = await chat.messageList(conversationId);
      this.messages = []
      this.twinsChatMessages = [] // æ¸…ç©º twins chat æ¶ˆæ¯

      if (this.mode === 'task') {
        res.forEach(item => {
          if (item.meta && typeof item.meta === 'string') {
            item.meta = JSON.parse(item.meta);
          }
          const { action_type } = item.meta;
          if (action_type == "error" || action_type == "stop") {
            let conversation_id = item.conversation_id
            let chat = this.list.find((c) => c.conversation_id == conversation_id)
            if (chat) {
              chat.status = "done";
            }
          }
          // å¤„ç†æ¶ˆæ¯
          messageFun.handleMessage(item, this.messages);
        });
        const lastItem = res[res.length - 1];
        if (lastItem && lastItem.meta) {
          const { action_type } = lastItem.meta;
          if (action_type === "error" || action_type === "stop") {
            let conversation_id = lastItem.conversation_id;
            let chat = this.list.find((c) => c.conversation_id == conversation_id);
            if (chat) {
              chat.status = "done";
            }
          }
        }

        // æ£€æŸ¥æ˜¯å¦æ˜¯ twins æ¨¡å¼ï¼Œå¦‚æœæ˜¯åˆ™åŠ è½½ twins chat æ¶ˆæ¯
        if (this.chat.twins_id) {
          try {
            console.log('Loading twins chat messages for twins_id:', this.chat.twins_id);
            // ç›´æ¥ä½¿ç”¨ twins_id ä½œä¸º conversation_id è·å–æ¶ˆæ¯
            const twinsChatRes = await chat.messageList(this.chat.twins_id);
            //å¾ªç¯ æŠŠ meta è½¬ json
            twinsChatRes.forEach(item => {
              if (item.meta && typeof item.meta === 'string') {
                item.meta = JSON.parse(item.meta);
              }
            });
            this.twinsChatMessages = twinsChatRes || [];
            console.log('Loaded twins chat messages:', this.twinsChatMessages.length);

            // åˆå§‹åŒ– twins token ä¿¡æ¯
            try {
              const tokenInfo = await chat.getTwinsTokens(this.chat.twins_id);
              console.log('Token info:', tokenInfo);
              if (tokenInfo) {
                const twinsInfo = this.twinsConversationList[this.chat.twins_id] || { status: 'done', input_tokens: 0, output_tokens: 0, total: 0 };
                twinsInfo.input_tokens = tokenInfo.input_tokens || 0;
                twinsInfo.output_tokens = tokenInfo.output_tokens || 0;
                twinsInfo.total = tokenInfo.total || 0;
                this.twinsConversationList[this.chat.twins_id] = twinsInfo;
                console.log('Initialized twins token info:', twinsInfo);
              }
            } catch (tokenError) {
              console.error('Error initializing twins token info:', tokenError);
            }
          } catch (error) {
            console.error('Error loading twins chat messages:', error);
          }
          this.scrollToBottomLeft();
          this.scrollToBottomRight();
        }
      } else if (this.mode === 'chat') {
        // reset
        this.chatInfo.msgList = res;
        // console.log("å½“å‰this.chatInfo.msgList",this.chatInfo.msgList)
      }
      // console.log("this.messages", this.messages)
      this.scrollToBottom();
    },
    //æ¶ˆæ¯å›æ”¾
    async playback(conversationId, time = 0) { // ç¡®ä¿å‡½æ•°å£°æ˜æ—¶åŒ…å« async å…³é”®å­—
      this.stopReplay = false;
      this.replayStatus = 'running';
      this.messages = [];
      this.twinsChatMessages = []; // æ¸…ç©º twins chat æ¶ˆæ¯
      const get_res = await chat.get(conversationId);
      this.chat = get_res;

      // è·å–ä¸»å¯¹è¯æ¶ˆæ¯
      let res = await chat.messageList(conversationId);

      // å¦‚æœæ˜¯ twins æ¨¡å¼ï¼ŒåŒæ—¶è·å– twins chat æ¶ˆæ¯
      let twinsRes = [];
      if (this.chat.twins_id) {
        try {
          console.log('Loading twins chat messages for playback, twins_id:', this.chat.twins_id);
          twinsRes = await chat.messageList(this.chat.twins_id);
          console.log('Loaded twins chat messages for playback:', twinsRes.length);
        } catch (error) {
          console.error('Error loading twins chat messages for playback:', error);
        }
      }
      // å¤„ç† twins chat æ¶ˆæ¯
      console.log('twinsRes', twinsRes);
      if (this.chat.twins_id && twinsRes.length > 0) {
        this.twinsChatMessages = [];

        // twinsæ¶ˆæ¯é€æ¡ä¸²è¡Œæ¸²æŸ“ï¼Œä½†æ•´ä½“ä¸ä¸»chatå¹¶è¡Œ
        (async () => {
          this.twinsChatMessages = [];
          for (let i = 0; i < twinsRes.length; i++) {
            let message = twinsRes[i];
            let originalContent = message.content;
            message.content = "";
            this.twinsChatMessages.push(message);
            if (message.role == "user") {
              this.twinsChatMessages[i].content = originalContent;
              continue
            }

            let delay = 50;
            for (let j = 0; j < originalContent.length; j++) {
              if (this.replayStatus != 'running') { break; }
              await new Promise(resolve => setTimeout(resolve, delay));
              this.twinsChatMessages[i].content += originalContent[j];
              this.scrollToBottomLeft();
            }
            this.twinsChatMessages[i].content = originalContent;
            this.scrollToBottomLeft();
          }
        })();


        //æ›´æ–°token ä¿¡æ¯
        const tokenInfo = await chat.getTwinsTokens(this.chat.twins_id);
        if (tokenInfo) {
          const twinsInfo = this.twinsConversationList[this.chat.twins_id] || { status: 'done', input_tokens: 0, output_tokens: 0, total: 0 };
          twinsInfo.input_tokens = tokenInfo.input_tokens || 0;
          twinsInfo.output_tokens = tokenInfo.output_tokens || 0;
          twinsInfo.total = tokenInfo.total || 0;
          twinsInfo.status = 'done';
          this.twinsConversationList[this.chat.twins_id] = twinsInfo;
          console.log('Updated twins token info:', this.chat.twins_id, twinsInfo);
        }
      }

      // å¤„ç†ä¸»å¯¹è¯æ¶ˆæ¯
      for (let item of res) { // ä½¿ç”¨ for...of å¾ªç¯æ¥éå†æ•°ç»„
        //å»¶è¿Ÿæ—¶é—´
        let delay = 100;
        if (!this.stopReplay) {
          await new Promise(resolve => setTimeout(resolve, time)); // æ­£ç¡®ä½¿ç”¨ await æ¥ç­‰å¾… Promise å®Œæˆ
          delay = 0;
        }
        messageFun.handleMessage(item, this.messages); // å‡è®¾ handleMessage æ˜¯æ­£ç¡®å¯¼å…¥æˆ–å®šä¹‰çš„
        setTimeout(() => {
          //åˆ¤æ–­æ˜¯å¦æ‰“å¼€é¢„è§ˆ  emitter.emit('preview',{})
          // åªæœ‰PCç«¯æ‰è‡ªåŠ¨æ‰“å¼€é¢„è§ˆï¼Œç§»åŠ¨ç«¯ä¸è‡ªåŠ¨æ‰“å¼€
          const isMobile = window.innerWidth <= 768;
          if (!isMobile) {
            emitter.emit('preview', { message: item });
          }
          //finish_summery
          let meta = JSON.parse(JSON.stringify(item.meta));
          //json
          let file = meta?.json[0] || {};
          console.log('meta.action_type', meta.action_type);
          if (meta.action_type == "finish_summery" && file && !isMobile) {
            emitter.emit('fullPreviewVisable', file)
          }
        }, delay);

        this.isScrolledToBottom = true;
        this.scrollToBottom(0);
      }



      this.replayStatus = 'done';
    },
    async toResult() {
      this.replayStatus = 'done';
      this.stopReplay = true;
    },
    async autoTitle() {
      if (this.updateTitle) {
        // æ›´æ–° title
        const update_res = await chat.update(this.conversationId, "");
        console.log('update_res', update_res);
        //è°ƒç”¨get è·å–æœ€æ–°çš„ä¼šè¯
        const get_res = await chat.get(this.conversationId);
        this.chat.title = get_res.title;
        this.chat.status = 'running';
        //ä¿®æ”¹ list
        this.list.find(item => item.conversation_id === this.conversationId).title = get_res.title;
        this.list.find(item => item.conversation_id === this.conversationId).status = 'running';
        console.log('this.list', this.list);
        this.updateTitle = false;
        this.status = 'running';
      }
    },
    async updateConversationTitle(title) {
      const update_res = await chat.update(this.conversationId, title);

      // æ›´æ–°å½“å‰èŠå¤©å¯¹è±¡
      this.chat.title = title;

      // æ›´æ–°èŠå¤©åˆ—è¡¨ä¸­çš„å¯¹åº”é¡¹
      const listItem = this.list.find(item => item.conversation_id === this.conversationId);
      if (listItem) {
        listItem.title = update_res.title;
      }
    },
    async updateConversationTitleById(title, id) {
      const update_res = await chat.update(id, title);

      // æ›´æ–°èŠå¤©åˆ—è¡¨ä¸­çš„å¯¹åº”é¡¹
      const listItem = this.list.find(item => item.conversation_id === id);
      if (listItem) {
        listItem.title = update_res.title;
      }

      // å¦‚æœæ›´æ–°çš„æ˜¯å½“å‰èŠå¤©ï¼Œä¹Ÿè¦æ›´æ–°å½“å‰èŠå¤©å¯¹è±¡
      if (id === this.conversationId) {
        this.chat.title = title;
      }
    },
    // ä¿®æ”¹å½“å‰ä¼šè¯çš„å¯è§æ€§
    async updateConversationVisibility(is_public) {
      const update_res = await chat.updateVisibility(this.conversationId, is_public);

      // æ›´æ–°å½“å‰èŠå¤©å¯¹è±¡
      this.chat.is_public = is_public;

      // æ›´æ–°èŠå¤©åˆ—è¡¨ä¸­çš„å¯¹åº”é¡¹
      const listItem = this.list.find(item => item.conversation_id === this.conversationId);
      if (listItem) {
        listItem.is_public = is_public;
      }

      return update_res;
    },
    // æ ¹æ®IDä¿®æ”¹ä¼šè¯çš„å¯è§æ€§
    async updateConversationVisibilityById(is_public, id) {
      const update_res = await chat.updateVisibility(id, is_public);

      // æ›´æ–°èŠå¤©åˆ—è¡¨ä¸­çš„å¯¹åº”é¡¹
      const listItem = this.list.find(item => item.conversation_id === id);
      if (listItem) {
        listItem.is_public = is_public;
      }

      // å¦‚æœæ›´æ–°çš„æ˜¯å½“å‰èŠå¤©ï¼Œä¹Ÿè¦æ›´æ–°å½“å‰èŠå¤©å¯¹è±¡
      if (id === this.conversationId) {
        this.chat.is_public = is_public;
      }

      return update_res;
    },
    onMessageEvent(data) {
      // this.socket.emit('oh_event', data);
      const { source, message } = data;
      // console.log('onMessageEvent', data);
    },
    // åˆ›å»ºæ–°ä¼šè¯
    async createConversation(message, mode_type = 'task') {
      console.log('createConversation', this.model_id);
      this.messages = []; // æ¸…ç©ºæ¶ˆæ¯
      this.twinsChatMessages = [];
      await this.resetChatInfo()
      this.updateTitle = true;
      const result = await chat.create(message, mode_type, this.agent.id, this.model_id);
      this.chat = result;
      this.conversationId = result.conversation_id;
      this.init();
      this.autoTitle();
      return result;
    },
    async resetChatInfo() {
      this.chatInfo = {
        pid: -1,
        msgList: []
      }
    },
    // å‘é€æ¶ˆæ¯
    sendMessage(message) {
    },
    // message
    handleInitMessage(content, files = [], screenshot = '', filepath = '') {
      console.log('handleInitMessage', content);
      this.mode_editor = false;
      let meta = {
        json: files,
        action_type: 'question',
      }
      if (screenshot && filepath) {
        this.mode_editor = true;
        meta.json = { files, screenshot, filepath }
      }
      const message = {
        content: content,
        timestamp: new Date().getTime(),
        meta: meta,
        role: 'user',
        is_temp: true,
      }
      this.messages.push(message);
      const bot_message = {
        content: "",
        role: 'assistant',
        timestamp: new Date().getTime(),
        is_temp: true,
      }
      this.messages.push(bot_message);
      this.isScrolledToBottom = true;
      this.scrollToBottom();
    },
    // twins chat message initialization
    handleInitTwinsMessage(content, files = [], screenshot = '', filepath = '') {
      console.log('handleInitTwinsMessage', content);
      let meta = {
        json: files,
        action_type: 'question',
      }
      if (screenshot && filepath) {
        meta.json = { files, screenshot, filepath }
      }
      const message = {
        content: content,
        timestamp: new Date().getTime(),
        meta: meta,
        role: 'user',
        is_temp: true,
      }
      this.twinsChatMessages.push(message);
      const bot_message = {
        content: "",
        role: 'assistant',
        timestamp: new Date().getTime(),
        is_temp: true,
      }
      this.twinsChatMessages.push(bot_message);
      this.isScrolledToBottom = true;
      this.scrollToBottomLeft(); // ä½¿ç”¨å·¦æ ä¸“ç”¨çš„æ»šåŠ¨å‡½æ•°
    },
    async removeConversation(conversationId) {
      // if (this.socket) {
      //   this.socket.close();
      // }
      const result = await chat.remove(conversationId);
      let index = this.list.findIndex(item => item.conversation_id === conversationId);
      if (index !== -1) {
        this.list.splice(index, 1);
      }
      return result;
    },
    scrollToBottom(time = 500) {
      setTimeout(() => {
        console.log('scrollToBottom', this.isScrolledToBottom);
        //å°†æ¶ˆæ¯æ»šåŠ¨åˆ°æœ€åº•éƒ¨
        const messageList = document.querySelector('.message-list');
        if (this.isScrolledToBottom && messageList) {
          messageList.scrollTop = messageList.scrollHeight - messageList.clientHeight;
          // console.log('scrollToBottom', messageList.scrollTop, messageList.scrollHeight, messageList.clientHeight);
        }
      }, time);
      this.scrollToBottomRight(time)
    },
    // twins æ¨¡å¼å·¦æ æ»šåŠ¨åˆ°åº•éƒ¨ (Chat)
    scrollToBottomLeft(time = 500) {
      setTimeout(() => {
        console.log('scrollToBottomLeft twins chat column');
        const chatColumn = document.querySelector('.twins-column.chat-column .column-content');
        console.log('chatColumn element found:', !!chatColumn);

        // æ£€æŸ¥è‡ªåŠ¨æ»šåŠ¨æ˜¯å¦å¯ç”¨
        if (typeof window !== 'undefined' && window.twinsAutoScrollState) {
          if (!window.twinsAutoScrollState.isLeftEnabled()) {
            console.log('â›” Left auto scroll disabled, skipping store scroll');
            return;
          }
        } else {
          console.log('âš ï¸ No twinsAutoScrollState found, proceeding with scroll');
        }

        // è®¾ç½®è‡ªåŠ¨æ»šåŠ¨æ ‡è®°ï¼Œéšè—æŒ‰é’®
        if (typeof window !== 'undefined' && window.twinsAutoScrollState) {
          window.twinsAutoScrollState.setLeftScrolling(true);
        }

        if (chatColumn) {
          const targetScrollTop = chatColumn.scrollHeight - chatColumn.clientHeight;
          chatColumn.scrollTop = targetScrollTop;
          console.log('scrollToBottomLeft', {
            targetScrollTop,
            actualScrollTop: chatColumn.scrollTop,
            scrollHeight: chatColumn.scrollHeight,
            clientHeight: chatColumn.clientHeight
          });

          // ç¨åæ¸…é™¤æ ‡è®°ï¼Œè®©æŒ‰é’®å¯ä»¥é‡æ–°æ˜¾ç¤º
          setTimeout(() => {
            if (typeof window !== 'undefined' && window.twinsAutoScrollState) {
              window.twinsAutoScrollState.setLeftScrolling(false);
            }
          }, 300);
        } else {
          console.warn('Chat column not found for scrollToBottomLeft');
        }
      }, time);
    },
    // twins æ¨¡å¼å³æ æ»šåŠ¨åˆ°åº•éƒ¨ (Agent)
    scrollToBottomRight(time = 500) {
      setTimeout(() => {
        console.log('scrollToBottomRight twins agent column');
        const agentColumn = document.querySelector('.twins-column.agent-column .column-content');
        console.log('agentColumn element found:', !!agentColumn);

        // æ£€æŸ¥è‡ªåŠ¨æ»šåŠ¨æ˜¯å¦å¯ç”¨
        if (typeof window !== 'undefined' && window.twinsAutoScrollState) {
          if (!window.twinsAutoScrollState.isRightEnabled()) {
            console.log('â›” Right auto scroll disabled, skipping store scroll');
            return;
          }
        } else {
          console.log('âš ï¸ No twinsAutoScrollState found, proceeding with scroll');
        }

        // è®¾ç½®è‡ªåŠ¨æ»šåŠ¨æ ‡è®°ï¼Œéšè—æŒ‰é’®
        if (typeof window !== 'undefined' && window.twinsAutoScrollState) {
          window.twinsAutoScrollState.setRightScrolling(true);
        }

        if (agentColumn) {
          const targetScrollTop = agentColumn.scrollHeight - agentColumn.clientHeight;
          agentColumn.scrollTop = targetScrollTop;
          console.log('scrollToBottomRight', {
            targetScrollTop,
            actualScrollTop: agentColumn.scrollTop,
            scrollHeight: agentColumn.scrollHeight,
            clientHeight: agentColumn.clientHeight
          });

          // ç¨åæ¸…é™¤æ ‡è®°ï¼Œè®©æŒ‰é’®å¯ä»¥é‡æ–°æ˜¾ç¤º
          setTimeout(() => {
            if (typeof window !== 'undefined' && window.twinsAutoScrollState) {
              window.twinsAutoScrollState.setRightScrolling(false);
            }
          }, 300);
        } else {
          console.warn('Agent column not found for scrollToBottomRight');
        }
      }, time);
    },
    async favorite() {
      const result = await chat.favorite(this.conversationId);
      this.chat.is_favorite = true;
    },
    async unfavorite() {
      const result = await chat.unfavorite(this.conversationId);
      this.chat.is_favorite = false;
    },
    async convertToTree(messages) {
      console.log("åˆå§‹åŒ–tree", messages)
      // åˆ›å»ºæ¶ˆæ¯æ˜ å°„ï¼Œä¾¿äºå¿«é€ŸæŸ¥æ‰¾
      const messageMap = new Map();
      messages.forEach(msg => {
        const meta = JSON.parse(msg.meta);
        console.log('meta', meta)
        messageMap.set(msg.id, {
          id: msg.id,
          pid: meta.pid,
          role: msg.role,
          content: msg.content,
          children: []
        });
      });

      // æ„å»ºæ ‘ç»“æ„
      const tree = [];
      messageMap.forEach(msg => {
        if (msg.pid === '-1') {
          // æ ¹èŠ‚ç‚¹ç›´æ¥åŠ å…¥æ ‘
          tree.push(msg);
        } else {
          // éæ ¹èŠ‚ç‚¹ï¼Œæ‰¾åˆ°çˆ¶èŠ‚ç‚¹å¹¶åŠ å…¥å…¶ children
          const parent = messageMap.get(Number(msg.pid));
          if (parent) {
            parent.children.push(msg);
          }
        }
      });

      // æŒ‰ id æ’åºæ ¹èŠ‚ç‚¹ï¼ˆå¯é€‰ï¼Œæ ¹æ®éœ€è¦ï¼‰
      tree.sort((a, b) => a.id - b.id);

      return tree;
    },

    // ç”Ÿæˆ twinsConversationList
    generateTwinsConversationList() {
      // æ¸…ç©ºä¹‹å‰çš„æ•°æ®
      this.twinsConversationList = {};

      // éå† listï¼ŒæŸ¥æ‰¾æœ‰ twins_id çš„ conversation
      this.list.forEach(conversation => {
        if (conversation.twins_id) {
          this.twinsConversationList[conversation.twins_id] = {
            status: conversation.status || 'done',
            input_tokens: 0,
            output_tokens: 0,
            total: 0
          };
        }
      });

      console.log('Generated twinsConversationList:', this.twinsConversationList);
    },

  },
  persist: true,
})



================================================
FILE: frontend/src/store/modules/demo.js
================================================
import { defineStore } from 'pinia'

export const useDemoStore = defineStore('demo', {
  state: () => ({
    count: 0,
  }),
  actions: {
    setCount(count) {
      this.count = count;
    }
  },
  persist: true,
})



================================================
FILE: frontend/src/store/modules/editor.js
================================================
import { defineStore } from 'pinia'

export const useEditorStore = defineStore('editor', {
  state: () => ({
    // ç¼–è¾‘å™¨æ¨¡å¼
    editorMode: 'preview',
    // é€‰ä¸­å…ƒç´ çš„ä¿¡æ¯
    selectedElement: null,
    // é€‰ä¸­å…ƒç´ çš„æˆªå›¾
    selectedScreenshot: null,
    // æ˜¯å¦æ˜¾ç¤ºé€‰ä¸­é¢„è§ˆ
    showSelectionPreview: false,
    // é€‰ä¸­çš„HTMLå†…å®¹
    selectedHtml: '',
    // é€‰ä¸­å…ƒç´ çš„è·¯å¾„
    selectedPath: '',
  }),

  actions: {
    // è®¾ç½®é€‰ä¸­å…ƒç´ ä¿¡æ¯
    setSelectedElement(elementInfo) {
      this.selectedElement = elementInfo;
      if (elementInfo) {
        this.selectedScreenshot = elementInfo.screenshot || null;
        this.selectedHtml = elementInfo.html || '';
        this.selectedPath = elementInfo.path || '';
        this.showSelectionPreview = !!elementInfo.screenshot;
      }
    },

    // æ¸…é™¤é€‰ä¸­çŠ¶æ€
    clearSelection() {
      this.selectedElement = null;
      this.selectedScreenshot = null;
      this.selectedHtml = '';
      this.selectedPath = '';
      this.showSelectionPreview = false;
    },

    // è®¾ç½®é€‰ä¸­é¢„è§ˆæ˜¾ç¤ºçŠ¶æ€
    setShowSelectionPreview(show) {
      this.showSelectionPreview = show;
    },

    // è®¾ç½®ç¼–è¾‘å™¨æ¨¡å¼
    setEditorMode(mode) {
      this.editorMode = mode;
    }
  }
})



================================================
FILE: frontend/src/store/modules/server.js
================================================
import { defineStore } from 'pinia';
import { message } from "ant-design-vue";
import http from '@/utils/http';
import i18n from '@/locals';

const t = i18n.global.t;

export const useServerStore = defineStore('server', {
  state: () => ({
    servers: [],
  }),
  actions: {
    async fetchServers() {
      try {
        const list = await http.get('/api/mcp_server');
        console.log('response', list);
        this.servers = list;
        console.log('servers', this.servers);
      } catch (error) {
        message.error(t('setting.mcpService.fetchFailed'));
        console.error('Fetch servers error:', error);
      }
    },
    async addServer(server) {
      try {
        const mcp_server = await http.post('/api/mcp_server', server);
        console.log('add.server.response', mcp_server);
        this.servers.push(mcp_server);
        message.success(t('setting.mcpService.addSuccess'));
      } catch (error) {
        message.error(t('setting.mcpService.addFailed'));
        console.error('Add server error:', error);
      }
    },
    async updateServer(server) {
      try {
        await http.put(`/api/mcp_server/${server.id}`, server);
        const index = this.servers.findIndex((s) => s.id === server.id);
        if (index !== -1) {
          this.servers[index] = server;
        }
        message.success(t('setting.mcpService.updateSuccess'));
      } catch (error) {
        message.error(t('setting.mcpService.updateFailed'));
        console.error('Update server error:', error);
      }
    },
    async deleteServer(serverId) {
      try {
        await http.del(`/api/mcp_server/${serverId}`);
        const index = this.servers.findIndex((s) => s.id === serverId);
        if (index !== -1) {
          this.servers.splice(index, 1);
        }
        message.success(t('setting.mcpService.deleteSuccess'));
      } catch (error) {
        message.error(t('setting.mcpService.deleteFailed'));
        console.error('Delete server error:', error);
      }
    },
  },
});




================================================
FILE: frontend/src/store/modules/user.js
================================================
import { set } from '@vueuse/core';
import { defineStore } from 'pinia'

export const useUserStore = defineStore('user', {
  state: () => ({
    user: {},
    membership:{},
    points:{}
  }),
  actions: {
    setUser(user) {
      console.log('setUser', user);
      this.user = user;
    },
    setMembership(membership) {
      console.log('setMembership', membership);
      this.membership = membership;
    },
    setPoints(points) {
      this.points = points;
    },
    clear(){
      this.user = {};
      this.membership = {};
      this.points = {};
    }

  },
  persist: true,
})



================================================
FILE: frontend/src/utils/base64.js
================================================
export const decode = (encoded) => {
  const decodedString = decodeURIComponent(
    atob(encoded)
      .split("")
      .map(function (char) {
        return "%" + ("00" + char.charCodeAt(0).toString(16)).slice(-2);
      })
      .join("")
  );
  return decodedString;
};

export default {
  decode,
};



================================================
FILE: frontend/src/utils/chat.js
================================================
function convertToTree(messages) {
  // åˆ›å»ºæ¶ˆæ¯æ˜ å°„ï¼Œä¾¿äºå¿«é€ŸæŸ¥æ‰¾
  console.log("convertToTree",messages)
  const messageMap = new Map();
  messages.forEach(msg => {
    console.log("msg",msg)
    //åˆ¤æ–­ msg.meta æ˜¯string è¿˜æ˜¯object
    let meta = msg.meta;
    if (typeof meta === 'string') {
      meta = JSON.parse(meta);
    }
    messageMap.set(msg.id, {
      id: msg.id,
      pid: meta.pid,
      role: msg.role,
      content: msg.content,
      is_active: meta.is_active,
      children: []
    });
  });
  console.log("messageMap",messageMap)
  // æ„å»ºæ ‘ç»“æ„
  const tree = [];
  messageMap.forEach(msg => {
    if (msg.pid === -1) {
      // æ ¹èŠ‚ç‚¹ç›´æ¥åŠ å…¥æ ‘
      tree.push(msg);
    } else {
      // éæ ¹èŠ‚ç‚¹ï¼Œæ‰¾åˆ°çˆ¶èŠ‚ç‚¹å¹¶åŠ å…¥å…¶ children
      const parent = messageMap.get(msg.pid);
      if (parent) {
        parent.children.push(msg);
      }
    }
  });

  // æŒ‰ id æ’åºæ ¹èŠ‚ç‚¹ï¼ˆå¯é€‰ï¼Œæ ¹æ®éœ€è¦ï¼‰
  tree.sort((a, b) => a.id - b.id);

  return tree;
}




export default {
  convertToTree,
};


================================================
FILE: frontend/src/utils/emitter.js
================================================
import mitt from "mitt";

const emitter = mitt()

export default emitter


================================================
FILE: frontend/src/utils/file.js
================================================


const imgType = ['png','jpg','svg','jpeg','gif','webp','bmp']
const blobTypeDict = ['png','jpg','svg','jpeg','gif','webp','bmp','pdf','docx','doc','xlsx','xls','pptx','ppt']

// 
function getFileReponseTypeByName(filename){
    const fileExtendName = filename.split('.').pop();
    if(blobTypeDict.includes(fileExtendName)){
        return 'blob';
    }else{
        return 'json';
    }
};

async function handleFileDownload(file) {
    try {
      const filePath = file.filepath;
      const fileName = filePath.split("/").pop();
      const fileExt = fileName.split(".").pop().toLowerCase();
  
      // æ–‡ä»¶åç¼€å¯¹åº” MIME ç±»å‹è¡¨ï¼ˆå¯æ‰©å±•ï¼‰
      const mimeTypes = {
        txt: "text/plain",
        csv: "text/csv",
        json: "application/json",
        pdf: "application/pdf",
        xls: "application/vnd.ms-excel",
        xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        doc: "application/msword",
        docx: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        png: "image/png",
        jpg: "image/jpeg",
        jpeg: "image/jpeg",
        gif: "image/gif",
        mp3: "audio/mpeg",
        mp4: "video/mp4",
        zip: "application/zip",
      };
      const mimeType = mimeTypes[fileExt] || "application/octet-stream";
      const accessToken = localStorage.getItem('access_token');
      // è°ƒç”¨åç«¯æ¥å£è·å–æ–‡ä»¶æµ
      const response = await fetch('/api/file/read', {
        method: 'POST',
        headers: { 
          'Content-Type': 'application/json' , 
          'Authorization': `Bearer ${accessToken}`
        },
        body: JSON.stringify({ path: filePath })
      });
  
      if (!response.ok) {
        throw new Error('Download failed');
      }
  
      // å°†è¿”å›çš„æµè½¬æˆ Blob
      const fileContent = await response.blob();
      const blob = new Blob([fileContent], { type: mimeType });
      console.log("=== blob ====",blob)
      const url = window.URL.createObjectURL(blob);
      console.log("=== url ====",url)
      // åˆ›å»ºä¸‹è½½é“¾æ¥
      const link = document.createElement('a');
      link.href = url;
      link.download = fileName;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      window.URL.revokeObjectURL(url);
  
      console.log('Download successful:', fileName);
    } catch (err) {
      console.error('Download failed:', err);
    }
  }




export default {
    getFileReponseTypeByName,
    handleFileDownload,
    imgType
};


================================================
FILE: frontend/src/utils/http.js
================================================
import axios from "axios";
import { message } from 'ant-design-vue';

// è®¾ç½® post è¯·æ±‚å¤´
axios.defaults.headers.post["Content-Type"] =
  "application/x-www-form-urlencoded;charset=UTF-8";
// åœ¨è·¨åŸŸè¯·æ±‚æ—¶ï¼Œä¸ä¼šæºå¸¦ç”¨æˆ·å‡­è¯ï¼›è¿”å›çš„ response é‡Œä¹Ÿä¼šå¿½ç•¥ cookie
axios.defaults.withCredentials = false;

console.log("ç¯å¢ƒå˜é‡", import.meta.env);
// åˆ›å»º axios å®ä¾‹, è¯·æ±‚è¶…æ—¶æ—¶é—´ä¸º 10 ç§’ baseURL: import.meta.env.BASE_URL,

const isDev = import.meta.env.MODE === 'development';

const instance = axios.create({
  baseURL: isDev ? undefined : import.meta.env.VITE_SERVICE_URL,  // å¼€å‘ç¯å¢ƒä¸è®¾ç½® baseURL
  timeout: 100000,
});

// è¯·æ±‚å‘èµ·å‰æ‹¦æˆª
instance.interceptors.request.use(
  (config) => {
    if (config.url === '/api/file/upload') {
      //ä¸Šä¼ å›¾ç‰‡åˆ°å›¾åº“è¯·æ±‚å¤´å¤„ç†
      config.headers['Content-Type'] = 'multipart/form-data'
    }

    const accessToken = localStorage.getItem('access_token');
    if (accessToken) {
      config.headers = {
        ...config.headers, // ä¿ç•™åŸæœ‰çš„ headers é…ç½®
        "Authorization": `Bearer ${accessToken}`
      };
    }
    
    return config;
  },
  (error) => {
    // Do something with request error
    return Promise.reject(error);
  }
);




// å“åº”æ‹¦æˆªï¼ˆè¯·æ±‚è¿”å›åæ‹¦æˆªï¼‰
let isShowing401Error = false; // æ ‡å¿—ä½ï¼Œç”¨äºæ§åˆ¶ 401 æç¤ºæ˜¯å¦å·²æ˜¾ç¤º

instance.interceptors.response.use(
  (res) => {
    // åˆ¤æ–­URL ä¸º /api/file/read ä¸æ‹¦æˆª
    
    if (res.config.url == '/api/file/read') {
      return res;
    }else if(res.config.url == '/api/model'){
      return res.data;
    }
    if (res.data.data) {
      return res.data.data;
    }
    return res;
  },
  (error) => {
    return Promise.reject(error);
  }
);

const http = {
  get(url, params) {
    return instance.get(url, { params: params });
  },
  post(url, params, header = {},responseType='json') {
    const options = {
      url,
      method: "POST",
      data: params,
      headers: Object.assign({ 'Content-Type': 'application/json' }, header),
      responseType:responseType,
    }
    return instance.request(options);
  },
  patch(url, params, header = {}) {
    const options = {
      url,
      method: "PATCH",
      data: params,
      headers: Object.assign({ 'Content-Type': 'application/json' }, header),
    };
    return instance.request(options);
  },
  put(url, params, header = {}) {
    const options = {
      url,
      method: "PUT",
      data: params,
      headers: Object.assign({ 'Content-Type': 'application/json' }, header),
    }
    return instance.request(options);
  },
  del(url, params, header = {}) {
    const options = {
      url,
      method: "DELETE",
      params: params,
      headers: Object.assign({ 'Content-Type': 'application/json' }, header),
    }
    return instance.request(options);
  },
};

export default http;



================================================
FILE: frontend/src/utils/markdown.js
================================================
import { marked } from 'marked'; // å¼•å…¥ marked

export const renderMarkdown = (content) => {
  // åˆ›å»ºè‡ªå®šä¹‰ renderer
  const renderer = new marked.Renderer();

  // é‡å†™ renderer çš„ link æ–¹æ³•ï¼Œæ·»åŠ  target="_blank" å’Œ rel="noopener noreferrer"
  renderer.link = function (href, title, text) {
    const link = marked.Renderer.prototype.link.call(this, href, title, text);
    return link.replace('<a', '<a target="_blank" rel="noopener noreferrer"');
  };

  // ä½¿ç”¨è‡ªå®šä¹‰ renderer
  const html = marked(content, {
    renderer: renderer,
    breaks: true,
  });

  return html;
};

export default {
  renderMarkdown
};


================================================
FILE: frontend/src/utils/time.js
================================================
export const formatTime = (timestamp) => {
  const date = new Date(timestamp);
  const now = new Date();

  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0'); // æœˆä»½ä»0å¼€å§‹
  const day = String(date.getDate()).padStart(2, '0');
  
  // å¦‚æœæ˜¯ NaN è¿”å› ç©ºå­—ç¬¦ä¸²
  if (isNaN(year)) {
    return '';
  }
  if (year === now.getFullYear()) {
    // ä»Šå¹´å†…ï¼Œæ˜¾ç¤º MM/DD
    return `${month}/${day}`;
  } else {
    // ä»Šå¹´ä»¥å‰ï¼Œæ˜¾ç¤º YYYY/MM/DD
    return `${year}/${month}/${day}`;
  }
};

export const formatTimeWithHMS = (timestamp) => {
  const date = new Date(timestamp);
  const now = new Date();

  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0'); // æœˆä»½ä»0å¼€å§‹
  const day = String(date.getDate()).padStart(2, '0');
  const hour = String(date.getHours()).padStart(2, '0');
  const minute = String(date.getMinutes()).padStart(2, '0');
  const second = String(date.getSeconds()).padStart(2, '0');
  
  // å¦‚æœæ˜¯ NaN è¿”å› ç©ºå­—ç¬¦ä¸²
  if (isNaN(year)) {
    return '';
  }
  if (year === now.getFullYear()) {
    // ä»Šå¹´å†…ï¼Œæ˜¾ç¤º MM/DD HH:mm:ss
    return `${month}/${day} ${hour}:${minute}:${second}`;
  } else {
    // ä»Šå¹´ä»¥å‰ï¼Œæ˜¾ç¤º YYYY/MM/DD HH:mm:ss
    return `${year}/${month}/${day} ${hour}:${minute}:${second}`;
  }
};


export default {
    formatTime,
    formatTimeWithHMS
}


================================================
FILE: frontend/src/utils/viewList.js
================================================
import { useChatStore } from '@/store/modules/chat';
import { timestamp } from '@vueuse/core';
import { storeToRefs } from 'pinia';
import { computed } from 'vue';
import time from './time';
// åˆå§‹åŒ– chatStore å’Œ messages
const chatStore = useChatStore();


// æå–æ‰€æœ‰ meta.action_type ä¸º plan çš„æ¶ˆæ¯ä¸­ meta.json çš„ actionsï¼Œåˆå¹¶ä¸ºæ‰å¹³åˆ—è¡¨
function viewRealTime( messages){
  const result = [];
  // éå† messages
  messages.value.forEach((message) => {
    // æ£€æŸ¥ meta.action_type æ˜¯å¦ä¸º plan
    if (message.meta?.action_type === 'plan') {
      // ç¡®ä¿ meta.json å­˜åœ¨ä¸”æ˜¯æ•°ç»„
      if (Array.isArray(message.meta.json)) {
        // éå† meta.json
        message.meta.json.forEach((jsonItem) => {
          // ç¡®ä¿ actions å­˜åœ¨ä¸”æ˜¯æ•°ç»„
          if (Array.isArray(jsonItem.actions)) {
            // å°† actions æ·»åŠ åˆ°ç»“æœåˆ—è¡¨
            jsonItem.actions.forEach((action) => {
              // æ·»åŠ  action
              if(action.status!== 'running'){
                result.push(action)
              }
            });
          }
        });
      }
    }
  });
  return result;
};

// 
function viewLocal(messages,passImg){
  const result = [];
  messages.forEach((message)=>{
    if (message.meta?.action_type === 'finish_summery' || message.meta?.action_type === 'question') {
      // ç¡®ä¿ meta.json å­˜åœ¨ä¸”æ˜¯æ•°ç»„
      if (Array.isArray(message.meta.json)) {
        // å¾ªç¯æ·»åŠ è¿›resultå¹¶æ·»åŠ id
        message.meta.json.forEach((jsonItem) => {
          result.push({
            timestamp: message.timestamp,
            ...jsonItem
          });
        });
      }
    }
  })
  if(passImg){
    return handlePassImg(result);
  }
  return result;
};


const imageType = ['png', 'jpg', 'jpeg', 'gif', 'bmp', 'webp', 'svg', 'ico']
function handlePassImg(fileList){
  const result = [];
  fileList.forEach(element => {
    if (!imageType.includes(element?.filename?.split('.').pop())) {
      result.push(element);
    }
  });
return result;
}


export const viewList = {
  viewRealTime,
  viewLocal
};


================================================
FILE: frontend/src/view/agents/index.vue
================================================
<template>
  <div class="agent">
    <div class="agent-header">
          <!-- <span class="disabled">Agents</span> -->
          <!-- <span>
            <MenuSearch class="search-icon" @click="onSearch" />
          </span> -->
      </div>
    <div class="agent-list" ref="agentListRef">
      <div v-for="agent in agents" :key="agent.id" class="agent-item"
      :class="{ active: selectedAgent?.id === agent.id }" 
      :ref="el => setAgentRef(el, agent.id)"
      @mouseenter="hoverAgent = agent.id"
      @mouseleave="hoverAgent = null" @click.stop="selectAgent(agent, true)">
      <span class="agent-name" :title="agent.name.length > 20 ? agent.name : null">{{ agent.name }}</span>
      <div v-if="hoverAgent === agent.id" class="ellipsis" @click.stop="openMenu(agent.id,$event)">
        <EllipsisIcon />
      </div>
      <Teleport to="body">
      <div v-if="showMenu === agent.id" class="menu" :style="menuStyle" @mouseleave="showMenu = null">
        <div class="menu-item" @click.stop="openEdit(agent.id)">
          <EditOutlined class="icon" /> Edit
        </div>
        <div class="menu-item" @click.stop="openKnowledge(agent.id)">
          <ReadOutlined class="icon" /> Experience 
        </div>
        <div class="menu-item danger" @click.stop="confirmDelete(agent.id)">
          <DeleteOutlined class="icon" /> Delete
        </div>
      </div>
    </Teleport>
    </div>
    </div>

  </div>
  <AgentsEdit v-model:visible="visible" v-model:id="agentId" />
  <KnowledgeModal :agentId="agentId" ref="knowledgeModalRef" />
  <a-modal
        :footer="null"
        :centered="true"
        v-model:open="searchModalVisible"
        @cancel="handleCancel"
        :closable="false"
        style="width: 800px; height: 500px;"
      >
        <template #title>
          <div class="search-header">
            <div class="search-header-icon">
              <MenuSearch />
            </div>
            <a-input ref="searchInputRef" v-model:value="searchValue" placeholder="Search Agents..." />
            <div class="search-header-icon" @click="handleCancel">
              <Close />
            </div>
          </div>
        </template>
        <!-- 
         @click="setActiveChat(chat)"
            :class="{ 'active': chat.conversation_id === conversationId }"
        -->
        <div class="search-content">
          <div
            v-for="agent in filteredAgents"
            :key="agent.id"
            class="search-item"
            @click="selectAgent(agent, true)"
          >
            <!-- <div class="search-item-avatar">
              <div class="avatar-placeholder">{{ agent.name.charAt(0).toUpperCase() }}</div>
            </div> -->
            <div class="search-item-content">
              <div class="search-item-name">{{ agent.name }}</div>
              <div class="search-item-time">{{ formatTime(agent.create_at) }}</div>
            </div>
          </div>
          <div v-if="filteredAgents.length === 0 && searchValue.trim()" class="no-results">
            No agents found for "{{ searchValue }}"
          </div>
        </div>
      </a-modal>
</template>
<script setup>
import { ref, onMounted, onUnmounted, watch, computed, nextTick } from 'vue'
import { EditOutlined, DeleteOutlined, ReadOutlined } from '@ant-design/icons-vue'
import AgentsEdit from '@/view/agents/components/agentsEdit.vue'
import KnowledgeModal from '@/view/agents/components/KnowledgeModal.vue'
import { message, Modal } from 'ant-design-vue'
import agentService from "@/services/agent"
import emitter from '@/utils/emitter'
import { useRouter, useRoute } from 'vue-router'
import MenuSearch from '@/assets/svg/menuSearch.svg'
import Close from '@/assets/filePreview/close.svg'
import EllipsisIcon from '@/assets/svg/ellipsis-icon.svg'
import { formatTime } from '@/utils/time';
const router = useRouter()
const route = useRoute()

import { storeToRefs } from 'pinia';
import { useChatStore } from '@/store/modules/chat';
const chatStore = useChatStore();
const { agent,conversationId } = storeToRefs(chatStore);


const agents = ref([])
const visible = ref(false)
const agentId = ref(null)
const knowledgeModalRef = ref(null)
const hoverAgent = ref(null)
const showMenu = ref(null)
const selectedAgent = ref(null)
const menuStyle = ref({})
const agentListRef = ref(null)
const agentRefs = ref(new Map())


const searchModalVisible = ref(false)
const searchValue = ref("")
const searchInputRef = ref(null)

// è¿‡æ»¤åçš„agentsåˆ—è¡¨
const filteredAgents = computed(() => {
  if (!searchValue.value.trim()) {
    return agents.value
  }
  return agents.value.filter(agent => 
    agent.name.toLowerCase().includes(searchValue.value.toLowerCase())
  )
})

const onSearch = async () => {
  searchModalVisible.value = true
  searchValue.value = ""
  await nextTick()
  searchInputRef.value?.focus()
}

const handleCancel = () => {
  searchModalVisible.value = false
  searchValue.value = ""
}

// è®¾ç½® agent å…ƒç´ çš„ ref
const setAgentRef = (el, agentId) => {
  if (el) {
    agentRefs.value.set(agentId, el)
  } else {
    agentRefs.value.delete(agentId)
  }
}

// æ»šåŠ¨åˆ°é€‰ä¸­çš„ agent
const scrollToSelectedAgent = () => {
  if (selectedAgent.value && agentRefs.value.has(selectedAgent.value.id)) {
    nextTick(() => {
      const element = agentRefs.value.get(selectedAgent.value.id)
      if (element && agentListRef.value) {
        element.scrollIntoView({
          behavior: 'smooth',
          block: 'start',
          inline: 'nearest'
        })
      }
    })
  }
}

// ç›‘å¬ selectedAgent å˜åŒ–ï¼Œè‡ªåŠ¨æ»šåŠ¨
watch(selectedAgent, () => {
  scrollToSelectedAgent()
})

// ç¼–è¾‘
function openEdit(id) {
  visible.value = true
  agentId.value = id
}

// åˆ é™¤ï¼ˆä½¿ç”¨ Modal ç¡®è®¤ï¼‰
function confirmDelete(id) {
  Modal.confirm({
    title: 'Confirm Delete',
    content: 'Are you sure you want to delete this agent?',
    onOk: async () => {
      await agentService.delete(id)
      fetchAgents()
      message.success("Delete Success")
      router.push("/lemon")
    }
  })
}

const closeOtherWindows = () => {
  emitter.emit('preview-close', false);
  emitter.emit('terminal-visible', false);
  emitter.emit('fullPreviewVisable-close');
};

//openKnowledge
function openKnowledge(id) {
  agentId.value = id
  knowledgeModalRef.value.visible = true
}
// å±•å¼€æ›´å¤šèœå•
function openMenu(id,event) {
  showMenu.value = showMenu.value === id ? null : id
  const targetRect = event.currentTarget.getBoundingClientRect();
  const menuHeight = 120; // ä½ èœå•çš„å®é™…é«˜åº¦ï¼Œæˆ–è€…åŠ¨æ€è·å–
  const padding = 8; // é˜²æ­¢è´´è¾¹å¤ªç´§

  let top = 0;
  if (window.innerHeight - targetRect.bottom < menuHeight + padding) {
    // ç©ºé—´ä¸è¶³ â†’ æ˜¾ç¤ºåœ¨ä¸Šæ–¹
    top = targetRect.top - menuHeight + 25;
  } else {
    // ç©ºé—´å……è¶³ â†’ æ˜¾ç¤ºåœ¨ä¸‹æ–¹
    top = targetRect.bottom;
  }

  menuStyle.value = {
    position: 'fixed',
    top: `${top}px`,
    left: `${targetRect.left}px`,
    zIndex: 99999,
  };
}

// è·å–å…¨éƒ¨ agent åˆ—è¡¨
const fetchAgents = async () => {
  let res = await agentService.getList()
  // create_at æ ¹æ® åˆ›å»ºæ—¶é—´ é™åº
  res.sort((a, b) => new Date(b.create_at) - new Date(a.create_at))
  agents.value = res
}

//å…¨å±€äº‹ä»¶ emitter æ›´æ–°agentåˆ—è¡¨
emitter.on('updateAgentList', fetchAgents)
//å…¨å±€äº‹ä»¶ æ–°å¢agent
emitter.on('addAgent', addAgent)
emitter.on('selectedAgent', findAgent)

//æ–°å¢å›è°ƒ
function addAgent(item) {
  fetchAgents();
  //é€‰ä¸­æ–°å¢çš„agent
  selectAgent(item, true,false)
}

//é€‰ä¸­agent
function findAgent(item) {
  // å…ˆç”¨IDåœ¨agentsæ•°ç»„ä¸­æŸ¥æ‰¾
  const existingAgent = agents.value.find(agent => agent.id === item.id);
  
  if (existingAgent) {
    // å¦‚æœå­˜åœ¨ï¼Œèµ°é€‰ä¸­å‡½æ•°
    console.log('Agent exists, selecting:', existingAgent);
    selectAgent(existingAgent, true,false);
  } else {
    // å¦‚æœä¸å­˜åœ¨ï¼Œèµ°æ·»åŠ å‡½æ•°
    console.log('Agent not found, adding new agent:', item);
    addAgent(item);
  }
}


// é€‰ä¸­ agent
async function  selectAgent(item, isClick = false,needSelect = true) {
  closeOtherWindows();
  searchModalVisible.value = false
  // emitter.emit('open-collapse');
  console.log("è§¦å‘äº†é€‰ä¸­äº‹ä»¶", conversationId.value)
  selectedAgent.value = selectedAgent.value?.id === item.id ? null : item
  agentId.value = selectedAgent.value?.id ?? null
  //è®¾ç½®å½“å‰é€‰ä¸­çš„agent
  agent.value = item
  await chatStore.init("task");
  if(needSelect){
    await chatStore.selectFirst();
  }
  
  // ç§»åŠ¨ç«¯é€‰æ‹©agentåå…³é—­èœå•
  if (window.innerWidth <= 768) {
    emitter.emit('toggleMobileMenu', false);
  }
  
  if (isClick) {
    if(conversationId.value){
      router.push(`/lemon/${agent.value.id}/${conversationId.value}`)
    }else{
      router.push(`/lemon/${agent.value.id}`)
    }
   
  }
}


//ç›‘å¬è·¯ç”±ä¸­çš„ agent_id å¦‚æœæ²¡æœ‰ æ¸…ç©º selectedAgent
watch(() => route.params.agentId, (newVal) => {
  console.log("route.params.agentId æ”¹å˜", newVal)
  if (!newVal) {
    selectedAgent.value = null
  }
})
// ç‚¹å‡»ç©ºç™½åŒºåŸŸå…³é—­æ›´å¤šèœå•
function closeMenu() {
  showMenu.value = null
}

onMounted(async () => {
  await fetchAgents()
  const agentId = route.params.agentId
  if (agentId && agentId!='chat') {
    selectAgent(agents.value.find(item => item.id == agentId), false)
  }
  window.addEventListener('click', closeMenu)
})


onUnmounted(() => {
  window.removeEventListener('click', closeMenu)
})

// æš´éœ²æ–¹æ³•ä¾›çˆ¶ç»„ä»¶è°ƒç”¨
defineExpose({
  onSearch
})

</script>
<style lang="scss"  scoped>
.agent {
  width: 100%;
  padding: 0 12px;
  display: flex;
  gap: 12px;
  flex-direction: column;
  overflow: hidden;
}
.agent-list{
  width: 100%;
  display: flex;
  gap: 12px;
  flex-direction: column;
  overflow: auto;
}

.agent-item {
  position: relative;
  display: flex;
  justify-content: space-between;
  align-items: center;
  cursor: pointer;
  padding: 8px;
  gap: 5px;
  line-height: 23px;
  border-radius: 12px;
  color: rgba(16,16,16,1);
  font-size: 14px;
  text-align: left;
  font-family: PingFangSC-regular;

}


/* */

.agent-item:hover {
  border: 1px solid rgba(236,236,236,1);
  background-color: #F9F9FB;
}

.agent-item.active {
  border: 1px solid rgba(236,236,236,1);
  background-color: #F9F9FB;
} 

.search-icon{
  width: 20px;
  height: 20px;
  cursor: pointer;
}



.search-header {
  display: flex;
  align-items: center;
  gap: 0.625rem;

  input {
    border: unset !important;
    color: #34322d;
    font-size: 18px;
    font-weight: 400;
    line-height: 1.75rem;
  }

  .search-header-icon {
    width: 20px;
    height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;

    svg {
      width: 20px;
      height: 20px;
    }
  }
}

.ellipsis {
  cursor: pointer;
  padding: 0 4px;
  display: flex;
  align-items: center;
  justify-content: center;

  svg {
    width: 18px;
    height: 18px;
  }
}

.agent-name {
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.menu {
  background: #ffffff;
  border: 1px solid rgba(224, 224, 224, 0.8);
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08), 0 2px 4px rgba(0, 0, 0, 0.04);
  border-radius: 8px;
  padding: 4px;
  min-width: 140px;
  overflow: hidden;
  backdrop-filter: blur(8px);
}

.menu-item {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 12px;
  font-size: 14px;
  font-family: PingFangSC-regular;
  line-height: 20px;
  cursor: pointer;
  color: rgba(16, 16, 16, 1);
  border-radius: 6px;
  transition: all 0.15s ease;
  user-select: none;

  .icon {
    font-size: 16px;
    flex-shrink: 0;
    transition: transform 0.15s ease;
  }

  &:hover {
    background-color: rgba(0, 0, 0, 0.04);

    .icon {
      transform: scale(1.1);
    }
  }

  &:active {
    background-color: rgba(0, 0, 0, 0.06);
    transform: scale(0.98);
  }

  &.danger {
    color: #ff4d4f;

    &:hover {
      background-color: rgba(255, 77, 79, 0.08);
    }

    &:active {
      background-color: rgba(255, 77, 79, 0.12);
    }
  }
}

.agent-header{
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0 12px;
  font-size: 14px;
  color: #0d0d0d;
}
.disabled {
  color: #8f8f8f;
  pointer-events: none;
}

/* Search Content Styles */
.search-content {
  height: 400px;
  max-height: 400px;
  overflow-y: auto;
  padding: 8px 0;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.search-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  cursor: pointer;
  padding: 8px;
  gap: 5px;
  line-height: 23px;
  border-radius: 12px;
  color: rgba(16,16,16,1);
  font-size: 16px;
  text-align: left;
  font-family: PingFangSC-regular;
  border: 1px solid rgba(236,236,236,1);
  background-color: #F9F9FB;
  transition: all 0.2s ease;
  box-sizing: border-box;

  &:hover {
    background-color: #0000000f;
  }

  &:active {
    transform: scale(0.98);
  }
}

.search-item-avatar {
  margin-right: 12px;
  flex-shrink: 0;
}

.avatar-placeholder {
  width: 28px;
  height: 28px;
  border-radius: 50%;
  background: #34322d;
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 600;
  font-size: 16px;
  text-transform: uppercase;
}

.search-item-content {
  display: flex;
  flex-direction: row;
  width: 100%;
  justify-content: space-between;
  align-items: center;
  flex: 1;
  min-width: 0;
}

.search-item-name {
  line-height: 23px;
  color: rgba(16,16,16,1);
  font-size: 16px;
  text-align: left;
  font-family: PingFangSC-regular;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  flex: 1;
}

.search-item-time {
  line-height: 17px;
  color: rgba(154,154,154,1);
  font-size: 12px;
  text-align: left;
  font-family: PingFangSC-regular;
  white-space: nowrap;
  flex-shrink: 0;
  margin-left: 12px;
}

.search-item-desc {
  font-size: 13px;
  color: #718096;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

/* Empty state */
.search-content:empty::after {
  content: "No agents found";
  display: block;
  text-align: center;
  color: #a0aec0;
  font-size: 14px;
  padding: 32px 16px;
}

.no-results {
  text-align: center;
  color: #a0aec0;
  font-size: 14px;
  padding: 32px 16px;
  font-style: italic;
}

/* Scrollbar styling */
.search-content::-webkit-scrollbar {
  width: 6px;
}

.search-content::-webkit-scrollbar-track {
  background: #f1f5f9;
  border-radius: 3px;
}

.search-content::-webkit-scrollbar-thumb {
  background: #cbd5e0;
  border-radius: 3px;
  
  &:hover {
    background: #a0aec0;
  }
}
</style>


================================================
FILE: frontend/src/view/agents/components/agentsEdit.vue
================================================
<template>
    <a-modal :open="visible" :title="modalTitle" width="800px" @cancel="handleCancel" @ok="handleOk">
        <a-form :model="form" layout="vertical">
            <a-form-item label="Name">
                <a-input v-model:value="form.name" placeholder="Please enter name" />
            </a-form-item>

            <a-form-item label="Description">
                <a-textarea v-model:value="form.describe" rows="4" placeholder="Please enter describe" />
            </a-form-item>

            <!-- <a-form-item label="Visibility">
                <a-radio-group style="width: 100%;display: flex;justify-content: space-between;" v-model:value="form.is_public">
                    <a-radio v-for="option in visibilityOptions" :key="option.value" :value="option.value" 
                             :disabled="!option.value && isPersonalDisabled">
                        <span>{{ option.label }}</span>
                        <a-tag v-if="!option.value" size="small" style="margin-left: 4px; background-color: #000; color: #fff; border: none;">Pro+</a-tag>
                        <span style="color: #666; font-size: 12px; margin-left: 8px;">{{ option.desc }}</span>
                    </a-radio>
                </a-radio-group>
                <div v-if="isPersonalDisabled" style="margin-top: 8px; padding: 8px; background-color: #f0f0f0; border: 1px solid #d9d9d9; border-radius: 4px;">
                    <span style="color: #666; font-size: 12px;">
                        Want to {{ isEditMode ? 'set agent as' : 'create' }} private? 
                        <a @click="upgradeToPro()" style="color: #1890ff; text-decoration: underline; cursor: pointer;">Upgrade to Pro+</a>
                    </span>
                </div>
            </a-form-item> -->
            
            <a-collapse>
                <a-collapse-panel key="1" header="Select MCP Services">
                    <a-input-search v-model:value="searchKeyword" placeholder="Search MCP services" allowClear
                        style="margin-bottom: 16px" />
                    <div class="mcp-grid">
                        <div v-for="mcp in mcpServers" :key="mcp.id"
                            :class="['mcp-card', { selected: form.mcpids.includes(mcp.id) }]"
                            @click="toggleMcp(mcp.id)">
                            <div class="checkbox-icon">
                                <a-icon v-if="form.mcpids.includes(mcp.id)" type="check-circle"
                                    style="color: #52c41a; font-size: 20px" />
                            </div>
                            <div class="mcp-content">
                                <div class="mcp-name">{{ mcp.name }}</div>
                                <div class="mcp-desc">{{ mcp.describe }}</div>
                            </div>
                        </div>
                    </div>
                </a-collapse-panel>
            </a-collapse>
        </a-form>
    </a-modal>
</template>
<script setup>
import { ref, reactive, watch, computed } from 'vue'
import mcpService from "@/services/mcp";
import agentService from "@/services/agent";
import emitter from '@/utils/emitter';
import { storeToRefs } from 'pinia';
import { useUserStore } from '@/store/modules/user';
import { useChatStore } from '@/store/modules/chat';
const userStore = useUserStore();
const { user,membership, points } = storeToRefs(userStore);

const chatStore = useChatStore();
const { agent } = storeToRefs(chatStore);

const props = defineProps({
    visible: Boolean,
    id: String,
})

const emit = defineEmits(['update:visible', 'updateList'])

const form = reactive({
    name: '',
    describe: '',
    mcpids: [],
    is_public:true
})

const mcpServers = ref([]);
const searchKeyword = ref('');
const loading = ref(false);
const modalTitle = ref('Create Agent');
const showUpgradeModal = ref(false);
const upgradeTitle = ref("Upgrade")

const visibilityOptions = [
    {
        value: true,
        label: 'Public',
        desc: 'Anyone can view and remix',
    },
    {
        value: false,
        label: 'Personal',
        desc: 'Only visible to yourself',
    },
];

const isEditMode = computed(() => !!props.id);

const isPersonalDisabled = computed(() => !membership.value?.planName);


const closeModal = () => {
  showUpgradeModal.value = false;
};
const upgradeToPro = () => {
  showUpgradeModal.value = true;
};
const fetchMcpServers = async () => {
    try {
        const servers = await mcpService.activate_servers();
        mcpServers.value = Array.isArray(servers) ? servers : [];
    } catch (error) {
        console.error("Error fetching MCP servers:", error);
    }
};

const resetForm = () => {
    form.name = '';
    form.describe = '';
    form.mcpids = [];
    form.is_public = true;
    searchKeyword.value = '';
};

const initAgent = async () => {
    console.log('initAgent',props.id);
    resetForm();
    
    // æ ¹æ®æ˜¯å¦ä¸ºç¼–è¾‘æ¨¡å¼è®¾ç½®æ ‡é¢˜
    modalTitle.value = isEditMode.value ? 'Edit Agent' : 'Create Agent';
    
    if (!isEditMode.value) return;

    loading.value = true;
    try {
        const res = await agentService.getById(props.id);
        console.log('res', res);
        form.name = res.name || '';
        form.describe = res.describe || '';
        form.mcpids = res.mcp_server_ids || [];
        form.is_public = res.is_public;
    } catch (e) {
        console.error('initAgent error', e);
    } finally {
        loading.value = false;
    }
};

watch(() => props.visible, async (val) => {
    if (val) {
        await fetchMcpServers();
        await initAgent();
    }
});

const handleOk = async () => {
    if (isEditMode.value) {
        await agentService.update(props.id, form.name, form.describe, form.mcpids,form.is_public); 
        //agent.value
        if (agent.value && agent.value.id === props.id) {
            agent.value = {
                ...agent.value,
                name: form.name,
                describe: form.describe,
                mcp_server_ids: form.mcpids,
                is_public: form.is_public
            };
        }

        emitter.emit('updateAgentList');
    } else {
        let res = await agentService.create(form.name, form.describe, form.mcpids);
        emitter.emit('addAgent', res);
    }
    emit('update:visible', false);
};

const handleCancel = () => {
    resetForm();
    emit('update:visible', false);
};

const toggleMcp = (id) => {
    const index = form.mcpids.indexOf(id);
    if (index > -1) {
        form.mcpids.splice(index, 1);
    } else {
        form.mcpids.push(id);
    }
};
</script>




<style scoped>
.mcp-grid {
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
}

.mcp-card {
    cursor: pointer;
    border: 1px solid #d9d9d9;
    border-radius: 6px;
    padding: 12px;
    width: 180px;
    position: relative;
    transition: border-color 0.3s;
    user-select: none;
    background-color: #fff;
    display: flex;
    flex-direction: column;
    min-height: 100px;
}

.mcp-card.selected {
    border-color: #22ce55;
    background-color: #f6ffed;
}

.checkbox-icon {
    position: absolute;
    top: 8px;
    right: 8px;
}

.mcp-name {
    font-weight: 600;
    margin-bottom: 6px;
    font-size: 14px;
}

.mcp-desc {
    font-size: 14px;
    color: #666;
    overflow: hidden;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    /* æ˜¾ç¤º2è¡Œ */
    -webkit-box-orient: vertical;
    white-space: normal;
    text-overflow: ellipsis;
}
</style>



================================================
FILE: frontend/src/view/agents/components/KnowledgeModal.vue
================================================
<template>
  <a-modal
    v-model:open="visible"
    title="Experience Management"
    width="900px"
    @cancel="onCancel"
    @ok="onOk"
    :footer="null"
    ok-text="Close"
    :cancel-button-props="{ style: { display: 'none' } }"
  >
    <a-tabs v-model:activeKey="activeTab" @change="onTabChange" style="margin-bottom: 16px;">
      <a-tab-pane key="personal" tab="Personal Experience" />
      <a-tab-pane key="system" tab="System Experience" />
    </a-tabs>

    <div class="toolbar">
      <a-input-search
        v-model:value="searchText"
        placeholder="Please enter content or category"
        enter-button
        @search="onSearch"
        style="max-width: 300px"
      />
      <a-button type="primary" @click="showAddModal">Add Experience</a-button>
    </div>

    <div class="table-container">
      <a-table
        :columns="columns"
        :data-source="filteredList"
        row-key="id"
        :pagination="{ pageSize: 5 }"
      >
        <template #bodyCell="{ column, record }">
          <template v-if="column.key === 'create_at'">
            {{ dayjs(record[column.dataIndex]).format('YYYY-MM-DD HH:mm') }}
          </template>
          <template v-else-if="column.key === 'action'">
            <a-space>
              <a-button type="link" @click="editItem(record)">Edit</a-button>
              <a-popconfirm title="Are you sure to delete?" @confirm="() => deleteItem(record.id)">
                <a-button danger type="link">Delete</a-button>
              </a-popconfirm>
            </a-space>
          </template>
          <template v-else-if="column.key === 'content'">
            <div class="content-ellipsis">{{ record[column.dataIndex] }}</div>
          </template>
          <template v-else>
            {{ record[column.dataIndex] }}
          </template>
        </template>
      </a-table>

      <!-- è’™ç‰ˆï¼Œä»…åœ¨éä¼šå‘˜æŸ¥çœ‹ system æ—¶æ˜¾ç¤º -->
      <div v-if="showOverlay" class="overlay-mask">
        <div class="overlay-content">
          {{ $t("setting.experience.systemExperienceRequiresUpgrade") }}
          <button @click="goUpgrade" class="upgrade">{{ $t("member.upgrade") }}</button>
        </div>
        
      </div>
    </div>

    <!-- ç¼–è¾‘ / æ·»åŠ  å¼¹çª— -->
    <a-modal
      v-model:open="editVisible"
      :title="editingItem?.id ? 'Edit Experience' : 'Add Experience'"
      @ok="saveItem"
      @cancel="editVisible = false"
      :width="700"
    >
      <a-form :model="form" layout="vertical">
        <a-form-item label="Content">
          <a-textarea v-model:value="form.content" :rows="12" placeholder="Enter content here" />
        </a-form-item>
        <a-form-item label="Category">
          <a-select v-model:value="form.category" placeholder="Please select category" allow-clear>
            <a-select-option v-for="item in categories" :key="item" :value="item">
              {{ item }}
            </a-select-option>
          </a-select>
        </a-form-item>
      </a-form>
      <template #footer>
        <a-button
          style="background-color: #1a1a19; border-color: #1a1a19; color: #fff;"
          @click="saveItem"
        >
          Save
        </a-button>
        <a-button @click="editVisible = false">Cancel</a-button>
      </template>
    </a-modal>
  </a-modal>
</template>

<script setup>
import { ref, computed, onMounted, watch } from 'vue';
import dayjs from 'dayjs';
import { message } from 'ant-design-vue';
import service from '@/services/knowledge.js';
import { useChatStore } from '@/store/modules/chat';
import { useUserStore } from '@/store/modules/user'; // ç¡®ä¿ä½ æœ‰è¿™è¡Œ
import { storeToRefs } from 'pinia';
import { useRouter } from 'vue-router';

const chatStore = useChatStore();
const { agent } = storeToRefs(chatStore);

const userStore = useUserStore();
const { user, membership, points } = storeToRefs(userStore);

const router = useRouter();

const visible = ref(false);
const editVisible = ref(false);
const editingItem = ref(null);
const form = ref({ content: '', category: '' });

const searchText = ref('');
const data = ref([]);
const categories = ref([]);
const activeTab = ref('personal'); // å½“å‰Tab

// agentId prop
const props = defineProps({
  agentId: {
    type: Number,
    default: 0
  }
});

function getAgentId() {
  return props.agentId || agent.value.id;
}

// ä¼šå‘˜æ ¡éªŒ
const isMember = computed(() => !!membership.value?.planName);
const showOverlay = computed(() => activeTab.value === 'system' && !isMember.value);

// åˆ†ç±»åˆ—è¡¨
const getCategoryList = async () => {
  try {
    const res = await service.getCategoryList();
    categories.value = res || [];
  } catch (err) {
    console.error(err);
  }
};

// æ•°æ®åˆ—è¡¨
const getList = async () => {
  try {
    const res = await service.getList(getAgentId());
    data.value = activeTab.value === 'system' ? (res.system || []) : (res.personal || []);
  } catch (err) {
    console.error(err);
  }
};

// tab åˆ‡æ¢
const onTabChange = async (key) => {
  if (key === 'system' && !isMember.value) {
    // message.warning('You need to upgrade to view system experiences.');
  }
  activeTab.value = key;
  await getList();
};

const filteredList = computed(() =>
  data.value.filter(
    (item) =>
      item.content?.includes(searchText.value) ||
      item.category?.includes(searchText.value)
  )
);

const showAddModal = () => {
  editingItem.value = null;
  form.value = { content: '', category: '' };
  editVisible.value = true;
};

const editItem = (record) => {
  editingItem.value = record;
  form.value = { content: record.content, category: record.category };
  editVisible.value = true;
};

const saveItem = async () => {
  if (!form.value.content || !form.value.category) {
    message.error('Please complete content and category.');
    return;
  }
  try {
    if (editingItem.value?.id) {
      await service.update(editingItem.value.id, form.value.content, form.value.category);
      message.success('Updated successfully.');
    } else {
      await service.create(form.value.content, form.value.category, getAgentId());
      message.success('Added successfully.');
    }
    editVisible.value = false;
    getList();
  } catch (e) {
    console.error(e);
    message.error('Operation failed.');
  }
};

const deleteItem = async (id) => {
  try {
    await service.delete(id);
    message.success('Deleted successfully.');
    getList();
  } catch (e) {
    console.error(e);
    message.error('Failed to delete.');
  }
};

const onCancel = () => {
  visible.value = false;
};

const onOk = () => {
  visible.value = false;
};

const onSearch = () => {
  // handled by computed
};

const goUpgrade = () => {
  // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦ç™»å½•
  const accessToken = localStorage.getItem('access_token');
  const hasUserId = user.value && user.value.id;
  
  if (!accessToken || !hasUserId) {
    // æœªç™»å½•ï¼Œè·³è½¬åˆ°ç™»å½•é¡µé¢
    router.push({ name: 'login' });
  } else {
    // å·²ç™»å½•ï¼Œè·³è½¬åˆ°å‡çº§é¡µé¢
    router.push({ name: 'pricing' });
  }
};

const columns = [
  { title: 'Content', dataIndex: 'content', key: 'content' },
  { title: 'Category', dataIndex: 'category', key: 'category' },
  {
    title: 'Created At',
    dataIndex: 'create_at',
    key: 'create_at',
    width: 200,
  },
  {
    title: 'Actions',
    key: 'action',
    width: 100
  },
];

onMounted(() => {
  getCategoryList();
});

watch(visible, (val) => {
  if (val) {
    getList();
  }
});

defineExpose({ visible });
</script>

<style scoped>
.toolbar {
  display: flex;
  justify-content: space-between;
  margin-bottom: 16px;
}
.content-ellipsis {
  display: -webkit-box;
  -webkit-line-clamp: 3;
  -webkit-box-orient: vertical;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: normal;
  word-break: break-word;
}
.table-container {
  position: relative;
}
.overlay-mask {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: rgba(255, 255, 255, 0.4); /* åŠé€æ˜ç™½è‰²ï¼Œå¯ä»¥è°ƒ */
    z-index: 10;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;

    /* å…³é”®ï¼šæ¨¡ç³Šæ»¤é•œ */
    backdrop-filter: blur(2px);
    -webkit-backdrop-filter: blur(2px); /* Safari å…¼å®¹ */
}

.overlay-content {
  color: #000000; /* æ”¹ä¸ºé»‘è‰²æ–‡å­— */
  font-weight: 500;
  font-size: 16px;
  text-align: center;
  padding: 16px 24px;
  background: #f5f5f5; /* æµ…ç°èƒŒæ™¯ï¼ŒåŸæ¥æ˜¯æ·¡è“ */
  border: 1px dashed #d9d9d9; /* ç°è‰²è¾¹æ¡†ï¼Œæ›¿ä»£åŸæ¥çš„è“è‰² */
  border-radius: 8px;
  /* text-decoration: underline; */
}

.upgrade{
  color: #fff;
  background-color: #1a1a19;
  padding-left: .75rem;
  padding-right: .75rem;
  border-radius: 16px;
  border: 1px solid #1a1a19;
  margin-left: 10px;
  cursor: pointer;
  /* ç«‹ä½“æ„Ÿ */
  box-shadow: 0 2px 6px rgba(0,0,0,0.2);
}
</style>



================================================
FILE: frontend/src/view/auth/GoogleCallback.vue
================================================
[Binary file]


================================================
FILE: frontend/src/view/auth/index.vue
================================================
<template>
  <Login />
</template>

<script setup>
import Login from './Login.vue';
</script>


================================================
FILE: frontend/src/view/auth/Login.vue
================================================
<template>
  <div class="auth-container">
    <div class="auth-content">
      <!-- Logo -->
      <div class="logo-container">
        <div class="logo">
          <img :src="logo" alt="logo" />
        </div>
      </div>
      <!-- Title -->
      <h2 class="auth-title">{{ pageTitle }}</h2>
      <div v-if="activeKey === 'login'">
        <login @toRegister="handleToRegister" @handleLogin="handleLogin" @toForgot="handleToForgot" @handleGoogleLogin="handleGoogleLogin" @handleSMSLogin="activeKey = 'smsLogin'" />
      </div>
      <div v-if="activeKey === 'smsLogin'">
        <smsLogin @toLogin="activeKey = 'login'" @handleLoginSMSCode="handleLoginSMSCode" />
      </div>
      <div v-if="activeKey === 'register'">
        <!-- Register Form -->
        <register @toLogin="activeKey = 'login'" @handleRegister="handleRegister" @handleGoogleRegister="handleGoogleLogin"/>
      </div>
      <div v-if="activeKey === 'forgot'">
        <forgot @toLogin="activeKey = 'login'" @handleForgotPassword="handleForgotPassword"/>
      </div>
      <div v-if="activeKey === 'verify'">
        <!-- Email Verification Form -->
        <div class="verify-container">
          <p class="verify-text">{{ $t('auth.codeSentTo') }} {{ verifyEmail }}</p>
          <a-form :model="verifyForm" name="verify-form" @finish="handleVerify" autocomplete="off" layout="vertical">
            <a-form-item name="code" :rules="[{ required: true, message: $t('auth.pleaseInput6DigitCode') }]">
              <a-input v-model:value="verifyForm.code" :placeholder="$t('auth.pleaseInput6DigitCode')">
              </a-input>
            </a-form-item>
            <a-form-item>
              <a-button type="primary" html-type="submit" block :loading="loading" :disabled="!verifyForm.code">
                {{ $t('auth.verifyEmailButton') }}
              </a-button>
            </a-form-item>
            <div class="verify-footer">
              <p>{{ $t('auth.notReceivedCode') }} <a @click="resendCode">{{ $t('auth.resendCode') }}</a></p>
            </div>
          </a-form>
        </div>
      </div>
      <div class="auth-footer">
        <span class="auth-footer-keep-offline" @click="toHome">{{ $t('auth.keepOffline') }}</span>
      </div>
      
    </div>
  </div>
</template>

<script setup>
import { ref, reactive, computed, onMounted } from 'vue';
import logo from '@/assets/image/lemon.jpg';
import google from '@/assets/svg/google.svg';

// import apple from '@/assets/svg/apple.svg';
import { useRouter } from 'vue-router';
import { message } from 'ant-design-vue';
import auth from '@/services/auth';

import login from './components/login.vue'
import register from './components/register.vue'
import forgot from './components/forgot.vue'
import smsLogin from './components/sms-login.vue'

import { storeToRefs } from 'pinia';
import { useUserStore } from '@/store/modules/user.js'
const userStore = useUserStore();
const { user } = storeToRefs(userStore);

const router = useRouter();
import { useI18n } from 'vue-i18n';
const { t } = useI18n();

// é¡µé¢çŠ¶æ€
const activeKey = ref('login');
const loading = ref(false);


onMounted(() => {
  const isClient = import.meta.env.VITE_IS_CLIENT === 'true';
  console.log("isClient === ",isClient);
  if(window.electronAPI){
    window.electronAPI.on('oauth-login-success', ({ code, state }) => {
      if  (user.value.id) {
        window.location.href = '/';
      }else{
        window.location.hash = `/auth/google?code=${code}&state=${state}`;
      }
    });
  }
})

//åˆ¤æ–­æ˜¯å›½å†…è¿˜æ˜¯æµ·å¤– VITE_REGION
const isAbroad = ref(true)



// éªŒè¯ç›¸å…³çŠ¶æ€
const verifyEmail = ref('');
const verifyForm = reactive({
  code: ''
});

// é¡µé¢æ ‡é¢˜
const pageTitle = computed(() => {
  switch (activeKey.value) {
    case 'login':
      return t('auth.loginToLemonAI');
    case 'register':
      return t('auth.registerLemonAIAccount');
    case 'verify':
      return t('auth.verifyEmail');
    case 'smsLogin':
      return t('auth.loginToLemonAI');
    default:
      return t('auth.resetPassword');
  }
});

// å¤„ç†éªŒè¯ç æäº¤
const handleVerify = async () => {
  try {
    loading.value = true;
    const res = await auth.verifyEmailVerifyCode(verifyEmail.value, verifyForm.code);
    if (res.code === 200) {
      const resRegister = await auth.register(
        registerForm.value.fullname,
        registerForm.value.email,
        registerForm.value.password,
        ''
      );
      if (resRegister.code === 200) {
        message.success(t('auth.registrationSuccessful'));
        activeKey.value = 'login';
      } else {
        message.error(resRegister.message);
      }
    } else {
      message.error(res.message);
    }
  } catch (error) {
    message.error(t('auth.verificationCodeError'));
  } finally {
    loading.value = false;
  }
};

// é‡æ–°å‘é€éªŒè¯ç 
const resendCode = async () => {
  const now = new Date();
  const lastSendTimeString = localStorage.getItem('lastSendTime');
  if (lastSendTimeString) {
    const lastSendTime = new Date(lastSendTimeString);
    const diff = now - lastSendTime;
    if (diff < 60000) {
      message.error(t('auth.doNotSendFrequently'));
      return;
    }
  }
  localStorage.setItem('lastSendTime', now.toString());
  loading.value = true;
  const res = await auth.sendEmailVerification(verifyEmail.value);
  if (res.code === 200) {
      verifyForm.code = '';
      message.info(t('auth.codeResent'));
      loading.value = false;
  } else {
    message.error(res.message);
    loading.value = false;
  }
};

const toHome = () => {
  router.push('/');
};

// è·³è½¬åˆ°çº¿ä¸Šæ³¨å†Œé¡µé¢
const handleToRegister = () => {
  window.open('https://app.lemonai.ai/auth', '_blank');
};

// è·³è½¬åˆ°çº¿ä¸Šå¿˜è®°å¯†ç é¡µé¢
const handleToForgot = () => {
  window.open('https://app.lemonai.ai/auth', '_blank');
};

// å¤„ç†ç™»å½•
const handleLogin = async (values) => {
  try {
    loading.value = true;
    const res = await auth.login(values.email, values.password,values.phone);
    console.log('res', res);
    if (res.code === 200) {
      message.success(t('auth.loginSuccessful'));
      router.push({ name: 'lemon' });
    } else {
      message.error(res.message);
    }
  } catch (error) {
    console.log('error', error);
    message.error(t('auth.loginFailed'));
  } finally {
    loading.value = false;
  }
};

//çŸ­ä¿¡éªŒè¯ç ç™»å½• 
const handleLoginSMSCode = async (values) => { 
  const res = await auth.loginSMSCode(values.phone, values.smsCode);
  if (res.code === 200) {
    message.success(t('auth.loginSuccessful'));
    router.push({ name: 'lemon' });
  }else{
    message.error(res.message);
    return;
  }
};
const registerForm = ref({});
// å¤„ç†æ³¨å†Œ
const handleRegister = async (values) => {
  console.log('handleRegister', values);
  registerForm.value = values;
  try {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(values.email) && isAbroad.value) {
      throw new Error(t('auth.pleaseEnterValidEmail'));
    }
    const phoneRegex = /^1[3-9]\d{9}$/
    if (!phoneRegex.test(values.phone) && !isAbroad.value) {
      throw new Error(t('auth.pleaseInputValidPhone'));
    }
    if (values.password.length < 6) {
      throw new Error(t('auth.passwordTooShort'));
    }
    if(isAbroad.value){
      verifyEmail.value = values.email;
      const res = await auth.sendEmailVerification(values.email);
      if (res.code === 200) {
        message.success(t('auth.codeSent'));
        activeKey.value = 'verify';
      } else {
        message.error(res.message);
      }
    }else{
      //éªŒè¯çŸ­ä¿¡éªŒè¯ç  values.smsCode
      let smsRes = await auth.verifySmsVerifyCode(values.phone, values.smsCode);
      if (smsRes.code === 200) {
        let res = await auth.register(values.fullname, "", values.password,values.phone);
        if (res.code === 200) {
          message.success(t('auth.registrationSuccessful'));
          activeKey.value = 'login';
        } else {
          message.error(res.message);
        }
      } else {
        message.error(t('auth.verificationCodeError'));
      }
      console.log("smsRes",smsRes);
    
    }

    localStorage.setItem('lastSendTime', new Date().toString());

  } catch (error) {
    message.error(error.message || t('auth.registrationFailed'));
  } finally {
  }
};

// å¤„ç†å¿˜è®°å¯†ç 
const handleForgotPassword = async (values) => {
  try {
    loading.value = true;
    //ç¬¬ä¸€æ­¥ æ ¡éªŒéªŒè¯ç 
    let codeRes = null;
    if(isAbroad.value){
      codeRes = await auth.verifyEmailVerifyCode(values.email, values.code);
    }else{
      codeRes = await auth.verifySmsVerifyCode(values.phone, values.smsCode);
    }
    if(codeRes.code === 200){
      //é‡ç½®å¯†ç 
      let res = await auth.resetPassword(values.email, values.password,values.phone);
      if(res.code === 200){
        message.success(t('auth.passwordResetSuccessful'));
        activeKey.value = 'login';
      }else{
        message.error(t('auth.passwordResetFailed'));
      }
    }else{
      message.error(t('auth.codeError'));
      return;
    }
  } catch (error) {
    message.error(t('auth.passwordResetFailed'));
  } finally {
    loading.value = false;
  }
};

// ç¤¾äº¤ç™»å½•æ–¹æ³•
const handleGoogleLogin = () => {
  try {
    loading.value = true;
    const isClient = import.meta.env.VITE_IS_CLIENT === 'true';
    const redirectUri = isClient
      ? import.meta.env.VITE_GOOGLE_REDIRECT_URI_ELECTRON// Electron ä¸»è¿›ç¨‹å¤„ç†
      : 'http://localhost:5005/api/users/auth/google'; 
    const clientId = '973572698649-hbp15ju1nhlsja1k2gbqktmrulk0hopp.apps.googleusercontent.com';
    const scope = encodeURIComponent('profile email');
    const responseType = 'code';
    const googleAuthUrl = `https://accounts.google.com/o/oauth2/auth?client_id=${clientId}&redirect_uri=${redirectUri}&scope=${scope}&response_type=${responseType}&access_type=offline&prompt=consent`;
    window.location.href = googleAuthUrl;
  } catch (error) {
    message.error(t('auth.googleLoginFailed'));
  } finally {
    loading.value = false;
  }
};

const handleAppleLogin = async () => {
  try {
    loading.value = true;
    message.info(t('auth.appleLoginInProgress'));
  } finally {
    loading.value = false;
  }
};


const handleAppleRegister = async () => {
  try {
    loading.value = true;
    message.info(t('auth.appleRegisterInProgress'));
  } finally {
    loading.value = false;
  }
};
</script>

<style lang="scss" scoped>


.auth-footer {
    text-align: center;
    margin-top: 16px;
    font-size: 14px;
    color: #6b7280;

    .auth-footer-keep-offline{
        //ä¸‹åˆ’çº¿
        text-decoration: underline;
        // margin-left: 8px;;
        cursor: pointer;
    }
}

.auth-container {
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  background-color: #f8f8f7;

  .auth-content {
    width: 100%;
    max-width: 420px;
    padding: 32px;

    .logo-container {
      display: flex;
      justify-content: center;
      margin-bottom: 16px;

      .logo {
        width: 64px;
        height: 64px;
        color: #333;

        img{
          width: 100%;
          height: 100%;
        }
      }
    }

    .auth-title {
      text-align: center;
      font-size: 24px;
      font-weight: 600;
      margin-bottom: 32px;
      color: #111827;
    }

    .social-buttons {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-bottom: 24px;
      align-items: center;

      .social-button {
        width: 100%;
        height: 40px;
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        color: #333;


        img {
          margin-right: 6px;
        }

        &.google {
          border: none;
          background-color: white;
          color: #333;
          box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
      }



    }



    .password-label-container {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 4px;

      .form-label {
        font-size: 14px;
        color: rgba(0, 0, 0, 0.85);
        font-weight: 500;
      }

      .forgot-link {
        font-size: 14px;
        color: #4f46e5;
        cursor: pointer;

        &:hover {
          text-decoration: underline;
        }
      }
    }

    :deep(.ant-form-item-control-input-content) {
      width: 360px;
    }

    :deep(.ant-form-item) {
      width: 100%;
      margin-bottom: 20px;
      display: flex;
      justify-content: center;

      .ant-form-item-control {
        width: 100%;
      }

      .ant-form-item-label>label {
        font-size: 14px;
        font-weight: 500;
        color: #374151;
      }

      .form-label {
        font-size: 14px;
        color: rgba(0, 0, 0, 0.85);
        font-weight: 500;
        margin-bottom: 4px;

        .required-mark {
          color: #ff4d4f;
          margin-left: 2px;
        }
      }

      .ant-input {
        width: 100%;
        height: 40px;
        border-radius: 8px;
        border: 1px solid #d1d5db;
        background-color: #ffffff;

        &:hover,
        &:focus {
          border-color: #4f46e5;
        }
      }

      .ant-input-affix-wrapper {
        width: 100%;
        height: 40px !important;
        border-radius: 8px !important;
        border: 1px solid #d1d5db !important;
        background-color: #ffffff !important;
        box-shadow: none !important;
        padding: 0 11px !important;

        &:hover,
        &:focus,
        &-focused {
          border-color: #4f46e5 !important;
        }



        .ant-input {
          width: 100% !important;
          height: 38px !important;
          border: none !important;
          box-shadow: none !important;
          padding: 0 !important;
          background-color: #ffffff !important;

          &:focus {
            box-shadow: none !important;
          }
        }

        .ant-input-suffix {
          margin-left: 0 !important;
        }
      }

      .ant-btn {
        width: 100%;
        height: 40px;
        border-radius: 8px;
        font-size: 16px;
        font-weight: 500;
        background-color: #4f46e5;
        border-color: #4f46e5;

        &:hover {
          background-color: #4338ca;
          border-color: #4338ca;
        }

        &[disabled] {
          background-color: #d1d5db;
          border-color: #d1d5db;
          color: white;
          cursor: not-allowed;

          &:hover {
            background-color: #d1d5db;
            border-color: #d1d5db;
          }
        }
      }
    }

    .auth-footer {
      text-align: center;
      margin-top: 16px;
      font-size: 14px;
      color: #6b7280;

      a {
        color: #4f46e5;
        font-weight: 500;
        cursor: pointer;

        &:hover {
          text-decoration: underline;
        }
      }
    }
  }
}

.verify-container {
  text-align: center;
  padding: 24px;

  .verify-icon {
    margin-bottom: 24px;

    svg {
      color: #4f46e5;
    }
  }

  .verify-title {
    font-size: 24px;
    font-weight: 600;
    margin-bottom: 16px;
    color: #111827;
  }

  .verify-text {
    font-size: 16px;
    color: #6b7280;
    margin-bottom: 32px;
  }

  .verify-footer {
    margin-top: 24px;
    font-size: 14px;
    color: #6b7280;

    p {
      margin-bottom: 12px;
    }

    a {
      color: #4f46e5;
      font-weight: 500;
      cursor: pointer;

      &:hover {
        text-decoration: underline;
      }
    }
  }

  :deep(.ant-form-item) {
    max-width: 100%;
    margin: 0 auto;

    .ant-input {
      text-align: center;
      letter-spacing: 8px;
      font-size: 18px;
    }
  }
}
</style>


================================================
FILE: frontend/src/view/auth/usage.vue
================================================
<template>
  <div class="usage">
      <div class="member-info">
          <div style="    display: flex;align-items: center;justify-content: space-between;">
              <div>
                  <div class="plan-name">
                      {{ membership?.planName || t('member.freePlan') }}
                  </div>
                  <div class="expiration-date" v-if="membership">
                      {{ t('member.expirationDate') }}{{ dayjs(membership.endDate).format('YYYY-MM-DD HH:mm') }}
                  </div>
              </div>
              <div style="gap:12px;display: flex;">
                  <button @click="toMember" class="upgrade">{{ t('member.upgrade') }}</button>
                  <button @click="toPoints" v-if="membership" class="upgrade">{{ t('member.purchasePoints') }}</button>
              </div>
          </div>

          <div class="points-details">
            <div class="points-details-text-container">
              <div class="points-details-text">{{ t('member.points') }}</div>
              <div class="points-details-total">{{ points.total }}</div>
            </div>
            <div>
              <div class="points-details-accounts" v-for="item in points.accounts">
                <div class="points-accounts">{{ getPointsTypeName(item.type) }}</div>
                <div class="points-accounts">{{ item.balance }}</div>
              </div>
            </div>

          </div>

      </div>

      <a-card :title="t('member.pointsUsageHistory')">
          <a-table :columns="columns" @change="handleTableChange" :data-source="data" row-key="id"
              :pagination="{ current: page, pageSize: pageSize, page, total: total }" />
      </a-card>
  </div>

  <a-modal
  v-model:open="isModalVisible"
  :title="t('member.purchasePoints')"
  :footer="null"
  width="800px"
  class="recharge-modal"
  centered
>
  <div v-if="rechargeProducts.length" class="recharge-products">
    <div
      v-for="item in rechargeProducts"
      :key="item.id"
      class="product-card"
    >
      <div class="product-title">{{ item.product_name }}</div>
      <div class="product-info">
        <p style="margin-top: 8px;">{{ currency }} {{ item.amount }}</p>
        <p>{{ item.points_awarded }}{{ t('member.pointsUnit') }}</p>
      </div>
      <button size="small" :loading="loading" @click="handleBuy(item)">{{ t('member.buyNow') }}</button>
    </div>
  </div>
  <div v-else>{{ t('member.noPackagesAvailable') }}</div>
</a-modal>
<a-modal v-model:open="showQrCode" :title="t('member.wechatScanToPay')" centered :footer="null">
<div style="text-align: center;display: flex;
    flex-direction: column;
    align-items: center;">
  <div style="display: inline-block;">
    <a-qrcode :value="qrCodeUrl" :size="200" />
  </div>
  <p style="margin-top: 12px;">{{ t('member.wechatScanPrompt') }}</p>
</div>
</a-modal>

<!-- æ”¯ä»˜æ–¹å¼é€‰æ‹©å¼¹çª— -->
<a-modal
  v-model:open="showPaymentMethodModal"
  :footer="null"
  centered
  width="480"
  :title="$t('member.selectPaymentMethod')"
>
  <div style="display: flex; flex-direction: column; gap: 16px; padding: 12px 4px;">
    <!-- Stripe -->
    <div
      class="payment-option"
      @click="handlePayment('stripe')"
    >
      <StripeLogo/>
      <div class="payment-content">
        <div class="payment-title">{{ $t('payment.stripe.title') }}</div>
        <div class="payment-description">{{ $t('payment.stripe.description') }}</div>
      </div>
    </div>

    <!-- WeChat -->
    <div
      class="payment-option"
      @click="handlePayment('wechat')"
    >
      <WechatLogo/>
      <div class="payment-content">
        <div class="payment-title">{{ $t('payment.wechat.title') }}</div>
        <div class="payment-description">{{ $t('payment.wechat.description') }}</div>
      </div>
    </div>
  </div>
</a-modal>


</template>

<script setup>
import { ref, onMounted,computed } from 'vue'
import auth from '@/services/auth';
import membershipService from '@/services/membership'

// --- å›½é™…åŒ–å¼•å…¥ ---
import { useI18n } from 'vue-i18n'
const { t } = useI18n()

import dayjs from 'dayjs'
import { useRouter } from "vue-router";
const router = useRouter();
import { message  } from 'ant-design-vue';

import { storeToRefs } from 'pinia';
import { useUserStore } from '@/store/modules/user.js'
const userStore = useUserStore();
const { user, membership, points } = storeToRefs(userStore);

import StripeLogo from '@/assets/svg/stripe.svg'
import WechatLogo from '@/assets/svg/wechatpay.svg'


//åˆ¤æ–­æ˜¯å›½å†…è¿˜æ˜¯æµ·å¤– VITE_REGION
// const isAbroad = computed(() => import.meta.env.VITE_REGION === 'abroad');
const isAbroad = ref(true);

//Â¥
const currency = computed(() => {
  return isAbroad.value ? '$' : 'Â¥'
})





//è·å–ç”¨æˆ·ä¿¡æ¯ getUserInfo
async function getUserInfo() {
  let res = await auth.getUserInfo();
  //è®¾ç½®ç¼“å­˜
  membership.value = res.membership;
  points.value = res.points;
}

//åˆ†é¡µ
const page = ref(1)
const pageSize = ref(5)
const total = ref(0)
const data = ref([
])

const showQrCode = ref(false)
const qrCodeUrl = ref('')
const showPaymentMethodModal = ref(false)
const selectedPlan = ref(null)
const pollingTimer = ref(null)
const loading = ref(false)

const isModalVisible = ref(false)
const rechargeProducts = ref([])

onMounted(() => {
  getUserInfo();
  getPointsTransactionList()
  if(window.electronAPI){
    window.electronAPI.on('stripe-payment-success', ({ orderId,amount,currency,status }) => {
      console.log("stripe-payment-success",orderId,amount,currency,status);
      if(status === 'paid'){
        message.success(t('member.paySuccess'));
        router.push({
          name: 'app'
        });
      }else{
        message.error(t('member.payFailed'));
      }
    });
    //æ”¯ä»˜å–æ¶ˆ
    window.electronAPI.on('stripe-payment-cancel', () => {
      message.error(t('member.payCancel'));
    });
  }
})


//è¿”å›ç§¯åˆ†ç±»å‹å¯¹åº”çš„åç§°
//FREE: å…è´¹ç§¯åˆ†, MONTHLY: æœˆåº¦ç§¯åˆ†, PURCHASED_ADDON: è´­ä¹°é™„åŠ ç§¯åˆ†, GIFTED_ADDON: èµ é€é™„åŠ ç§¯åˆ†, FEEDBACK_ADDON: åé¦ˆçš„é™„åŠ ç§¯åˆ†
function getPointsTypeName(type) {
  switch (type) {
    case 'FREE':
      return t("member.pointsType.free")
    case 'MONTHLY':
      return t("member.pointsType.monthly")
    case 'PURCHASED_ADDON':
      return t("member.pointsType.purchasedAddon")
    case 'GIFTED_ADDON':
      return t("member.pointsType.giftedAddon")
    case 'FEEDBACK_ADDON':
      return t("member.pointsType.feedbackAddon")
  }
}


const handleBuy = async (item) => {
  showPaymentMethodModal.value = true
  selectedPlan.value = item
}

const handlePayment = async (method) => {
  showPaymentMethodModal.value = false
  loading.value = true

  if(method === 'stripe'){
    let from_client = import.meta.env.VITE_IS_CLIENT === 'true' ? 'desktop' : 'web'
    let res = await membershipService.createStripePointPurchaseOrder(selectedPlan.value.id,from_client)
    window.location.href = res.url; 
    loading.value = false
  }else{
    let res = await membershipService.createPointPurchaseOrder(selectedPlan.value.id)
    if (res && res.code_url) {
      loading.value = false
      qrCodeUrl.value = res.code_url
      showQrCode.value = true
      checkOrderStatus(res.order_sn)
    } else {
      loading.value = false
    }
    console.log(res)
  }
}

const checkOrderStatus = async (orderSn) => {
  const maxRetries = 20
  let attempts = 0

  pollingTimer.value = setInterval(async () => {
    attempts++

    const res = await membershipService.checkOrderStatus(orderSn)
    if (res?.status === 'paid') {
      clearInterval(pollingTimer.value)
      showQrCode.value = false
      message.success(t("member.paymentSuccess"))
      paySuccess();
      // message.success("æ”¯ä»˜æˆåŠŸï¼")
      console.log('æ”¯ä»˜æˆåŠŸ')
    }

    if (attempts >= maxRetries) {
      clearInterval(pollingTimer.value)
      console.warn("æ”¯ä»˜è¶…æ—¶ï¼Œè¯·é‡æ–°ä¸‹å•")
    }
  }, 3000)
}

//æ”¯ä»˜æˆåŠŸ 
const paySuccess = () => {
 //åˆ·æ–°å½“å‰é¡µé¢
 window.location.reload()
}

const getPointsTransactionList = async () => {
    const res = await membershipService.getPointsTransactionList(
        { page: page.value, pageSize: pageSize.value }
    )
    console.log(res)
    total.value = res.pagination.total
    data.value = res.list
}

const handleTableChange = (pagination) => {
    page.value = pagination.current
    pageSize.value = pagination.pageSize
    getPointsTransactionList()
}

const toMember = () => {
    router.push({ name: "pricing" });
};

const toPoints =  async () => {
    let res = await membershipService.getRechargeProductList()
    rechargeProducts.value = res || []
    isModalVisible.value = true
};

const columns = [
    // {
    //     title: t("member.table.conversation_title"),
    //     dataIndex: 'conversation_title',
    //     key: 'conversation_title'
    // },
    {
        title: t("member.table.details"),
        dataIndex: 'description',
        key: 'description'
    },
    {
        title: t("member.table.time"),
        dataIndex: 'created_at',
        key: 'created_at',
        customRender: ({ text }) => {
            return dayjs(text).format('YYYY-MM-DD HH:mm')
        }
    },
    {
        title:t("member.table.pointsChange"),
        key: 'amount',
        customRender: ({ record }) => {
            const prefix = record.type === 'credit' ? '+' : record.type === 'debit' ? '-' : ''
            return `${prefix}${record.amount}`
        }
    }
]


</script>

<style scoped>
.usage {
    padding: 24px;
}

.mb-4 {
    margin-bottom: 16px;
}

.member-info {
    border-radius: 12px;
    padding: 1rem;
    background-color: #37352f0a;
    border: 1px solid #0000000f;
    margin-bottom: 16px;
}

.plan-name {
    font-weight: 700;
    font-size: 1rem;
    line-height: 28px;
}
.points-details{
  margin-top: 12px;
}
.points-details-text{
    font-weight: 700;
    font-size: 1rem;
    line-height: 28px;
}
.points-details-text-container{
  display: flex;
  justify-content: space-between;
  align-items: center;
}
.points-details-accounts{
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.expiration-date {
    color: #858481;
    line-height: 18px;
    font-size: 13px;

}

.points-accounts{
    color: #858481;
    line-height: 18px;
    font-size: 13px;
}

button {
    color: #fff;
    background-color: #1a1a19;
    padding-left: .75rem;
    padding-right: .75rem;
    border-radius: 99999px;
    cursor: pointer;
}


.recharge-products {
  display: flex;
  flex-wrap: wrap;
  gap: 16px;
  background-color: #f8f8f7;
  padding: 24px;
  justify-content: space-between;
}

.product-card {
  width: calc(33.333% - 11px); /* 3åˆ—å¸ƒå±€ï¼Œå‡å»é—´è· */
  border: 1px solid #f0f0f0;
  background-color: #fff;
  border-radius: 8px;
  padding: 16px;
  box-sizing: border-box;
  text-align: center; /* æ–‡å­—å±…ä¸­ */
  transition: box-shadow 0.3s;
}

.product-card:hover {
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}
</style>
<style lang="scss">
.recharge-modal {
  .ant-modal-content {
    background-color: #f8f8f7!important;
  }
  .ant-modal-title{
    background-color: #f8f8f7!important;
  }
}


.payment-option {
  display: flex;
  align-items: center;
  padding: 16px;
  border: 1px solid #e5e5e5;
  border-radius: 12px;
  cursor: pointer;
  transition: all 0.25s ease;
  background-color: #fff;
  box-shadow: 0 2px 8px rgba(0,0,0,0.04);
  gap: 16px;
}

.payment-option:hover {
  border-color: #1677ff;
  box-shadow: 0 4px 16px rgba(22,119,255,0.12);
}

.payment-logo {
  width: 40px;
  height: 40px;
  margin-right: 16px;
  object-fit: contain;
}

.payment-content {
  display: flex;
  flex-direction: column;
}

.payment-title {
  font-weight: 600;
  font-size: 16px;
  margin-bottom: 4px;
}

.payment-description {
  font-size: 13px;
  color: #666;
}

</style>


================================================
FILE: frontend/src/view/auth/UserProfile.vue
================================================
<template>
  <div class="usage">
    <div class="account-management">
      <div class="username-section" style="margin-bottom: 16px;">
        <div>
          <span class="label">{{ t('account.usernameLabel') }}</span>
          <span>{{ user.user_name }}</span>
        </div>
        <button @click="openUpdateName">{{ t('account.edit') }}</button>
      </div>

      <div class="password-reset-section">
        <span class="label">{{ t('account.passwordLabel') }}</span>
        <button @click="resetPassword">{{ t('account.resetPassword') }}</button>
      </div>

    <a-modal
      centered
      :title="t('account.editUsernameTitle')"
      v-model:open="isUsernameModalVisible"
    >
      <a-input v-model:value="newUsername" :placeholder="t('account.newUsernamePlaceholder')" />
      <template #footer>
        <button @click="isUsernameModalVisible = false" style="background-color: #0000330f; border-color: #0000330f; color:#1a1a19; margin-right: 8px; ">{{ t('account.cancel') }}</button>
        <button type="primary" @click="updateUsername">
          {{ t('account.save') }}
        </button>
      </template>
    </a-modal>
    <a-modal
      centered
      :title="t('account.resetPasswordTitle')"
      v-model:open="isPasswordModalVisible"
    >
      <a-input-password v-model:value="newPassword" :placeholder="t('account.newPasswordPlaceholder')" />
      <template #footer>
        <button @click="isPasswordModalVisible = false" style="background-color: #0000330f; border-color: #0000330f; color:#1a1a19; margin-right: 8px; ">{{ t('account.cancel') }}</button>
        <button type="primary" @click="updatePassword">
          {{ t('account.save') }}
        </button>
      </template>
    </a-modal>
  </div>
    <a-card :title="t('account.ordersTitle')">
      <a-table :columns="columns" @change="handleTableChange" :data-source="data" row-key="id"
        :pagination="{ current: page, pageSize: pageSize, page, total: total }" />
    </a-card>
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue'
import membershipService from '@/services/membership'
import authService from '@/services/auth'
import { useUserStore } from '@/store/modules/user.js'
const { user, membership, points } = useUserStore();
import dayjs from 'dayjs'
import { useRouter } from "vue-router";
const router = useRouter();
import { message } from 'ant-design-vue';
// --- å›½é™…åŒ–å¼•å…¥ ---
import { useI18n } from 'vue-i18n'
const { t } = useI18n()

onMounted(() => {
  getOrderList()
})

//åˆ†é¡µ
const page = ref(1)
const pageSize = ref(5)
const total = ref(0)
const data = ref([
])
const isUsernameModalVisible = ref(false)
const newUsername = ref('')

const isPasswordModalVisible = ref(false)
const newPassword = ref('')


const openUpdateName = () =>{
  isUsernameModalVisible.value = true;
  newUsername.value = user.user_name
}

const resetPassword = async () => {
  isPasswordModalVisible.value = true;
  newPassword.value = ''
}

const updateUsername = async () => { 
  await authService.updateUsername(newUsername.value)
  isUsernameModalVisible.value = false
  user.user_name = newUsername.value
  message.success(t("account.updateSuccess"))
}

const updatePassword = async () => { 
  await authService.resetPassword("", newPassword.value,user.mobile)
  isPasswordModalVisible.value = false
  message.success(t("account.updateSuccess"))
}
const getOrderList = async () => {
  const res = await membershipService.getOrderList(
    { page: page.value, pageSize: pageSize.value }
  )
  console.log(res)
  total.value = res.total
  data.value = res.list
}

const handleTableChange = (pagination) => {
  page.value = pagination.current
  pageSize.value = pagination.pageSize
  getOrderList()
}
const columns = [
  {
    title: t("account.table.orderId"),
    dataIndex: 'order_sn',
    key: 'order_sn'
  },
  {
    title: t("account.table.orderAmount"),
    dataIndex: 'amount',
    key: 'amount'
  },
  {
    title: t("account.table.time"),
    dataIndex: 'created_at',
    key: 'created_at',
    customRender: ({ text }) => {
      return dayjs(text).format('YYYY-MM-DD HH:mm')
    }
  },
  {
    title: t("account.table.status"),
    key: 'status',
    customRender: ({ record }) => {
     //pending(å¾…æ”¯ä»˜)ã€paid(å·²æ”¯ä»˜)ã€cancelled(å·²å–æ¶ˆ)ã€failed(æ”¯ä»˜å¤±è´¥)
     switch (record.status) {
       case 'pending':
         return t("account.orderStatus.pending")
       case 'paid':
       return t("account.orderStatus.paid")
       case 'cancelled':
       return t("account.orderStatus.cancelled")
       case 'failed':
       return t("account.orderStatus.failed")
       default:
       return t("account.orderStatus.unknown")
     }
    }
  }
]

</script>

<style scoped>
.usage {
  padding: 24px;
}

.mb-4 {
  margin-bottom: 16px;
}

.account-management {
  border-radius: 12px;
  padding: 1rem;
  background-color: #37352f0a;
  border: 1px solid #0000000f;
  margin-bottom: 16px;
}

.plan-name {
  font-weight: 700;
  font-size: 1rem;
  line-height: 28px;
}

.points-details {
  margin-top: 12px;
}

.points-details-text {
  font-weight: 700;
  font-size: 1rem;
  line-height: 28px;
}

.points-details-text-container {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.points-details-accounts {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.expiration-date {
  color: #858481;
  line-height: 18px;
  font-size: 13px;

}

.points-accounts {
  color: #858481;
  line-height: 18px;
  font-size: 13px;
}

button {
  color: #fff;
  background-color: #1a1a19;
  padding-left: .75rem;
  padding-right: .75rem;
  border-radius: 8px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 400;
  font-family: none;
}
.username-section{
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.password-reset-section{
  display: flex;
  align-items: center;
  justify-content: space-between;
}


.recharge-products {
  display: flex;
  flex-wrap: wrap;
  gap: 16px;
  background-color: #f8f8f7;
  padding: 24px;
  justify-content: space-between;
}

.product-card {
  width: calc(33.333% - 11px);
  /* 3åˆ—å¸ƒå±€ï¼Œå‡å»é—´è· */
  border: 1px solid #f0f0f0;
  background-color: #fff;
  border-radius: 8px;
  padding: 16px;
  box-sizing: border-box;
  text-align: center;
  /* æ–‡å­—å±…ä¸­ */
  transition: box-shadow 0.3s;
}

.product-card:hover {
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}
</style>
<style lang="scss">
.recharge-modal {
  .ant-modal-content {
    background-color: #f8f8f7 !important;
  }

  .ant-modal-title {
    background-color: #f8f8f7 !important;
  }
}
</style>


================================================
FILE: frontend/src/view/auth/components/forgot.vue
================================================
<template>
  <div>
    <!-- Forgot Password Form -->
    <a-form :model="forgotForm" name="forgot-form" @finish="handleForgotPassword" autocomplete="off" layout="vertical">
      
      <!-- é‚®ç®±ï¼ˆæµ·å¤–ï¼‰æˆ–æ‰‹æœºå·ï¼ˆå›½å†…ï¼‰ -->
      <a-form-item
        v-if="isAbroad"
        name="email"
        :rules="[
          { required: true, message: $t('auth.pleaseInputEmail') },
          { type: 'email', message: $t('auth.pleaseInputValidEmail') }
        ]"
      >
        <div class="form-label">{{ $t('auth.email') }}<span class="required-mark">*</span></div>
        <a-input v-model:value="forgotForm.email" :placeholder="$t('auth.pleaseInputEmail')" />
      </a-form-item>

      <a-form-item
        v-else
        name="phone"
        :rules="[
          { required: true, message: $t('auth.pleaseInputPhone') },
          { pattern: /^1[3-9]\d{9}$/, message: $t('auth.pleaseInputValidPhone') }
        ]"
      >
        <div class="form-label">{{ $t('auth.phone') }}<span class="required-mark">*</span></div>
        <a-input v-model:value="forgotForm.phone" :placeholder="$t('auth.pleaseInputPhone')" />
      </a-form-item>

      <!-- éªŒè¯ç  -->
      <a-form-item v-if="!isAbroad" name="smsCode" :rules="[{ required: true, message: $t('auth.pleaseInputSMSCode') }]">
          <div class="form-label">
            {{ $t('auth.smsCode') }}<span class="required-mark">*</span>
          </div>
          <a-input-group compact>
            <a-input v-model:value="forgotForm.smsCode" style="width: 65%;" :placeholder="$t('auth.pleaseInputSMSCode')" />
            <a-button
              style="width: 30%; margin-left: 5%; color:#fff"
              :disabled="smsCountdown > 0"
              @click="sendSMSCode"
            >
              {{ smsCountdown > 0 ? `${smsCountdown}s` : $t('auth.sendCode') }}
            </a-button>
          </a-input-group>
      </a-form-item>
      <!-- é‚®ç®± éªŒè¯ç  -->
      <a-form-item
        v-if="isAbroad"
        name="code"
        :rules="[{ required: true, message: $t('auth.pleaseInputVerifyCode') }]"
      >
        <div class="form-label">
          {{ $t('auth.verifyCode') }}<span class="required-mark">*</span>
        </div>
        <a-input-group compact>
          <a-input
            v-model:value="forgotForm.code"
            style="width: 65%;"
            :placeholder="$t('auth.pleaseInputVerifyCode')"
          />
          <a-button
            style="width: 30%; margin-left: 5%; color:#fff"
            :disabled="emailCountdown > 0"
            @click="sendEmailCode"
          >
            {{ emailCountdown > 0 ? `${emailCountdown}s` : $t('auth.sendCode') }}
          </a-button>
        </a-input-group>
      </a-form-item>
      <!-- æ–°å¯†ç  -->
      <a-form-item
        name="password"
        :rules="[{ required: true, message: $t('auth.pleaseInputNewPassword') }]"
      >
        <div class="form-label">{{ $t('auth.password') }}<span class="required-mark">*</span></div>
        <a-input-password v-model:value="forgotForm.password" :placeholder="$t('auth.pleaseInputNewPassword')" />
      </a-form-item>

      <!-- ç¡®è®¤å¯†ç  -->
      <a-form-item
        name="confirmPassword"
        :rules="[{ required: true, message: $t('auth.pleaseConfirmPassword') },{ validator: validateConfirmPassword }]"
      >
        <div class="form-label">{{ $t('auth.pleaseConfirmPassword') }}<span class="required-mark">*</span></div>
        <a-input-password
          v-model:value="forgotForm.confirmPassword"
          :placeholder="$t('auth.pleaseConfirmPassword')"
        />
      </a-form-item>

      <!-- æäº¤æŒ‰é’® -->
      <a-form-item>
        <a-button type="primary" :disabled="!isForgotValid" html-type="submit" block :loading="loading">
          {{ $t('auth.resetPasswordButton') }}
        </a-button>
      </a-form-item>

      <!-- è¿”å›ç™»å½• -->
      <div class="auth-footer">
        <a @click="toLogin">{{ $t('auth.backToLogin') }}</a>
      </div>
    </a-form>
  </div>
</template>
<script setup>
import { computed, reactive,ref } from 'vue';
import google from '@/assets/svg/google.svg';
import { message } from 'ant-design-vue';
import { MobileOutlined } from '@ant-design/icons-vue';
//åˆ¤æ–­æ˜¯å›½å†…è¿˜æ˜¯æµ·å¤– VITE_REGION
import { useI18n } from 'vue-i18n';

const { t } = useI18n();
import auth from '@/services/auth';
const emit = defineEmits(['toLogin','handleForgotPassword']);

const isAbroad = ref(true)

// å¿˜è®°å¯†ç è¡¨å•
const forgotForm = reactive({
  email: '',
  code: '',//é‚®ç®±éªŒè¯ç 
  password: '',
  phone: '',
  smsCode: '',//çŸ­ä¿¡éªŒè¯ç 
  confirmPassword: ''
});

const smsCountdown = ref(0)
let smsTimer = null

const emailCountdown = ref(0)
let emailTimer = null


const isForgotValid = computed(() => {
  const passwordValid =
    forgotForm.password &&
    forgotForm.confirmPassword &&
    forgotForm.password === forgotForm.confirmPassword;

  if (isAbroad.value) {
    const emailValid = /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(forgotForm.email);
    const emailCodeValid = !!forgotForm.code;
    return emailValid && emailCodeValid && passwordValid;
  } else {
    const phoneValid = /^1[3-9]\d{9}$/.test(forgotForm.phone);
    const smsCodeValid = !!forgotForm.smsCode;
    return phoneValid && smsCodeValid && passwordValid;
  }
});



const handleForgotPassword = (value) => {
  emit("handleForgotPassword",value)
};

function sendSMSCode() {
  if (!/^1[3-9]\d{9}$/.test(forgotForm.phone)) {
    message.error(t('auth.pleaseInputValidPhone'))
    return
  }
  auth.sendSmsCode(forgotForm.phone)
  // æ¨¡æ‹Ÿå‘é€éªŒè¯ç 
  smsCountdown.value = 60
  smsTimer = setInterval(() => {
    smsCountdown.value--
    if (smsCountdown.value <= 0) {
      clearInterval(smsTimer)
      smsTimer = null
    }
  }, 1000)
}

//å‘é€é‚®ç®±éªŒè¯ç 
function sendEmailCode() {
  if (!/^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$/.test(forgotForm.email)) {
    message.error(t('auth.pleaseEnterValidEmail'))
    return
  }
  auth.sendEmailVerification(forgotForm.email)
  // æ¨¡æ‹Ÿå‘é€éªŒè¯ç 
  emailCountdown.value = 60
  emailTimer = setInterval(() => {
    emailCountdown.value--
    if (emailCountdown.value <= 0) {
      clearInterval(emailTimer)
      emailTimer = null
    }
  }, 1000)
  message.success(t('auth.codeSent'))
}

function validateConfirmPassword(_, value) {
  if (value !== forgotForm.password) {
    return Promise.reject(new Error(t('auth.passwordsDoNotMatch')))
  }
  return Promise.resolve()
}

const toLogin = () => {
  emit('toLogin')
}


</script>
<style lang="scss" scoped>
.social-buttons {
    display: flex;
    flex-direction: column;
    gap: 12px;
    margin-bottom: 24px;
    align-items: center;

    .social-button {
        width: 100%;
        height: 40px;
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        color: #333;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        border: none;
        background-color: white;
        color: #333;

        img {
            margin-right: 6px;
        }
    }

}


:deep(.ant-form-item-control-input-content) {
    width: 360px;
}

:deep(.ant-form-item) {
    width: 100%;
    margin-bottom: 20px;
    display: flex;
    justify-content: center;

    .ant-form-item-control {
        width: 100%;
    }

    .ant-form-item-label>label {
        font-size: 14px;
        font-weight: 500;
        color: #374151;
    }

    .form-label {
        font-size: 14px;
        color: rgba(0, 0, 0, 0.85);
        font-weight: 500;
        margin-bottom: 4px;

        .required-mark {
            color: #ff4d4f;
            margin-left: 2px;
        }
    }

    .ant-input {
        width: 100%;
        height: 40px;
        border-radius: 8px;
        border: 1px solid #d1d5db;
        background-color: #ffffff;

        &:hover,
        &:focus {
            border-color: #4f46e5;
        }
    }

    .ant-input-affix-wrapper {
        width: 100%;
        height: 40px !important;
        border-radius: 8px !important;
        border: 1px solid #d1d5db !important;
        background-color: #ffffff !important;
        box-shadow: none !important;
        padding: 0 11px !important;

        &:hover,
        &:focus,
        &-focused {
            border-color: #4f46e5 !important;
        }



        .ant-input {
            width: 100% !important;
            height: 38px !important;
            border: none !important;
            box-shadow: none !important;
            padding: 0 !important;
            background-color: #ffffff !important;

            &:focus {
                box-shadow: none !important;
            }
        }

        .ant-input-suffix {
            margin-left: 0 !important;
        }
    }

    .ant-btn {
        width: 100%;
        height: 40px;
        border-radius: 8px;
        font-size: 16px;
        font-weight: 500;
        background-color: #4f46e5;
        border-color: #4f46e5;

        &:hover {
            background-color: #4338ca;
            border-color: #4338ca;
        }

        &[disabled] {
            background-color: #d1d5db;
            border-color: #d1d5db;
            color: white;
            cursor: not-allowed;

            &:hover {
                background-color: #d1d5db;
                border-color: #d1d5db;
            }
        }
    }
}

.divider {
    position: relative;
    text-align: center;
    margin: 24px 0;

    &::before {
        content: '';
        position: absolute;
        top: 50%;
        left: 0;
        right: 0;
        height: 1px;
        background-color: #e5e7eb;
        z-index: 0;
    }

    span {
        position: relative;
        background-color: transparent;
        padding: 0 12px;
        color: #6b7280;
        font-size: 14px;
        z-index: 1;
    }
}

.auth-footer {
    text-align: center;
    margin-top: 16px;
    font-size: 14px;
    color: #6b7280;

    a {
        color: #4f46e5;
        font-weight: 500;
        cursor: pointer;

        &:hover {
            text-decoration: underline;
        }
    }
}

.password-label-container {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 4px;

    .form-label {
        font-size: 14px;
        color: rgba(0, 0, 0, 0.85);
        font-weight: 500;
    }

    .forgot-link {
        font-size: 14px;
        color: #4f46e5;
        cursor: pointer;

        &:hover {
            text-decoration: underline;
        }
    }
}
</style>


================================================
FILE: frontend/src/view/auth/components/login.vue
================================================
<template>
    <div>
        <!-- Login Form -->
        <div class="social-buttons">
            <a-button class="social-button google" @click="handleGoogleLogin" v-if="isAbroad">
                <template #icon>
                    <google />
                </template>
                {{ $t('auth.loginWithGoogle') }}
            </a-button>
            <!-- Apple login button hidden as requested -->
            <!-- æ‰‹æœºå·+çŸ­ä¿¡éªŒè¯ç   ç™»å½• -->
            <a-button class="social-button phone" @click="handleSMSLogin" v-if="!isAbroad">
                <template #icon>
                    <MobileOutlined />
                </template>
                {{ $t('auth.loginWithPhone') }}
            </a-button>
        </div>
        <div class="divider">
            <span>{{ $t('auth.or') }}</span>
        </div>
        <a-form :model="loginForm" name="login-form" @finish="handleLogin" autocomplete="off" layout="vertical">
            <!-- Email or Phone Input -->
            <a-form-item v-if="isAbroad" name="email" :rules="[
                { required: true, message: $t('auth.pleaseInputEmail') },
                { type: 'email', message: $t('auth.pleaseInputValidEmail') }
            ]">
                <div class="form-label">
                    {{ $t('auth.email') }}<span class="required-mark">*</span>
                </div>
                <a-input v-model:value="loginForm.email" :placeholder="$t('auth.pleaseInputEmail')" />
            </a-form-item>

            <a-form-item v-else name="phone" :rules="[
                { required: true, message: $t('auth.pleaseInputPhone') },
                { pattern: /^1[3-9]\d{9}$/, message: $t('auth.pleaseInputValidPhone') }
            ]">
                <div class="form-label">
                    {{ $t('auth.phone') }}<span class="required-mark">*</span>
                </div>
                <a-input v-model:value="loginForm.phone" :placeholder="$t('auth.pleaseInputPhone')" />
            </a-form-item>

            <!-- Password Input -->
            <a-form-item name="password" :rules="[{ required: true, message: $t('auth.pleaseInputPassword') }]">
                <div class="password-label-container">
                    <div class="form-label">
                        {{ $t('auth.password') }}<span class="required-mark">*</span>
                    </div>
                    <a class="forgot-link" @click="toForgot">
                        {{ $t('auth.forgotPassword') }}
                    </a>
                </div>
                <a-input-password v-model:value="loginForm.password" :placeholder="$t('auth.pleaseInputPassword')" />
            </a-form-item>

            <!-- Submit Button -->
            <a-form-item>
                <a-button type="primary" html-type="submit" block :loading="loading" :disabled="!isLoginValid">
                    {{ $t('auth.login') }}
                </a-button>
            </a-form-item>

            <!-- Footer -->
            <div class="auth-footer">
                <span>{{ $t('auth.noAccount') }} </span>
                <a @click="toRegister">{{ $t('auth.register') }}</a>
                <!-- ä¿æŒç¦»çº¿çŠ¶æ€ -->
            </div>
        </a-form>

    </div>
</template>
<script setup>
import { computed, reactive, ref } from 'vue';
import google from '@/assets/svg/google.svg';
import { MobileOutlined } from '@ant-design/icons-vue';
//åˆ¤æ–­æ˜¯å›½å†…è¿˜æ˜¯æµ·å¤– VITE_REGION
import { useI18n } from 'vue-i18n';

const { t } = useI18n();

const emit = defineEmits(['toRegister','toForgot','handleLogin','handleGoogleLogin']);

// ç™»å½•è¡¨å•
const loginForm = reactive({
    email: '',
    phone: '',
    password: '',
    remember: false
});

const isAbroad = ref(true)
const isLoginValid = computed(() => {
  const hasPassword = !!loginForm.password;

  if (isAbroad.value) {
    const emailValid = /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(loginForm.email || '');
    return emailValid && hasPassword;
  } else {
    const phoneValid = /^1[3-9]\d{9}$/.test(loginForm.phone || '');
    return phoneValid && hasPassword;
  }
});

const handleLogin = (value) => { 
    emit("handleLogin",value)
};

const handleSMSLogin = () => {
    emit('handleSMSLogin');
};
const handleGoogleLogin = () => {
    emit('handleGoogleLogin');
};
const toRegister = () => {
    emit('toRegister');
};

const toForgot = () => {
    emit('toForgot');
};

</script>
<style lang="scss" scoped>
.social-buttons {
    display: flex;
    flex-direction: column;
    gap: 12px;
    margin-bottom: 24px;
    align-items: center;

    .social-button {
        width: 100%;
        height: 40px;
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        color: #333;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        border: none;
        background-color: white;
        color: #333;
        img {
            margin-right: 6px;
        }
    }

}


:deep(.ant-form-item-control-input-content) {
    width: 360px;
}

:deep(.ant-form-item) {
    width: 100%;
    margin-bottom: 20px;
    display: flex;
    justify-content: center;

    .ant-form-item-control {
        width: 100%;
    }

    .ant-form-item-label>label {
        font-size: 14px;
        font-weight: 500;
        color: #374151;
    }

    .form-label {
        font-size: 14px;
        color: rgba(0, 0, 0, 0.85);
        font-weight: 500;
        margin-bottom: 4px;

        .required-mark {
            color: #ff4d4f;
            margin-left: 2px;
        }
    }

    .ant-input {
        width: 100%;
        height: 40px;
        border-radius: 8px;
        border: 1px solid #d1d5db;
        background-color: #ffffff;

        &:hover,
        &:focus {
            border-color: #4f46e5;
        }
    }

    .ant-input-affix-wrapper {
        width: 100%;
        height: 40px !important;
        border-radius: 8px !important;
        border: 1px solid #d1d5db !important;
        background-color: #ffffff !important;
        box-shadow: none !important;
        padding: 0 11px !important;

        &:hover,
        &:focus,
        &-focused {
            border-color: #4f46e5 !important;
        }



        .ant-input {
            width: 100% !important;
            height: 38px !important;
            border: none !important;
            box-shadow: none !important;
            padding: 0 !important;
            background-color: #ffffff !important;

            &:focus {
                box-shadow: none !important;
            }
        }

        .ant-input-suffix {
            margin-left: 0 !important;
        }
    }

    .ant-btn {
        width: 100%;
        height: 40px;
        border-radius: 8px;
        font-size: 16px;
        font-weight: 500;
        background-color: #4f46e5;
        border-color: #4f46e5;

        &:hover {
            background-color: #4338ca;
            border-color: #4338ca;
        }

        &[disabled] {
            background-color: #d1d5db;
            border-color: #d1d5db;
            color: white;
            cursor: not-allowed;

            &:hover {
                background-color: #d1d5db;
                border-color: #d1d5db;
            }
        }
    }
}

.divider {
    position: relative;
    text-align: center;
    margin: 24px 0;

    &::before {
        content: '';
        position: absolute;
        top: 50%;
        left: 0;
        right: 0;
        height: 1px;
        background-color: #e5e7eb;
        z-index: 0;
    }

    span {
        position: relative;
        background-color: transparent;
        padding: 0 12px;
        color: #6b7280;
        font-size: 14px;
        z-index: 1;
    }
}

.auth-footer {
    text-align: center;
    margin-top: 16px;
    font-size: 14px;
    color: #6b7280;

    .auth-footer-keep-offline{
        //ä¸‹åˆ’çº¿
        text-decoration: underline;
        // margin-left: 8px;;
        cursor: pointer;
    }

    a {
        color: #4f46e5;
        font-weight: 500;
        cursor: pointer;

        &:hover {
            text-decoration: underline;
        }
    }
}

.password-label-container {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 4px;

    .form-label {
        font-size: 14px;
        color: rgba(0, 0, 0, 0.85);
        font-weight: 500;
    }

    .forgot-link {
        font-size: 14px;
        color: #4f46e5;
        cursor: pointer;

        &:hover {
            text-decoration: underline;
        }
    }
}
</style>


================================================
FILE: frontend/src/view/auth/components/register.vue
================================================
<template>
    <div>
      <!-- Register Form -->
      <div class="social-buttons">
        <a-button class="social-button google" @click="handleGoogleRegister" v-if="isAbroad">
          <template #icon>
            <google />
          </template>
          {{ $t('auth.registerWithGoogle') }}
        </a-button>
      </div>
  
      <div class="divider" v-if="isAbroad">
        <span>{{ $t('auth.or') }}</span>
      </div>
  
      <a-form :model="registerForm" name="register-form" @finish="handleRegister" autocomplete="off" layout="vertical">
        <!-- Fullname -->
        <a-form-item name="fullname" :rules="[{ required: true, message: $t('auth.pleaseInputFullname') }]">
          <div class="form-label">
            {{ $t('auth.fullname') }}<span class="required-mark">*</span>
          </div>
          <a-input v-model:value="registerForm.fullname" :placeholder="$t('auth.pleaseInputFullname')" />
        </a-form-item>
  
        <!-- Email (abroad) -->
        <a-form-item v-if="isAbroad" name="email" :rules="[
          { required: true, message: $t('auth.pleaseInputEmail') },
          { type: 'email', message: $t('auth.pleaseInputValidEmail') }
        ]">
          <div class="form-label">
            {{ $t('auth.email') }}<span class="required-mark">*</span>
          </div>
          <a-input v-model:value="registerForm.email" :placeholder="$t('auth.pleaseInputEmail')" />
        </a-form-item>
  
        <!-- Phone (domestic) -->
        <a-form-item v-else name="phone" :rules="[
          { required: true, message: $t('auth.pleaseInputPhone') },
          { pattern: /^1[3-9]\d{9}$/, message: $t('auth.pleaseInputValidPhone') }
        ]">
          <div class="form-label">
            {{ $t('auth.phone') }}<span class="required-mark">*</span>
          </div>
          <a-input v-model:value="registerForm.phone" :placeholder="$t('auth.pleaseInputPhone')" />
        </a-form-item>
  
        <!-- Password -->
        <a-form-item name="password" :rules="[{ required: true, message: $t('auth.pleaseInputPassword') }]">
          <div class="form-label">
            {{ $t('auth.password') }}<span class="required-mark">*</span>
          </div>
          <a-input-password v-model:value="registerForm.password" :placeholder="$t('auth.pleaseInputPassword')" />
        </a-form-item>
  
        <!-- SMS Code (only for domestic users) -->
        <a-form-item v-if="!isAbroad" name="smsCode" :rules="[{ required: true, message: $t('auth.pleaseInputSMSCode') }]">
          <div class="form-label">
            {{ $t('auth.smsCode') }}<span class="required-mark">*</span>
          </div>
          <a-input-group compact>
            <a-input v-model:value="registerForm.smsCode" style="width: 65%;" :placeholder="$t('auth.pleaseInputSMSCode')" />
            <a-button
              style="width: 30%; margin-left: 5%; color:#fff"
              :disabled="smsCountdown > 0"
              @click="sendSMSCode"
            >
              {{ smsCountdown > 0 ? `${smsCountdown}s` : $t('auth.sendCode') }}
            </a-button>
          </a-input-group>
        </a-form-item>
  
        <!-- Submit Button -->
        <a-form-item>
          <a-button type="primary" html-type="submit" block :loading="loading" :disabled="!isRegisterValid">
            {{ $t('auth.register') }}
          </a-button>
        </a-form-item>
  
        <!-- Footer -->
        <div class="auth-footer">
          <span>{{ $t('auth.haveAccount') }}</span>
          <a @click="toLogin">{{ $t('auth.login') }}</a>
        </div>
      </a-form>
    </div>
</template>
<script setup>
import { computed, reactive,ref } from 'vue';
import google from '@/assets/svg/google.svg';
import { message } from 'ant-design-vue';
import { MobileOutlined } from '@ant-design/icons-vue';
//åˆ¤æ–­æ˜¯å›½å†…è¿˜æ˜¯æµ·å¤– VITE_REGION
import { useI18n } from 'vue-i18n';
const isAbroad = ref(true)
const { t } = useI18n();
import auth from '@/services/auth';
const emit = defineEmits(['toLogin','handleRegister','handleGoogleRegister']);

// æ³¨å†Œè¡¨å•

const registerForm = ref({
  fullname: '',
  email: '',
  phone: '',
  password: '',
  smsCode: ''
})
const smsCountdown = ref(0)
let smsTimer = null

const isRegisterValid = computed(() => {
  return registerForm.value.fullname &&
    (isAbroad.value ? registerForm.value.email : registerForm.value.phone) &&
    registerForm.value.password &&
    (!isAbroad.value ? registerForm.value.smsCode : true)
})


const handleGoogleRegister = async () => {
  emit('handleGoogleRegister');
};

const toLogin = () => {
    emit('toLogin');
};

const handleRegister = async (value) => { 
    emit('handleRegister', value);
};


function sendSMSCode() {
  if (!/^1[3-9]\d{9}$/.test(registerForm.value.phone)) {
    message.error(t('auth.pleaseInputValidPhone'))
    return
  }
  auth.sendSmsCode(registerForm.value.phone)
  // æ¨¡æ‹Ÿå‘é€éªŒè¯ç 
  smsCountdown.value = 60
  smsTimer = setInterval(() => {
    smsCountdown.value--
    if (smsCountdown.value <= 0) {
      clearInterval(smsTimer)
      smsTimer = null
    }
  }, 1000)
}


</script>
<style lang="scss" scoped>
.social-buttons {
    display: flex;
    flex-direction: column;
    gap: 12px;
    margin-bottom: 24px;
    align-items: center;

    .social-button {
        width: 100%;
        height: 40px;
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        color: #333;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        border: none;
        background-color: white;
        color: #333;

        img {
            margin-right: 6px;
        }
    }

}


:deep(.ant-form-item-control-input-content) {
    width: 360px;
}

:deep(.ant-form-item) {
    width: 100%;
    margin-bottom: 20px;
    display: flex;
    justify-content: center;

    .ant-form-item-control {
        width: 100%;
    }

    .ant-form-item-label>label {
        font-size: 14px;
        font-weight: 500;
        color: #374151;
    }

    .form-label {
        font-size: 14px;
        color: rgba(0, 0, 0, 0.85);
        font-weight: 500;
        margin-bottom: 4px;

        .required-mark {
            color: #ff4d4f;
            margin-left: 2px;
        }
    }

    .ant-input {
        width: 100%;
        height: 40px;
        border-radius: 8px;
        border: 1px solid #d1d5db;
        background-color: #ffffff;

        &:hover,
        &:focus {
            border-color: #4f46e5;
        }
    }

    .ant-input-affix-wrapper {
        width: 100%;
        height: 40px !important;
        border-radius: 8px !important;
        border: 1px solid #d1d5db !important;
        background-color: #ffffff !important;
        box-shadow: none !important;
        padding: 0 11px !important;

        &:hover,
        &:focus,
        &-focused {
            border-color: #4f46e5 !important;
        }



        .ant-input {
            width: 100% !important;
            height: 38px !important;
            border: none !important;
            box-shadow: none !important;
            padding: 0 !important;
            background-color: #ffffff !important;

            &:focus {
                box-shadow: none !important;
            }
        }

        .ant-input-suffix {
            margin-left: 0 !important;
        }
    }

    .ant-btn {
        width: 100%;
        height: 40px;
        border-radius: 8px;
        font-size: 16px;
        font-weight: 500;
        background-color: #4f46e5;
        border-color: #4f46e5;

        &:hover {
            background-color: #4338ca;
            border-color: #4338ca;
        }

        &[disabled] {
            background-color: #d1d5db;
            border-color: #d1d5db;
            color: white;
            cursor: not-allowed;

            &:hover {
                background-color: #d1d5db;
                border-color: #d1d5db;
            }
        }
    }
}

.divider {
    position: relative;
    text-align: center;
    margin: 24px 0;

    &::before {
        content: '';
        position: absolute;
        top: 50%;
        left: 0;
        right: 0;
        height: 1px;
        background-color: #e5e7eb;
        z-index: 0;
    }

    span {
        position: relative;
        background-color: transparent;
        padding: 0 12px;
        color: #6b7280;
        font-size: 14px;
        z-index: 1;
    }
}

.auth-footer {
    text-align: center;
    margin-top: 16px;
    font-size: 14px;
    color: #6b7280;

    a {
        color: #4f46e5;
        font-weight: 500;
        cursor: pointer;

        &:hover {
            text-decoration: underline;
        }
    }
}

.password-label-container {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 4px;

    .form-label {
        font-size: 14px;
        color: rgba(0, 0, 0, 0.85);
        font-weight: 500;
    }

    .forgot-link {
        font-size: 14px;
        color: #4f46e5;
        cursor: pointer;

        &:hover {
            text-decoration: underline;
        }
    }
}
</style>


================================================
FILE: frontend/src/view/auth/components/sms-login.vue
================================================
<template>
    <div>
      <!-- Login Password Form -->
      <a-form :model="loginForm" name="login-form" @finish="handleLoginSMSCode" autocomplete="off" layout="vertical">
  
        <a-form-item
          name="phone"
          :rules="[
            { required: true, message: $t('auth.pleaseInputPhone') },
            { pattern: /^1[3-9]\d{9}$/, message: $t('auth.pleaseInputValidPhone') }
          ]"
        >
          <div class="form-label">{{ $t('auth.phone') }}<span class="required-mark">*</span></div>
          <a-input v-model:value="loginForm.phone" :placeholder="$t('auth.pleaseInputPhone')" />
        </a-form-item>
  
        <!-- éªŒè¯ç  -->
        <a-form-item name="smsCode" :rules="[{ required: true, message: $t('auth.pleaseInputSMSCode') }]">
            <div class="form-label">
              {{ $t('auth.smsCode') }}<span class="required-mark">*</span>
            </div>
            <a-input-group compact>
              <a-input v-model:value="loginForm.smsCode" style="width: 65%;" :placeholder="$t('auth.pleaseInputSMSCode')" />
              <a-button
                style="width: 30%; margin-left: 5%; color:#fff"
                :disabled="smsCountdown > 0"
                @click="sendSMSCode"
              >
                {{ smsCountdown > 0 ? `${smsCountdown}s` : $t('auth.sendCode') }}
              </a-button>
            </a-input-group>
        </a-form-item>
        <!-- æäº¤æŒ‰é’® -->
        <a-form-item>
          <a-button type="primary" :disabled="!isLoginValid" html-type="submit" block :loading="loading">
            {{ $t('auth.login') }}
          </a-button>
        </a-form-item>
  
        <!-- è¿”å›ç™»å½• -->
        <div class="auth-footer">
            <a @click="toLogin">{{ $t('auth.otherLogin') }}</a>
        </div>
      </a-form>
    </div>
  </template>
  <script setup>
  import { computed, reactive,ref } from 'vue';
  import google from '@/assets/svg/google.svg';
  import { message } from 'ant-design-vue';
  import { MobileOutlined } from '@ant-design/icons-vue';
  //åˆ¤æ–­æ˜¯å›½å†…è¿˜æ˜¯æµ·å¤– VITE_REGION
  import { useI18n } from 'vue-i18n';
  
  const { t } = useI18n();
  import auth from '@/services/auth';
  const emit = defineEmits(['toLogin','handleLoginSMSCode']);
  
  const isAbroad = computed(() => import.meta.env.VITE_REGION === 'abroad');
  
  // å¿˜è®°å¯†ç è¡¨å•
  const loginForm = reactive({
    email: '',
    code: '',//é‚®ç®±éªŒè¯ç 
    password: '',
    phone: '',
    smsCode: '',//çŸ­ä¿¡éªŒè¯ç 
    confirmPassword: ''
  });
  
  const smsCountdown = ref(0)
  let smsTimer = null
  
  
  const isLoginValid = computed(() => {
      const phoneValid = /^1[3-9]\d{9}$/.test(loginForm.phone);
      const smsCodeValid = !!loginForm.smsCode;
      return phoneValid && smsCodeValid;
  });
  
  
  
  const handleLoginSMSCode = (value) => {
    emit("handleLoginSMSCode",value)
  };
  
  function sendSMSCode() {
    if (!/^1[3-9]\d{9}$/.test(loginForm.phone)) {
      message.error(t('auth.pleaseInputValidPhone'))
      return
    }
    auth.sendSmsCode(loginForm.phone)
    // æ¨¡æ‹Ÿå‘é€éªŒè¯ç 
    smsCountdown.value = 60
    smsTimer = setInterval(() => {
      smsCountdown.value--
      if (smsCountdown.value <= 0) {
        clearInterval(smsTimer)
        smsTimer = null
      }
    }, 1000)
  }
  
  const toLogin = () => {
    emit('toLogin')
  }
  
  
  </script>
  <style lang="scss" scoped>
  .social-buttons {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-bottom: 24px;
      align-items: center;
  
      .social-button {
          width: 100%;
          height: 40px;
          border-radius: 8px;
          display: flex;
          align-items: center;
          justify-content: center;
          font-size: 14px;
          color: #333;
          box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
          border: none;
          background-color: white;
          color: #333;
  
          img {
              margin-right: 6px;
          }
      }
  
  }
  
  
  :deep(.ant-form-item-control-input-content) {
      width: 360px;
  }
  
  :deep(.ant-form-item) {
      width: 100%;
      margin-bottom: 20px;
      display: flex;
      justify-content: center;
  
      .ant-form-item-control {
          width: 100%;
      }
  
      .ant-form-item-label>label {
          font-size: 14px;
          font-weight: 500;
          color: #374151;
      }
  
      .form-label {
          font-size: 14px;
          color: rgba(0, 0, 0, 0.85);
          font-weight: 500;
          margin-bottom: 4px;
  
          .required-mark {
              color: #ff4d4f;
              margin-left: 2px;
          }
      }
  
      .ant-input {
          width: 100%;
          height: 40px;
          border-radius: 8px;
          border: 1px solid #d1d5db;
          background-color: #ffffff;
  
          &:hover,
          &:focus {
              border-color: #4f46e5;
          }
      }
  
      .ant-input-affix-wrapper {
          width: 100%;
          height: 40px !important;
          border-radius: 8px !important;
          border: 1px solid #d1d5db !important;
          background-color: #ffffff !important;
          box-shadow: none !important;
          padding: 0 11px !important;
  
          &:hover,
          &:focus,
          &-focused {
              border-color: #4f46e5 !important;
          }
  
  
  
          .ant-input {
              width: 100% !important;
              height: 38px !important;
              border: none !important;
              box-shadow: none !important;
              padding: 0 !important;
              background-color: #ffffff !important;
  
              &:focus {
                  box-shadow: none !important;
              }
          }
  
          .ant-input-suffix {
              margin-left: 0 !important;
          }
      }
  
      .ant-btn {
          width: 100%;
          height: 40px;
          border-radius: 8px;
          font-size: 16px;
          font-weight: 500;
          background-color: #4f46e5;
          border-color: #4f46e5;
  
          &:hover {
              background-color: #4338ca;
              border-color: #4338ca;
          }
  
          &[disabled] {
              background-color: #d1d5db;
              border-color: #d1d5db;
              color: white;
              cursor: not-allowed;
  
              &:hover {
                  background-color: #d1d5db;
                  border-color: #d1d5db;
              }
          }
      }
  }
  
  .divider {
      position: relative;
      text-align: center;
      margin: 24px 0;
  
      &::before {
          content: '';
          position: absolute;
          top: 50%;
          left: 0;
          right: 0;
          height: 1px;
          background-color: #e5e7eb;
          z-index: 0;
      }
  
      span {
          position: relative;
          background-color: transparent;
          padding: 0 12px;
          color: #6b7280;
          font-size: 14px;
          z-index: 1;
      }
  }
  
  .auth-footer {
      text-align: center;
      margin-top: 16px;
      font-size: 14px;
      color: #6b7280;
  
      a {
          color: #4f46e5;
          font-weight: 500;
          cursor: pointer;
  
          &:hover {
              text-decoration: underline;
          }
      }
  }
  
  .password-label-container {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 4px;
  
      .form-label {
          font-size: 14px;
          color: rgba(0, 0, 0, 0.85);
          font-weight: 500;
      }
  
      .Login-link {
          font-size: 14px;
          color: #4f46e5;
          cursor: pointer;
  
          &:hover {
              text-decoration: underline;
          }
      }
  }
  </style>


================================================
FILE: frontend/src/view/auth/components/user-profile.vue
================================================
<template>
    <div class="user-center-popup">
        <div class="userInfo" v-if="isLogin">
            <div class="userName">
                {{ userName }}
            </div>
            <div class="userEmail">
                {{ user.user_email }}
            </div>
        </div>
        <!-- ä¼šå‘˜ä¿¡æ¯ -->
        <div class="memberInfo" v-if="isLogin">
            <span>{{ membership?.planName || $t("member.freePlan") }}</span>
            <button @click="toMember" class="upgrade">{{ $t("member.upgrade") }}</button>
        </div> 
        <!-- ç§¯åˆ† -->
        <div v-if="isLogin">
            <div class="score" @click="toUsage">
                <div>
                <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M15.2102 1.57437C15.2709 1.39188 15.529 1.39188 15.5897 1.57437L15.9325 2.60482C16.1315 3.20299 16.6008 3.67234 17.199 3.87131L18.2294 4.21408C18.4119 4.27478 18.4119 4.53293 18.2294 4.59363L17.199 4.9364C16.6008 5.13537 16.1315 5.60472 15.9325 6.20289L15.5897 7.23334C15.529 7.41583 15.2709 7.41583 15.2102 7.23334L14.8674 6.20289C14.6684 5.60472 14.1991 5.13537 13.6009 4.9364L12.5705 4.59363C12.388 4.53293 12.388 4.27478 12.5705 4.21408L13.6009 3.87131C14.1991 3.67234 14.6684 3.20299 14.8674 2.60482L15.2102 1.57437Z" fill="currentColor"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M8.10529 6.19431C7.64765 7.5701 6.56814 8.6496 5.19235 9.10724L2.42617 10.0274C1.96992 10.1791 1.96992 10.8245 2.42617 10.9763L5.19236 11.8964C6.56815 12.354 7.64765 13.4335 8.10529 14.8093L9.02543 17.5755C9.17719 18.0318 9.82255 18.0318 9.97431 17.5755L10.8945 14.8093C11.3521 13.4335 12.4316 12.354 13.8074 11.8964L16.5736 10.9763C17.0298 10.8245 17.0298 10.1791 16.5736 10.0274L13.8074 9.10724C12.4316 8.6496 11.3521 7.5701 10.8945 6.19431L9.97431 3.42812C9.82255 2.97188 9.17719 2.97188 9.02543 3.42812L8.10529 6.19431ZM9.49987 7.22075C8.86634 8.69339 7.69143 9.86829 6.2188 10.5018C7.69143 11.1354 8.86634 12.3103 9.49987 13.7829C10.1334 12.3103 11.3083 11.1354 12.7809 10.5018C11.3083 9.86829 10.1334 8.69339 9.49987 7.22075Z" fill="currentColor"></path></svg>
                <span>{{ $t("member.points") }}</span>
            </div>
            <span>{{ points.total }}</span>
            </div>
            
            
        </div>
        <!-- è®¾ç½® -->
        <div @click="toSetting" >
            <svg t="1744338498135" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg"
                p-id="5527" width="20" height="20">
                <path
                    d="M439.816 101.851c-8.631-16.952-28.007-25.48-46.337-20.396-70.066 19.435-133.165 55.501-184.82 103.628-12.909 12.028-16.413 31.094-8.623 46.926 5.374 10.92 8.414 23.234 8.414 36.376 0 45.555-36.833 82.347-82.1 82.347-0.381 0-0.762-0.003-1.142-0.008-17.691-0.253-33.448 11.147-38.74 28.031C73.159 421.209 66 466.344 66 513.078c0 30.844 3.118 61.001 9.07 90.156 4.1 20.082 22.714 33.816 43.111 31.808a83.069 83.069 0 0 1 8.169-0.399c45.267 0 82.1 36.791 82.1 82.346 0 20.276-7.254 38.74-19.334 53.086-13.177 15.649-12.423 38.718 1.748 53.472 52.742 54.916 119.403 96.417 194.376 118.784 20.888 6.231 42.918-5.408 49.543-26.174 10.616-33.275 41.714-57.212 78.217-57.212s67.601 23.937 78.217 57.212c6.625 20.766 28.655 32.405 49.543 26.174 74.973-22.367 141.634-63.868 194.376-118.784 14.17-14.755 14.924-37.823 1.748-53.471-12.08-14.346-19.334-32.811-19.334-53.087 0-45.554 36.834-82.346 82.1-82.346 2.773 0 5.496 0.135 8.169 0.399 20.397 2.008 39.011-11.726 43.111-31.808 5.951-29.155 9.07-59.312 9.07-90.156 0-46.734-7.16-91.869-20.468-134.323-5.292-16.884-21.049-28.285-38.741-28.031-0.379 0.005-0.76 0.008-1.141 0.008-45.266 0-82.1-36.792-82.1-82.347 0-13.142 3.04-25.456 8.414-36.376 7.79-15.832 4.286-34.898-8.623-46.926-51.655-48.127-114.754-84.193-184.82-103.628-18.33-5.084-37.706 3.444-46.337 20.396-13.648 26.806-41.357 44.97-73.184 44.97-31.827 0-59.536-18.164-73.184-44.97zM288.45 268.385c0-14.471-1.9-28.535-5.47-41.936 31.114-25.118 66.377-45.232 104.576-59.156 29.686 36.285 74.82 59.528 125.444 59.528 50.624 0 95.758-23.243 125.444-59.528 38.199 13.924 73.462 34.038 104.576 59.156a162.748 162.748 0 0 0-5.47 41.936c0 79.513 57.113 145.772 132.604 159.667 6.434 27.261 9.846 55.723 9.846 85.026 0 14.581-0.845 28.951-2.485 43.065-79.109 10.814-139.965 78.769-139.965 160.846 0 26.162 6.201 50.922 17.202 72.84-30.829 27.076-66.197 49.043-104.786 64.612-28.717-45.337-79.271-75.496-136.966-75.496-57.695 0-108.249 30.159-136.966 75.496-38.589-15.569-73.957-37.536-104.787-64.612 11.002-21.918 17.203-46.678 17.203-72.84 0-82.077-60.856-150.032-139.965-160.846A373.007 373.007 0 0 1 146 513.078c0-29.304 3.411-57.765 9.845-85.026 75.492-13.894 132.605-80.154 132.605-159.667zM513 336c-97.202 0-176 78.798-176 176s78.798 176 176 176 176-78.798 176-176-78.798-176-176-176zM409 512c0-57.438 46.562-104 104-104s104 46.562 104 104-46.562 104-104 104-104-46.562-104-104z"
                    fill="#666" p-id="5528"></path>
            </svg>
            <span>{{  $t("settings") }}</span>
        </div>
        <div class="logout" @click="logOut" v-if="isLogin">
            <Logout />
            <span>{{ $t(`auth.logOut`) }}</span>
        </div>
        <!-- å»ç™»å½• -->
         <div class="login" v-else @click="handleLogin">
            <svg t="1749714854005" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5537" width="20" height="20"><path d="M832 896H298.666667a104.533333 104.533333 0 0 1-106.666667-102.4v-101.973333h53.333333v102.826666A52.48 52.48 0 0 0 298.666667 845.653333h533.333333a52.48 52.48 0 0 0 53.333333-51.2V229.546667a52.48 52.48 0 0 0-53.333333-51.2H298.666667a52.48 52.48 0 0 0-53.333334 51.2v102.826666H192V229.546667A104.533333 104.533333 0 0 1 298.666667 128h533.333333A104.533333 104.533333 0 0 1 938.666667 229.546667v564.906666A104.533333 104.533333 0 0 1 832 896zM601.173333 352a25.6 25.6 0 0 1 0-36.693333 27.733333 27.733333 0 0 1 37.546667 0l184.32 177.066666a30.293333 30.293333 0 0 1 0 39.253334L640 708.693333a27.733333 27.733333 0 0 1-37.546667 0 25.173333 25.173333 0 0 1 0-36.266666l139.946667-134.826667H112.213333a25.6 25.6 0 1 1 0-51.2h628.906667z" fill="#2c2c2c" p-id="5538"></path></svg>
            <span>{{ $t(`auth.login`) }}</span>
        </div>
    </div>
</template>
<script setup>
import { computed, inject, h,ref,onMounted,nextTick} from "vue";

import Logout from "@/assets/logout.svg";
import auth from '@/services/auth';
import { storeToRefs } from 'pinia';
import { useUserStore } from '@/store/modules/user.js'
const userStore = useUserStore();
const { user, membership, points } = storeToRefs(userStore);
import { useRouter } from "vue-router";
const router = useRouter();

// --- å›½é™…åŒ–å¼•å…¥ ---
import { useI18n } from 'vue-i18n'
const { t } = useI18n()

const userName = computed(() => {
    return user.user_name || user.mobile || user.user_email;
});

const props = defineProps({
    show: {
        type: Boolean,
        default: false
    }
})

const toMember = () => {
    router.push({ name: "pricing" });
};

const toSetting = () => {
    router.push({ path: '/setting/basic' });
};

//åˆ¤æ–­æ˜¯å¦ç™»å½•
const  isLogin = computed(() => {
    //åˆ¤æ–­æ˜¯å¦å­˜åœ¨ç”¨æˆ·ID user
    if  (user.value.id) {
        return true;    
    }
    return false;
});


const logOut = async () => {
    await auth.logout();
    //è·³è½¬å›ç™»å½• 
    window.location.reload();
};

const handleLogin = async () => { 
    router.push({ name: "login" });
};

const toUsage = () => {
    router.push({ path: '/setting/usage' });
};

//è·å–ç”¨æˆ·ä¿¡æ¯ getUserInfo
async function getUserInfo() {
  //åˆ¤æ–­æœ‰æ²¡æœ‰ç™»å½•
  if (!isLogin.value) {
    return;
  }
  let res = await auth.getUserInfo();
  //è®¾ç½®ç¼“å­˜
  membership.value = res.membership;
  points.value = res.points;
}

onMounted(() => {
  nextTick(() => {
    getUserInfo();
  });
});

</script>
<style lang="scss" scoped>
.user-center-popup {
    >div:not(.userInfo){
        padding: .5rem;
        display: flex;
        align-items: center;
        gap: .75rem;
        border-radius: .5rem;
    }
    >div:not(.userInfo):hover {
        background-color: #37352F0F;
    }
    .memberInfo{
        display: flex;
        background-color: #37352F0F;
        justify-content: space-between;
        padding: 12px!important;
        margin-bottom: .75rem;
        button{
            color: #fff;
            background-color: #1a1a19;
            padding-left: .75rem;
            padding-right: .75rem;
            border-radius: 99999px;
            cursor: pointer;

        }
    }
    .score{
        width: 100%;
    display: flex;
    align-items: center;
    justify-content: space-between;
        >div{
            display: flex;
            gap: .75rem;
            align-items: center;
            >div{
                display: flex;
                justify-content: space-between;
            }
        }
      
    }
    .userInfo {
        padding: 0px 0px 10px 0px;

        .userName {
            line-height: 22px;
            font-weight: 600;
            font-size: 1rem;
            color: #34322D;
            text-overflow: ellipsis;
            overflow: hidden;
            white-space: nowrap;
        }

        .userEmail {
            line-height: 18px;
            font-weight: 400;
            font-size: 0.875rem;
            color: #858481;
            text-overflow: ellipsis;
            overflow: hidden;
            white-space: nowrap;
        }

    }

    .user-name {
        margin-bottom: 5px;
    }

    .userCenter {
        margin-bottom: 10px;
        padding: 20px 16px 16px 20px;
        background-color: hsla(240, 9%, 59%, 0.1);
        ;
        border-radius: 6px;
        display: flex;
        justify-content: center;
    }

    .balance {
        margin-bottom: 10px;
    }
    
    .logout {
        cursor: pointer;
        padding: 8px;
        display: flex;
        justify-content: start;
        align-items: center;
        border-radius: 6px;
        line-height: 1.25rem;
        font-weight: 500;
        font-size: 0.875rem;
        color: #F25A5A;

        img {
            width: 20px;
            height: 20px;
        }

        &:hover {
            background-color: hsla(240, 9%, 59%, 0.1);
        }

        span {
            margin-left: 5px;
        }
    }
}
</style>


================================================
FILE: frontend/src/view/demo/HelloWorld.vue
================================================
<template>
  <h1>{{ msg }}</h1>

  <div class="card">
    <button type="button" @click="plus()">count is {{ demoStore.count }}</button>
    <p>
      Edit
      <code>components/HelloWorld.vue</code> to test HMR
    </p>
  </div>

  <p>
    Check out
    <a href="https://vuejs.org/guide/quick-start.html#local" target="_blank">create-vue</a>, the official Vue + Vite
    starter
  </p>
  <p>
    Learn more about IDE Support for Vue in the
    <a href="https://vuejs.org/guide/scaling-up/tooling.html#ide-support" target="_blank">Vue Docs Scaling up Guide</a>.
  </p>
  <p class="read-the-docs">Click on the Vite and Vue logos to learn more</p>
</template>

<script setup>
import { ref } from 'vue'
import { useDemoStore } from "@/store/modules/demo.js";
const demoStore = useDemoStore();

defineProps({
  msg: String,
})

// const count = ref(0)
const plus = () => {
  demoStore.setCount(demoStore.count + 1);
}

</script>



<style scoped>
.read-the-docs {
  color: #888;
}
</style>



================================================
FILE: frontend/src/view/demo/index.vue
================================================
<template>
  <div>
    <h1>demo</h1>
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue';
import { io } from "socket.io-client";
const socket = ref(null)

const connectWebSocket = () => {
  // Connect to WebSocket with specific parameters
  socket.value = io('ws://localhost:3000', {
    path: '/socket.io/',
    query: {
      latest_event_id: -1,
      conversation_id: 'b0316208a2054a16968a90f14f50da3c',
      EIO: 4,
      transport: 'websocket'
    }
  });

  // Listen for messages
  socket.value.on('message', (data) => {
    console.log('Received message:', data);
    // Handle the message here
  });

  // Handle connection events
  socket.value.on('connect', () => {
    console.log('Connected to WebSocket server');
  });

  socket.value.on('oh_event', (data) => {
    console.log('oh_event', data);
  });

  socket.value.on('disconnect', () => {
    console.log('Disconnected from WebSocket server');
  });

  socket.value.on('error', (error) => {
    console.error('WebSocket error:', error);
  });
}

onMounted(() => {
  connectWebSocket();
});

</script>

<style scoped>
.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}

.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}

.logo.vue:hover {
  filter: drop-shadow(0 0 2em #42b883aa);
}
</style>



================================================
FILE: frontend/src/view/desktop/redirect.vue
================================================
<template>
    <div class="redirect-container">
      <a-result
        status="success"
        title="ç™»å½•æˆåŠŸ"
        sub-title="æ­£åœ¨ä¸ºä½ æ‰“å¼€å®¢æˆ·ç«¯ï¼Œè¯·åœ¨æµè§ˆå™¨æç¤ºä¸­ç‚¹å‡»â€œæ‰“å¼€â€ã€‚"
      >
        <template #icon>
          <a-icon type="check-circle" theme="twoTone" two-tone-color="#52c41a" />
        </template>
        <template #extra>
          <a-button type="primary" size="large" @click="openApp">
            æ‰‹åŠ¨æ‰“å¼€å®¢æˆ·ç«¯
          </a-button>
          <p class="tip-text">è‹¥æœªçœ‹åˆ°å¼¹çª—ï¼Œè¯·æ‰‹åŠ¨ç‚¹å‡»ä¸Šæ–¹æŒ‰é’®ã€‚</p>
        </template>
      </a-result>
    </div>
  </template>
  
  <script setup>
  import { onMounted } from 'vue';
  import { useRoute } from 'vue-router';
  
  const route = useRoute();
  
  function openApp() {
    const code = route.query.code;
    if (code) {
      const deeplink = `lemonai://auth?code=${encodeURIComponent(code)}`;
      window.location.href = deeplink;
    }
  }
  
  onMounted(() => {
    openApp();
  
    // fallback ä¸åšè·³è½¬ï¼Œå¯ç•™ç©ºç­‰ç”¨æˆ·æ‰‹åŠ¨ç‚¹å‡»æŒ‰é’®
  });
  </script>
  
  <style scoped>
  .redirect-container {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    background: #f0f2f5;
  }
  
  .tip-text {
    margin-top: 1rem;
    color: rgba(0, 0, 0, 0.45);
    font-size: 14px;
  }
  </style>
  


================================================
FILE: frontend/src/view/editor/index.vue
================================================
<template>
  <div class="h-screen flex flex-col">
    <!-- é¡¶éƒ¨å·¥å…·æ  -->
    <ToolBar
      @import-html="importHTML"
      @save-file="saveFileContent"
      @export-html="exportHTML"
      @toggle-code-panel="toggleCodePanel"
      @toggle-upload-area="toggleUploadArea"
      @toggle-version-panel="toggleVersionPanel"
    />

    <div class="flex-1 flex overflow-hidden">
      <!-- å·¦ä¾§é¢æ¿ -->
      <SidePanel
        :element-path="elementPath"
        :selected-element="selectedElement"
        @select-from-path="selectFromPath"
        @open-ai-dialog="openAIDialog"
        @open-rich-editor="openRichEditor"
        @open-inline-editor="openInlineEditor"
      />

      <!-- ä¸­é—´é¢„è§ˆåŒºåŸŸ -->
      <div class="flex-1 flex flex-col">
        <!-- æ–‡ä»¶ä¸Šä¼ åŒºåŸŸ -->
        <div v-if="showUploadArea" class="upload-area-wrapper">
          <FileUploadArea @file-uploaded="handleFileUploaded" @files-uploaded="handleFilesUploaded" />
        </div>

        <!-- é¢„è§ˆåŒºåŸŸ -->
        <div class="flex-1">
          <PreviewArea ref="previewAreaRef" @editStarted="onEditStarted" @editComplete="onDirectEditComplete" @mediaElementDoubleClick="onMediaElementDoubleClick" />
        </div>
      </div>

      <!-- å³ä¾§é¢æ¿ -->
      <div v-if="showCodePanel || showVersionPanel" class="right-panels">
        <!-- ä»£ç é¢æ¿ -->
        <CodePanel v-if="showCodePanel" :html-content="htmlContent" @sync-from-code="syncFromCode" class="code-panel" />

        <!-- ç‰ˆæœ¬å†å²é¢æ¿ -->
        <VersionHistoryPanel
          v-if="showVersionPanel"
          :version-manager="versionManagerInstance"
          @version-change="onVersionChange"
          @export-history="onExportHistory"
          @import-history="onImportHistory"
          class="version-panel"
        />
      </div>
    </div>

    <!-- AIç¼–è¾‘å¯¹è¯æ¡† -->
    <AIEditDialog ref="aiEditDialogRef" @apply-edit="onAIEditApplied" />

    <!-- å¯Œæ–‡æœ¬ç¼–è¾‘å™¨ -->
    <RichTextEditor ref="richTextEditorRef" @save-content="onRichTextSaved" />

    <!-- ä¸Šä¼ çŠ¶æ€æç¤º -->
    <UploadStatus
      :visible="uploadState.visible"
      :status="uploadState.status"
      :title="uploadState.title"
      :message="uploadState.message"
      :files="uploadState.files"
      :auto-close="uploadState.autoClose"
      :auto-close-delay="uploadState.autoCloseDelay"
      @close="hideUploadStatus"
      @confirm="confirmUpload"
      @retry="retryLastUpload"
    />

    <!-- æµ®åŠ¨ç‰ˆæœ¬æ“ä½œæ  -->
    <VersionActions :can-undo="versionCanUndo" :can-redo="versionCanRedo" :version-count="versionCount" :has-unsaved-changes="hasUnsavedChanges" @undo="undo" @redo="redo" />

    <!-- å†…è”ç¼–è¾‘æ¨¡æ€æ¡† -->
    <InlineEditModal ref="inlineEditModalRef" @save="onInlineEditSave" @cancel="onInlineEditCancel" />

    <!-- å¤šåª’ä½“ç¼–è¾‘å¯¹è¯æ¡† -->
    <MediaEditDialog ref="mediaEditDialogRef" @save="onMediaEditSave" @close="onMediaEditClose" />
  </div>
</template>

<script setup>
import { ref, reactive, onMounted, onUnmounted, nextTick, watch } from "vue";
import { useRoute } from "vue-router";
import fileService from "@/services/files.js";
import ToolBar from "./components/ToolBar.vue";
import SidePanel from "./components/SidePanel.vue";
import PreviewArea from "./components/PreviewArea.vue";
import CodePanel from "./components/CodePanel.vue";
import AIEditDialog from "./components/AIEditDialog.vue";
import RichTextEditor from "./components/RichTextEditor.vue";
import FileUploadArea from "./components/FileUploadArea.vue";
import UploadStatus from "./components/UploadStatus.vue";
import { useEditorCore } from "./composables/useEditorCore";
import { useFileManager } from "./composables/useFileManager";
import { useNotification } from "./composables/useNotification";
import { useDragDrop } from "./composables/useDragDrop";
import { useFileUpload } from "./composables/useFileUpload";
import { useVersionManager } from "./composables/useVersionManager";
import VersionHistoryPanel from "./components/VersionHistoryPanel.vue";
import VersionActions from "./components/VersionActions.vue";
import InlineEditModal from "./components/InlineEditModal.vue";
import MediaEditDialog from "./components/MediaEditDialog.vue";

// è·¯ç”±å‚æ•°
const route = useRoute();
const currentFileId = ref(route.params.file_id || null);

// å“åº”å¼æ•°æ®
const htmlContent = ref(`<div class="container mx-auto p-6">
    <h1 class="text-3xl font-bold text-gray-800 mb-4">æ¬¢è¿ä½¿ç”¨ HTML ç¼–è¾‘å™¨</h1>
    <p class="text-gray-600 mb-6">è¿™æ˜¯ä¸€ä¸ªç¤ºä¾‹æ®µè½ï¼Œæ‚¨å¯ä»¥ç‚¹å‡»ä»»ä½•å…ƒç´ è¿›è¡Œç¼–è¾‘ã€‚</p>
    <div class="bg-blue-100 p-4 rounded-lg">
        <h2 class="font-semibold text-lg">æ·»åŠ è®°è´¦</h2>
        <p class="text-gray-700 mb-4">æµ‹è¯•å¯Œæ–‡æœ¬ç¼–è¾‘å™¨çš„ç±»åä¿æŒåŠŸèƒ½ - ç‚¹å‡»ä¸Šé¢çš„æ ‡é¢˜è¿›è¡Œç¼–è¾‘</p>
        <h3 class="text-xl font-semibold text-blue-800 mb-2">åŠŸèƒ½ç‰¹æ€§</h3>
        <ul class="list-disc list-inside text-blue-700">
            <li>å®æ—¶é¢„è§ˆ</li>
            <li>å…ƒç´ é€‰æ‹©</li>
            <li>AI æ™ºèƒ½ç¼–è¾‘</li>
            <li>å¯Œæ–‡æœ¬ç¼–è¾‘ï¼ˆä¿æŒç±»åï¼‰</li>
            <li>å¿«é€Ÿå†…è”ç¼–è¾‘</li>
        </ul>
    </div>
</div>`);

const showCodePanel = ref(false);
const showUploadArea = ref(false);
const showVersionPanel = ref(false);
const selectedElement = ref(null);
const elementPath = ref([]);

// ç»„ä»¶å¼•ç”¨
const previewAreaRef = ref(null);
const aiEditDialogRef = ref(null);
const richTextEditorRef = ref(null);
const inlineEditModalRef = ref(null);
const mediaEditDialogRef = ref(null);

// ä½¿ç”¨ composables
const {
  selectedElement: coreSelectedElement,
  elementPath: coreElementPath,
  initializeEditor,
  updatePreview,
  selectFromPath,
  clearInlineEdit,
  openAIDialog: editorOpenAI,
  openRichEditor: editorOpenRich,
  openInlineEditor: editorOpenInline,
  syncToCode,
  addToHistory,
  setOnContentChangeCallback,
  setOnInlineEditCallback,
  updateElementContent,
} = useEditorCore();

// åŒæ­¥çŠ¶æ€
watch(coreSelectedElement, (newVal) => {
  selectedElement.value = newVal;
});

watch(coreElementPath, (newVal) => {
  elementPath.value = newVal;
});

const { importHTML: fileImportHTML, exportHTML: fileExportHTML } = useFileManager();

const { showNotification } = useNotification();

const { initDragDrop, setCallbacks: setDragCallbacks } = useDragDrop();

const { uploadState, handleSingleFileUpload, handleMultipleFileUpload, hideUploadStatus, confirmUpload } = useFileUpload();

// ç‰ˆæœ¬ç®¡ç†
const versionManagerInstance = useVersionManager();
const {
  initialize: initializeVersionManager,
  addVersion,
  undo: versionUndo,
  redo: versionRedo,
  canUndo: versionCanUndo,
  canRedo: versionCanRedo,
  versionCount,
  hasUnsavedChanges,
} = versionManagerInstance;

// æ–¹æ³•
const toggleCodePanel = () => {
  showCodePanel.value = !showCodePanel.value;
};

const toggleUploadArea = () => {
  showUploadArea.value = !showUploadArea.value;
};

const toggleVersionPanel = () => {
  showVersionPanel.value = !showVersionPanel.value;
};

const syncFromCode = (newContent) => {
  if (newContent !== htmlContent.value) {
    htmlContent.value = newContent;
    updatePreview(newContent);
    // æ·»åŠ ç‰ˆæœ¬è®°å½•
    addVersion(newContent, "ä»£ç åŒæ­¥", { source: "ä»£ç ç¼–è¾‘" });
  }
};

const undo = () => {
  // ä½¿ç”¨ç‰ˆæœ¬ç®¡ç†çš„æ’¤é”€åŠŸèƒ½
  const version = versionUndo();
  if (version) {
    htmlContent.value = version.content;
    updatePreview(version.content);
  }
};

const redo = () => {
  // ä½¿ç”¨ç‰ˆæœ¬ç®¡ç†çš„é‡åšåŠŸèƒ½
  const version = versionRedo();
  if (version) {
    htmlContent.value = version.content;
    updatePreview(version.content);
  }
};

const openAIDialog = () => {
  if (selectedElement.value && aiEditDialogRef.value) {
    // å…ˆæ¸…ç†ä»»ä½•æ­£åœ¨è¿›è¡Œçš„å†…è”ç¼–è¾‘
    clearInlineEdit();
    // ä¼ é€’å½“å‰å®Œæ•´çš„HTMLå†…å®¹
    aiEditDialogRef.value.show(selectedElement.value, htmlContent.value);
  }
};

const openRichEditor = () => {
  if (selectedElement.value && richTextEditorRef.value) {
    // å…ˆæ¸…ç†ä»»ä½•æ­£åœ¨è¿›è¡Œçš„å†…è”ç¼–è¾‘
    clearInlineEdit();
    richTextEditorRef.value.show(selectedElement.value);
  }
};

const openInlineEditor = () => {
  if (selectedElement.value) {
    editorOpenInline(selectedElement.value);
  }
};

const importHTML = async () => {
  try {
    const result = await fileImportHTML();
    htmlContent.value = result.content;
    updatePreview(result.content);

    // åŒæ­¥æ›´æ–°ç¼–è¾‘å™¨æ ¸å¿ƒå†å²è®°å½•
    addToHistory(result.content);

    // é‡ç½®ç‰ˆæœ¬å†å²å¹¶æ·»åŠ æ–°çš„åˆå§‹ç‰ˆæœ¬
    initializeVersionManager(result.content, `å¯¼å…¥æ–‡ä»¶: ${result.filename}`);

    showNotification(`å·²å¯¼å…¥æ–‡ä»¶: ${result.filename}`, "success");
  } catch (error) {
    showNotification(`å¯¼å…¥å¤±è´¥: ${error.message}`, "error");
  }
};

const exportHTML = () => {
  const result = fileExportHTML(htmlContent.value);
  if (result.success) {
    showNotification(`å·²å¯¼å‡ºæ–‡ä»¶: ${result.filename}`, "success");
  } else {
    showNotification(`å¯¼å‡ºå¤±è´¥: ${result.error}`, "error");
  }
};

const onAIEditApplied = (edit) => {
  console.log("AIç¼–è¾‘åº”ç”¨", edit);

  // ä½¿ç”¨æ ¸å¿ƒç¼–è¾‘å™¨çš„æ–¹æ³•è·å–æœ€æ–°HTMLå†…å®¹
  const newHtmlContent = syncToCode();
  console.log("AIç¼–è¾‘è·å–çš„æ–°å†…å®¹:", newHtmlContent?.substring(0, 100) + "...");

  if (newHtmlContent && newHtmlContent !== htmlContent.value) {
    htmlContent.value = newHtmlContent;

    // æ·»åŠ åˆ°ç‰ˆæœ¬ç®¡ç†
    const success = addVersion(newHtmlContent, "AIç¼–è¾‘", { source: "AI", templateType: edit.templateType });
    console.log("ç‰ˆæœ¬æ·»åŠ ç»“æœ:", success);

    // æ›´æ–°é¢„è§ˆ
    updatePreview(newHtmlContent);

    showNotification("AIç¼–è¾‘å·²åº”ç”¨", "success");
  }
};

const onRichTextSaved = (saveData) => {
  console.log("å¯Œæ–‡æœ¬ç¼–è¾‘ä¿å­˜", saveData);

  // åœ¨iframeç¯å¢ƒä¸‹ï¼Œé€šè¿‡updateElementContentæ›´æ–°å†…å®¹
  if (selectedElement.value && saveData.content) {
    updateElementContent(selectedElement.value, saveData.content);
    showNotification("å¯Œæ–‡æœ¬ç¼–è¾‘å·²ä¿å­˜", "success");
  }
};

// å¤„ç†ç¼–è¾‘å™¨å†…å®¹å˜åŒ–ï¼ˆå†…è”ç¼–è¾‘ç­‰ï¼‰
const onEditorContentChange = (newContent, action) => {
  console.log("ç¼–è¾‘å™¨å†…å®¹å˜åŒ–:", action, newContent?.substring(0, 100) + "...");
  console.log("å½“å‰htmlContent:", htmlContent.value?.substring(0, 100) + "...");
  console.log("å†…å®¹æ˜¯å¦ä¸åŒ:", newContent !== htmlContent.value);

  if (newContent && newContent !== htmlContent.value) {
    console.log("æ›´æ–°htmlContentä»", htmlContent.value?.substring(0, 50), "åˆ°", newContent?.substring(0, 50));
    htmlContent.value = newContent;
    // æ·»åŠ åˆ°ç‰ˆæœ¬ç®¡ç†
    const success = addVersion(newContent, action, { source: "ç¼–è¾‘å™¨" });
    console.log("ç‰ˆæœ¬æ·»åŠ ç»“æœ:", success);
  } else {
    console.log("å†…å®¹ç›¸åŒï¼Œè·³è¿‡æ›´æ–°");
  }
};

// å¤„ç†å†…è”ç¼–è¾‘è¯·æ±‚
const onInlineEditRequest = (elementInfo) => {
  console.log("å†…è”ç¼–è¾‘è¯·æ±‚:", elementInfo);
  if (inlineEditModalRef.value) {
    inlineEditModalRef.value.show(elementInfo);
  }
};

// å¤„ç†å†…è”ç¼–è¾‘ä¿å­˜
const onInlineEditSave = (editData) => {
  console.log("å†…è”ç¼–è¾‘ä¿å­˜:", editData);
  updateElementContent(editData.element, editData.content);
};

// å¤„ç†å†…è”ç¼–è¾‘å–æ¶ˆ
const onInlineEditCancel = () => {
  console.log("å†…è”ç¼–è¾‘å–æ¶ˆ");
};

// ç‰ˆæœ¬ç®¡ç†äº‹ä»¶å¤„ç†
const onVersionChange = (version) => {
  htmlContent.value = version.content;
  updatePreview(version.content);
  showNotification(`åˆ‡æ¢åˆ°ç‰ˆæœ¬: ${version.action}`, "info");
};

const onExportHistory = () => {
  showNotification("ç‰ˆæœ¬å†å²å·²å¯¼å‡º", "success");
};

const onImportHistory = () => {
  showNotification("ç‰ˆæœ¬å†å²å·²å¯¼å…¥", "success");
};

// å¤„ç†æ–‡ä»¶ä¸Šä¼ 
const handleFileUploaded = (result) => {
  handleSingleFileUpload(result, (fileResult) => {
    htmlContent.value = fileResult.content;
    updatePreview(fileResult.content);

    // åŒæ­¥æ›´æ–°ç¼–è¾‘å™¨æ ¸å¿ƒå†å²è®°å½•
    addToHistory(fileResult.content);

    // é‡ç½®ç‰ˆæœ¬å†å²å¹¶æ·»åŠ æ–°çš„åˆå§‹ç‰ˆæœ¬
    initializeVersionManager(fileResult.content, `ä¸Šä¼ æ–‡ä»¶: ${fileResult.filename}`);
  });
};

const handleFilesUploaded = (results) => {
  handleMultipleFileUpload(results, (fileResult) => {
    htmlContent.value = fileResult.content;
    updatePreview(fileResult.content);

    // åŒæ­¥æ›´æ–°ç¼–è¾‘å™¨æ ¸å¿ƒå†å²è®°å½•
    addToHistory(fileResult.content);

    // é‡ç½®ç‰ˆæœ¬å†å²å¹¶æ·»åŠ æ–°çš„åˆå§‹ç‰ˆæœ¬
    initializeVersionManager(fileResult.content, `æ‰¹é‡ä¸Šä¼ æ–‡ä»¶: ${fileResult.filename}`);
  });
};

// é‡è¯•æœ€åçš„ä¸Šä¼ æ“ä½œ
const retryLastUpload = () => {
  hideUploadStatus();
  // è¿™é‡Œå¯ä»¥æ·»åŠ é‡è¯•é€»è¾‘
  showNotification("è¯·é‡æ–°é€‰æ‹©æ–‡ä»¶", "info");
};

// å¤„ç†ç›´æ¥ç¼–è¾‘å¼€å§‹äº‹ä»¶
const onEditStarted = (elementData) => {
  console.log("ç›´æ¥ç¼–è¾‘å¼€å§‹:", elementData);
  // å¯ä»¥åœ¨è¿™é‡Œæ˜¾ç¤ºç¼–è¾‘çŠ¶æ€æŒ‡ç¤º
};

// å¤„ç†ç›´æ¥ç¼–è¾‘å®Œæˆäº‹ä»¶
const onDirectEditComplete = (data) => {
  console.log("ç›´æ¥ç¼–è¾‘å®Œæˆ:", data);

  const { element, content } = data;

  try {
    // ä½¿ç”¨æ›´ç²¾ç¡®çš„æ–¹æ³•ï¼šåŸºäºå…ƒç´ ä¿¡æ¯è¿›è¡Œå®šä½å’Œæ›¿æ¢
    console.log("æ¥æ”¶åˆ°çš„ç¼–è¾‘å†…å®¹:", content);
    console.log("ç¼–è¾‘çš„å…ƒç´ ä¿¡æ¯:", element);

    if (!element || content === undefined) {
      console.error("ç¼ºå°‘å¿…è¦çš„å…ƒç´ ä¿¡æ¯æˆ–å†…å®¹");
      return;
    }

    // ä½¿ç”¨updateElementContentæ–¹æ³•æ¥æ›´æ–°ç‰¹å®šå…ƒç´ 
    // è¿™æ ·å¯ä»¥ä¿æŒå®Œæ•´çš„HTMLç»“æ„
    const elementInfo = {
      tagName: element.tagName,
      id: element.id,
      className: element.className,
      innerHTML: element.innerHTML,
      outerHTML: element.outerHTML,
    };

    console.log("å‡†å¤‡æ›´æ–°å…ƒç´ å†…å®¹ï¼Œå…ƒç´ ä¿¡æ¯:", elementInfo);

    // è°ƒç”¨useEditorCoreçš„updateElementContentæ–¹æ³•
    updateElementContent(elementInfo, content);

    showNotification("å†…å®¹å·²ä¿å­˜", "success");
  } catch (error) {
    console.error("æ›´æ–°å†…å®¹å¤±è´¥:", error);
    showNotification("ä¿å­˜å¤±è´¥", "error");
  }
};

// å¤„ç†å¤šåª’ä½“å…ƒç´ åŒå‡»äº‹ä»¶
const onMediaElementDoubleClick = (data) => {
  console.log("å¤šåª’ä½“å…ƒç´ åŒå‡»:", data);

  const { element, mediaType } = data;

  if (mediaEditDialogRef.value) {
    mediaEditDialogRef.value.show(element, mediaType);
  }
};

// å¤„ç†å¤šåª’ä½“ç¼–è¾‘ä¿å­˜
const onMediaEditSave = (data) => {
  console.log("å¤šåª’ä½“ç¼–è¾‘ä¿å­˜:", data);

  const { element, newSrc, mediaType, fileData } = data;

  try {
    // å¤„ç†base64æ•°æ®ï¼Œç¡®ä¿å®ƒæ˜¯æœ‰æ•ˆçš„
    let finalSrc = newSrc;

    if (fileData && fileData.base64) {
      finalSrc = fileData.base64;
      console.log("ä½¿ç”¨base64æ•°æ®ï¼Œé•¿åº¦:", finalSrc.length);
    }

    const currentHtml = htmlContent.value;
    let newHtml = currentHtml;

    console.log("å¼€å§‹æ›¿æ¢åª’ä½“å…ƒç´ ï¼Œæ ‡è¯†ç¬¦:", element.editorId);
    console.log("å…ƒç´ ä¿¡æ¯:", element);

    // åŸºäºå­—ç¬¦ä¸²æ›¿æ¢çš„å®‰å…¨æ›¿æ¢ç­–ç•¥ï¼Œä¸ç ´åHTMLç»“æ„
    const replaceElementInHtml = (html, targetElement, newSrcValue) => {
      try {
        let modifiedHtml = html;
        let replaced = false;

        // è½¬ä¹‰æ–°å€¼ä¸­çš„ç‰¹æ®Šå­—ç¬¦
        const escapedNewValue = newSrcValue.replace(/["'&<>]/g, (match) => {
          const escapeMap = {
            '"': "&quot;",
            "'": "&#39;",
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
          };
          return escapeMap[match];
        });

        // ç­–ç•¥1: é€šè¿‡editorIdç²¾ç¡®åŒ¹é… (æœ€å¯é )
        if (targetElement.editorId && !replaced) {
          try {
            const attrName = mediaType === "object" ? "data" : "src";
            const editorIdPattern = `data-editor-id="${targetElement.editorId}"`;
            const tagStart = `<${targetElement.tagName}`;

            // æŸ¥æ‰¾åŒ…å«editorIdçš„æ ‡ç­¾å¼€å§‹ä½ç½®
            const startIndex = html.indexOf(tagStart);
            if (startIndex !== -1) {
              const editorIdIndex = html.indexOf(editorIdPattern, startIndex);
              if (editorIdIndex !== -1) {
                // æ‰¾åˆ°æ ‡ç­¾çš„ç»“æŸä½ç½®
                const tagEndIndex = html.indexOf(">", editorIdIndex);
                if (tagEndIndex !== -1) {
                  const tagContent = html.substring(startIndex, tagEndIndex + 1);
                  const srcPattern = new RegExp(`\\s*(${attrName})="[^"]*"`, "gi");
                  const newTagContent = tagContent.replace(srcPattern, ` ${attrName}="${escapedNewValue}"`);
                  modifiedHtml = html.substring(0, startIndex) + newTagContent + html.substring(tagEndIndex + 1);
                  replaced = true;
                  console.log("é€šè¿‡editorIdæ›¿æ¢æˆåŠŸ");
                }
              }
            }
          } catch (error) {
            console.warn("editorIdåŒ¹é…å¤±è´¥:", error);
          }
        }

        // ç­–ç•¥2: é€šè¿‡IDåŒ¹é…
        if (!replaced && targetElement.id) {
          try {
            const attrName = mediaType === "object" ? "data" : "src";
            const idPattern = `id="${targetElement.id}"`;
            const tagStart = `<${targetElement.tagName}`;

            const startIndex = html.indexOf(tagStart);
            if (startIndex !== -1) {
              const idIndex = html.indexOf(idPattern, startIndex);
              if (idIndex !== -1) {
                const tagEndIndex = html.indexOf(">", idIndex);
                if (tagEndIndex !== -1) {
                  const tagContent = html.substring(startIndex, tagEndIndex + 1);
                  const srcPattern = new RegExp(`\\s*(${attrName})="[^"]*"`, "gi");
                  const newTagContent = tagContent.replace(srcPattern, ` ${attrName}="${escapedNewValue}"`);
                  modifiedHtml = html.substring(0, startIndex) + newTagContent + html.substring(tagEndIndex + 1);
                  replaced = true;
                  console.log("é€šè¿‡IDæ›¿æ¢æˆåŠŸ");
                }
              }
            }
          } catch (error) {
            console.warn("IDåŒ¹é…å¤±è´¥:", error);
          }
        }

        // ç­–ç•¥3: é€šè¿‡srcå±æ€§å€¼åŒ¹é… (ä½¿ç”¨å­—ç¬¦ä¸²æ“ä½œè€Œä¸æ˜¯å¤æ‚æ­£åˆ™)
        if (!replaced && targetElement.src) {
          try {
            const attrName = mediaType === "object" ? "data" : "src";
            const srcToFind = `${attrName}="${targetElement.src}"`;

            const srcIndex = html.indexOf(srcToFind);
            if (srcIndex !== -1) {
              const beforeSrc = html.substring(0, srcIndex);
              const afterSrc = html.substring(srcIndex + srcToFind.length);
              modifiedHtml = beforeSrc + `${attrName}="${escapedNewValue}"` + afterSrc;
              replaced = true;
              console.log("é€šè¿‡srcå±æ€§æ›¿æ¢æˆåŠŸ");
            }
          } catch (error) {
            console.warn("srcå±æ€§åŒ¹é…å¤±è´¥:", error);
          }
        }

        if (replaced) {
          console.log("å…ƒç´ å±æ€§å·²æ›´æ–°");
          return modifiedHtml;
        } else {
          console.error("æ— æ³•æ‰¾åˆ°ç›®æ ‡å…ƒç´ è¿›è¡Œæ›¿æ¢");
          return html;
        }
      } catch (error) {
        console.error("å­—ç¬¦ä¸²æ›¿æ¢å¤±è´¥:", error);
        return html;
      }
    };

    // æ‰§è¡Œæ›¿æ¢
    newHtml = replaceElementInHtml(currentHtml, element, finalSrc);

    if (newHtml !== currentHtml) {
      // ç¡®ä¿htmlContentä¸­ä¹ŸåŒ…å«editorIdï¼Œä¸iframeä¿æŒåŒæ­¥
      const processedHtml = ensureHtmlEditorIds(newHtml);
      htmlContent.value = processedHtml;
      updatePreview(processedHtml);

      // æ·»åŠ åˆ°ç‰ˆæœ¬å†å²
      addToHistory(processedHtml);
      addVersion(processedHtml, "åª’ä½“æ›¿æ¢", {
        source: "å¤šåª’ä½“ç¼–è¾‘",
        mediaType: mediaType,
        oldSrc: element.src || element.href || element.data,
        newSrc: finalSrc,
        fileInfo: fileData
          ? {
              name: fileData.name,
              type: fileData.type,
              size: fileData.size,
            }
          : null,
      });

      showNotification(`${mediaTypeText(mediaType)}å·²æˆåŠŸæ›¿æ¢`, "success");
    } else {
      console.warn("HTMLå†…å®¹æœªå‘ç”Ÿå˜åŒ–");
      showNotification("æœªèƒ½æ‰¾åˆ°è¦æ›¿æ¢çš„å…ƒç´ ", "warning");
    }
  } catch (error) {
    console.error("åª’ä½“æ›´æ–°å¤±è´¥:", error);
    showNotification("åª’ä½“æ›´æ–°å¤±è´¥: " + error.message, "error");
  }
};

// è¾…åŠ©å‡½æ•°ï¼šè·å–åª’ä½“ç±»å‹çš„ä¸­æ–‡åç§°
const mediaTypeText = (type) => {
  const typeMap = {
    img: "å›¾ç‰‡",
    video: "è§†é¢‘",
    audio: "éŸ³é¢‘",
    iframe: "æ¡†æ¶",
    embed: "åµŒå…¥å†…å®¹",
    object: "å¯¹è±¡",
  };
  return typeMap[type] || "åª’ä½“";
};

// ç¡®ä¿HTMLä¸­çš„åª’ä½“å…ƒç´ éƒ½æœ‰editorId (ä½¿ç”¨å­—ç¬¦ä¸²æ›¿æ¢ï¼Œä¸ç ´åscriptæ ‡ç­¾)
const ensureHtmlEditorIds = (htmlContent) => {
  try {
    let modifiedHtml = htmlContent;

    // å®šä¹‰åª’ä½“å…ƒç´ æ ‡ç­¾
    const mediaSelectors = ["img", "video", "audio", "embed", "object", "iframe"];

    mediaSelectors.forEach((selector) => {
      // åŒ¹é…æ²¡æœ‰data-editor-idå±æ€§çš„åª’ä½“å…ƒç´ å¼€æ ‡ç­¾
      const regex = new RegExp(`(<${selector}(?![^>]*data-editor-id)[^>]*?)>`, "gi");

      modifiedHtml = modifiedHtml.replace(regex, (match, tag) => {
        const editorId = "editor-element-" + Date.now() + "-" + Math.random().toString(36).substr(2, 9);
        // åœ¨æ ‡ç­¾æœ«å°¾ï¼ˆ>ä¹‹å‰ï¼‰æ·»åŠ data-editor-idå±æ€§
        return tag + ` data-editor-id="${editorId}">`;
      });
    });

    return modifiedHtml;
  } catch (error) {
    console.error("Failed to ensure editor IDs:", error);
    return htmlContent;
  }
};

// å¤„ç†å¤šåª’ä½“ç¼–è¾‘å…³é—­
const onMediaEditClose = () => {
  console.log("å¤šåª’ä½“ç¼–è¾‘å¯¹è¯æ¡†å…³é—­");
};

// ç‰ˆæœ¬ç®¡ç†çŠ¶æ€å·²ç»é€šè¿‡propsç›´æ¥ä¼ é€’ç»™VersionActionsç»„ä»¶

// ç§»é™¤è‡ªåŠ¨ç›‘å¬å†…å®¹å˜åŒ–ï¼Œæ”¹ä¸ºåœ¨å…·ä½“æ“ä½œä¸­æ‰‹åŠ¨æ·»åŠ ç‰ˆæœ¬
// è¿™æ ·å¯ä»¥é¿å…é‡å¤æ·»åŠ ç‰ˆæœ¬å’Œæ§åˆ¶ç‰ˆæœ¬åˆ›å»ºçš„æ—¶æœº

// é”®ç›˜å¿«æ·é”®å¤„ç†
const handleKeyDown = (event) => {
  if (event.ctrlKey || event.metaKey) {
    if (event.key === "z" && !event.shiftKey) {
      event.preventDefault();
      undo();
    } else if (event.key === "y" || (event.key === "z" && event.shiftKey)) {
      event.preventDefault();
      redo();
    }
  }
};

// åŠ è½½æ–‡ä»¶å†…å®¹
const loadFileContent = async () => {
  if (!currentFileId.value) return;

  try {
    const response = await fileService.getFileById(currentFileId.value);
    if (response && response.content) {
      htmlContent.value = response.content;
      // åˆå§‹åŒ–ç‰ˆæœ¬ç®¡ç†
      initializeVersionManager(response.content, `åŠ è½½æ–‡ä»¶: ${response.filename || "file"}`);
      // åˆå§‹åŒ–ç¼–è¾‘å™¨æ ¸å¿ƒå†å²
      addToHistory(response.content);
    }
  } catch (error) {
    console.error("åŠ è½½æ–‡ä»¶å¤±è´¥:", error);
    showNotification("åŠ è½½æ–‡ä»¶å¤±è´¥", "error");
  }
};

// ä¿å­˜æ–‡ä»¶å†…å®¹
const saveFileContent = async () => {
  const path = route.query.path;
  if (!path) {
    showNotification("æ–‡ä»¶è·¯å¾„ä¸å­˜åœ¨", "error");
    return;
  }

  try {
    await fileService.saveFileByPath(path, htmlContent.value);
    showNotification("æ–‡ä»¶ä¿å­˜æˆåŠŸ", "success");
  } catch (error) {
    console.error("ä¿å­˜æ–‡ä»¶å¤±è´¥:", error);
    showNotification("ä¿å­˜æ–‡ä»¶å¤±è´¥", "error");
  }
};

const loadFileContentByPath = async () => {
  const path = route.query.path;
  try {
    const response = await fileService.getFileByPath(path);
    console.log("response", response);
    const content = response.data;
    if (content) {
      htmlContent.value = content;
      // åˆå§‹åŒ–ç‰ˆæœ¬ç®¡ç†
      initializeVersionManager(content, `åŠ è½½æ–‡ä»¶: ${path}`);
      // åˆå§‹åŒ–ç¼–è¾‘å™¨æ ¸å¿ƒå†å²
      addToHistory(content);
    }
  } catch (error) {
    console.error("åŠ è½½æ–‡ä»¶å¤±è´¥:", error);
    showNotification("åŠ è½½æ–‡ä»¶å¤±è´¥", "error");
  }
};

// ç”Ÿå‘½å‘¨æœŸ
onMounted(() => {
  // ç­‰å¾…DOMæ›´æ–°åå†åˆå§‹åŒ–
  nextTick(async () => {
    // å¦‚æœæœ‰æ–‡ä»¶IDï¼Œå…ˆåŠ è½½æ–‡ä»¶å†…å®¹
    const path = route.query.path;
    if (currentFileId.value) {
      await loadFileContent();
    }
    if (path) {
      await loadFileContentByPath();
    }

    // å…ˆåˆå§‹åŒ–ç¼–è¾‘å™¨
    if (previewAreaRef.value) {
      initializeEditor(previewAreaRef.value, htmlContent.value);
      // è®¾ç½®å†…å®¹å˜åŒ–å›è°ƒ
      setOnContentChangeCallback(onEditorContentChange);
      // è®¾ç½®å†…è”ç¼–è¾‘å›è°ƒ
      setOnInlineEditCallback(onInlineEditRequest);
    }

    // å†åˆå§‹åŒ–ç‰ˆæœ¬ç®¡ç†ï¼ˆç¡®ä¿ç¼–è¾‘å™¨å·²ç»å°±ç»ªï¼‰
    setTimeout(() => {
      if (!currentFileId.value) {
        // åªæœ‰åœ¨æ²¡æœ‰åŠ è½½æ–‡ä»¶æ—¶æ‰åˆå§‹åŒ–é»˜è®¤å†…å®¹
        initializeVersionManager(htmlContent.value, "åˆå§‹å†…å®¹");
      }
      console.log("ç‰ˆæœ¬ç®¡ç†åˆå§‹åŒ–å®Œæˆ", {
        canUndo: versionCanUndo.value,
        canRedo: versionCanRedo.value,
        versionCount: versionCount.value,
      });
    }, 100);

    // æ·»åŠ é”®ç›˜äº‹ä»¶ç›‘å¬
    document.addEventListener("keydown", handleKeyDown);

    // è®¾ç½®æ‹–æ‹½åŠŸèƒ½
    setDragCallbacks({
      onFileProcessed: (result) => {
        if (result.success) {
          htmlContent.value = result.content;
          updatePreview(result.content);

          // åŒæ­¥æ›´æ–°ç¼–è¾‘å™¨æ ¸å¿ƒå†å²è®°å½•
          addToHistory(result.content);

          // é‡ç½®ç‰ˆæœ¬å†å²å¹¶æ·»åŠ æ–°çš„åˆå§‹ç‰ˆæœ¬
          initializeVersionManager(result.content, `æ‹–æ‹½å¯¼å…¥: ${result.filename}`);

          showNotification(`å·²æˆåŠŸå¯¼å…¥æ–‡ä»¶: ${result.filename}`, "success");
        }
      },
      onMultipleFilesProcessed: (results) => {
        const lastFile = results[results.length - 1];
        if (lastFile && lastFile.success) {
          htmlContent.value = lastFile.content;
          updatePreview(lastFile.content);

          // åŒæ­¥æ›´æ–°ç¼–è¾‘å™¨æ ¸å¿ƒå†å²è®°å½•
          addToHistory(lastFile.content);

          // é‡ç½®ç‰ˆæœ¬å†å²å¹¶æ·»åŠ æ–°çš„åˆå§‹ç‰ˆæœ¬
          initializeVersionManager(lastFile.content, `æ‰¹é‡æ‹–æ‹½å¯¼å…¥: ${lastFile.filename} (${results.length}ä¸ªæ–‡ä»¶)`);

          showNotification(`å·²æˆåŠŸå¯¼å…¥ ${results.length} ä¸ªæ–‡ä»¶ï¼Œå½“å‰æ˜¾ç¤º: ${lastFile.filename}`, "success");
        }
      },
    });

    // åˆå§‹åŒ–æ‹–æ‹½åˆ°æ•´ä¸ªç¼–è¾‘å™¨åŒºåŸŸ
    initDragDrop(document.body);
  });
});

// ç»„ä»¶å¸è½½æ—¶ç§»é™¤äº‹ä»¶ç›‘å¬
onUnmounted(() => {
  document.removeEventListener("keydown", handleKeyDown);
});
</script>

<style lang="scss" scoped>
.h-screen {
  height: 100vh;
}

.upload-area-wrapper {
  padding: 16px;
  background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
  border-bottom: 1px solid #e2e8f0;
  animation: slideDown 0.3s ease;
}

@keyframes slideDown {
  from {
    opacity: 0;
    transform: translateY(-20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

// ç¡®ä¿é¢„è§ˆåŒºåŸŸåœ¨æœ‰ä¸Šä¼ åŒºåŸŸæ—¶èƒ½æ­£ç¡®æ˜¾ç¤º
.flex-1 {
  min-height: 0;
}

// å³ä¾§é¢æ¿æ ·å¼
.right-panels {
  display: flex;
  flex-direction: column;
  width: 400px;
  border-left: 1px solid #e5e7eb;
  background: #fafafa;
}

.code-panel {
  flex: 1;
  min-height: 0;
  border-bottom: 1px solid #e5e7eb;
}

.version-panel {
  height: 350px;
  min-height: 300px;
}

// å“åº”å¼è®¾è®¡
@media (max-width: 1024px) {
  .right-panels {
    width: 350px;
  }
}

@media (max-width: 768px) {
  .right-panels {
    width: 100%;
    position: fixed;
    top: 60px;
    right: 0;
    bottom: 0;
    z-index: 1000;
    box-shadow: -4px 0 12px rgba(0, 0, 0, 0.1);
  }
}
</style>



================================================
FILE: frontend/src/view/editor/components/AIEditDialog.vue
================================================
<template>
  <a-modal v-model:open="visible" width="700px" :footer="null" @cancel="handleCancel" class="ai-edit-modal">
    <template #title>
      <div class="flex items-center">
        <div class="w-8 h-8 bg-gradient-to-r from-purple-500 to-blue-500 rounded-lg flex items-center justify-center mr-3">
          <i class="fas fa-magic text-white"></i>
        </div>
        <span class="text-lg font-semibold">AI æ™ºèƒ½ç¼–è¾‘</span>
      </div>
    </template>
    <div class="space-y-4">
      <div v-if="selectedElement">
        <h4 class="font-medium text-gray-800 mb-2">å½“å‰é€‰ä¸­å…ƒç´ :</h4>
        <div class="bg-gray-100 p-3 rounded text-sm font-mono whitespace-pre-line">
          {{ elementInfoText }}
        </div>
      </div>

      <!-- æ¨¡æ¿é€‰æ‹© -->
      <div>
        <div class="flex items-center justify-between mb-2">
          <label class="block text-sm font-medium text-gray-700"> AI ç¼–è¾‘æ¨¡æ¿: </label>
          <a-button type="link" size="small" @click="showPromptPreview = !showPromptPreview">
            <template #icon>
              <i :class="showPromptPreview ? 'fas fa-eye-slash' : 'fas fa-eye'"></i>
            </template>
            {{ showPromptPreview ? "éšè—" : "æ˜¾ç¤º" }}æç¤ºè¯
          </a-button>
        </div>
        <a-select v-model:value="selectedTemplate" class="w-full" placeholder="é€‰æ‹©ç¼–è¾‘æ¨¡æ¿ç±»å‹">
          <a-select-option v-for="option in templateOptions" :key="option.value" :value="option.value">
            <div class="flex items-center justify-between w-full">
              <div>
                <span class="font-medium">{{ option.label }}</span>
                <span class="ml-2 text-xs text-gray-500 capitalize">[{{ option.category }}]</span>
              </div>
              <i v-if="selectedTemplate === option.value && prompt.trim() && detectTemplateType(prompt) === option.value" class="fas fa-magic text-purple-500 text-xs" title="æ™ºèƒ½æ¨è"></i>
            </div>
          </a-select-option>
        </a-select>
      </div>

      <div>
        <label class="block text-sm font-medium text-gray-700 mb-2"> è¯·æè¿°æ‚¨æƒ³è¦çš„ä¿®æ”¹: </label>
        <a-textarea v-model:value="prompt" :rows="3" placeholder="ä¾‹å¦‚ï¼šå°†è¿™ä¸ªæ ‡é¢˜æ”¹ä¸ºçº¢è‰²ï¼Œå¢å¤§å­—ä½“..." class="w-full" />
        <div class="mt-1 text-xs text-gray-500 flex items-center gap-1">
          <i class="fas fa-lightbulb"></i>
          ç³»ç»Ÿå°†æ ¹æ®æ‚¨çš„è¾“å…¥è‡ªåŠ¨é€‰æ‹©æœ€åˆé€‚çš„æ¨¡æ¿
          <span v-if="prompt.trim() && detectTemplateType(prompt) !== 'basic'" class="ml-2 px-2 py-0.5 bg-purple-100 text-purple-700 rounded text-xs">
            æ¨è: {{ promptTemplates[detectTemplateType(prompt)]?.name }}
          </span>
        </div>
      </div>

      <!-- å®æ—¶æç¤ºè¯é¢„è§ˆ -->
      <div v-if="showPromptPreview && fullPrompt" class="space-y-2">
        <div class="flex items-center justify-between">
          <h4 class="font-medium text-gray-800">å®Œæ•´ AI æç¤ºè¯:</h4>
          <a-button type="text" size="small" @click="copyPrompt">
            <template #icon>
              <i class="fas fa-copy"></i>
            </template>
            å¤åˆ¶
          </a-button>
        </div>
        <div class="bg-slate-50 p-4 rounded-lg border max-h-60 overflow-y-auto">
          <pre class="text-xs text-gray-700 whitespace-pre-wrap font-mono">{{ fullPrompt }}</pre>
        </div>
      </div>

      <div v-if="isProcessing" class="flex items-center justify-center py-4">
        <a-spin size="small" />
        <span class="ml-2 text-gray-600">AI æ­£åœ¨åˆ†ææ‚¨çš„éœ€æ±‚...</span>
      </div>

      <div v-if="previewResult" class="space-y-3">
        <div class="flex items-center justify-between">
          <h4 class="font-medium text-gray-800">AI é¢„è§ˆç»“æœ:</h4>
          <div class="flex items-center gap-2">
            <span class="text-xs px-2 py-1 rounded-full font-medium" :class="previewResult.action === 'replace' ? 'bg-green-100 text-green-800' : 'bg-orange-100 text-orange-800'">
              {{ previewResult.action === "replace" ? "éƒ¨åˆ†æ›¿æ¢" : "æ•´ä½“é‡å†™" }}
            </span>
            <span class="text-xs px-2 py-1 bg-purple-100 text-purple-800 rounded-full">
              {{ promptTemplates[previewResult.templateType]?.name || "åŸºç¡€ç¼–è¾‘" }}
            </span>
          </div>
        </div>

        <div class="bg-blue-50 p-4 rounded-lg">
          <div class="mb-3">
            <h5 class="text-sm font-medium text-blue-900 mb-1">ä¿®æ”¹è¯´æ˜:</h5>
            <p class="text-sm text-blue-800">{{ previewResult.description }}</p>
          </div>

          <div class="mb-3">
            <div class="flex items-center justify-between mb-2">
              <h5 class="text-sm font-medium text-blue-900">ç”Ÿæˆçš„ä»£ç :</h5>
              <div class="flex items-center gap-2">
                <span class="text-xs text-blue-600">
                  {{ previewResult.action === "replace" ? "ä»…æ›¿æ¢å½“å‰å…ƒç´ " : "å®Œæ•´HTMLæ–‡æ¡£" }}
                </span>
                <a-button type="text" size="small" @click="copyCode">
                  <template #icon>
                    <i class="fas fa-copy"></i>
                  </template>
                  å¤åˆ¶ä»£ç 
                </a-button>
              </div>
            </div>
            <div class="bg-white p-3 rounded border font-mono text-xs max-h-40 overflow-y-auto">
              <pre class="whitespace-pre-wrap">{{ previewResult.code }}</pre>
            </div>
          </div>

          <div class="grid grid-cols-1 md:grid-cols-2 gap-2 text-xs">
            <details>
              <summary class="cursor-pointer text-blue-700 hover:text-blue-900 font-medium"><i class="fas fa-eye mr-1"></i>æŸ¥çœ‹AIæç¤ºè¯</summary>
              <div class="mt-2 p-2 bg-gray-50 rounded text-gray-600 whitespace-pre-wrap max-h-32 overflow-y-auto">
                {{ previewResult.usedPrompt }}
              </div>
            </details>

            <details v-if="previewResult.xmlResponse">
              <summary class="cursor-pointer text-blue-700 hover:text-blue-900 font-medium"><i class="fas fa-code mr-1"></i>æŸ¥çœ‹XMLå“åº”</summary>
              <div class="mt-2 p-2 bg-gray-50 rounded text-gray-600 font-mono text-xs whitespace-pre-wrap max-h-32 overflow-y-auto">
                {{ previewResult.xmlResponse }}
              </div>
            </details>
          </div>
        </div>
      </div>

      <div class="flex justify-end space-x-2 pt-4 border-t">
        <a-button @click="handleCancel">å–æ¶ˆ</a-button>
        <a-button type="primary" @click="handleGenerate" :disabled="!prompt.trim()" :loading="isProcessing"> ç”Ÿæˆé¢„è§ˆ </a-button>
        <a-button v-if="previewResult" type="primary" @click="handleApply" class="bg-green-500 border-green-500 hover:bg-green-600"> åº”ç”¨ä¿®æ”¹ </a-button>
      </div>
    </div>
  </a-modal>
</template>

<script setup>
import { ref, computed, watch } from "vue";
import { message } from "ant-design-vue";
import { useAIPrompts } from "../composables/useAIPrompts";

const emit = defineEmits(["apply-edit"]);

const visible = ref(false);
const selectedElement = ref(null);
const prompt = ref("");
const isProcessing = ref(false);
const previewResult = ref(null);
const selectedTemplate = ref("basic");
const showPromptPreview = ref(false);
const fullPageHTML = ref("");

// ä½¿ç”¨ AI æç¤ºè¯ composable
const { promptTemplates, detectTemplateType, generatePrompt, getTemplateSuggestions, formatElementInfo, getTemplateCategories, parseAIResponse, generateSampleResponse, detectComplexity } =
  useAIPrompts();

// æ¨¡æ¿é€‰é¡¹
const templateOptions = computed(() => {
  return Object.entries(promptTemplates).map(([key, template]) => ({
    value: key,
    label: template.name,
    category: template.category,
  }));
});

// å®æ—¶ç”Ÿæˆçš„å®Œæ•´æç¤ºè¯
const fullPrompt = computed(() => {
  if (!selectedElement.value || !prompt.value.trim()) {
    return "";
  }

  return generatePrompt(selectedTemplate.value, selectedElement.value, prompt.value, fullPageHTML.value);
});

// ç›‘å¬ç”¨æˆ·è¾“å…¥ï¼Œè‡ªåŠ¨æ£€æµ‹æ¨¡æ¿ç±»å‹
watch(
  prompt,
  (newPrompt) => {
    if (newPrompt.trim()) {
      const detectedType = detectTemplateType(newPrompt);
      if (detectedType !== selectedTemplate.value) {
        selectedTemplate.value = detectedType;
      }
    }
  },
  { debounce: 300 }
);

// æ ¼å¼åŒ–çš„å…ƒç´ ä¿¡æ¯
const elementInfoText = computed(() => {
  return formatElementInfo(selectedElement.value);
});

const show = (element, pageHTML = "") => {
  selectedElement.value = element;
  fullPageHTML.value = pageHTML;
  visible.value = true;
  prompt.value = "";
  previewResult.value = null;
  selectedTemplate.value = "basic";
  showPromptPreview.value = false;
};

const handleCancel = () => {
  visible.value = false;
  selectedElement.value = null;
  fullPageHTML.value = "";
  prompt.value = "";
  previewResult.value = null;
  selectedTemplate.value = "basic";
  showPromptPreview.value = false;
};

// å¤åˆ¶æç¤ºè¯åˆ°å‰ªè´´æ¿
const copyPrompt = async () => {
  if (!fullPrompt.value) return;

  try {
    await navigator.clipboard.writeText(fullPrompt.value);
    message.success("æç¤ºè¯å·²å¤åˆ¶åˆ°å‰ªè´´æ¿");
  } catch (error) {
    message.error("å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨é€‰æ‹©å¤åˆ¶");
  }
};

// å¤åˆ¶ç”Ÿæˆçš„ä»£ç åˆ°å‰ªè´´æ¿
const copyCode = async () => {
  if (!previewResult.value?.code) return;

  try {
    await navigator.clipboard.writeText(previewResult.value.code);
    message.success("ä»£ç å·²å¤åˆ¶åˆ°å‰ªè´´æ¿");
  } catch (error) {
    message.error("å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨é€‰æ‹©å¤åˆ¶");
  }
};

const getElementInfo = (element) => {
  if (!element) return "";
  const tagName = element.tagName.toLowerCase();
  const className = element.className ? ` class="${element.className}"` : "";
  const id = element.id ? ` id="${element.id}"` : "";
  return `<${tagName}${id}${className}>`;
};

const handleGenerate = async () => {
  if (!prompt.value.trim() || !selectedElement.value) return;

  isProcessing.value = true;

  try {
    // ç”Ÿæˆå®Œæ•´çš„æç¤ºè¯
    const aiPrompt = fullPrompt.value;

    // æ¨¡æ‹Ÿå‘é€åˆ° AI API
    console.log("å‘é€åˆ° AI çš„æç¤ºè¯:", aiPrompt);

    // æ¨¡æ‹Ÿ AI å¤„ç†æ—¶é—´
    await new Promise((resolve) => setTimeout(resolve, 1500));

    // ç”Ÿæˆæ¨¡æ‹Ÿçš„XMLå“åº”
    const xmlResponse = generateSampleResponse(prompt.value, selectedTemplate.value, selectedElement.value, fullPageHTML.value);
    console.log("AIè¿”å›çš„XMLå“åº”:", xmlResponse);

    // è§£æXMLå“åº”
    const parsedResponse = parseAIResponse(xmlResponse);

    if (!parsedResponse.isValid) {
      message.error("AIå“åº”æ ¼å¼é”™è¯¯: " + parsedResponse.error);
      return;
    }

    // æ„å»ºé¢„è§ˆç»“æœ
    previewResult.value = {
      action: parsedResponse.action,
      description: parsedResponse.description,
      code: parsedResponse.code,
      usedPrompt: aiPrompt,
      templateType: selectedTemplate.value,
      xmlResponse: xmlResponse,
      isValid: parsedResponse.isValid,
    };
  } catch (error) {
    message.error("AI å¤„ç†å¤±è´¥ï¼Œè¯·é‡è¯•");
    console.error("AIå¤„ç†é”™è¯¯:", error);
  } finally {
    isProcessing.value = false;
  }
};

const simulateAIResponse = (promptText, element) => {
  const lowerPrompt = promptText.toLowerCase();

  if (lowerPrompt.includes("çº¢è‰²") || lowerPrompt.includes("é¢œè‰²")) {
    return {
      type: "style",
      property: "color",
      value: "text-red-500",
      description: "å°†æ–‡å­—é¢œè‰²æ”¹ä¸ºçº¢è‰²",
      code: "element.className = element.className.replace(/text-\\w+-\\d+/g, '') + ' text-red-500'",
    };
  } else if (lowerPrompt.includes("è“è‰²")) {
    return {
      type: "style",
      property: "color",
      value: "text-blue-500",
      description: "å°†æ–‡å­—é¢œè‰²æ”¹ä¸ºè“è‰²",
      code: "element.className = element.className.replace(/text-\\w+-\\d+/g, '') + ' text-blue-500'",
    };
  } else if (lowerPrompt.includes("å¤§") || lowerPrompt.includes("æ ‡é¢˜")) {
    return {
      type: "style",
      property: "size",
      value: "text-2xl font-bold",
      description: "å¢å¤§å­—ä½“å¹¶åŠ ç²—",
      code: "element.className = element.className.replace(/text-\\w+/g, '').replace(/font-\\w+/g, '') + ' text-2xl font-bold'",
    };
  } else {
    return {
      type: "content",
      description: "ä¿®æ”¹å…ƒç´ å†…å®¹",
      code: `element.textContent = "${promptText}"`,
    };
  }
};

const handleApply = () => {
  if (!previewResult.value || !selectedElement.value) return;

  try {
    // åº”ç”¨ä¿®æ”¹
    if (previewResult.value.type === "style") {
      if (previewResult.value.property === "color") {
        // ç§»é™¤ç°æœ‰é¢œè‰²ç±»å¹¶æ·»åŠ æ–°çš„
        selectedElement.value.className = selectedElement.value.className.replace(/text-\w+-\d+/g, "").trim() + " " + previewResult.value.value;
      } else if (previewResult.value.property === "size") {
        selectedElement.value.className =
          selectedElement.value.className
            .replace(/text-\w+/g, "")
            .replace(/font-\w+/g, "")
            .trim() +
          " " +
          previewResult.value.value;
      }
    } else if (previewResult.value.type === "content") {
      selectedElement.value.textContent = prompt.value;
    }

    emit("apply-edit", previewResult.value);
    message.success("ä¿®æ”¹å·²åº”ç”¨");
    handleCancel();
  } catch (error) {
    message.error("åº”ç”¨ä¿®æ”¹å¤±è´¥");
  }
};

defineExpose({
  show,
});
</script>

<style lang="scss" scoped>
:deep(.ai-edit-modal) {
  .ant-modal-content {
    border-radius: 12px;
    overflow: hidden;
  }

  .ant-modal-header {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    border-bottom: none;
    padding: 20px 24px;

    .ant-modal-title {
      color: white;
      margin: 0;
    }
  }

  .ant-modal-close {
    color: white;

    &:hover {
      color: rgba(255, 255, 255, 0.8);
    }
  }

  .ant-modal-body {
    padding: 24px;
  }
}

:deep(.ant-input) {
  border-radius: 8px;
  border-color: #e1e5e9;
  transition: all 0.3s ease;

  &:focus {
    border-color: #667eea;
    box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.1);
  }
}

:deep(.ant-btn) {
  border-radius: 6px;
  font-weight: 500;
  transition: all 0.3s ease;

  &:hover {
    transform: translateY(-1px);
  }
}
</style>



================================================
FILE: frontend/src/view/editor/components/CodePanel.vue
================================================
<template>
  <div class="code-panel-container">
    <div class="code-panel-header">
      <h3 class="code-panel-title">
        <i class="fas fa-code mr-2"></i>
        HTML ä»£ç 
      </h3>
      <p class="code-panel-subtitle">åœ¨æ­¤ç¼–è¾‘ä»£ç å°†å®æ—¶åŒæ­¥åˆ°é¢„è§ˆåŒºåŸŸ</p>
    </div>
    <div class="code-panel-content">
      <a-textarea ref="codeEditorRef" v-model:value="currentContent" @input="handleInput" class="code-editor" placeholder="HTML ä»£ç å°†æ˜¾ç¤ºåœ¨è¿™é‡Œ..." :autoSize="false" />
    </div>
  </div>
</template>

<script setup>
import { ref, watch } from "vue";

const props = defineProps({
  htmlContent: {
    type: String,
    default: "",
  },
});

const emit = defineEmits(["sync-from-code"]);

const codeEditorRef = ref(null);

const currentContent = ref("");

// åˆå§‹åŒ–å†…å®¹
currentContent.value = props.htmlContent;

const handleInput = (e) => {
  const newValue = e.target.value;
  currentContent.value = newValue;
  console.log("ä»£ç é¢æ¿è¾“å…¥å˜åŒ–:", newValue?.substring(0, 100) + "...");
  emit("sync-from-code", newValue);
};

// ç›‘å¬ htmlContent å˜åŒ–ï¼ŒåŒæ­¥åˆ°æœ¬åœ°çŠ¶æ€
watch(
  () => props.htmlContent,
  (newContent) => {
    if (newContent !== currentContent.value) {
      currentContent.value = newContent;
    }
  },
  { immediate: true }
);
</script>

<style lang="scss" scoped>
.code-panel-container {
  display: flex;
  flex-direction: column;
  height: 100%;
  width: 400px;
  background: white;
  border-left: 1px solid #e5e7eb;
}

.code-panel-header {
  flex-shrink: 0;
  padding: 16px;
  border-bottom: 1px solid #e5e7eb;
  background: #f8fafc;
}

.code-panel-title {
  display: flex;
  align-items: center;
  font-weight: 500;
  font-size: 14px;
  color: #1f2937;
  margin: 0;
}

.code-panel-subtitle {
  font-size: 12px;
  color: #6b7280;
  margin: 4px 0 0 0;
}

.code-panel-content {
  flex: 1;
  display: flex;
  flex-direction: column;
  padding: 16px;
  min-height: 0; // é‡è¦ï¼šå…è®¸flexå­å…ƒç´ æ”¶ç¼©
}

.code-editor {
  flex: 1;
  font-family: "SF Mono", "Monaco", "Menlo", "Consolas", "Ubuntu Mono", monospace;
  font-size: 13px;
  line-height: 1.6;
  border: 1px solid #d1d5db;
  border-radius: 8px;
  background: #fafafa;
  padding: 12px;
  resize: none;
  word-wrap: break-word;
  white-space: pre-wrap;

  // ç¡®ä¿textareaå¯ä»¥æ»šåŠ¨
  overflow-y: auto;
  overflow-x: auto;

  &:focus {
    border-color: #3b82f6;
    outline: none;
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
    background: white;
  }

  &::placeholder {
    color: #9ca3af;
    font-style: italic;
  }

  // è‡ªå®šä¹‰æ»šåŠ¨æ¡
  &::-webkit-scrollbar {
    width: 8px;
    height: 8px;
  }

  &::-webkit-scrollbar-track {
    background: #f1f5f9;
    border-radius: 4px;
  }

  &::-webkit-scrollbar-thumb {
    background: #cbd5e1;
    border-radius: 4px;

    &:hover {
      background: #94a3b8;
    }
  }
}

// è¦†ç›–Ant Designçš„æ ·å¼
:deep(.ant-input) {
  font-family: "SF Mono", "Monaco", "Menlo", "Consolas", "Ubuntu Mono", monospace !important;
  font-size: 13px !important;
  line-height: 1.6 !important;
  height: 100% !important;
  border: 1px solid #d1d5db !important;
  border-radius: 8px !important;
  background: #fafafa !important;

  &:focus {
    border-color: #3b82f6 !important;
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1) !important;
    background: white !important;
  }
}

.fas {
  font-size: 14px;
  color: #3b82f6;
}
</style>



================================================
FILE: frontend/src/view/editor/components/FileUploadArea.vue
================================================
<template>
  <div 
    class="upload-area-container"
    :class="{ 'upload-active': isUploading, 'drag-over': isDragOver }"
    @drop="handleDrop"
    @dragover.prevent="handleDragOver"
    @dragenter.prevent="handleDragEnter"
    @dragleave.prevent="handleDragLeave"
    @click="triggerFileInput"
  >
    <!-- èƒŒæ™¯è£…é¥° -->
    <div class="upload-background">
      <div class="upload-pattern"></div>
    </div>
    
    <!-- ä¸Šä¼ åŒºåŸŸå†…å®¹ -->
    <div class="upload-content" v-if="!isUploading">
      <div class="upload-icon">
        <i class="fas fa-cloud-upload-alt"></i>
      </div>
      <h3 class="upload-title">æ‹–æ‹½æ–‡ä»¶åˆ°æ­¤å¤„ä¸Šä¼ </h3>
      <p class="upload-subtitle">æˆ–è€…ç‚¹å‡»é€‰æ‹©æ–‡ä»¶</p>
      <div class="upload-types">
        æ”¯æŒ HTMLã€TXTã€MD æ ¼å¼
      </div>
      <div class="upload-hint">
        <i class="fas fa-info-circle"></i>
        æ‚¨ä¹Ÿå¯ä»¥ä½¿ç”¨ Ctrl+V ç²˜è´´æ–‡ä»¶æˆ–æ–‡æœ¬å†…å®¹
      </div>
    </div>
    
    <!-- ä¸Šä¼ è¿›åº¦ -->
    <div class="upload-progress" v-if="isUploading">
      <div class="progress-spinner">
        <i class="fas fa-spinner fa-spin"></i>
      </div>
      <h3 class="progress-title">æ­£åœ¨å¤„ç†æ–‡ä»¶...</h3>
      <div class="progress-bar">
        <div class="progress-fill" :style="{ width: progress + '%' }"></div>
      </div>
      <p class="progress-text">{{ progressText }}</p>
    </div>
    
    <!-- éšè—çš„æ–‡ä»¶è¾“å…¥ -->
    <input 
      ref="fileInputRef"
      type="file"
      accept=".html,.htm,.txt,.md"
      multiple
      style="display: none"
      @change="handleFileSelect"
    />
  </div>
</template>

<script setup>
import { ref, onMounted, onUnmounted } from 'vue'
import { message } from 'ant-design-vue'

const emit = defineEmits(['file-uploaded', 'files-uploaded'])

const isDragOver = ref(false)
const isUploading = ref(false)
const progress = ref(0)
const progressText = ref('')
const fileInputRef = ref(null)
const dragCounter = ref(0)

// å¤„ç†æ‹–æ‹½è¿›å…¥
const handleDragEnter = (e) => {
  e.preventDefault()
  dragCounter.value++
  if (dragCounter.value === 1) {
    isDragOver.value = true
  }
}

// å¤„ç†æ‹–æ‹½ç¦»å¼€
const handleDragLeave = (e) => {
  e.preventDefault()
  dragCounter.value--
  if (dragCounter.value === 0) {
    isDragOver.value = false
  }
}

// å¤„ç†æ‹–æ‹½æ‚¬åœ
const handleDragOver = (e) => {
  e.preventDefault()
}

// å¤„ç†æ–‡ä»¶æ‹–æ”¾
const handleDrop = (e) => {
  e.preventDefault()
  isDragOver.value = false
  dragCounter.value = 0
  
  const files = Array.from(e.dataTransfer.files)
  if (files.length > 0) {
    processFiles(files)
  }
}

// è§¦å‘æ–‡ä»¶é€‰æ‹©
const triggerFileInput = () => {
  if (!isUploading.value) {
    fileInputRef.value?.click()
  }
}

// å¤„ç†æ–‡ä»¶é€‰æ‹©
const handleFileSelect = (e) => {
  const files = Array.from(e.target.files)
  if (files.length > 0) {
    processFiles(files)
  }
  // æ¸…ç©ºinputå€¼ï¼Œå…è®¸é‡å¤é€‰æ‹©åŒä¸€æ–‡ä»¶
  e.target.value = ''
}

// å¤„ç†ç²˜è´´äº‹ä»¶
const handlePaste = (e) => {
  const clipboardData = e.clipboardData || window.clipboardData
  
  // æ£€æŸ¥æ˜¯å¦æœ‰æ–‡ä»¶
  const files = Array.from(clipboardData.files)
  if (files.length > 0) {
    e.preventDefault()
    processFiles(files)
    return
  }
  
  // æ£€æŸ¥æ˜¯å¦æœ‰æ–‡æœ¬å†…å®¹
  const text = clipboardData.getData('text/plain')
  const html = clipboardData.getData('text/html')
  
  if (html && html.trim()) {
    e.preventDefault()
    processTextContent(html, 'HTML')
  } else if (text && text.trim()) {
    e.preventDefault()
    processTextContent(text, 'TEXT')
  }
}

// å¤„ç†æ–‡ä»¶
const processFiles = async (files) => {
  if (isUploading.value) return
  
  isUploading.value = true
  progress.value = 0
  
  try {
    const validFiles = files.filter(file => {
      const extension = file.name.toLowerCase().split('.').pop()
      return ['html', 'htm', 'txt', 'md'].includes(extension)
    })
    
    if (validFiles.length === 0) {
      message.error('è¯·é€‰æ‹© HTMLã€TXT æˆ– MD æ ¼å¼çš„æ–‡ä»¶')
      return
    }
    
    if (validFiles.length !== files.length) {
      message.warning(`å·²è¿‡æ»¤ ${files.length - validFiles.length} ä¸ªä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼`)
    }
    
    const results = []
    
    for (let i = 0; i < validFiles.length; i++) {
      const file = validFiles[i]
      progressText.value = `æ­£åœ¨å¤„ç†: ${file.name}`
      progress.value = Math.round((i / validFiles.length) * 80)
      
      // æ¨¡æ‹Ÿå¤„ç†æ—¶é—´
      await new Promise(resolve => setTimeout(resolve, 300))
      
      try {
        const content = await readFileContent(file)
        const result = {
          success: true,
          filename: file.name,
          content: content,
          size: file.size,
          type: file.type || 'text/plain'
        }
        results.push(result)
      } catch (error) {
        results.push({
          success: false,
          filename: file.name,
          error: error.message
        })
      }
    }
    
    progress.value = 100
    progressText.value = 'å¤„ç†å®Œæˆ'
    
    // å»¶è¿Ÿä¸€ä¸‹æ˜¾ç¤ºå®ŒæˆçŠ¶æ€
    await new Promise(resolve => setTimeout(resolve, 500))
    
    if (results.length === 1) {
      emit('file-uploaded', results[0])
    } else {
      emit('files-uploaded', results)
    }
    
  } catch (error) {
    message.error(`æ–‡ä»¶å¤„ç†å¤±è´¥: ${error.message}`)
  } finally {
    isUploading.value = false
    progress.value = 0
    progressText.value = ''
  }
}

// å¤„ç†æ–‡æœ¬å†…å®¹
const processTextContent = async (content, type) => {
  if (isUploading.value) return
  
  isUploading.value = true
  progress.value = 0
  progressText.value = `æ­£åœ¨å¤„ç†ç²˜è´´çš„${type}å†…å®¹`
  
  try {
    // æ¨¡æ‹Ÿå¤„ç†
    for (let i = 0; i <= 100; i += 20) {
      progress.value = i
      await new Promise(resolve => setTimeout(resolve, 100))
    }
    
    const result = {
      success: true,
      filename: `ç²˜è´´å†…å®¹.${type.toLowerCase() === 'html' ? 'html' : 'txt'}`,
      content: content,
      size: new Blob([content]).size,
      type: type.toLowerCase() === 'html' ? 'text/html' : 'text/plain'
    }
    
    progressText.value = 'å¤„ç†å®Œæˆ'
    await new Promise(resolve => setTimeout(resolve, 300))
    
    emit('file-uploaded', result)
    
  } catch (error) {
    message.error(`å†…å®¹å¤„ç†å¤±è´¥: ${error.message}`)
  } finally {
    isUploading.value = false
    progress.value = 0
    progressText.value = ''
  }
}

// è¯»å–æ–‡ä»¶å†…å®¹
const readFileContent = (file) => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader()
    reader.onload = (e) => {
      resolve(e.target.result)
    }
    reader.onerror = (e) => {
      reject(new Error('æ–‡ä»¶è¯»å–å¤±è´¥'))
    }
    reader.readAsText(file, 'UTF-8')
  })
}

// æ·»åŠ å…¨å±€ç²˜è´´ç›‘å¬
onMounted(() => {
  document.addEventListener('paste', handlePaste)
})

onUnmounted(() => {
  document.removeEventListener('paste', handlePaste)
})
</script>

<style lang="scss" scoped>
.upload-area-container {
  position: relative;
  width: 100%;
  height: 300px;
  border: 2px dashed #d1d5db;
  border-radius: 12px;
  background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
  cursor: pointer;
  transition: all 0.3s ease;
  overflow: hidden;
  
  &:hover {
    border-color: #3b82f6;
    background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%);
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(59, 130, 246, 0.15);
  }
  
  &.drag-over {
    border-color: #10b981;
    background: linear-gradient(135deg, #ecfdf5 0%, #d1fae5 100%);
    transform: scale(1.02);
    box-shadow: 0 12px 35px rgba(16, 185, 129, 0.2);
    
    .upload-icon i {
      color: #10b981;
      animation: bounce 0.6s ease infinite alternate;
    }
    
    .upload-title {
      color: #065f46;
    }
  }
  
  &.upload-active {
    border-color: #f59e0b;
    background: linear-gradient(135deg, #fffbeb 0%, #fef3c7 100%);
    cursor: wait;
  }
}

.upload-background {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  opacity: 0.1;
  
  .upload-pattern {
    width: 100%;
    height: 100%;
    background-image: 
      radial-gradient(circle at 25px 25px, #3b82f6 2px, transparent 2px),
      radial-gradient(circle at 75px 75px, #8b5cf6 2px, transparent 2px);
    background-size: 100px 100px;
    animation: patternMove 20s linear infinite;
  }
}

.upload-content {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  text-align: center;
  padding: 24px;
  z-index: 1;
  position: relative;
}

.upload-icon {
  margin-bottom: 16px;
  
  i {
    font-size: 48px;
    color: #6b7280;
    transition: all 0.3s ease;
  }
}

.upload-title {
  font-size: 20px;
  font-weight: 600;
  color: #374151;
  margin-bottom: 8px;
  transition: color 0.3s ease;
}

.upload-subtitle {
  font-size: 14px;
  color: #6b7280;
  margin-bottom: 16px;
}

.upload-types {
  display: inline-block;
  background: rgba(59, 130, 246, 0.1);
  color: #1e40af;
  padding: 6px 12px;
  border-radius: 20px;
  font-size: 12px;
  font-weight: 500;
  margin-bottom: 16px;
}

.upload-hint {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 12px;
  color: #9ca3af;
  background: rgba(156, 163, 175, 0.1);
  padding: 8px 12px;
  border-radius: 6px;
  
  i {
    color: #6b7280;
  }
}

.upload-progress {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  text-align: center;
  padding: 24px;
  z-index: 1;
  position: relative;
}

.progress-spinner {
  margin-bottom: 16px;
  
  i {
    font-size: 36px;
    color: #f59e0b;
  }
}

.progress-title {
  font-size: 18px;
  font-weight: 600;
  color: #374151;
  margin-bottom: 16px;
}

.progress-bar {
  width: 200px;
  height: 8px;
  background: #e5e7eb;
  border-radius: 4px;
  overflow: hidden;
  margin-bottom: 12px;
}

.progress-fill {
  height: 100%;
  background: linear-gradient(90deg, #f59e0b 0%, #d97706 100%);
  border-radius: 4px;
  transition: width 0.3s ease;
  position: relative;
  
  &::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    bottom: 0;
    right: 0;
    background: linear-gradient(
      90deg,
      transparent,
      rgba(255, 255, 255, 0.6),
      transparent
    );
    animation: shimmer 1.5s infinite;
  }
}

.progress-text {
  font-size: 12px;
  color: #6b7280;
}

@keyframes bounce {
  0% {
    transform: translateY(0);
  }
  100% {
    transform: translateY(-10px);
  }
}

@keyframes patternMove {
  0% {
    background-position: 0 0, 50px 50px;
  }
  100% {
    background-position: 100px 100px, 150px 150px;
  }
}

@keyframes shimmer {
  0% {
    transform: translateX(-100%);
  }
  100% {
    transform: translateX(100%);
  }
}

// å“åº”å¼è®¾è®¡
@media (max-width: 640px) {
  .upload-area-container {
    height: 250px;
  }
  
  .upload-icon i {
    font-size: 36px;
  }
  
  .upload-title {
    font-size: 18px;
  }
  
  .progress-bar {
    width: 160px;
  }
}
</style>


================================================
FILE: frontend/src/view/editor/components/InlineEditModal.vue
================================================
<template>
  <!-- ç›´æ¥å†…è”ç¼–è¾‘ï¼Œæ— æ¨¡æ€æ¡† -->
  <div class="inline-edit-overlay" v-if="visible" @click.self="handleCancel">
    <!-- ç¼–è¾‘å·¥å…·æ  -->
    <div class="edit-toolbar" :style="toolbarStyle">
      <div class="toolbar-content">
        <div class="element-info">
          <a-tag :color="getTagColor(elementInfo.tagName)" size="small">{{ elementInfo.tagName?.toUpperCase() }}</a-tag>
        </div>
        <div class="toolbar-actions">
          <a-space size="small">
            <a-button size="small" type="text" @click="handleSave" :loading="saving" title="ä¿å­˜ (Enter)">
              <template #icon><i class="fas fa-check text-green-500"></i></template>
            </a-button>
            <a-button size="small" type="text" @click="handleCancel" title="å–æ¶ˆ (Esc)">
              <template #icon><i class="fas fa-times text-red-500"></i></template>
            </a-button>
          </a-space>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, nextTick, watch, onMounted, onUnmounted } from "vue";

const visible = ref(false);
const elementInfo = ref({});
const saving = ref(false);
const toolbarStyle = ref({});
const currentEditingElement = ref(null);

const emit = defineEmits(["save", "cancel"]);

// æ˜¾ç¤ºå†…è”ç¼–è¾‘
const show = (element) => {
  elementInfo.value = element;
  visible.value = true;

  nextTick(() => {
    // å¯ç”¨ contentEditable ç›´æ¥ç¼–è¾‘
    enableDirectEditing(element);
  });
};

// å¯ç”¨ç›´æ¥ç¼–è¾‘æ¨¡å¼
const enableDirectEditing = (element) => {
  // é€šè¿‡ iframe å‘é€æ¶ˆæ¯æ¥å¯ç”¨ç¼–è¾‘
  const iframe = document.querySelector('#preview-frame');
  if (iframe && iframe.contentWindow) {
    iframe.contentWindow.postMessage({
      action: 'enableEdit',
      selector: element.selector,
      tempId: element.tempId
    }, '*');
    
    // ç›‘å¬ç¼–è¾‘çŠ¶æ€
    currentEditingElement.value = element;
    
    // è®¡ç®—å·¥å…·æ ä½ç½®
    updateToolbarPosition(element);
  }
};

// æ›´æ–°å·¥å…·æ ä½ç½®
const updateToolbarPosition = (element) => {
  // è¿™é‡Œéœ€è¦æ ¹æ®å…ƒç´ åœ¨iframeä¸­çš„ä½ç½®æ¥è®¡ç®—å·¥å…·æ ä½ç½®
  // ç”±äºè·¨iframeé™åˆ¶ï¼Œæˆ‘ä»¬å°†å·¥å…·æ å›ºå®šåœ¨é¡¶éƒ¨
  toolbarStyle.value = {
    position: 'fixed',
    top: '80px',
    right: '20px',
    zIndex: 1000
  };
};

// è·å–æ ‡ç­¾é¢œè‰²
const getTagColor = (tagName) => {
  const colorMap = {
    h1: "red",
    h2: "volcano", 
    h3: "orange",
    h4: "gold",
    h5: "lime",
    h6: "green",
    p: "cyan",
    div: "blue",
    span: "geekblue",
    a: "purple",
    img: "magenta",
  };
  return colorMap[tagName?.toLowerCase()] || "default";
};

// é”®ç›˜äº‹ä»¶å¤„ç†
const handleKeyDown = (e) => {
  if (e.key === "Enter" && !e.shiftKey) {
    e.preventDefault();
    handleSave();
  } else if (e.key === "Escape") {
    e.preventDefault();
    handleCancel();
  }
};

// ä¿å­˜ç¼–è¾‘
const handleSave = () => {
  if (saving.value) return;

  saving.value = true;

  // ä»iframeè·å–ç¼–è¾‘åçš„å†…å®¹
  const iframe = document.querySelector('#preview-frame');
  if (iframe && iframe.contentWindow) {
    iframe.contentWindow.postMessage({
      action: 'saveEdit',
      tempId: currentEditingElement.value?.tempId
    }, '*');
  }

  setTimeout(() => {
    saving.value = false;
    visible.value = false;
    currentEditingElement.value = null;
  }, 300);
};

// å–æ¶ˆç¼–è¾‘
const handleCancel = () => {
  // é€šçŸ¥iframeå–æ¶ˆç¼–è¾‘
  const iframe = document.querySelector('#preview-frame');
  if (iframe && iframe.contentWindow) {
    iframe.contentWindow.postMessage({
      action: 'cancelEdit',
      tempId: currentEditingElement.value?.tempId
    }, '*');
  }

  emit("cancel");
  visible.value = false;
  currentEditingElement.value = null;
};

// ç›‘å¬iframeçš„æ¶ˆæ¯
const handleIframeMessage = (event) => {
  if (event.data.action === 'editComplete') {
    // ç¼–è¾‘å®Œæˆï¼Œå‘é€ä¿å­˜äº‹ä»¶
    emit("save", {
      element: currentEditingElement.value,
      content: event.data.content,
    });
  }
};

// æ·»åŠ å…¨å±€é”®ç›˜ç›‘å¬
const handleGlobalKeyDown = (e) => {
  if (visible.value) {
    handleKeyDown(e);
  }
};

onMounted(() => {
  window.addEventListener('message', handleIframeMessage);
  document.addEventListener('keydown', handleGlobalKeyDown);
});

onUnmounted(() => {
  window.removeEventListener('message', handleIframeMessage);
  document.removeEventListener('keydown', handleGlobalKeyDown);
});

// ç›‘å¬æ˜¾ç¤ºçŠ¶æ€å˜åŒ–
watch(visible, (newVal) => {
  if (!newVal) {
    // é‡ç½®çŠ¶æ€
    elementInfo.value = {};
    saving.value = false;
    currentEditingElement.value = null;
  }
});

defineExpose({
  show,
});
</script>

<style lang="scss" scoped>
.inline-edit-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.05);
  z-index: 999;
  pointer-events: none;
}

.edit-toolbar {
  background: rgba(255, 255, 255, 0.95);
  border: 1px solid #e2e8f0;
  border-radius: 12px;
  padding: 8px 12px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  pointer-events: auto;
  
  .toolbar-content {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 12px;
    
    .element-info {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .toolbar-actions {
      :deep(.ant-btn) {
        border: none;
        box-shadow: none;
        background: transparent;
        
        &:hover {
          background: rgba(0, 0, 0, 0.05);
        }
        
        .fas {
          font-size: 12px;
        }
      }
    }
  }
}

// ç¼–è¾‘çŠ¶æ€æ ·å¼æ³¨å…¥åˆ°iframeä¸­
:global(.editing-element) {
  outline: 2px solid #00aaff !important;
  box-shadow: 0 0 10px rgba(0, 170, 255, 0.7) !important;
  transition: all 0.2s ease !important;
}

:global(.editing-element:focus) {
  outline: 2px solid #0066cc !important;
  box-shadow: 0 0 15px rgba(0, 102, 204, 0.8) !important;
}
</style>



================================================
FILE: frontend/src/view/editor/components/MediaEditDialog.vue
================================================
<template>
  <Teleport to="body">
    <Transition name="media-dialog">
      <div v-if="visible" class="media-edit-overlay" @click.self="handleClose" @dragover.prevent @drop.prevent @paste.prevent>
        <div class="media-edit-dialog" @dragover.stop @drop.stop @paste.stop @click.stop>
          <!-- å¤´éƒ¨ -->
          <div class="dialog-header">
            <div class="header-info">
              <i class="fas fa-image text-blue-500 mr-2"></i>
              <span class="font-semibold">ç¼–è¾‘ {{ mediaTypeText }}</span>
              <a-tag :color="getMediaTypeColor()" size="small" class="ml-2">
                {{ elementInfo.tagName }}
              </a-tag>
            </div>
            <a-button type="text" @click="handleClose" class="close-btn">
              <template #icon><i class="fas fa-times"></i></template>
            </a-button>
          </div>

          <!-- å½“å‰åª’ä½“é¢„è§ˆ -->
          <div class="current-media-preview">
            <div class="preview-header">
              <div class="preview-label">
                <i class="fas fa-image text-blue-500 mr-2"></i>
                <span>å½“å‰å†…å®¹</span>
              </div>
              <div v-if="hasChanges" class="preview-indicator">
                <i class="fas fa-arrow-right text-blue-500 mx-3"></i>
                <span class="text-blue-600 font-medium">é¢„è§ˆæ–°å†…å®¹</span>
              </div>
            </div>

            <div class="media-comparison">
              <!-- åŸå§‹åª’ä½“ -->
              <div class="media-item" :class="{ 'half-width': hasChanges }">
                <div v-if="hasChanges" class="item-label">åŸå§‹</div>
                <div class="media-container">
                  <!-- å›¾ç‰‡ -->
                  <img v-if="mediaType === 'img' && currentSrc" :src="currentSrc" :alt="elementInfo.alt || 'å›¾ç‰‡'" class="current-media" @error="handleImageError" />
                  <!-- è§†é¢‘ -->
                  <video v-else-if="mediaType === 'video' && currentSrc" :src="currentSrc" controls class="current-media" @error="handleVideoError">æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒè§†é¢‘æ’­æ”¾</video>
                  <!-- éŸ³é¢‘ -->
                  <audio v-else-if="mediaType === 'audio' && currentSrc" :src="currentSrc" controls class="current-media audio-player" @error="handleAudioError">æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒéŸ³é¢‘æ’­æ”¾</audio>
                  <!-- iframe -->
                  <iframe v-else-if="mediaType === 'iframe' && currentSrc" :src="currentSrc" class="current-media iframe-preview" @error="handleIframeError"></iframe>
                  <!-- å…¶ä»–åª’ä½“ç±»å‹ -->
                  <div v-else-if="currentSrc" class="media-preview-generic">
                    <div class="generic-icon">
                      <i :class="getMediaIcon()" class="text-4xl mb-2"></i>
                    </div>
                    <div class="generic-info">
                      <p class="media-url">{{ currentSrc }}</p>
                      <p class="media-type">{{ mediaType.toUpperCase() }} å…ƒç´ </p>
                    </div>
                    <a :href="currentSrc" target="_blank" class="preview-link">
                      <i class="fas fa-external-link-alt mr-1"></i>
                      åœ¨æ–°çª—å£ä¸­æŸ¥çœ‹
                    </a>
                  </div>
                  <!-- æ— å†…å®¹çŠ¶æ€ -->
                  <div v-else class="media-placeholder">
                    <i :class="getMediaIcon()" class="text-4xl text-gray-400 mb-2"></i>
                    <span class="text-gray-500">{{ mediaTypeText }}</span>
                    <span class="text-xs text-gray-400 mt-1">æœªæ‰¾åˆ°æœ‰æ•ˆçš„srcå±æ€§</span>
                  </div>
                </div>
              </div>

              <!-- æ–°åª’ä½“é¢„è§ˆ -->
              <div v-if="hasChanges" class="media-item half-width">
                <div class="item-label new">æ–°å†…å®¹</div>
                <div class="media-container new">
                  <!-- å›¾ç‰‡ -->
                  <img v-if="mediaType === 'img' && newSrc" :src="newSrc" :alt="'æ–°å›¾ç‰‡é¢„è§ˆ'" class="current-media" @error="handleNewImageError" />
                  <!-- è§†é¢‘ -->
                  <video v-else-if="mediaType === 'video' && newSrc" :src="newSrc" controls class="current-media" @error="handleNewVideoError">æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒè§†é¢‘æ’­æ”¾</video>
                  <!-- éŸ³é¢‘ -->
                  <audio v-else-if="mediaType === 'audio' && newSrc" :src="newSrc" controls class="current-media audio-player" @error="handleNewAudioError">æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒéŸ³é¢‘æ’­æ”¾</audio>
                  <!-- iframe -->
                  <iframe v-else-if="mediaType === 'iframe' && newSrc" :src="newSrc" class="current-media iframe-preview" @error="handleNewIframeError"></iframe>
                  <!-- å…¶ä»–ç±»å‹ -->
                  <div v-else-if="newSrc" class="media-preview-generic">
                    <div class="generic-icon">
                      <i :class="getMediaIcon()" class="text-4xl mb-2 text-blue-500"></i>
                    </div>
                    <div class="generic-info">
                      <p class="media-url">{{ newSrc }}</p>
                      <p class="media-type">æ–°{{ mediaType.toUpperCase() }} å…ƒç´ </p>
                    </div>
                    <a :href="newSrc" target="_blank" class="preview-link">
                      <i class="fas fa-external-link-alt mr-1"></i>
                      åœ¨æ–°çª—å£ä¸­æŸ¥çœ‹
                    </a>
                  </div>
                  <!-- åŠ è½½ä¸­ -->
                  <div v-else class="media-placeholder">
                    <i class="fas fa-spinner fa-spin text-blue-500 text-2xl mb-2"></i>
                    <span class="text-blue-600">å‡†å¤‡ä¸­...</span>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- ç¼–è¾‘é€‰é¡¹å¡ -->
          <div class="edit-tabs">
            <a-tabs v-model:activeKey="activeTab" type="card" class="custom-tabs">
              <a-tab-pane key="local" class="tab-content">
                <template #tab>
                  <span class="tab-title">
                    <i class="fas fa-upload mr-2"></i>
                    æœ¬åœ°æ›¿æ¢
                  </span>
                </template>
                <LocalReplacePanel
                  :media-type="mediaType"
                  :current-src="currentSrc"
                  @file-selected="handleFileSelected"
                  @upload-complete="handleUploadComplete"
                  @replace-confirm="handleReplaceConfirm"
                />
              </a-tab-pane>

              <a-tab-pane key="search" class="tab-content">
                <template #tab>
                  <span class="tab-title">
                    <i class="fas fa-search mr-2"></i>
                    ä¸€é”®æœå›¾
                    <a-badge v-if="mediaType !== 'img'" status="default" class="ml-1" />
                  </span>
                </template>
                <ImageSearchPanel v-if="mediaType === 'img'" :current-alt="elementInfo.alt" @image-selected="handleSearchImageSelected" />
                <div v-else class="not-supported">
                  <i class="fas fa-info-circle text-blue-500 mr-2"></i>
                  <span>æœå›¾åŠŸèƒ½ä»…æ”¯æŒå›¾ç‰‡å…ƒç´ </span>
                </div>
              </a-tab-pane>

              <a-tab-pane key="generate" class="tab-content">
                <template #tab>
                  <span class="tab-title">
                    <i class="fas fa-magic mr-2"></i>
                    æ™ºèƒ½ç”Ÿå›¾
                    <a-badge v-if="mediaType !== 'img'" status="default" class="ml-1" />
                  </span>
                </template>
                <AIGeneratePanel v-if="mediaType === 'img'" :current-alt="elementInfo.alt" @image-generated="handleGeneratedImage" />
                <div v-else class="not-supported">
                  <i class="fas fa-info-circle text-blue-500 mr-2"></i>
                  <span>AIç”Ÿå›¾åŠŸèƒ½ä»…æ”¯æŒå›¾ç‰‡å…ƒç´ </span>
                </div>
              </a-tab-pane>
            </a-tabs>
          </div>

          <!-- åº•éƒ¨æ“ä½œ -->
          <div class="dialog-footer">
            <div class="footer-info">
              <span class="text-sm text-gray-500"> å°ºå¯¸: {{ currentDimensions }} | æ ¼å¼: {{ currentFormat }} </span>
            </div>
            <div class="footer-actions">
              <a-space>
                <a-button @click="handleClose">å–æ¶ˆ</a-button>
                <a-button type="primary" @click="handleSave" :loading="saving">
                  <template #icon><i class="fas fa-save"></i></template>
                  ä¿å­˜æ›´æ”¹
                </a-button>
              </a-space>
            </div>
          </div>
        </div>
      </div>
    </Transition>
  </Teleport>
</template>

<script setup>
import { ref, computed, watch, nextTick, onUnmounted } from "vue";
import LocalReplacePanel from "./media/LocalReplacePanel.vue";
import ImageSearchPanel from "./media/ImageSearchPanel.vue";
import AIGeneratePanel from "./media/AIGeneratePanel.vue";

const emit = defineEmits(["close", "save", "media-updated"]);

// çŠ¶æ€ç®¡ç†
const visible = ref(false);
const activeTab = ref("local");
const saving = ref(false);
const elementInfo = ref({});
const mediaType = ref("img");
const currentSrc = ref("");
const newSrc = ref("");
const newFileData = ref(null); // å­˜å‚¨æ–°æ–‡ä»¶çš„å®Œæ•´æ•°æ®
const hasChanges = ref(false);

// ä¿å­˜åŸå§‹çš„ body overflow æ ·å¼
let originalBodyOverflow = "";

// è®¡ç®—å±æ€§
const mediaTypeText = computed(() => {
  const typeMap = {
    img: "å›¾ç‰‡",
    video: "è§†é¢‘",
    audio: "éŸ³é¢‘",
    embed: "åµŒå…¥å†…å®¹",
    object: "å¯¹è±¡",
    iframe: "æ¡†æ¶",
  };
  return typeMap[mediaType.value] || "åª’ä½“";
});

const currentDimensions = computed(() => {
  // è¿™é‡Œå¯ä»¥ä»elementInfoä¸­è·å–å°ºå¯¸ä¿¡æ¯
  return elementInfo.value.width && elementInfo.value.height ? `${elementInfo.value.width} Ã— ${elementInfo.value.height}` : "æœªçŸ¥";
});

const currentFormat = computed(() => {
  if (!currentSrc.value) return "æœªçŸ¥";
  const ext = currentSrc.value.split(".").pop()?.toLowerCase();
  if (ext.length > 200) {
    return "base64";
  }
  return ext || "æœªçŸ¥";
});

// æ–¹æ³•
const show = (element, type) => {
  elementInfo.value = element;
  mediaType.value = type;

  // æ ¹æ®ä¸åŒåª’ä½“ç±»å‹è·å–æ­£ç¡®çš„src
  let src = "";
  if (element.src) {
    src = element.src;
  } else if (element.href) {
    src = element.href;
  } else if (element.data) {
    src = element.data;
  }

  currentSrc.value = src;
  newSrc.value = "";
  newFileData.value = null; // é‡ç½®æ–‡ä»¶æ•°æ®
  hasChanges.value = false;
  activeTab.value = "local";

  // é˜²æ­¢èƒŒæ™¯æ»šåŠ¨
  originalBodyOverflow = document.body.style.overflow;
  document.body.style.overflow = "hidden";

  visible.value = true;

  console.log("MediaEditDialog opened for:", {
    element: element,
    type: type,
    src: src,
  });
};

const getMediaTypeColor = () => {
  const colorMap = {
    img: "blue",
    video: "purple",
    audio: "orange",
    embed: "green",
    object: "cyan",
    iframe: "magenta",
  };
  return colorMap[mediaType.value] || "default";
};

const handleClose = () => {
  if (hasChanges.value) {
    // å¯ä»¥æ·»åŠ ç¡®è®¤å¯¹è¯æ¡†
  }

  // æ¢å¤èƒŒæ™¯æ»šåŠ¨
  document.body.style.overflow = originalBodyOverflow;

  visible.value = false;
  emit("close");
};

const handleSave = async () => {
  if (!hasChanges.value) {
    handleClose();
    return;
  }

  saving.value = true;
  try {
    emit("save", {
      element: elementInfo.value,
      newSrc: newSrc.value,
      mediaType: mediaType.value,
      fileData: newFileData.value, // ä¼ é€’å®Œæ•´çš„æ–‡ä»¶æ•°æ®
    });

    setTimeout(() => {
      saving.value = false;
      visible.value = false;
    }, 500);
  } catch (error) {
    console.error("ä¿å­˜å¤±è´¥:", error);
    saving.value = false;
  }
};

// å­ç»„ä»¶äº‹ä»¶å¤„ç†
const handleFileSelected = (file) => {
  console.log("æ–‡ä»¶é€‰æ‹©:", file);
};

const handleUploadComplete = (result) => {
  console.log("ä¸Šä¼ å®Œæˆ:", result);
  newSrc.value = result.url;
  hasChanges.value = true;
};

const handleReplaceConfirm = (data) => {
  console.log("Replace confirm:", data);

  if (typeof data === "string") {
    // å…¼å®¹æ—§ç‰ˆæœ¬ï¼Œç›´æ¥ä¼ URLå­—ç¬¦ä¸²
    newSrc.value = data;
    newFileData.value = null;
  } else if (data && data.url) {
    // æ–°ç‰ˆæœ¬ï¼Œä¼ é€’å¯¹è±¡
    newSrc.value = data.url;
    // ä¿å­˜æ–‡ä»¶æ•°æ®ä»¥ä¾¿ä¼ é€’ç»™çˆ¶ç»„ä»¶
    newFileData.value = {
      file: data.file,
      type: data.type,
      name: data.name,
      size: data.size,
      base64: data.url,
    };
  }

  hasChanges.value = true;
};

const handleSearchImageSelected = (imageUrl) => {
  newSrc.value = imageUrl;
  hasChanges.value = true;
  // ä¿æŒåœ¨å½“å‰æ ‡ç­¾ï¼Œç”¨æˆ·å¯ä»¥çœ‹åˆ°é¢„è§ˆå¯¹æ¯”
};

const handleGeneratedImage = (imageUrl) => {
  newSrc.value = imageUrl;
  hasChanges.value = true;
  // ä¿æŒåœ¨å½“å‰æ ‡ç­¾ï¼Œç”¨æˆ·å¯ä»¥çœ‹åˆ°é¢„è§ˆå¯¹æ¯”
};

// åª’ä½“å›¾æ ‡æ˜ å°„
const getMediaIcon = () => {
  const iconMap = {
    img: "fas fa-image text-blue-500",
    video: "fas fa-video text-purple-500",
    audio: "fas fa-volume-up text-green-500",
    embed: "fas fa-code text-orange-500",
    object: "fas fa-cube text-cyan-500",
    iframe: "fas fa-external-link-alt text-indigo-500",
  };
  return iconMap[mediaType.value] || "fas fa-file-alt text-gray-500";
};

// é”™è¯¯å¤„ç†æ–¹æ³•
const handleImageError = (e) => {
  console.error("åŸå§‹å›¾ç‰‡åŠ è½½å¤±è´¥:", e.target.src);
  e.target.style.display = "none";
};

const handleNewImageError = (e) => {
  console.error("æ–°å›¾ç‰‡åŠ è½½å¤±è´¥:", e.target.src);
  e.target.style.display = "none";
};

const handleVideoError = (e) => {
  console.error("åŸå§‹è§†é¢‘åŠ è½½å¤±è´¥:", e.target.src);
};

const handleNewVideoError = (e) => {
  console.error("æ–°è§†é¢‘åŠ è½½å¤±è´¥:", e.target.src);
};

const handleAudioError = (e) => {
  console.error("åŸå§‹éŸ³é¢‘åŠ è½½å¤±è´¥:", e.target.src);
};

const handleNewAudioError = (e) => {
  console.error("æ–°éŸ³é¢‘åŠ è½½å¤±è´¥:", e.target.src);
};

const handleIframeError = (e) => {
  console.error("åŸå§‹iframeåŠ è½½å¤±è´¥:", e.target.src);
};

const handleNewIframeError = (e) => {
  console.error("æ–°iframeåŠ è½½å¤±è´¥:", e.target.src);
};

// ç›‘å¬æ–°å›¾ç‰‡å˜åŒ–ï¼Œæ›´æ–°é¢„è§ˆ
watch(newSrc, (newVal) => {
  if (newVal) {
    // è¿™é‡Œå¯ä»¥æ·»åŠ é¢„è§ˆé€»è¾‘
  }
});

// ç»„ä»¶å¸è½½æ—¶æ¢å¤æ»šåŠ¨
onUnmounted(() => {
  if (visible.value) {
    document.body.style.overflow = originalBodyOverflow;
  }
});

defineExpose({
  show,
});
</script>

<style lang="scss" scoped>
// è¿‡æ¸¡åŠ¨ç”»
.media-dialog-enter-active,
.media-dialog-leave-active {
  transition: all 0.3s ease;
}

.media-dialog-enter-from {
  opacity: 0;

  .media-edit-dialog {
    transform: scale(0.9) translateY(20px);
  }
}

.media-dialog-leave-to {
  opacity: 0;

  .media-edit-dialog {
    transform: scale(0.9) translateY(20px);
  }
}

.media-edit-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.6);
  backdrop-filter: blur(4px);
  // ä½¿ç”¨æ›´é«˜çš„ z-index ç¡®ä¿åœ¨æœ€ä¸Šå±‚
  z-index: 9999;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 20px;

  // ç¡®ä¿è¦†ç›–æ•´ä¸ªè§†å£
  width: 100vw;
  height: 100vh;

  // é˜»æ­¢æ»šåŠ¨
  overflow: hidden;

  /* é˜»æ­¢æ‰€æœ‰äº‹ä»¶ç©¿é€ */
  pointer-events: auto;
}

.media-edit-dialog {
  background: white;
  border-radius: 16px;
  width: 90%;
  max-width: 800px;
  max-height: 90vh;
  overflow: hidden;
  box-shadow:
    0 25px 50px -12px rgba(0, 0, 0, 0.25),
    0 0 0 1px rgba(0, 0, 0, 0.05);
  display: flex;
  flex-direction: column;
  position: relative;
  // ç¡®ä¿å¼¹çª—å†…å®¹ä¹Ÿåœ¨æœ€ä¸Šå±‚
  z-index: 10000;
  // æ·»åŠ è¿‡æ¸¡åŠ¨ç”»
  transition:
    transform 0.3s ease,
    opacity 0.3s ease;
}

.dialog-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 20px 24px;
  border-bottom: 1px solid #e5e7eb;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;

  .header-info {
    display: flex;
    align-items: center;
    font-size: 16px;
  }

  .close-btn {
    color: white;
    border: none;

    &:hover {
      background: rgba(255, 255, 255, 0.1);
      color: white;
    }
  }
}

.current-media-preview {
  padding: 20px 24px;
  border-bottom: 1px solid #e5e7eb;

  .preview-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 16px;

    .preview-label {
      display: flex;
      align-items: center;
      font-size: 14px;
      color: #374151;
      font-weight: 600;
    }

    .preview-indicator {
      display: flex;
      align-items: center;
      font-size: 13px;
    }
  }

  .media-comparison {
    display: flex;
    gap: 16px;
    align-items: flex-start;
  }

  .media-item {
    flex: 1;
    transition: all 0.3s ease;

    &.half-width {
      flex: 0 0 calc(50% - 8px);
    }

    .item-label {
      font-size: 12px;
      color: #6b7280;
      margin-bottom: 8px;
      font-weight: 500;
      text-align: center;

      &.new {
        color: #3b82f6;
        font-weight: 600;
      }
    }
  }

  .media-container {
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 140px;
    background: #f9fafb;
    border-radius: 8px;
    border: 2px dashed #d1d5db;
    position: relative;
    overflow: hidden;

    &.new {
      border-color: #3b82f6;
      background: #eff6ff;
    }
  }

  .current-media {
    max-width: 100%;
    max-height: 180px;
    border-radius: 6px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    transition: all 0.2s ease;

    &:hover {
      transform: scale(1.02);
    }

    &.audio-player {
      width: 100%;
      max-height: 54px;
      height: 54px;
      margin: 20px 0;
    }

    &.iframe-preview {
      width: 100%;
      height: 160px;
      border: 1px solid #e5e7eb;
      background: white;
    }
  }

  .media-preview-generic {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 20px;
    text-align: center;

    .generic-icon {
      margin-bottom: 12px;
    }

    .generic-info {
      margin-bottom: 16px;

      .media-url {
        font-size: 12px;
        color: #6b7280;
        word-break: break-all;
        margin-bottom: 4px;
        max-width: 200px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      .media-type {
        font-size: 13px;
        color: #374151;
        font-weight: 500;
      }
    }

    .preview-link {
      display: inline-flex;
      align-items: center;
      font-size: 12px;
      color: #3b82f6;
      text-decoration: none;
      padding: 6px 12px;
      border: 1px solid #3b82f6;
      border-radius: 4px;
      transition: all 0.2s ease;

      &:hover {
        background: #3b82f6;
        color: white;
        text-decoration: none;
      }
    }
  }

  .media-placeholder {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 30px;
    text-align: center;
  }
}

.edit-tabs {
  flex: 1;
  overflow: hidden;
  display: flex;
  flex-direction: column;

  .custom-tabs {
    height: 100%;

    :deep(.ant-tabs-nav) {
      padding: 0 24px;
      background: #f8fafc;
      border-bottom: 1px solid #e2e8f0;
      margin: 0;
    }

    :deep(.ant-tabs-tab) {
      border-radius: 8px 8px 0 0;
      margin-right: 4px;
      border: none;
      background: transparent;

      &.ant-tabs-tab-active {
        background: white;
        border: 1px solid #e2e8f0;
        border-bottom: 1px solid white;
        margin-bottom: -1px;

        .ant-tabs-tab-btn {
          color: #3b82f6;
          font-weight: 600;
        }
      }

      &:hover:not(.ant-tabs-tab-active) {
        background: rgba(59, 130, 246, 0.05);
      }
    }

    .tab-title {
      display: flex;
      align-items: center;
      padding: 2px 4px;

      i {
        font-size: 13px;
      }
    }
  }

  :deep(.ant-tabs) {
    height: 100%;
    display: flex;
    flex-direction: column;
  }

  :deep(.ant-tabs-content-holder) {
    flex: 1;
    overflow: auto;
    background: white;
  }

  .tab-content {
    padding: 24px;
    height: 100%;
    background: white;
  }

  .not-supported {
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 60px 20px;
    color: #6b7280;
    font-size: 14px;
    background: #f9fafb;
    border-radius: 8px;
    border: 1px dashed #d1d5db;
  }
}

.dialog-footer {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 16px 24px;
  border-top: 1px solid #e5e7eb;
  background: #f9fafb;

  .footer-info {
    font-size: 12px;
  }

  .footer-actions {
    :deep(.ant-btn) {
      border-radius: 6px;
    }
  }
}
</style>



================================================
FILE: frontend/src/view/editor/components/PreviewArea.vue
================================================
<template>
  <div class="flex-1 flex flex-col bg-gradient-to-br from-gray-50 to-gray-100">
    <!-- é¢„è§ˆåŒºé¡¶éƒ¨ä¿¡æ¯æ  -->
    <div class="bg-white border-b border-gray-200 px-4 py-2 flex items-center justify-between">
      <div class="flex items-center">
        <i class="fas fa-eye text-blue-500 mr-2"></i>
        <span class="text-sm font-medium text-gray-700">å®æ—¶é¢„è§ˆ</span>
      </div>
      <div class="text-xs text-gray-500">ç‚¹å‡»é€‰æ‹©å…ƒç´ ï¼ŒåŒå‡»ç›´æ¥ç¼–è¾‘ (Enterä¿å­˜ï¼ŒEscå–æ¶ˆ)</div>
    </div>

    <div class="flex-1 relative">
      <div class="preview-container">
        <div class="preview-content">
          <iframe ref="previewIframe" class="preview-frame" sandbox="allow-scripts allow-same-origin allow-modals allow-popups allow-forms" @load="onIframeLoad"></iframe>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted, onUnmounted } from "vue";

// å®šä¹‰äº‹ä»¶
const emit = defineEmits(["elementSelected", "elementDoubleClick", "editStarted", "editComplete", "mediaElementDoubleClick"]);

const previewIframe = ref(null);
const isIframeReady = ref(false);
const messageHandlers = new Map();

// iframeåŠ è½½å®Œæˆäº‹ä»¶
const onIframeLoad = () => {
  const iframe = previewIframe.value;
  if (!iframe) return;

  try {
    // æ³¨å…¥é€šä¿¡è„šæœ¬åˆ°iframe
    const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
    const script = iframeDoc.createElement("script");
    script.textContent = `
      (function() {
        // å‘çˆ¶çª—å£å‘é€æ¶ˆæ¯çš„å·¥å…·å‡½æ•°
        function sendMessage(type, data) {
          window.parent.postMessage({
            type: type,
            data: data,
            timestamp: Date.now()
          }, '*');
        }
        
        // å½“å‰é€‰ä¸­çš„å…ƒç´ 
        let selectedElement = null;
        let hoveredElement = null;
        
        // å…ƒç´ é€‰æ‹©å¤„ç†
        function handleElementClick(e) {
          e.preventDefault();
          e.stopPropagation();
          
          // æ¸…é™¤ä¹‹å‰çš„é€‰ä¸­çŠ¶æ€
          if (selectedElement) {
            selectedElement.classList.remove('selected-element');
          }
          
          selectedElement = e.target;
          selectedElement.classList.add('selected-element');
          
          // ç”Ÿæˆå…ƒç´ è·¯å¾„
          const path = generateElementPath(selectedElement);
          
          sendMessage('elementSelected', {
            element: getElementInfo(selectedElement),
            path: path
          });
        }
        
        // æ£€æŸ¥æ˜¯å¦ä¸ºå¤šåª’ä½“å…ƒç´ 
        function isMediaElement(element) {
          const mediaTypes = ['IMG', 'VIDEO', 'AUDIO', 'EMBED', 'OBJECT', 'IFRAME'];
          return mediaTypes.includes(element.tagName);
        }
        
        // åŒå‡»ç¼–è¾‘å¤„ç† - åŒºåˆ†å¤šåª’ä½“å…ƒç´ å’Œæ–‡æœ¬å…ƒç´ 
        function handleElementDoubleClick(e) {
          e.preventDefault();
          e.stopPropagation();
          
          if (isMediaElement(e.target)) {
            // å¤šåª’ä½“å…ƒç´ ï¼Œè§¦å‘åª’ä½“ç¼–è¾‘
            sendMessage('mediaElementDoubleClick', {
              element: getElementInfo(e.target),
              mediaType: e.target.tagName.toLowerCase()
            });
          } else {
            // æ™®é€šå…ƒç´ ï¼Œå¯ç”¨ç›´æ¥ç¼–è¾‘æ¨¡å¼
            enableDirectEdit(e.target);
          }
        }
        
        // å½“å‰æ­£åœ¨ç¼–è¾‘çš„å…ƒç´ 
        let currentEditingElement = null;
        
        // å¯ç”¨ç›´æ¥ç¼–è¾‘æ¨¡å¼
        function enableDirectEdit(element) {
          // å¦‚æœå·²æœ‰ç¼–è¾‘ä¸­çš„å…ƒç´ ï¼Œå…ˆå®Œæˆç¼–è¾‘
          if (currentEditingElement && currentEditingElement !== element) {
            disableDirectEdit(currentEditingElement, false);
          }
          
          // è·³è¿‡ä¸å¯ç¼–è¾‘çš„å…ƒç´ 
          if (element.tagName === 'BODY' || element.tagName === 'HTML') return;
          
          // éšè—æ‚¬æµ®æç¤º
          hideHoverTooltip();
          
          currentEditingElement = element;
          currentEditingElement.contentEditable = 'true';
          currentEditingElement.classList.add('editing-element');
          
          // è®¾ç½®ç¼–è¾‘æ ·å¼
          currentEditingElement.style.outline = '2px solid #00aaff';
          currentEditingElement.style.boxShadow = '0 0 10px rgba(0, 170, 255, 0.7)';
          currentEditingElement.style.transition = 'all 0.2s ease';
          
          // æ˜¾ç¤ºç¼–è¾‘æç¤º
          showEditingTooltip(element);
          
          // èšç„¦å¹¶é€‰ä¸­å†…å®¹
          currentEditingElement.focus();
          
          // é€šçŸ¥çˆ¶çª—å£ç¼–è¾‘å¼€å§‹
          sendMessage('editStarted', {
            element: getElementInfo(currentEditingElement)
          });
        }
        
        // ç¦ç”¨ç›´æ¥ç¼–è¾‘æ¨¡å¼
        function disableDirectEdit(element, save = true) {
          if (!element) return;
          
          element.contentEditable = 'false';
          element.classList.remove('editing-element');
          
          // æ¸…é™¤ç¼–è¾‘æ ·å¼
          element.style.outline = 'none';
          element.style.boxShadow = 'none';
          
          // éšè—ç¼–è¾‘æç¤º
          hideEditingTooltip();
          
          if (save) {
            // å‘é€ç¼–è¾‘å®Œæˆçš„å†…å®¹
            sendMessage('editComplete', {
              element: getElementInfo(element),
              content: element.innerHTML
            });
          }
          
          if (currentEditingElement === element) {
            currentEditingElement = null;
          }
        }
        
        // ç›‘å¬ç¼–è¾‘å…ƒç´ çš„å¤±ç„¦äº‹ä»¶
        function handleEditBlur(e) {
          if (e.target === currentEditingElement) {
            disableDirectEdit(currentEditingElement, true);
          }
        }
        
        // ç›‘å¬ç¼–è¾‘æ—¶çš„é”®ç›˜äº‹ä»¶
        function handleEditKeyDown(e) {
          if (currentEditingElement && e.target === currentEditingElement) {
            // Enterä¿å­˜å¹¶é€€å‡ºç¼–è¾‘
            if (e.key === 'Enter' && !e.shiftKey) {
              e.preventDefault();
              disableDirectEdit(currentEditingElement, true);
            }
            // Escapeå–æ¶ˆç¼–è¾‘
            else if (e.key === 'Escape') {
              e.preventDefault();
              disableDirectEdit(currentEditingElement, false);
            }
          }
        }
        
        
        // æ‚¬æµ®æç¤ºå…ƒç´ 
        let hoverTooltip = null;
        let editingTooltip = null;
        
        // åˆ›å»ºæ‚¬æµ®æç¤º
        function createHoverTooltip() {
          if (hoverTooltip) return hoverTooltip;
          
          hoverTooltip = document.createElement('div');
          hoverTooltip.className = 'hover-tooltip';
          hoverTooltip.style.cssText = \`
            position: fixed;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            white-space: nowrap;
            pointer-events: none;
            z-index: 999999;
            opacity: 0;
            transition: all 0.2s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            transform: translateY(-8px);
          \`;
          document.body.appendChild(hoverTooltip);
          return hoverTooltip;
        }
        
        // æ˜¾ç¤ºæ‚¬æµ®æç¤º
        function showHoverTooltip(element, x, y) {
          const tooltip = createHoverTooltip();
          
          // è·å–å…ƒç´ ä¿¡æ¯
          const tagName = element.tagName.toLowerCase();
          const elementId = element.id ? \`#\${element.id}\` : '';
          
          // å¤„ç†classNameï¼Œè¿‡æ»¤æ‰ç¼–è¾‘å™¨çŠ¶æ€ç±»å’Œå¤æ‚ç±»å
          let className = '';
          if (element.className && typeof element.className === 'string') {
            const classes = element.className.split(' ')
              .filter(cls => cls && !cls.includes('selected') && !cls.includes('hovered') && !cls.includes('editing'))
              .slice(0, 3) // åªæ˜¾ç¤ºå‰3ä¸ªç±»åï¼Œé¿å…è¿‡é•¿
              .join('.');
            if (classes) className = \`.\${classes}\`;
          }
          
          // æ„å»ºæ˜¾ç¤ºæ–‡æœ¬
          let displayText = \`<\${tagName}\`;
          if (elementId) displayText += elementId;
          if (className) displayText += className;
          displayText += '> åŒå‡»ç¼–è¾‘';
          
          // é™åˆ¶æ–‡æœ¬é•¿åº¦ï¼Œé¿å…æ‚¬æµ®æ¡†è¿‡å®½
          if (displayText.length > 50) {
            displayText = displayText.substring(0, 47) + '...> åŒå‡»ç¼–è¾‘';
          }
          
          tooltip.innerHTML = displayText;
          
          // è®¡ç®—ä½ç½®ï¼Œç¡®ä¿ä¸è¶…å‡ºè§†çª—
          const rect = element.getBoundingClientRect();
          const tooltipRect = tooltip.getBoundingClientRect();
          
          let left = rect.left + rect.width / 2 - tooltipRect.width / 2;
          let top = rect.top - 40;
          
          // è¾¹ç•Œæ£€æŸ¥
          if (left < 10) left = 10;
          if (left + tooltipRect.width > window.innerWidth - 10) {
            left = window.innerWidth - tooltipRect.width - 10;
          }
          if (top < 10) top = rect.bottom + 10;
          
          tooltip.style.left = left + 'px';
          tooltip.style.top = top + 'px';
          tooltip.style.opacity = '1';
          tooltip.style.transform = 'translateY(0)';
        }
        
        // éšè—æ‚¬æµ®æç¤º
        function hideHoverTooltip() {
          if (hoverTooltip) {
            hoverTooltip.style.opacity = '0';
            hoverTooltip.style.transform = 'translateY(-8px)';
            setTimeout(() => {
              if (hoverTooltip && hoverTooltip.parentNode) {
                hoverTooltip.parentNode.removeChild(hoverTooltip);
                hoverTooltip = null;
              }
            }, 200);
          }
        }
        
        // åˆ›å»ºç¼–è¾‘æç¤º
        function createEditingTooltip() {
          if (editingTooltip) return editingTooltip;
          
          editingTooltip = document.createElement('div');
          editingTooltip.className = 'editing-tooltip';
          editingTooltip.style.cssText = \`
            position: fixed;
            background: linear-gradient(135deg, #00aaff 0%, #0066cc 100%);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            white-space: nowrap;
            pointer-events: none;
            z-index: 999999;
            opacity: 0;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0, 170, 255, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            transform: translateY(-8px);
          \`;
          editingTooltip.innerHTML = 'æ­£åœ¨ç¼–è¾‘... (Enterä¿å­˜, Escå–æ¶ˆ)';
          document.body.appendChild(editingTooltip);
          return editingTooltip;
        }
        
        // æ˜¾ç¤ºç¼–è¾‘æç¤º
        function showEditingTooltip(element) {
          const tooltip = createEditingTooltip();
          
          // è®¡ç®—ä½ç½®
          const rect = element.getBoundingClientRect();
          
          let left = rect.left;
          let top = rect.top - 45;
          
          // è¾¹ç•Œæ£€æŸ¥
          if (left < 10) left = 10;
          if (left + 200 > window.innerWidth - 10) {
            left = window.innerWidth - 210;
          }
          if (top < 10) top = rect.bottom + 10;
          
          tooltip.style.left = left + 'px';
          tooltip.style.top = top + 'px';
          tooltip.style.opacity = '1';
          tooltip.style.transform = 'translateY(0)';
        }
        
        // éšè—ç¼–è¾‘æç¤º
        function hideEditingTooltip() {
          if (editingTooltip) {
            editingTooltip.style.opacity = '0';
            editingTooltip.style.transform = 'translateY(-8px)';
            setTimeout(() => {
              if (editingTooltip && editingTooltip.parentNode) {
                editingTooltip.parentNode.removeChild(editingTooltip);
                editingTooltip = null;
              }
            }, 300);
          }
        }
        
        // é¼ æ ‡æ‚¬åœå¤„ç†
        function handleElementMouseOver(e) {
          e.stopPropagation();
          
          // è·³è¿‡ä¸å¯ç¼–è¾‘çš„å…ƒç´ 
          if (e.target.tagName === 'BODY' || e.target.tagName === 'HTML') return;
          
          if (hoveredElement && hoveredElement !== selectedElement) {
            hoveredElement.classList.remove('hovered-element');
          }
          
          if (e.target !== selectedElement && e.target !== currentEditingElement) {
            hoveredElement = e.target;
            hoveredElement.classList.add('hovered-element');
            
            // æ˜¾ç¤ºæ‚¬æµ®æç¤º
            showHoverTooltip(e.target, e.clientX, e.clientY);
          }
        }
        
        function handleElementMouseOut(e) {
          if (hoveredElement && hoveredElement !== selectedElement) {
            hoveredElement.classList.remove('hovered-element');
            hoveredElement = null;
            
            // éšè—æ‚¬æµ®æç¤º
            hideHoverTooltip();
          }
        }
        
        // ç”Ÿæˆå…ƒç´ è·¯å¾„
        function generateElementPath(element) {
          const path = [];
          let current = element;
          
          while (current && current !== document.body && current !== document.documentElement) {
            let selector = current.tagName.toLowerCase();
            
            if (current.id) {
              selector += '#' + current.id;
              path.unshift(selector);
              break; // IDæ˜¯å”¯ä¸€çš„ï¼Œå¯ä»¥åœæ­¢
            } else if (current.className && typeof current.className === 'string') {
              selector += '.' + current.className.trim().split(/\\s+/).join('.');
            }
            
            // å¦‚æœæœ‰å…„å¼ŸèŠ‚ç‚¹ï¼Œæ·»åŠ nth-child
            const parent = current.parentElement;
            if (parent) {
              const siblings = Array.from(parent.children).filter(child => 
                child.tagName === current.tagName
              );
              if (siblings.length > 1) {
                const index = siblings.indexOf(current) + 1;
                selector += ':nth-child(' + index + ')';
              }
            }
            
            path.unshift(selector);
            current = current.parentElement;
          }
          
          return path;
        }
        
        // è·å–å…ƒç´ ä¿¡æ¯
        function getElementInfo(element) {
          const info = {
            tagName: element.tagName.toLowerCase(),
            id: element.id || '',
            className: element.className || '',
            textContent: element.textContent ? element.textContent.substring(0, 100) : '',
            outerHTML: element.outerHTML.substring(0, 500),
            innerHTML: element.innerHTML.substring(0, 500)
          };
          
          // ä¸ºå…ƒç´ æ·»åŠ å”¯ä¸€æ ‡è¯†ç¬¦ä»¥ä¾¿å‡†ç¡®å®šä½
          if (!element.dataset.editorId) {
            element.dataset.editorId = 'editor-element-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
          }
          info.editorId = element.dataset.editorId;
          
          // æ·»åŠ åª’ä½“å…ƒç´ çš„ç‰¹æ®Šå±æ€§
          if (element.tagName === 'IMG') {
            info.src = element.src || '';
            info.alt = element.alt || '';
            info.width = element.naturalWidth || element.width || '';
            info.height = element.naturalHeight || element.height || '';
          } else if (element.tagName === 'VIDEO' || element.tagName === 'AUDIO') {
            info.src = element.src || '';
            info.controls = element.controls || false;
            info.autoplay = element.autoplay || false;
            info.loop = element.loop || false;
            if (element.tagName === 'VIDEO') {
              info.width = element.videoWidth || element.width || '';
              info.height = element.videoHeight || element.height || '';
            }
          } else if (element.tagName === 'IFRAME') {
            info.src = element.src || '';
            info.width = element.width || '';
            info.height = element.height || '';
            info.frameborder = element.frameBorder || '';
          } else if (element.tagName === 'EMBED' || element.tagName === 'OBJECT') {
            info.src = element.src || '';
            info.data = element.data || '';
            info.type = element.type || '';
            info.width = element.width || '';
            info.height = element.height || '';
          } else if (element.tagName === 'A') {
            info.href = element.href || '';
            info.target = element.target || '';
          }
          
          return info;
        }
        
        // æ ¹æ®è·¯å¾„é€‰æ‹©å…ƒç´ 
        function selectElementByPath(path) {
          try {
            const selector = path.join(' > ');
            const element = document.querySelector(selector);
            if (element) {
              // æ¸…é™¤ä¹‹å‰çš„é€‰ä¸­çŠ¶æ€
              if (selectedElement) {
                selectedElement.classList.remove('selected-element');
              }
              
              selectedElement = element;
              selectedElement.classList.add('selected-element');
              
              // æ»šåŠ¨åˆ°å…ƒç´ ä½ç½®
              element.scrollIntoView({ behavior: 'smooth', block: 'center' });
              
              sendMessage('elementSelected', {
                element: getElementInfo(selectedElement),
                path: path
              });
            }
          } catch (error) {
            console.error('é€‰æ‹©å…ƒç´ å¤±è´¥:', error);
          }
        }
        
        // æ›´æ–°å…ƒç´ å†…å®¹
        function updateElementContent(selector, content) {
          try {
            const element = document.querySelector(selector);
            if (element) {
              element.innerHTML = content;
              
              // å¦‚æœè¿™æ˜¯å½“å‰é€‰ä¸­çš„å…ƒç´ ï¼Œæ›´æ–°é€‰ä¸­çŠ¶æ€
              if (selectedElement && (selectedElement === element || selectedElement.contains(element))) {
                selectedElement.classList.remove('selected-element');
                selectedElement = element;
                selectedElement.classList.add('selected-element');
              }
              
              sendMessage('contentUpdated', {
                success: true,
                element: getElementInfo(element)
              });
            } else {
              sendMessage('contentUpdated', {
                success: false,
                error: 'æœªæ‰¾åˆ°ç›®æ ‡å…ƒç´ '
              });
            }
          } catch (error) {
            sendMessage('contentUpdated', {
              success: false,
              error: error.message
            });
          }
        }
        
        // ç›‘å¬æ¥è‡ªçˆ¶çª—å£çš„æ¶ˆæ¯
        window.addEventListener('message', function(event) {
          const { type, data, action } = event.data;
          
          // å¤„ç†æ–°çš„æ¶ˆæ¯æ ¼å¼
          if (action) {
            switch (action) {
              case 'enableEdit':
                const editElement = document.querySelector(data.selector);
                if (editElement) {
                  enableDirectEdit(editElement);
                }
                break;
              case 'saveEdit':
                if (currentEditingElement) {
                  disableDirectEdit(currentEditingElement, true);
                }
                break;
              case 'cancelEdit':
                if (currentEditingElement) {
                  disableDirectEdit(currentEditingElement, false);
                }
                break;
            }
            return;
          }
          
          // å¤„ç†åŸæœ‰çš„æ¶ˆæ¯æ ¼å¼
          switch (type) {
            case 'selectElement':
              selectElementByPath(data.path);
              break;
            case 'updateContent':
              updateElementContent(data.selector, data.content);
              break;
            case 'clearSelection':
              if (selectedElement) {
                selectedElement.classList.remove('selected-element');
                selectedElement = null;
              }
              break;
          }
        });
        
        // ç­‰å¾…DOMåŠ è½½å®Œæˆåç»‘å®šäº‹ä»¶
        function initEventListeners() {
          // ä¸ºæ‰€æœ‰å…ƒç´ æ·»åŠ äº¤äº’äº‹ä»¶
          document.addEventListener('click', handleElementClick, true);
          document.addEventListener('dblclick', handleElementDoubleClick, true);
          document.addEventListener('mouseover', handleElementMouseOver, true);
          document.addEventListener('mouseout', handleElementMouseOut, true);
          
          // æ·»åŠ ç¼–è¾‘ç›¸å…³äº‹ä»¶ç›‘å¬
          document.addEventListener('blur', handleEditBlur, true);
          document.addEventListener('keydown', handleEditKeyDown, true);
          
          // é¡µé¢æ»šåŠ¨æ—¶éšè—æç¤º
          document.addEventListener('scroll', function() {
            hideHoverTooltip();
            hideEditingTooltip();
          }, true);
          
          // çª—å£å¤§å°æ”¹å˜æ—¶éšè—æç¤º
          window.addEventListener('resize', function() {
            hideHoverTooltip();
            hideEditingTooltip();
          });
          
          
          // é˜»æ­¢å³é”®èœå•
          document.addEventListener('contextmenu', function(e) {
            e.preventDefault();
          });
          
          sendMessage('iframeReady', { ready: true });
        }
        
        // DOMåŠ è½½å®Œæˆååˆå§‹åŒ–
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', initEventListeners);
        } else {
          initEventListeners();
        }
      })();
    `;

    iframeDoc.head.appendChild(script);

    // æ·»åŠ æ ·å¼
    const style = iframeDoc.createElement("style");
    style.textContent = `
      .selected-element {
        outline: 3px solid #3b82f6 !important;
        outline-offset: 2px;
        background-color: rgba(59, 130, 246, 0.08) !important;
        border-radius: 4px;
        position: relative;
        transition: all 0.2s ease;
      }
      
      .selected-element::before {
        content: "";
        position: absolute;
        top: -8px;
        left: -8px;
        right: -8px;
        bottom: -8px;
        background: linear-gradient(45deg, #3b82f6, #8b5cf6);
        border-radius: 8px;
        opacity: 0.1;
        z-index: -1;
        animation: pulse 2s infinite;
      }
      
      .hovered-element {
        outline: 2px solid #667eea !important;
        outline-offset: 1px;
        background-color: rgba(102, 126, 234, 0.08) !important;
        border-radius: 3px;
        transition: all 0.2s ease;
        cursor: pointer;
        position: relative;
        box-shadow: 0 2px 8px rgba(102, 126, 234, 0.15) !important;
      }
      
      .hovered-element:hover {
        outline-color: #4f46e5 !important;
        background-color: rgba(79, 70, 229, 0.12) !important;
        transform: translateY(-1px);
      }
      
      @keyframes pulse {
        0% { opacity: 0.1; }
        50% { opacity: 0.2; }
        100% { opacity: 0.1; }
      }
      
      /* ç¼–è¾‘çŠ¶æ€æ ·å¼ */
      .editing-element {
        outline: 2px solid #00aaff !important;
        box-shadow: 0 0 10px rgba(0, 170, 255, 0.7) !important;
        transition: all 0.2s ease !important;
        background-color: rgba(0, 170, 255, 0.05) !important;
      }
      
      .editing-element:focus {
        outline: 2px solid #0066cc !important;
        box-shadow: 0 0 15px rgba(0, 102, 204, 0.8) !important;
      }
      
      /* ç¼–è¾‘æç¤ºå·²ç§»è‡³JavaScriptåŠ¨æ€åˆ›å»º */
      
      @keyframes fadeIn {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
      }
    `;

    iframeDoc.head.appendChild(style);
    isIframeReady.value = true;
  } catch (error) {
    console.error("Failed to initialize iframe:", error);
  }
};

// å¤„ç†æ¥è‡ªiframeçš„æ¶ˆæ¯
const handleMessage = (event) => {
  const { type, data, action } = event.data;

  // å¤„ç†æ–°çš„ç¼–è¾‘æ¶ˆæ¯æ ¼å¼
  if (type === "editStarted") {
    emit("editStarted", data);
    return;
  }

  if (type === "editComplete") {
    emit("editComplete", data);
    return;
  }

  if (type === "mediaElementDoubleClick") {
    emit("mediaElementDoubleClick", data);
    return;
  }

  if (messageHandlers.has(type)) {
    messageHandlers.get(type)(data);
  }
};

// å‘iframeå‘é€æ¶ˆæ¯
const sendMessageToIframe = (type, data) => {
  if (!previewIframe.value || !isIframeReady.value) {
    console.warn("Iframe not ready for message:", type);
    return;
  }

  try {
    previewIframe.value.contentWindow.postMessage(
      {
        type,
        data,
        timestamp: Date.now(),
      },
      "*"
    );
  } catch (error) {
    console.error("Failed to send message to iframe:", error);
  }
};

// æ›´æ–°é¢„è§ˆå†…å®¹
const updatePreview = (htmlContent) => {
  const iframe = previewIframe.value;
  if (!iframe) return;

  try {
    // åœ¨æ›´æ–°iframeä¹‹å‰ï¼Œä¸ºHTMLä¸­çš„åª’ä½“å…ƒç´ æ·»åŠ editorId
    const processedHtml = addEditorIdsToMediaElements(htmlContent);

    // åˆ›å»ºå®Œæ•´çš„HTMLæ–‡æ¡£
    const fullHtml = `
      <!DOCTYPE html>
      <html lang="zh-CN">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>é¢„è§ˆ</title>
      </head>
      <body>
        ${processedHtml}
      </body>
      </html>
    `;

    // ä½¿ç”¨srcdocå±æ€§æ›´æ–°å†…å®¹ï¼Œè¿™æ ·å¯ä»¥é¿å…è·¨åŸŸé—®é¢˜
    iframe.srcdoc = fullHtml;
  } catch (error) {
    console.error("Failed to update preview:", error);
  }
};

// ä¸ºHTMLä¸­çš„åª’ä½“å…ƒç´ æ·»åŠ editorId (ä½¿ç”¨å­—ç¬¦ä¸²æ›¿æ¢ï¼Œä¸ç ´åscriptæ ‡ç­¾)
const addEditorIdsToMediaElements = (htmlContent) => {
  try {
    let modifiedHtml = htmlContent;
    
    // å®šä¹‰åª’ä½“å…ƒç´ æ ‡ç­¾
    const mediaSelectors = ["img", "video", "audio", "embed", "object", "iframe"];
    
    mediaSelectors.forEach((selector) => {
      // åŒ¹é…æ²¡æœ‰data-editor-idå±æ€§çš„åª’ä½“å…ƒç´ å¼€æ ‡ç­¾
      const regex = new RegExp(`(<${selector}(?![^>]*data-editor-id)[^>]*?)>`, 'gi');
      
      modifiedHtml = modifiedHtml.replace(regex, (match, tag) => {
        const editorId = "editor-element-" + Date.now() + "-" + Math.random().toString(36).substr(2, 9);
        // åœ¨æ ‡ç­¾æœ«å°¾ï¼ˆ>ä¹‹å‰ï¼‰æ·»åŠ data-editor-idå±æ€§
        return tag + ` data-editor-id="${editorId}">`;
      });
    });
    
    return modifiedHtml;
  } catch (error) {
    console.error("Failed to add editor IDs:", error);
    return htmlContent;
  }
};

// é€‰æ‹©å…ƒç´ 
const selectElementByPath = (path) => {
  sendMessageToIframe("selectElement", { path });
};

// æ¸…é™¤é€‰ä¸­çŠ¶æ€
const clearSelection = () => {
  sendMessageToIframe("clearSelection");
};

// æ›´æ–°å…ƒç´ å†…å®¹
const updateElementContent = (selector, content) => {
  sendMessageToIframe("updateContent", { selector, content });
};

// æ³¨å†Œæ¶ˆæ¯å¤„ç†å™¨
const onMessage = (type, handler) => {
  messageHandlers.set(type, handler);
};

// ç§»é™¤æ¶ˆæ¯å¤„ç†å™¨
const offMessage = (type) => {
  messageHandlers.delete(type);
};

// è·å–iframeå…ƒç´ ï¼ˆå…¼å®¹æ—§æ¥å£ï¼‰
const getPreviewElement = () => {
  return previewIframe.value;
};

// ç”Ÿå‘½å‘¨æœŸ
onMounted(() => {
  window.addEventListener("message", handleMessage);
});

onUnmounted(() => {
  window.removeEventListener("message", handleMessage);
  messageHandlers.clear();
});

defineExpose({
  getPreviewElement,
  updatePreview,
  selectElementByPath,
  clearSelection,
  updateElementContent,
  onMessage,
  offMessage,
  isIframeReady,
  previewIframe, // æš´éœ²iframeå¼•ç”¨
});
</script>

<style lang="scss" scoped>
.preview-container {
  width: 100%;
  height: 100%;
  padding: 24px;
  overflow: hidden;
}

.preview-content {
  width: 100%;
  max-width: 1200px;
  margin: 0 auto;
  height: 100%;
  position: relative;
}

.preview-frame {
  width: 100%;
  height: 100%;
  min-height: calc(100vh - 200px);
  background: white;
  border-radius: 12px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
  border: 1px solid #e5e7eb;
  transition: all 0.3s ease;

  &:hover {
    box-shadow: 0 8px 30px rgba(0, 0, 0, 0.12);
    transform: translateY(-2px);
  }
}
</style>



================================================
FILE: frontend/src/view/editor/components/RichTextEditor.vue
================================================
<template>
  <a-modal
    v-model:open="visible"
    width="900px"
    :footer="null"
    @cancel="handleCancel"
    class="rich-text-modal"
  >
    <template #title>
      <div class="flex items-center">
        <div class="w-8 h-8 bg-gradient-to-r from-orange-500 to-pink-500 rounded-lg flex items-center justify-center mr-3">
          <i class="fas fa-edit text-white"></i>
        </div>
        <span class="text-lg font-semibold">å¯Œæ–‡æœ¬ç¼–è¾‘å™¨</span>
      </div>
    </template>
    <div class="space-y-4">
      <div v-if="selectedElement">
        <h4 class="font-medium text-gray-800 mb-2">ç¼–è¾‘å…ƒç´ :</h4>
        <div class="bg-gray-100 p-3 rounded text-sm font-mono">
          {{ getElementInfo(selectedElement) }}
        </div>
      </div>
      
      <!-- å·¥å…·æ  -->
      <div class="border rounded p-2 bg-gray-50">
        <div class="flex items-center space-x-2 flex-wrap">
          <a-button-group size="small">
            <a-button @click="execCommand('bold')" :type="isActive('bold') ? 'primary' : 'default'">
              <template #icon><i class="fas fa-bold"></i></template>
            </a-button>
            <a-button @click="execCommand('italic')" :type="isActive('italic') ? 'primary' : 'default'">
              <template #icon><i class="fas fa-italic"></i></template>
            </a-button>
            <a-button @click="execCommand('underline')" :type="isActive('underline') ? 'primary' : 'default'">
              <template #icon><i class="fas fa-underline"></i></template>
            </a-button>
          </a-button-group>
          
          <a-divider type="vertical" />
          
          <a-button-group size="small">
            <a-button @click="execCommand('justifyLeft')">
              <template #icon><i class="fas fa-align-left"></i></template>
            </a-button>
            <a-button @click="execCommand('justifyCenter')">
              <template #icon><i class="fas fa-align-center"></i></template>
            </a-button>
            <a-button @click="execCommand('justifyRight')">
              <template #icon><i class="fas fa-align-right"></i></template>
            </a-button>
          </a-button-group>
          
          <a-divider type="vertical" />
          
          <a-button-group size="small">
            <a-button @click="execCommand('insertUnorderedList')">
              <template #icon><i class="fas fa-list-ul"></i></template>
            </a-button>
            <a-button @click="execCommand('insertOrderedList')">
              <template #icon><i class="fas fa-list-ol"></i></template>
            </a-button>
          </a-button-group>
          
          <a-divider type="vertical" />
          
          <a-select
            v-model:value="currentFontSize"
            @change="changeFontSize"
            size="small"
            style="width: 80px"
          >
            <a-select-option value="12px">12px</a-select-option>
            <a-select-option value="14px">14px</a-select-option>
            <a-select-option value="16px">16px</a-select-option>
            <a-select-option value="18px">18px</a-select-option>
            <a-select-option value="24px">24px</a-select-option>
            <a-select-option value="32px">32px</a-select-option>
          </a-select>
          
          <input
            type="color"
            v-model="currentColor"
            @change="changeColor"
            class="w-8 h-6 border rounded cursor-pointer"
          />
        </div>
      </div>
      
      <!-- ç¼–è¾‘åŒºåŸŸ -->
      <div class="border rounded">
        <div
          ref="editorRef"
          contenteditable="true"
          class="min-h-[200px] p-4 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50"
          @input="handleInput"
          @keydown="handleKeydown"
          @focus="handleFocus"
          @blur="handleBlur"
        ></div>
      </div>
      
      <div class="flex justify-end space-x-2 pt-4 border-t">
        <a-button @click="handleCancel">å–æ¶ˆ</a-button>
        <a-button type="primary" @click="handleSave">ä¿å­˜</a-button>
      </div>
    </div>
  </a-modal>
</template>

<script setup>
import { ref, nextTick } from 'vue'
import { message } from 'ant-design-vue'

const emit = defineEmits(['save-content'])

const visible = ref(false)
const selectedElement = ref(null)
const editorRef = ref(null)
const currentFontSize = ref('16px')
const currentColor = ref('#000000')
const originalContent = ref('')

const show = (element) => {
  selectedElement.value = element
  visible.value = true
  
  nextTick(() => {
    if (editorRef.value && element) {
      // ä¿å­˜åŸå§‹å†…å®¹
      originalContent.value = element.innerHTML
      // è®¾ç½®ç¼–è¾‘å™¨å†…å®¹ï¼Œä¿æŒåŸæœ‰çš„ç±»åå’Œæ ·å¼
      editorRef.value.innerHTML = element.innerHTML
      editorRef.value.focus()
    }
  })
}

const handleCancel = () => {
  visible.value = false
  selectedElement.value = null
  originalContent.value = ''
}

const getElementInfo = (element) => {
  if (!element) return ''
  const tagName = element.tagName.toLowerCase()
  const className = element.className ? ` class=\"${element.className}\"` : ''
  const id = element.id ? ` id=\"${element.id}\"` : ''
  return `<${tagName}${id}${className}>`
}

const execCommand = (command, value = null) => {
  document.execCommand(command, false, value)
  editorRef.value.focus()
}

const isActive = (command) => {
  try {
    return document.queryCommandState(command)
  } catch (e) {
    return false
  }
}

const changeFontSize = (size) => {
  execCommand('fontSize', '3') // ä½¿ç”¨é»˜è®¤å¤§å°
  // ç„¶åæ‰‹åŠ¨è®¾ç½®æ ·å¼
  const selection = window.getSelection()
  if (selection.rangeCount > 0) {
    const range = selection.getRangeAt(0)
    if (!range.collapsed) {
      const span = document.createElement('span')
      span.style.fontSize = size
      try {
        range.surroundContents(span)
      } catch (e) {
        // å¦‚æœæ— æ³•åŒ…å›´ï¼Œåˆ™ç›´æ¥åº”ç”¨åˆ°é€‰ä¸­æ–‡æœ¬
        const contents = range.extractContents()
        span.appendChild(contents)
        range.insertNode(span)
      }
    }
  }
  editorRef.value.focus()
}

const changeColor = () => {
  execCommand('foreColor', currentColor.value)
}

const handleInput = () => {
  // å®æ—¶æ›´æ–°é¢„è§ˆï¼ˆå¯é€‰ï¼‰
}

const handleKeydown = (e) => {
  // å¤„ç†å¿«æ·é”®
  if (e.ctrlKey || e.metaKey) {
    switch (e.key) {
      case 'b':
        e.preventDefault()
        execCommand('bold')
        break
      case 'i':
        e.preventDefault()
        execCommand('italic')
        break
      case 'u':
        e.preventDefault()
        execCommand('underline')
        break
    }
  }
}

const handleFocus = () => {
  // ç¼–è¾‘å™¨è·å¾—ç„¦ç‚¹
}

const handleBlur = () => {
  // ç¼–è¾‘å™¨å¤±å»ç„¦ç‚¹
}

const handleSave = () => {
  if (!selectedElement.value || !editorRef.value) return
  
  try {
    // è·å–ç¼–è¾‘å™¨çš„å†…å®¹
    const newContent = editorRef.value.innerHTML
    
    // æ£€æŸ¥å†…å®¹æ˜¯å¦æœ‰å˜åŒ–
    if (newContent === originalContent.value) {
      message.info('å†…å®¹æœªå‘ç”Ÿå˜åŒ–')
      handleCancel()
      return
    }
    
    // å°†æ–°å†…å®¹åº”ç”¨åˆ°åŸå…ƒç´ ï¼Œä¿æŒç±»åå’Œå…¶ä»–å±æ€§
    selectedElement.value.innerHTML = newContent
    
    // å‘é€ä¿å­˜äº‹ä»¶ï¼Œä¼ é€’å®Œæ•´çš„å…ƒç´ ä¿¡æ¯
    emit('save-content', {
      content: newContent,
      element: selectedElement.value,
      originalContent: originalContent.value
    })
    
    message.success('å†…å®¹å·²ä¿å­˜')
    handleCancel()
    
  } catch (error) {
    message.error('ä¿å­˜å¤±è´¥')
    console.error('Save error:', error)
  }
}

defineExpose({
  show
})
</script>

<style lang="scss" scoped>
.fas {
  font-size: 12px;
}

:deep(.rich-text-modal) {
  .ant-modal-content {
    border-radius: 12px;
    overflow: hidden;
  }
  
  .ant-modal-header {
    background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
    border-bottom: none;
    padding: 20px 24px;
    
    .ant-modal-title {
      color: white;
      margin: 0;
    }
  }
  
  .ant-modal-close {
    color: white;
    
    &:hover {
      color: rgba(255, 255, 255, 0.8);
    }
  }
  
  .ant-modal-body {
    padding: 24px;
  }
}

:deep(.ant-select-selection-item) {
  font-size: 12px;
}

:deep(.ant-btn-group) {
  .ant-btn {
    border-radius: 0;
    
    &:first-child {
      border-radius: 6px 0 0 6px;
    }
    
    &:last-child {
      border-radius: 0 6px 6px 0;
    }
  }
}

// ç¼–è¾‘å™¨æ ·å¼
:deep([contenteditable="true"]) {
  border: 2px solid #e1e5e9;
  border-radius: 8px;
  transition: all 0.3s ease;
  
  &:focus {
    outline: none;
    border-color: #f093fb;
    box-shadow: 0 0 0 2px rgba(240, 147, 251, 0.1);
  }
  
  // ä¿æŒåŸæœ‰æ ·å¼
  * {
    margin: inherit;
    padding: inherit;
    color: inherit;
    font-size: inherit;
    font-weight: inherit;
    text-align: inherit;
  }
}

// å·¥å…·æ æ ·å¼ä¼˜åŒ–
.border {
  border-radius: 8px;
  border-color: #e1e5e9;
}

:deep(.ant-btn) {
  border-radius: 6px;
  transition: all 0.3s ease;
  
  &:hover {
    transform: translateY(-1px);
  }
}
</style>


================================================
FILE: frontend/src/view/editor/components/SidePanel.vue
================================================
<template>
  <div class="w-64 bg-white border-r border-gray-200 flex flex-col shadow-sm">
    <!-- å…ƒç´ å±‚çº§é¢æ¿ -->
    <div class="p-4 border-b border-gray-100">
      <div class="flex items-center mb-3">
        <i class="fas fa-sitemap text-blue-500 mr-2"></i>
        <h3 class="font-semibold text-gray-800">å…ƒç´ å±‚çº§</h3>
      </div>
      
      <div v-if="elementPath.length > 0" class="bg-gray-50 rounded-lg p-3">
        <div class="flex flex-wrap gap-1">
          <a-tag 
            v-for="(item, index) in elementPath" 
            :key="index"
            @click="$emit('select-from-path', item)"
            class="cursor-pointer transition-all hover:shadow-sm"
            color="blue"
          >
            {{ item.display }}
          </a-tag>
        </div>
      </div>
      
      <div v-else class="text-center py-6 text-gray-400">
        <i class="fas fa-mouse-pointer text-2xl mb-2 block"></i>
        <p class="text-sm">ç‚¹å‡»é¢„è§ˆåŒºåŸŸçš„å…ƒç´ </p>
        <p class="text-xs">æŸ¥çœ‹å…ƒç´ å±‚çº§</p>
      </div>
    </div>
    
    <!-- æ“ä½œé¢æ¿ -->
    <div class="p-4 flex-1">
      <div class="flex items-center mb-3">
        <i class="fas fa-tools text-green-500 mr-2"></i>
        <h3 class="font-semibold text-gray-800">ç¼–è¾‘å·¥å…·</h3>
      </div>
      
      <div class="space-y-3">
        <!-- AI ç¼–è¾‘æŒ‰é’® -->
        <a-button 
          @click="handleAIEdit" 
          :disabled="!selectedElement"
          size="large"
          block
          class="ai-edit-btn"
          :class="{ 'opacity-50 cursor-not-allowed': !selectedElement }"
        >
          <template #icon>
            <i class="fas fa-magic"></i>
          </template>
          <span class="ml-2">AI æ™ºèƒ½ç¼–è¾‘</span>
        </a-button>
        
        <!-- å¯Œæ–‡æœ¬ç¼–è¾‘æŒ‰é’® -->
        <a-button 
          @click="handleRichEdit" 
          :disabled="!selectedElement"
          size="large"
          block
          class="rich-edit-btn"
          :class="{ 'opacity-50 cursor-not-allowed': !selectedElement }"
        >
          <template #icon>
            <i class="fas fa-edit"></i>
          </template>
          <span class="ml-2">å¯Œæ–‡æœ¬ç¼–è¾‘</span>
        </a-button>
        
        <!-- å¿«é€Ÿç¼–è¾‘æŒ‰é’® -->
        <a-button 
          @click="handleInlineEdit" 
          :disabled="!selectedElement"
          size="large"
          block
          class="inline-edit-btn"
          :class="{ 'opacity-50 cursor-not-allowed': !selectedElement }"
        >
          <template #icon>
            <i class="fas fa-i-cursor"></i>
          </template>
          <span class="ml-2">å¿«é€Ÿç¼–è¾‘</span>
        </a-button>
      </div>
      
      <!-- å½“å‰é€‰ä¸­å…ƒç´ ä¿¡æ¯ -->
      <div v-if="selectedElement" class="mt-4 p-3 bg-blue-50 rounded-lg border border-blue-200">
        <div class="flex items-center mb-2">
          <i class="fas fa-crosshairs text-blue-500 mr-2"></i>
          <span class="text-sm font-medium text-blue-800">å½“å‰é€‰ä¸­</span>
        </div>
        <div class="text-xs font-mono text-blue-700 bg-white p-2 rounded border">
          {{ getElementInfo(selectedElement) }}
        </div>
      </div>
      
      <!-- ä½¿ç”¨æç¤º -->
      <div class="mt-4 p-3 bg-gradient-to-r from-purple-50 to-pink-50 rounded-lg border border-purple-200">
        <div class="flex items-center mb-2">
          <i class="fas fa-lightbulb text-purple-500 mr-2"></i>
          <span class="text-sm font-medium text-purple-800">ä½¿ç”¨æç¤º</span>
        </div>
        <ul class="text-xs text-purple-700 space-y-1">
          <li class="flex items-center">
            <i class="fas fa-dot-circle text-purple-400 mr-2 text-xs"></i>
            å•å‡»é€‰æ‹©å…ƒç´ 
          </li>
          <li class="flex items-center">
            <i class="fas fa-dot-circle text-purple-400 mr-2 text-xs"></i>
            åŒå‡»å¿«é€Ÿç¼–è¾‘
          </li>
          <li class="flex items-center">
            <i class="fas fa-dot-circle text-purple-400 mr-2 text-xs"></i>
            AI ç¼–è¾‘æ™ºèƒ½ä¿®æ”¹æ ·å¼
          </li>
        </ul>
      </div>
    </div>
  </div>
</template>

<script setup>
const props = defineProps({
  elementPath: {
    type: Array,
    default: () => []
  },
  selectedElement: {
    type: Object,
    default: null
  }
})

const emit = defineEmits([
  'select-from-path',
  'open-ai-dialog',
  'open-rich-editor',
  'open-inline-editor'
])

const getElementInfo = (element) => {
  if (!element) return ''
  const tagName = element.tagName.toLowerCase()
  const className = element.className ? ` class="${element.className}"` : ''
  const id = element.id ? ` id="${element.id}"` : ''
  return `<${tagName}${id}${className}>`
}

const handleAIEdit = () => {
  if (props.selectedElement) {
    emit('open-ai-dialog')
  }
}

const handleRichEdit = () => {
  if (props.selectedElement) {
    emit('open-rich-editor')
  }
}

const handleInlineEdit = () => {
  if (props.selectedElement) {
    emit('open-inline-editor')
  }
}
</script>

<style lang="scss" scoped>
.fas {
  font-size: 14px;
}

.ai-edit-btn {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  border: none;
  color: white;
  transition: all 0.3s ease;
  
  &:hover:not(:disabled) {
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
  }
}

.rich-edit-btn {
  background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
  border: none;
  color: white;
  transition: all 0.3s ease;
  
  &:hover:not(:disabled) {
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(240, 147, 251, 0.4);
  }
}

.inline-edit-btn {
  background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
  border: none;
  color: white;
  transition: all 0.3s ease;
  
  &:hover:not(:disabled) {
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(79, 172, 254, 0.4);
  }
}

:deep(.ant-btn-large) {
  height: 44px;
  font-weight: 500;
}

:deep(.ant-tag) {
  border-radius: 6px;
  font-size: 11px;
  padding: 2px 8px;
}
</style>


================================================
FILE: frontend/src/view/editor/components/ToolBar.vue
================================================
<template>
  <div class="bg-gradient-to-r from-blue-600 to-purple-600 shadow-lg border-b px-6 py-3 flex items-center justify-between">
    <div class="flex items-center space-x-6">
      <div class="flex items-center">
        <i class="fas fa-code text-white text-xl mr-3"></i>
        <h1 class="text-xl font-bold text-white">HTML å¯è§†åŒ–ç¼–è¾‘å™¨</h1>
      </div>
    </div>

    <div class="flex items-center space-x-3">
      <a-button @click="$emit('import-html')" size="middle" title="å¯¼å…¥ HTML æ–‡ä»¶" class="action-btn import-btn">
        <template #icon>
          <i class="fas fa-upload"></i>
        </template>
        <span class="ml-1">å¯¼å…¥</span>
      </a-button>

      <a-button @click="$emit('save-file')" size="middle" title="ä¿å­˜æ–‡ä»¶" class="action-btn save-btn">
        <template #icon>
          <i class="fas fa-save"></i>
        </template>
        <span class="ml-1">ä¿å­˜</span>
      </a-button>

      <a-button @click="$emit('export-html')" size="middle" title="å¯¼å‡º HTML æ–‡ä»¶" class="action-btn export-btn">
        <template #icon>
          <i class="fas fa-download"></i>
        </template>
        <span class="ml-1">å¯¼å‡º</span>
      </a-button>

      <a-button @click="$emit('toggle-upload-area')" size="middle" title="æ˜¾ç¤º/éšè—ä¸Šä¼ åŒºåŸŸ" class="action-btn upload-btn">
        <template #icon>
          <i class="fas fa-cloud-upload-alt"></i>
        </template>
        <span class="ml-1">ä¸Šä¼ </span>
      </a-button>

      <a-button @click="$emit('toggle-code-panel')" size="middle" title="åˆ‡æ¢ä»£ç é¢æ¿" class="action-btn code-btn">
        <template #icon>
          <i class="fas fa-code"></i>
        </template>
        <span class="ml-1">ä»£ç </span>
      </a-button>

      <a-button @click="$emit('toggle-version-panel')" size="middle" title="åˆ‡æ¢ç‰ˆæœ¬å†å²é¢æ¿" class="action-btn version-btn">
        <template #icon>
          <i class="fas fa-history"></i>
        </template>
        <span class="ml-1">ç‰ˆæœ¬</span>
      </a-button>
    </div>
  </div>
</template>

<script setup>
defineEmits(["import-html", "export-html", "toggle-upload-area", "toggle-code-panel", "toggle-version-panel"]);
</script>

<style lang="scss" scoped>
.fas {
  font-size: 14px;
}

.history-btn {
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid rgba(255, 255, 255, 0.2);
  color: white;
  transition: all 0.3s ease;

  &:hover:not(:disabled) {
    background: rgba(255, 255, 255, 0.2);
    border-color: rgba(255, 255, 255, 0.3);
    transform: translateY(-1px);
  }

  &:disabled {
    background: rgba(255, 255, 255, 0.05);
    border-color: rgba(255, 255, 255, 0.1);
  }
}

.action-btn {
  background: white;
  border: none;
  color: #1f2937;
  font-weight: 500;
  transition: all 0.3s ease;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);

  &:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  }
}

.import-btn:hover {
  color: #059669;
  border-color: #059669;
}

.export-btn:hover {
  color: #dc2626;
  border-color: #dc2626;
}

.upload-btn:hover {
  color: #f59e0b;
  border-color: #f59e0b;
}

.code-btn:hover {
  color: #7c3aed;
  border-color: #7c3aed;
}

.version-btn:hover {
  color: #10b981;
  border-color: #10b981;
}

:deep(.ant-btn) {
  display: flex;
  align-items: center;
  justify-content: center;
}
</style>



================================================
FILE: frontend/src/view/editor/components/UploadStatus.vue
================================================
<template>
  <transition name="status-slide">
    <div v-if="visible" class="upload-status-container">
      <div 
        class="status-card"
        :class="{
          'status-success': status === 'success',
          'status-error': status === 'error',
          'status-warning': status === 'warning',
          'status-info': status === 'info'
        }"
      >
        <!-- çŠ¶æ€å›¾æ ‡ -->
        <div class="status-icon">
          <i 
            :class="{
              'fas fa-check-circle': status === 'success',
              'fas fa-exclamation-circle': status === 'error',
              'fas fa-exclamation-triangle': status === 'warning',
              'fas fa-info-circle': status === 'info'
            }"
          ></i>
        </div>
        
        <!-- çŠ¶æ€å†…å®¹ -->
        <div class="status-content">
          <h4 class="status-title">{{ title }}</h4>
          <p v-if="message" class="status-message">{{ message }}</p>
          
          <!-- æ–‡ä»¶åˆ—è¡¨ -->
          <div v-if="files && files.length > 0" class="file-list">
            <div 
              v-for="(file, index) in files"
              :key="index"
              class="file-item"
              :class="{ 'file-error': !file.success }"
            >
              <div class="file-info">
                <i class="fas fa-file-alt file-icon"></i>
                <span class="file-name">{{ file.filename }}</span>
                <span v-if="file.size" class="file-size">{{ formatFileSize(file.size) }}</span>
              </div>
              <div class="file-status">
                <i 
                  v-if="file.success"
                  class="fas fa-check text-green-500"
                ></i>
                <i 
                  v-else
                  class="fas fa-times text-red-500"
                  :title="file.error"
                ></i>
              </div>
            </div>
          </div>
          
          <!-- æ“ä½œæŒ‰é’® -->
          <div v-if="showActions" class="status-actions">
            <a-button 
              v-if="status === 'success' && onConfirm"
              type="primary" 
              size="small"
              @click="handleConfirm"
            >
              ç¡®è®¤
            </a-button>
            <a-button 
              v-if="onRetry"
              type="default" 
              size="small"
              @click="handleRetry"
            >
              é‡è¯•
            </a-button>
            <a-button 
              size="small"
              @click="handleClose"
            >
              å…³é—­
            </a-button>
          </div>
        </div>
        
        <!-- å…³é—­æŒ‰é’® -->
        <button class="status-close" @click="handleClose">
          <i class="fas fa-times"></i>
        </button>
      </div>
    </div>
  </transition>
</template>

<script setup>
import { ref, computed, watch } from 'vue'

const props = defineProps({
  visible: {
    type: Boolean,
    default: false
  },
  status: {
    type: String,
    default: 'info', // success, error, warning, info
    validator: (value) => ['success', 'error', 'warning', 'info'].includes(value)
  },
  title: {
    type: String,
    required: true
  },
  message: {
    type: String,
    default: ''
  },
  files: {
    type: Array,
    default: () => []
  },
  showActions: {
    type: Boolean,
    default: true
  },
  autoClose: {
    type: Boolean,
    default: false
  },
  autoCloseDelay: {
    type: Number,
    default: 3000
  },
  onConfirm: {
    type: Function,
    default: null
  },
  onRetry: {
    type: Function,
    default: null
  }
})

const emit = defineEmits(['close', 'confirm', 'retry'])

let autoCloseTimer = null

// ç›‘å¬visibleå˜åŒ–ï¼Œè‡ªåŠ¨å…³é—­
watch(() => props.visible, (newVal) => {
  if (newVal && props.autoClose) {
    autoCloseTimer = setTimeout(() => {
      handleClose()
    }, props.autoCloseDelay)
  } else if (!newVal && autoCloseTimer) {
    clearTimeout(autoCloseTimer)
    autoCloseTimer = null
  }
})

// æ ¼å¼åŒ–æ–‡ä»¶å¤§å°
const formatFileSize = (bytes) => {
  if (bytes === 0) return '0 B'
  
  const k = 1024
  const sizes = ['B', 'KB', 'MB', 'GB']
  const i = Math.floor(Math.log(bytes) / Math.log(k))
  
  return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i]
}

// å¤„ç†ç¡®è®¤
const handleConfirm = () => {
  if (props.onConfirm) {
    props.onConfirm()
  }
  emit('confirm')
}

// å¤„ç†é‡è¯•
const handleRetry = () => {
  if (props.onRetry) {
    props.onRetry()
  }
  emit('retry')
}

// å¤„ç†å…³é—­
const handleClose = () => {
  if (autoCloseTimer) {
    clearTimeout(autoCloseTimer)
    autoCloseTimer = null
  }
  emit('close')
}

// æ¸…ç†å®šæ—¶å™¨
const cleanup = () => {
  if (autoCloseTimer) {
    clearTimeout(autoCloseTimer)
    autoCloseTimer = null
  }
}

// ç»„ä»¶å¸è½½æ—¶æ¸…ç†
import { onUnmounted } from 'vue'
onUnmounted(() => {
  cleanup()
})
</script>

<style lang="scss" scoped>
.upload-status-container {
  position: fixed;
  top: 20px;
  right: 20px;
  z-index: 9999;
  max-width: 400px;
  min-width: 300px;
}

.status-card {
  background: white;
  border-radius: 12px;
  box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
  border-left: 4px solid;
  overflow: hidden;
  position: relative;
  animation: statusAppear 0.3s ease;
  
  &.status-success {
    border-left-color: #10b981;
    
    .status-icon i {
      color: #10b981;
    }
  }
  
  &.status-error {
    border-left-color: #ef4444;
    
    .status-icon i {
      color: #ef4444;
    }
  }
  
  &.status-warning {
    border-left-color: #f59e0b;
    
    .status-icon i {
      color: #f59e0b;
    }
  }
  
  &.status-info {
    border-left-color: #3b82f6;
    
    .status-icon i {
      color: #3b82f6;
    }
  }
}

.status-icon {
  position: absolute;
  top: 16px;
  left: 16px;
  
  i {
    font-size: 20px;
  }
}

.status-content {
  padding: 16px 50px 16px 48px;
}

.status-title {
  font-size: 16px;
  font-weight: 600;
  color: #374151;
  margin: 0 0 8px 0;
}

.status-message {
  font-size: 14px;
  color: #6b7280;
  margin: 0 0 12px 0;
  line-height: 1.4;
}

.file-list {
  margin: 12px 0;
}

.file-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 8px 12px;
  background: #f9fafb;
  border-radius: 6px;
  margin-bottom: 6px;
  transition: all 0.2s ease;
  
  &:last-child {
    margin-bottom: 0;
  }
  
  &.file-error {
    background: #fef2f2;
    border: 1px solid #fecaca;
  }
  
  &:hover {
    background: #f3f4f6;
    
    &.file-error {
      background: #fef2f2;
    }
  }
}

.file-info {
  display: flex;
  align-items: center;
  gap: 8px;
  flex: 1;
}

.file-icon {
  color: #6b7280;
  font-size: 12px;
}

.file-name {
  font-size: 13px;
  color: #374151;
  font-weight: 500;
  flex: 1;
  truncate: true;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.file-size {
  font-size: 11px;
  color: #9ca3af;
  font-weight: normal;
}

.file-status {
  margin-left: 8px;
  
  i {
    font-size: 12px;
  }
}

.status-actions {
  display: flex;
  gap: 8px;
  margin-top: 12px;
  padding-top: 12px;
  border-top: 1px solid #f3f4f6;
}

.status-close {
  position: absolute;
  top: 12px;
  right: 12px;
  width: 24px;
  height: 24px;
  border: none;
  background: transparent;
  color: #9ca3af;
  cursor: pointer;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 10px;
  transition: all 0.2s ease;
  
  &:hover {
    background: #f3f4f6;
    color: #6b7280;
  }
}

// åŠ¨ç”»
@keyframes statusAppear {
  from {
    opacity: 0;
    transform: translateX(100%);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

// è¿‡æ¸¡åŠ¨ç”»
.status-slide-enter-active,
.status-slide-leave-active {
  transition: all 0.3s ease;
}

.status-slide-enter-from {
  opacity: 0;
  transform: translateX(100%);
}

.status-slide-leave-to {
  opacity: 0;
  transform: translateX(100%);
}

// å“åº”å¼è®¾è®¡
@media (max-width: 640px) {
  .upload-status-container {
    left: 10px;
    right: 10px;
    max-width: none;
  }
  
  .status-content {
    padding: 14px 40px 14px 40px;
  }
  
  .status-title {
    font-size: 15px;
  }
  
  .status-message {
    font-size: 13px;
  }
}
</style>


================================================
FILE: frontend/src/view/editor/components/VersionActions.vue
================================================
<template>
  <div 
    class="version-actions-floating" 
    :class="{ 'dragging': isDragging }"
    :style="{ transform: `translate(${position.x}px, ${position.y}px)` }"
    ref="floatingPanel"
  >
    <div 
      class="version-controls" 
      :class="{ 'dragging': isDragging }"
      @mouseenter="handleMouseEnter" 
      @mouseleave="handleMouseLeave"
    >
      <!-- æ‹–æ‹½æ‰‹æŸ„ -->
      <div 
        class="drag-handle"
        @mousedown="startDrag"
        @touchstart="startDrag"
      >
        <i class="fas fa-grip-dots-vertical"></i>
      </div>

      <div class="control-buttons">
        <a-tooltip title="æ’¤é”€ (Ctrl+Z)" placement="left">
          <button 
            :disabled="!canUndo" 
            @click="$emit('undo')"
            :class="['control-btn', 'undo-btn', { 'disabled': !canUndo }]"
          >
            <i class="fas fa-undo"></i>
          </button>
        </a-tooltip>

        <a-tooltip title="é‡åš (Ctrl+Y)" placement="left">
          <button 
            :disabled="!canRedo" 
            @click="$emit('redo')"
            :class="['control-btn', 'redo-btn', { 'disabled': !canRedo }]"
          >
            <i class="fas fa-redo"></i>
          </button>
        </a-tooltip>
      </div>

      <div class="version-status-compact">
        <div class="status-indicator" :class="{ 'modified': hasUnsavedChanges }">
          <i class="fas fa-circle"></i>
        </div>
        <span class="version-text">{{ versionCount }}</span>
      </div>
    </div>

    <!-- è¯¦ç»†ä¿¡æ¯å±•å¼€ -->
    <Transition name="details">
      <div class="version-details" v-if="showDetails">
        <div class="detail-item">
          <span class="detail-label">ç‰ˆæœ¬æ•°é‡</span>
          <span class="detail-value">{{ versionCount }}</span>
        </div>
        <div class="detail-item">
          <span class="detail-label">ä¿å­˜çŠ¶æ€</span>
          <span class="detail-value" :class="{ 'modified': hasUnsavedChanges }">
            {{ hasUnsavedChanges ? 'æœªä¿å­˜' : 'å·²ä¿å­˜' }}
          </span>
        </div>
        <div class="detail-item" v-if="canUndo || canRedo">
          <span class="detail-label">æ“ä½œ</span>
          <span class="detail-value">
            <span v-if="canUndo" class="text-green-600">å¯æ’¤é”€</span>
            <span v-if="canUndo && canRedo" class="mx-1">Â·</span>
            <span v-if="canRedo" class="text-orange-600">å¯é‡åš</span>
          </span>
        </div>
      </div>
    </Transition>
  </div>
</template>

<script setup>
import { ref, reactive, onMounted, onUnmounted, nextTick } from 'vue'

defineProps({
  canUndo: {
    type: Boolean,
    default: false,
  },
  canRedo: {
    type: Boolean,
    default: false,
  },
  versionCount: {
    type: Number,
    default: 0,
  },
  hasUnsavedChanges: {
    type: Boolean,
    default: false,
  },
});

defineEmits(["undo", "redo"]);

const showDetails = ref(false)
const floatingPanel = ref(null)
const isDragging = ref(false)

// ä½ç½®çŠ¶æ€
const position = reactive({
  x: 0,
  y: 0
})

// æ‹–æ‹½çŠ¶æ€
const dragState = reactive({
  startX: 0,
  startY: 0,
  startPos: { x: 0, y: 0 }
})

// åˆå§‹åŒ–ä½ç½®
const initPosition = () => {
  // ä» localStorage è¯»å–ä¿å­˜çš„ä½ç½®ï¼Œæˆ–ä½¿ç”¨é»˜è®¤ä½ç½®
  const savedPosition = localStorage.getItem('version-actions-position')
  if (savedPosition) {
    try {
      const pos = JSON.parse(savedPosition)
      position.x = pos.x
      position.y = pos.y
    } catch (e) {
      // å¦‚æœè§£æå¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤ä½ç½®
      setDefaultPosition()
    }
  } else {
    setDefaultPosition()
  }
}

// è®¾ç½®é»˜è®¤ä½ç½®ï¼ˆå±å¹•å³ä¾§ä¸­å¤®ï¼‰
const setDefaultPosition = () => {
  position.x = window.innerWidth - 100
  position.y = window.innerHeight / 2 - 50
}

// ä¿å­˜ä½ç½®åˆ° localStorage
const savePosition = () => {
  localStorage.setItem('version-actions-position', JSON.stringify({
    x: position.x,
    y: position.y
  }))
}

// é™åˆ¶ä½ç½®åœ¨å±å¹•èŒƒå›´å†…
const constrainPosition = () => {
  const panel = floatingPanel.value
  if (!panel) return
  
  const rect = panel.getBoundingClientRect()
  const margin = 10
  
  // è·å–é¢æ¿å°ºå¯¸
  const panelWidth = rect.width
  const panelHeight = rect.height
  
  // è€ƒè™‘å¯èƒ½çš„è¯¦ç»†ä¿¡æ¯å±•å¼€åŒºåŸŸ
  const detailsWidth = 152 // è¯¦ç»†ä¿¡æ¯é¢æ¿çš„å®½åº¦åŠ ä¸Šè¾¹è·
  const leftConstraint = showDetails.value ? margin + detailsWidth : margin
  
  // é™åˆ¶åœ¨å±å¹•èŒƒå›´å†…ï¼Œç¡®ä¿è¯¦ç»†ä¿¡æ¯é¢æ¿ä¹Ÿèƒ½å®Œå…¨æ˜¾ç¤º
  position.x = Math.max(leftConstraint, Math.min(window.innerWidth - panelWidth - margin, position.x))
  position.y = Math.max(margin, Math.min(window.innerHeight - panelHeight - margin, position.y))
}

// å¼€å§‹æ‹–æ‹½
const startDrag = (e) => {
  e.preventDefault()
  isDragging.value = true
  
  const clientX = e.type === 'touchstart' ? e.touches[0].clientX : e.clientX
  const clientY = e.type === 'touchstart' ? e.touches[0].clientY : e.clientY
  
  dragState.startX = clientX
  dragState.startY = clientY
  dragState.startPos = { x: position.x, y: position.y }
  
  document.addEventListener('mousemove', onDrag)
  document.addEventListener('mouseup', stopDrag)
  document.addEventListener('touchmove', onDrag, { passive: false })
  document.addEventListener('touchend', stopDrag)
  
  // æ·»åŠ æ‹–æ‹½ä¸­çš„æ ·å¼
  document.body.style.userSelect = 'none'
  document.body.style.cursor = 'grabbing'
}

// æ‹–æ‹½ä¸­
const onDrag = (e) => {
  if (!isDragging.value) return
  
  e.preventDefault()
  
  const clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX
  const clientY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY
  
  const deltaX = clientX - dragState.startX
  const deltaY = clientY - dragState.startY
  
  position.x = dragState.startPos.x + deltaX
  position.y = dragState.startPos.y + deltaY
  
  constrainPosition()
}

// åœæ­¢æ‹–æ‹½
const stopDrag = () => {
  isDragging.value = false
  
  document.removeEventListener('mousemove', onDrag)
  document.removeEventListener('mouseup', stopDrag)
  document.removeEventListener('touchmove', onDrag)
  document.removeEventListener('touchend', stopDrag)
  
  // ç§»é™¤æ‹–æ‹½æ ·å¼
  document.body.style.userSelect = ''
  document.body.style.cursor = ''
  
  // ä¿å­˜ä½ç½®
  savePosition()
}

// é¼ æ ‡è¿›å…¥å¤„ç†
const handleMouseEnter = () => {
  if (!isDragging.value) {
    showDetails.value = true
  }
}

// é¼ æ ‡ç¦»å¼€å¤„ç†
const handleMouseLeave = () => {
  if (!isDragging.value) {
    showDetails.value = false
  }
}

// çª—å£å¤§å°æ”¹å˜æ—¶é‡æ–°è°ƒæ•´ä½ç½®
const handleResize = () => {
  nextTick(() => {
    constrainPosition()
    savePosition()
  })
}

onMounted(() => {
  initPosition()
  window.addEventListener('resize', handleResize)
})

onUnmounted(() => {
  window.removeEventListener('resize', handleResize)
  document.removeEventListener('mousemove', onDrag)
  document.removeEventListener('mouseup', stopDrag)
  document.removeEventListener('touchmove', onDrag)
  document.removeEventListener('touchend', stopDrag)
})
</script>

<style lang="scss" scoped>
.version-actions-floating {
  position: fixed;
  top: 0;
  left: 0;
  z-index: 100;
  transition: transform 0.1s ease-out;
  
  &:not(.dragging) {
    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  }
  
  .version-controls {
    position: relative;
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(12px);
    border: 1px solid rgba(226, 232, 240, 0.6);
    border-radius: 16px;
    padding: 8px 8px 12px 8px;
    box-shadow: 
      0 10px 25px rgba(0, 0, 0, 0.1),
      0 4px 12px rgba(0, 0, 0, 0.05);
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    
    &:hover {
      background: rgba(255, 255, 255, 0.98);
      box-shadow: 
        0 20px 35px rgba(0, 0, 0, 0.15),
        0 8px 20px rgba(0, 0, 0, 0.08);
      transform: scale(1.02);
    }
    
    &.dragging {
      transform: scale(1.05) rotate(2deg);
      box-shadow: 
        0 25px 50px rgba(0, 0, 0, 0.25),
        0 12px 30px rgba(0, 0, 0, 0.15);
      z-index: 1000;
    }
  }
  
  .drag-handle {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 100%;
    height: 20px;
    cursor: grab;
    color: #94a3b8;
    font-size: 12px;
    transition: all 0.2s ease;
    border-radius: 6px;
    margin-bottom: 4px;
    position: relative;
    
    &::before {
      content: '';
      position: absolute;
      width: 100%;
      height: 100%;
      background: linear-gradient(45deg, transparent 30%, rgba(148, 163, 184, 0.1) 30%, rgba(148, 163, 184, 0.1) 70%, transparent 70%);
      opacity: 0;
      transition: opacity 0.3s ease;
      border-radius: 6px;
    }
    
    &:hover {
      color: #64748b;
      background: rgba(148, 163, 184, 0.1);
      
      &::before {
        opacity: 1;
      }
    }
    
    &:active {
      cursor: grabbing;
      background: rgba(148, 163, 184, 0.2);
      transform: scale(1.05);
      
      &::before {
        opacity: 0.8;
      }
    }
    
    i {
      transform: rotate(90deg);
      position: relative;
      z-index: 1;
    }
  }

  .control-buttons {
    display: flex;
    flex-direction: column;
    gap: 8px;
  }
  
  .control-btn {
    width: 44px;
    height: 44px;
    border: none;
    border-radius: 12px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    font-size: 16px;
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    position: relative;
    overflow: hidden;
    
    &::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(255, 255, 255, 0.1);
      opacity: 0;
      transition: opacity 0.2s ease;
    }
    
    &:hover:not(.disabled) {
      transform: translateY(-2px) scale(1.05);
      box-shadow: 
        0 8px 25px rgba(102, 126, 234, 0.4),
        0 4px 12px rgba(102, 126, 234, 0.2);
        
      &::before {
        opacity: 1;
      }
    }
    
    &:active:not(.disabled) {
      transform: translateY(-1px) scale(1.02);
    }
    
    &.disabled {
      background: #f1f5f9;
      color: #cbd5e1;
      cursor: not-allowed;
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.06);
      
      &:hover {
        transform: none;
        box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.06);
      }
    }
    
    &.undo-btn:not(.disabled) {
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      
      &:hover {
        box-shadow: 
          0 8px 25px rgba(16, 185, 129, 0.4),
          0 4px 12px rgba(16, 185, 129, 0.2);
      }
    }
    
    &.redo-btn:not(.disabled) {
      background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
      
      &:hover {
        box-shadow: 
          0 8px 25px rgba(245, 158, 11, 0.4),
          0 4px 12px rgba(245, 158, 11, 0.2);
      }
    }
    
    i {
      position: relative;
      z-index: 1;
    }
  }
  
  .version-status-compact {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 4px;
  }
  
  .status-indicator {
    font-size: 8px;
    color: #10b981;
    transition: all 0.2s ease;
    
    &.modified {
      color: #f59e0b;
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }
  }
  
  .version-text {
    font-size: 11px;
    font-weight: 600;
    color: #64748b;
    text-align: center;
  }
  
  .version-details {
    position: absolute;
    right: 100%;
    top: 0;
    margin-right: 12px;
    padding: 12px;
    background: rgba(255, 255, 255, 0.98);
    backdrop-filter: blur(12px);
    border-radius: 12px;
    border: 1px solid rgba(226, 232, 240, 0.6);
    min-width: 140px;
    box-shadow: 
      0 10px 25px rgba(0, 0, 0, 0.15),
      0 4px 12px rgba(0, 0, 0, 0.08);
  }
  
  .detail-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 4px;
    
    &:last-child {
      margin-bottom: 0;
    }
  }
  
  .detail-label {
    font-size: 10px;
    color: #94a3b8;
    font-weight: 500;
  }
  
  .detail-value {
    font-size: 10px;
    font-weight: 600;
    color: #10b981;
    
    &.modified {
      color: #f59e0b;
    }
  }
}

// è¿‡æ¸¡åŠ¨ç”»
.details-enter-active, .details-leave-active {
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.details-enter-from {
  opacity: 0;
  transform: translateX(10px) scale(0.95);
}

.details-leave-to {
  opacity: 0;
  transform: translateX(10px) scale(0.95);
}

// å“åº”å¼è®¾è®¡
@media (max-width: 768px) {
  .version-actions-floating {
    position: fixed;
    bottom: 20px;
    right: 50%;
    top: auto;
    transform: translateX(50%);
    
    .version-controls {
      flex-direction: row;
      padding: 8px 16px;
      border-radius: 24px;
      
      &:hover {
        transform: scale(1.05);
      }
    }
    
    .control-buttons {
      flex-direction: row;
    }
    
    .control-btn {
      width: 36px;
      height: 36px;
      font-size: 14px;
    }
    
    .version-details {
      position: static;
      margin: 8px 0 0 0;
      width: 100%;
    }
  }
}

@media (max-width: 480px) {
  .version-actions-floating {
    .control-btn {
      width: 32px;
      height: 32px;
      font-size: 12px;
    }
  }
}
</style>



================================================
FILE: frontend/src/view/editor/components/VersionHistoryPanel.vue
================================================
<template>
  <div class="version-history-panel">
    <!-- é¢æ¿å¤´éƒ¨ -->
    <div class="panel-header">
      <div class="flex items-center">
        <div class="w-6 h-6 bg-gradient-to-r from-green-500 to-blue-500 rounded flex items-center justify-center mr-2">
          <i class="fas fa-history text-white text-xs"></i>
        </div>
        <h3 class="font-semibold text-gray-800">ç‰ˆæœ¬å†å²</h3>
        <span class="ml-2 text-xs px-2 py-0.5 bg-gray-100 text-gray-600 rounded-full">
          {{ versionCount }} ä¸ªç‰ˆæœ¬
        </span>
      </div>
      
      <div class="flex items-center gap-1">
        <a-tooltip title="å¯¼å‡ºå†å²">
          <a-button type="text" size="small" @click="exportHistory">
            <template #icon>
              <i class="fas fa-download"></i>
            </template>
          </a-button>
        </a-tooltip>
        
        <a-tooltip title="å¯¼å…¥å†å²">
          <a-button type="text" size="small" @click="triggerImportHistory">
            <template #icon>
              <i class="fas fa-upload"></i>
            </template>
          </a-button>
        </a-tooltip>
        
        <a-tooltip title="æ¸…ç†å†å²">
          <a-button type="text" size="small" @click="confirmClearHistory">
            <template #icon>
              <i class="fas fa-trash-alt"></i>
            </template>
          </a-button>
        </a-tooltip>
        
        <a-tooltip title="æŠ˜å é¢æ¿">
          <a-button type="text" size="small" @click="toggleCollapse">
            <template #icon>
              <i :class="collapsed ? 'fas fa-chevron-down' : 'fas fa-chevron-up'"></i>
            </template>
          </a-button>
        </a-tooltip>
      </div>
    </div>
    
    <!-- é¢æ¿å†…å®¹ -->
    <div v-show="!collapsed" class="panel-content">
      <!-- ç»Ÿè®¡ä¿¡æ¯ -->
      <div class="stats-section">
        <div class="stats-grid">
          <div class="stat-item">
            <i class="fas fa-check-circle text-green-500"></i>
            <span class="stat-value">{{ hasUnsavedChanges ? 'æœªä¿å­˜' : 'å·²ä¿å­˜' }}</span>
          </div>
          <div class="stat-item">
            <i class="fas fa-clock text-blue-500"></i>
            <span class="stat-value">{{ formatRelativeTime(currentVersion?.timestamp) }}</span>
          </div>
        </div>
      </div>
      
      <!-- ç‰ˆæœ¬åˆ—è¡¨ -->
      <div class="version-list">
        <div 
          v-for="(version, index) in versionHistory" 
          :key="version.id"
          class="version-item"
          :class="{
            'current': version.isCurrent,
            'saved': version.isSaved,
            'hover:bg-gray-50': !version.isCurrent
          }"
          @click="goToVersion(index)"
        >
          <div class="version-info">
            <div class="version-header">
              <div class="flex items-center">
                <div class="version-indicator">
                  <i v-if="version.isCurrent" class="fas fa-arrow-right text-blue-500"></i>
                  <i v-else-if="version.isSaved" class="fas fa-save text-green-500"></i>
                  <div v-else class="version-dot"></div>
                </div>
                <span class="version-action">{{ version.action }}</span>
              </div>
              <div class="version-meta">
                <span class="version-time">{{ formatTime(version.timestamp) }}</span>
                <span class="version-size">{{ formatFileSize(version.metadata.contentLength) }}</span>
              </div>
            </div>
            
            <div class="version-details">
              <span class="version-index">#{{ index + 1 }}</span>
              <div class="version-tags">
                <span v-if="version.isCurrent" class="tag current-tag">å½“å‰</span>
                <span v-if="version.isSaved" class="tag saved-tag">å·²ä¿å­˜</span>
                <span v-if="version.metadata.source" class="tag source-tag">{{ version.metadata.source }}</span>
              </div>
            </div>
          </div>
          
          <div class="version-actions">
            <a-tooltip title="æŸ¥çœ‹è¯¦æƒ…">
              <a-button type="text" size="small" @click.stop="showVersionDetails(version, index)">
                <template #icon>
                  <i class="fas fa-info-circle"></i>
                </template>
              </a-button>
            </a-tooltip>
            
            <a-tooltip title="æ¯”è¾ƒç‰ˆæœ¬" v-if="selectedVersions.length < 2">
              <a-button 
                type="text" 
                size="small" 
                :class="{ 'text-blue-500': selectedVersions.includes(index) }"
                @click.stop="toggleVersionSelection(index)"
              >
                <template #icon>
                  <i class="fas fa-code-compare"></i>
                </template>
              </a-button>
            </a-tooltip>
          </div>
        </div>
        
        <div v-if="versionHistory.length === 0" class="empty-state">
          <i class="fas fa-history text-gray-400 text-2xl mb-2"></i>
          <p class="text-gray-500 text-sm">æš‚æ— ç‰ˆæœ¬å†å²</p>
        </div>
      </div>
      
      <!-- ç‰ˆæœ¬æ¯”è¾ƒ -->
      <div v-if="selectedVersions.length === 2" class="version-compare">
        <div class="compare-header">
          <h4 class="font-medium">ç‰ˆæœ¬æ¯”è¾ƒ</h4>
          <a-button type="text" size="small" @click="clearSelection">
            <template #icon>
              <i class="fas fa-times"></i>
            </template>
          </a-button>
        </div>
        
        <div class="compare-content">
          <div v-if="compareResult" class="compare-stats">
            <div class="compare-stat">
              <span class="stat-label">ç›¸ä¼¼åº¦</span>
              <span class="stat-value">{{ Math.round(compareResult.contentDiff.similarity * 100) }}%</span>
            </div>
            <div class="compare-stat">
              <span class="stat-label">æ—¶é—´å·®</span>
              <span class="stat-value">{{ formatDuration(compareResult.timeDiff) }}</span>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- ç‰ˆæœ¬è¯¦æƒ…æ¨¡æ€æ¡† -->
    <a-modal
      v-model:open="showDetailsModal"
      title="ç‰ˆæœ¬è¯¦æƒ…"
      width="600px"
      :footer="null"
    >
      <div v-if="selectedVersionDetail" class="version-detail-content">
        <div class="detail-section">
          <h4 class="detail-title">åŸºæœ¬ä¿¡æ¯</h4>
          <div class="detail-grid">
            <div class="detail-item">
              <span class="detail-label">ç‰ˆæœ¬å·</span>
              <span class="detail-value">#{{ selectedVersionIndex + 1 }}</span>
            </div>
            <div class="detail-item">
              <span class="detail-label">æ“ä½œç±»å‹</span>
              <span class="detail-value">{{ selectedVersionDetail.action }}</span>
            </div>
            <div class="detail-item">
              <span class="detail-label">åˆ›å»ºæ—¶é—´</span>
              <span class="detail-value">{{ formatFullTime(selectedVersionDetail.timestamp) }}</span>
            </div>
            <div class="detail-item">
              <span class="detail-label">å†…å®¹å¤§å°</span>
              <span class="detail-value">{{ formatFileSize(selectedVersionDetail.metadata.contentLength) }}</span>
            </div>
          </div>
        </div>
        
        <div class="detail-section">
          <h4 class="detail-title">å†…å®¹é¢„è§ˆ</h4>
          <div class="content-preview">
            <pre class="preview-text">{{ getContentPreview(selectedVersionDetail.content) }}</pre>
          </div>
        </div>
      </div>
    </a-modal>
    
    <!-- éšè—çš„æ–‡ä»¶è¾“å…¥ -->
    <input 
      ref="fileInputRef"
      type="file"
      accept=".json"
      style="display: none"
      @change="handleImportFile"
    />
  </div>
</template>

<script setup>
import { ref, computed, watch } from 'vue'
import { Modal, message } from 'ant-design-vue'

const props = defineProps({
  versionManager: {
    type: Object,
    required: true
  }
})

const emit = defineEmits(['version-change', 'export-history', 'import-history'])

const collapsed = ref(false)
const selectedVersions = ref([])
const compareResult = ref(null)
const showDetailsModal = ref(false)
const selectedVersionDetail = ref(null)
const selectedVersionIndex = ref(-1)
const fileInputRef = ref(null)

// ä½¿ç”¨ä¼ å…¥çš„ç‰ˆæœ¬ç®¡ç†å™¨
const {
  versionCount,
  hasUnsavedChanges,
  currentVersion,
  getVersionHistory,
  goToVersion: goToVersionManager,
  compareVersions,
  clearHistory,
  exportVersionHistory,
  importVersionHistory
} = props.versionManager

// ç‰ˆæœ¬å†å²åˆ—è¡¨
const versionHistory = computed(() => getVersionHistory())

// åˆ‡æ¢æŠ˜å çŠ¶æ€
const toggleCollapse = () => {
  collapsed.value = !collapsed.value
}

// è·³è½¬åˆ°æŒ‡å®šç‰ˆæœ¬
const goToVersion = (index) => {
  const version = goToVersionManager(index)
  if (version) {
    emit('version-change', version)
  }
}

// é€‰æ‹©ç‰ˆæœ¬è¿›è¡Œæ¯”è¾ƒ
const toggleVersionSelection = (index) => {
  const existingIndex = selectedVersions.value.indexOf(index)
  if (existingIndex > -1) {
    selectedVersions.value.splice(existingIndex, 1)
  } else if (selectedVersions.value.length < 2) {
    selectedVersions.value.push(index)
  }
  
  // å¦‚æœé€‰æ‹©äº†ä¸¤ä¸ªç‰ˆæœ¬ï¼Œè¿›è¡Œæ¯”è¾ƒ
  if (selectedVersions.value.length === 2) {
    const [index1, index2] = selectedVersions.value.sort((a, b) => a - b)
    compareResult.value = compareVersions(index1, index2)
  } else {
    compareResult.value = null
  }
}

// æ¸…é™¤ç‰ˆæœ¬é€‰æ‹©
const clearSelection = () => {
  selectedVersions.value = []
  compareResult.value = null
}

// æ˜¾ç¤ºç‰ˆæœ¬è¯¦æƒ…
const showVersionDetails = (version, index) => {
  selectedVersionDetail.value = version
  selectedVersionIndex.value = index
  showDetailsModal.value = true
}

// ç¡®è®¤æ¸…ç†å†å²
const confirmClearHistory = () => {
  Modal.confirm({
    title: 'ç¡®è®¤æ¸…ç†å†å²',
    content: 'æ­¤æ“ä½œå°†åˆ é™¤æ‰€æœ‰ç‰ˆæœ¬å†å²è®°å½•ï¼ˆå½“å‰ç‰ˆæœ¬é™¤å¤–ï¼‰ï¼Œä¸”ä¸å¯æ¢å¤ã€‚ç¡®å®šè¦ç»§ç»­å—ï¼Ÿ',
    okText: 'ç¡®å®š',
    cancelText: 'å–æ¶ˆ',
    onOk() {
      clearHistory()
      clearSelection()
    }
  })
}

// å¯¼å‡ºå†å²
const exportHistory = () => {
  try {
    exportVersionHistory()
    emit('export-history')
  } catch (error) {
    message.error('å¯¼å‡ºå¤±è´¥: ' + error.message)
  }
}

// è§¦å‘å¯¼å…¥æ–‡ä»¶é€‰æ‹©
const triggerImportHistory = () => {
  fileInputRef.value?.click()
}

// å¤„ç†å¯¼å…¥æ–‡ä»¶
const handleImportFile = (event) => {
  const file = event.target.files[0]
  if (!file) return
  
  const reader = new FileReader()
  reader.onload = (e) => {
    try {
      const jsonData = e.target.result
      if (importVersionHistory(jsonData)) {
        emit('import-history')
        clearSelection()
      }
    } catch (error) {
      message.error('å¯¼å…¥å¤±è´¥: ' + error.message)
    }
  }
  reader.readAsText(file)
  
  // æ¸…ç©ºæ–‡ä»¶è¾“å…¥
  event.target.value = ''
}

// æ ¼å¼åŒ–æ—¶é—´
const formatTime = (timestamp) => {
  if (!timestamp) return ''
  return new Date(timestamp).toLocaleTimeString('zh-CN', {
    hour: '2-digit',
    minute: '2-digit'
  })
}

// æ ¼å¼åŒ–å®Œæ•´æ—¶é—´
const formatFullTime = (timestamp) => {
  if (!timestamp) return ''
  return new Date(timestamp).toLocaleString('zh-CN')
}

// æ ¼å¼åŒ–ç›¸å¯¹æ—¶é—´
const formatRelativeTime = (timestamp) => {
  if (!timestamp) return ''
  
  const now = new Date()
  const time = new Date(timestamp)
  const diff = now - time
  
  const minutes = Math.floor(diff / 60000)
  const hours = Math.floor(diff / 3600000)
  const days = Math.floor(diff / 86400000)
  
  if (minutes < 1) return 'åˆšåˆš'
  if (minutes < 60) return `${minutes}åˆ†é’Ÿå‰`
  if (hours < 24) return `${hours}å°æ—¶å‰`
  if (days < 7) return `${days}å¤©å‰`
  return formatTime(timestamp)
}

// æ ¼å¼åŒ–æŒç»­æ—¶é—´
const formatDuration = (ms) => {
  const minutes = Math.floor(ms / 60000)
  const hours = Math.floor(ms / 3600000)
  const days = Math.floor(ms / 86400000)
  
  if (minutes < 60) return `${minutes}åˆ†é’Ÿ`
  if (hours < 24) return `${hours}å°æ—¶`
  return `${days}å¤©`
}

// æ ¼å¼åŒ–æ–‡ä»¶å¤§å°
const formatFileSize = (bytes) => {
  if (bytes === 0) return '0 B'
  
  const k = 1024
  const sizes = ['B', 'KB', 'MB']
  const i = Math.floor(Math.log(bytes) / Math.log(k))
  
  return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i]
}

// è·å–å†…å®¹é¢„è§ˆ
const getContentPreview = (content) => {
  if (!content) return ''
  return content.length > 200 ? content.substring(0, 200) + '...' : content
}

// ç›‘å¬ç‰ˆæœ¬å˜åŒ–ï¼Œè‡ªåŠ¨æ¸…é™¤é€‰æ‹©
watch(versionHistory, () => {
  clearSelection()
})
</script>

<style lang="scss" scoped>
.version-history-panel {
  width: 100%;
  height: 100%;
  background: white;
  border-left: 1px solid #e5e7eb;
  display: flex;
  flex-direction: column;
}

.panel-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px 16px;
  border-bottom: 1px solid #e5e7eb;
  background: #f9fafb;
}

.panel-content {
  flex: 1;
  overflow: hidden;
  display: flex;
  flex-direction: column;
}

.stats-section {
  padding: 12px 16px;
  border-bottom: 1px solid #f3f4f6;
}

.stats-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
}

.stat-item {
  display: flex;
  align-items: center;
  gap: 6px;
  
  .stat-value {
    font-size: 12px;
    color: #6b7280;
    font-weight: 500;
  }
}

.version-list {
  flex: 1;
  overflow-y: auto;
  padding: 8px 0;
}

.version-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 8px 16px;
  cursor: pointer;
  transition: all 0.2s ease;
  
  &.current {
    background: #eff6ff;
    border-left: 3px solid #3b82f6;
  }
  
  &:hover {
    background: #f9fafb;
  }
}

.version-info {
  flex: 1;
  min-width: 0;
}

.version-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 4px;
}

.version-indicator {
  width: 16px;
  display: flex;
  align-items: center;
  justify-content: center;
  margin-right: 8px;
  
  .version-dot {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background: #d1d5db;
  }
}

.version-action {
  font-size: 13px;
  font-weight: 500;
  color: #374151;
  flex: 1;
  min-width: 0;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.version-meta {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 11px;
  color: #9ca3af;
}

.version-details {
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.version-index {
  font-size: 11px;
  color: #9ca3af;
  font-family: monospace;
}

.version-tags {
  display: flex;
  gap: 4px;
}

.tag {
  font-size: 10px;
  padding: 1px 4px;
  border-radius: 2px;
  font-weight: 500;
  
  &.current-tag {
    background: #dbeafe;
    color: #1d4ed8;
  }
  
  &.saved-tag {
    background: #d1fae5;
    color: #065f46;
  }
  
  &.source-tag {
    background: #f3e8ff;
    color: #7c3aed;
  }
}

.version-actions {
  display: flex;
  gap: 2px;
  margin-left: 8px;
}

.empty-state {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 40px 20px;
}

.version-compare {
  border-top: 1px solid #e5e7eb;
  padding: 12px 16px;
  background: #f9fafb;
}

.compare-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 8px;
  
  h4 {
    font-size: 13px;
    font-weight: 600;
    color: #374151;
  }
}

.compare-stats {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
}

.compare-stat {
  display: flex;
  align-items: center;
  justify-content: space-between;
  
  .stat-label {
    font-size: 11px;
    color: #6b7280;
  }
  
  .stat-value {
    font-size: 11px;
    font-weight: 600;
    color: #374151;
  }
}

.version-detail-content {
  .detail-section {
    margin-bottom: 20px;
    
    &:last-child {
      margin-bottom: 0;
    }
  }
  
  .detail-title {
    font-size: 14px;
    font-weight: 600;
    color: #374151;
    margin-bottom: 12px;
  }
  
  .detail-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 12px;
  }
  
  .detail-item {
    display: flex;
    flex-direction: column;
    
    .detail-label {
      font-size: 11px;
      color: #6b7280;
      margin-bottom: 2px;
    }
    
    .detail-value {
      font-size: 13px;
      color: #374151;
      font-weight: 500;
    }
  }
  
  .content-preview {
    background: #f9fafb;
    border: 1px solid #e5e7eb;
    border-radius: 6px;
    padding: 12px;
    max-height: 200px;
    overflow-y: auto;
    
    .preview-text {
      font-size: 11px;
      line-height: 1.4;
      color: #374151;
      margin: 0;
      white-space: pre-wrap;
      font-family: 'Monaco', 'Menlo', monospace;
    }
  }
}

// å“åº”å¼è®¾è®¡
@media (max-width: 768px) {
  .stats-grid {
    grid-template-columns: 1fr;
  }
  
  .detail-grid {
    grid-template-columns: 1fr;
  }
  
  .compare-stats {
    grid-template-columns: 1fr;
  }
}
</style>


================================================
FILE: frontend/src/view/editor/components/media/AIGeneratePanel.vue
================================================
<template>
  <div class="ai-generate-panel">
    <!-- æè¿°è¾“å…¥åŒºåŸŸ -->
    <div class="prompt-section">
      <div class="section-title">
        <i class="fas fa-magic text-purple-500 mr-2"></i>
        <span>AIç”Ÿå›¾æè¿°</span>
      </div>
      
      <div class="prompt-input-area">
        <a-textarea 
          v-model:value="promptText"
          placeholder="æè¿°ä½ æƒ³è¦çš„å›¾ç‰‡ï¼Œä¾‹å¦‚ï¼šä¸€åªå¯çˆ±çš„æ©™è‰²å°çŒ«ååœ¨é˜³å…‰æ˜åªšçš„çª—å°ä¸Šï¼ŒèƒŒæ™¯æ˜¯ç»¿è‰²æ¤ç‰©ï¼Œå¡é€šé£æ ¼ï¼Œé«˜è´¨é‡"
          :rows="4"
          :maxlength="500"
          show-count
          class="prompt-textarea"
        />
        
        <div class="prompt-actions">
          <a-space>
            <a-button @click="clearPrompt" size="small">
              <template #icon><i class="fas fa-eraser"></i></template>
              æ¸…ç©º
            </a-button>
            <a-button @click="optimizePrompt" size="small" :loading="optimizing">
              <template #icon><i class="fas fa-sparkles"></i></template>
              ä¼˜åŒ–æè¿°
            </a-button>
          </a-space>
        </div>
      </div>

      <!-- å¿«é€Ÿæç¤ºè¯ -->
      <div class="quick-prompts">
        <div class="prompts-label">å¿«é€Ÿæç¤ºè¯:</div>
        <a-space wrap>
          <a-tag 
            v-for="prompt in quickPrompts" 
            :key="prompt"
            class="prompt-tag"
            @click="selectQuickPrompt(prompt)"
          >
            {{ prompt }}
          </a-tag>
        </a-space>
      </div>
    </div>

    <!-- ç”Ÿæˆå‚æ•° -->
    <div class="params-section">
      <div class="section-title">
        <i class="fas fa-sliders-h text-blue-500 mr-2"></i>
        <span>ç”Ÿæˆå‚æ•°</span>
      </div>

      <div class="params-grid">
        <div class="param-group">
          <label class="param-label">é£æ ¼:</label>
          <a-select v-model:value="style" size="small" class="param-select">
            <a-select-option value="realistic">å†™å®</a-select-option>
            <a-select-option value="cartoon">å¡é€š</a-select-option>
            <a-select-option value="anime">åŠ¨æ¼«</a-select-option>
            <a-select-option value="painting">ç»˜ç”»</a-select-option>
            <a-select-option value="sketch">ç´ æ</a-select-option>
          </a-select>
        </div>

        <div class="param-group">
          <label class="param-label">å°ºå¯¸:</label>
          <a-select v-model:value="size" size="small" class="param-select">
            <a-select-option value="512x512">æ­£æ–¹å½¢ (512Ã—512)</a-select-option>
            <a-select-option value="768x512">æ¨ªå‘ (768Ã—512)</a-select-option>
            <a-select-option value="512x768">ç«–å‘ (512Ã—768)</a-select-option>
            <a-select-option value="1024x1024">é«˜æ¸…æ­£æ–¹å½¢ (1024Ã—1024)</a-select-option>
          </a-select>
        </div>

        <div class="param-group">
          <label class="param-label">è´¨é‡:</label>
          <a-select v-model:value="quality" size="small" class="param-select">
            <a-select-option value="standard">æ ‡å‡†</a-select-option>
            <a-select-option value="high">é«˜è´¨é‡</a-select-option>
            <a-select-option value="ultra">è¶…é«˜è´¨é‡</a-select-option>
          </a-select>
        </div>

        <div class="param-group">
          <label class="param-label">æ•°é‡:</label>
          <a-select v-model:value="count" size="small" class="param-select">
            <a-select-option :value="1">1å¼ </a-select-option>
            <a-select-option :value="2">2å¼ </a-select-option>
            <a-select-option :value="4">4å¼ </a-select-option>
          </a-select>
        </div>
      </div>
    </div>

    <!-- ç”ŸæˆæŒ‰é’® -->
    <div class="generate-section">
      <a-button 
        type="primary" 
        size="large" 
        :loading="generating"
        :disabled="!promptText.trim()"
        @click="handleGenerate"
        class="generate-btn"
      >
        <template #icon>
          <i class="fas fa-magic"></i>
        </template>
        {{ generating ? 'æ­£åœ¨ç”Ÿæˆä¸­...' : 'AIç”Ÿæˆå›¾ç‰‡' }}
      </a-button>
      
      <div class="generate-cost">
        <i class="fas fa-coins text-yellow-500 mr-1"></i>
        <span class="text-sm text-gray-600">é¢„è®¡æ¶ˆè€— {{ estimatedCost }} ç§¯åˆ†</span>
      </div>
    </div>

    <!-- ç”Ÿæˆç»“æœ -->
    <div v-if="generatedImages.length > 0 || generating" class="results-section">
      <div class="section-title">
        <i class="fas fa-images text-green-500 mr-2"></i>
        <span>ç”Ÿæˆç»“æœ</span>
      </div>

      <!-- ç”Ÿæˆä¸­çŠ¶æ€ -->
      <div v-if="generating" class="generating-state">
        <div class="progress-container">
          <a-spin size="large" />
          <div class="progress-text">
            <p class="text-lg font-medium text-gray-700 mb-2">AIæ­£åœ¨åˆ›ä½œä¸­...</p>
            <p class="text-sm text-gray-500">{{ progressText }}</p>
          </div>
          <div class="progress-bar">
            <div class="progress-fill" :style="{ width: progress + '%' }"></div>
          </div>
        </div>
      </div>

      <!-- ç”Ÿæˆç»“æœç½‘æ ¼ -->
      <div v-else class="results-grid">
        <div 
          v-for="(image, index) in generatedImages" 
          :key="index"
          class="result-item"
          :class="{ selected: selectedImage?.index === index }"
          @click="selectImage(image, index)"
        >
          <div class="image-wrapper">
            <img 
              :src="image.url" 
              :alt="`ç”Ÿæˆå›¾ç‰‡ ${index + 1}`"
              class="result-image"
              @load="handleImageLoad"
              @error="handleImageError"
            />
            <div class="image-overlay">
              <div class="image-actions">
                <a-button type="text" size="small" @click.stop="previewImage(image, index)">
                  <template #icon><i class="fas fa-eye text-white"></i></template>
                </a-button>
                <a-button type="text" size="small" @click.stop="downloadImage(image)">
                  <template #icon><i class="fas fa-download text-white"></i></template>
                </a-button>
                <a-button type="text" size="small" @click.stop="selectImage(image, index)">
                  <template #icon><i class="fas fa-check text-white"></i></template>
                </a-button>
              </div>
            </div>
          </div>
          
          <div class="image-info">
            <div class="image-size">{{ image.width }} Ã— {{ image.height }}</div>
            <div class="image-quality">{{ getQualityText(image.quality) }}</div>
          </div>
        </div>
      </div>

      <!-- æ“ä½œæŒ‰é’® -->
      <div v-if="generatedImages.length > 0" class="result-actions">
        <a-space size="large">
          <a-button @click="regenerate">
            <template #icon><i class="fas fa-redo"></i></template>
            é‡æ–°ç”Ÿæˆ
          </a-button>
          <a-button 
            type="primary" 
            :disabled="!selectedImage"
            @click="confirmSelection"
          >
            <template #icon><i class="fas fa-check"></i></template>
            ä½¿ç”¨é€‰ä¸­å›¾ç‰‡
          </a-button>
        </a-space>
      </div>
    </div>

    <!-- å›¾ç‰‡é¢„è§ˆæ¨¡æ€æ¡† -->
    <a-modal 
      v-model:open="previewVisible" 
      title="AIç”Ÿæˆå›¾ç‰‡é¢„è§ˆ" 
      :footer="null" 
      width="80%"
      centered
    >
      <div v-if="previewingImage" class="image-preview">
        <img 
          :src="previewingImage.url" 
          :alt="`é¢„è§ˆå›¾ç‰‡ ${previewingIndex + 1}`"
          class="preview-full-image"
        />
        <div class="preview-info">
          <div class="info-grid">
            <div class="info-item">
              <span class="info-label">å°ºå¯¸:</span>
              <span>{{ previewingImage.width }} Ã— {{ previewingImage.height }}</span>
            </div>
            <div class="info-item">
              <span class="info-label">é£æ ¼:</span>
              <span>{{ getStyleText(previewingImage.style) }}</span>
            </div>
            <div class="info-item">
              <span class="info-label">è´¨é‡:</span>
              <span>{{ getQualityText(previewingImage.quality) }}</span>
            </div>
            <div class="info-item">
              <span class="info-label">æç¤ºè¯:</span>
              <span>{{ previewingImage.prompt }}</span>
            </div>
          </div>
        </div>
        <div class="preview-actions">
          <a-space>
            <a-button @click="downloadImage(previewingImage)">
              <template #icon><i class="fas fa-download"></i></template>
              ä¸‹è½½
            </a-button>
            <a-button type="primary" @click="selectPreviewImage">
              <template #icon><i class="fas fa-check"></i></template>
              é€‰æ‹©æ­¤å›¾ç‰‡
            </a-button>
          </a-space>
        </div>
      </div>
    </a-modal>
  </div>
</template>

<script setup>
import { ref, computed } from 'vue'

const props = defineProps({
  currentAlt: {
    type: String,
    default: ''
  }
})

const emit = defineEmits(['image-generated'])

// çŠ¶æ€ç®¡ç†
const promptText = ref('')
const style = ref('realistic')
const size = ref('512x512')
const quality = ref('standard')
const count = ref(1)
const generating = ref(false)
const optimizing = ref(false)
const progress = ref(0)
const progressText = ref('')
const generatedImages = ref([])
const selectedImage = ref(null)
const previewVisible = ref(false)
const previewingImage = ref(null)
const previewingIndex = ref(0)

// å¿«é€Ÿæç¤ºè¯
const quickPrompts = ref([
  'å¯çˆ±çš„å°åŠ¨ç‰©',
  'ç°ä»£å»ºç­‘å¤–è§‚', 
  'ç¾ä¸½çš„è‡ªç„¶é£æ™¯',
  'ç§‘æŠ€æ„Ÿç•Œé¢',
  'æ¸©é¦¨çš„å®¤å†…è®¾è®¡',
  'ç¾å‘³çš„é£Ÿç‰©',
  'æŠ½è±¡è‰ºæœ¯ä½œå“',
  'å¡é€šäººç‰©'
])

// è®¡ç®—å±æ€§
const estimatedCost = computed(() => {
  const baseCost = 2
  const qualityMultiplier = quality.value === 'ultra' ? 3 : quality.value === 'high' ? 2 : 1
  const sizeMultiplier = size.value.includes('1024') ? 2 : 1
  return baseCost * count.value * qualityMultiplier * sizeMultiplier
})

// æ–¹æ³•
const clearPrompt = () => {
  promptText.value = ''
}

const optimizePrompt = async () => {
  if (!promptText.value.trim()) return
  
  optimizing.value = true
  try {
    // æ¨¡æ‹Ÿæç¤ºè¯ä¼˜åŒ–
    await new Promise(resolve => setTimeout(resolve, 1500))
    
    // è¿™é‡Œåº”è¯¥è°ƒç”¨AIä¼˜åŒ–æç¤ºè¯çš„API
    const optimizedPrompt = `${promptText.value}, high quality, detailed, professional photography`
    promptText.value = optimizedPrompt
    
  } catch (error) {
    console.error('ä¼˜åŒ–å¤±è´¥:', error)
  } finally {
    optimizing.value = false
  }
}

const selectQuickPrompt = (prompt) => {
  promptText.value = prompt
}

const handleGenerate = async () => {
  if (!promptText.value.trim()) return
  
  generating.value = true
  progress.value = 0
  progressText.value = 'æ­£åœ¨å‡†å¤‡ç”Ÿæˆ...'
  generatedImages.value = []
  selectedImage.value = null

  try {
    // æ¨¡æ‹Ÿç”Ÿæˆè¿›åº¦
    const progressSteps = [
      { value: 20, text: 'åˆ†ææç¤ºè¯...' },
      { value: 40, text: 'æ„å»ºå›¾åƒç»“æ„...' },
      { value: 60, text: 'ç»˜åˆ¶ç»†èŠ‚...' },
      { value: 80, text: 'ä¼˜åŒ–ç”»è´¨...' },
      { value: 100, text: 'ç”Ÿæˆå®Œæˆ!' }
    ]

    for (const step of progressSteps) {
      progress.value = step.value
      progressText.value = step.text
      await new Promise(resolve => setTimeout(resolve, 800))
    }

    // ç”Ÿæˆå›¾ç‰‡ç»“æœ
    const results = []
    for (let i = 0; i < count.value; i++) {
      const [width, height] = size.value.split('x').map(Number)
      results.push({
        url: `https://picsum.photos/${width}/${height}?random=${Date.now() + i}`,
        width,
        height,
        style: style.value,
        quality: quality.value,
        prompt: promptText.value
      })
    }
    
    generatedImages.value = results

  } catch (error) {
    console.error('ç”Ÿæˆå¤±è´¥:', error)
    message.error('ç”Ÿæˆå¤±è´¥ï¼Œè¯·ç¨åé‡è¯•')
  } finally {
    generating.value = false
  }
}

const regenerate = () => {
  handleGenerate()
}

const selectImage = (image, index) => {
  selectedImage.value = { ...image, index }
}

const confirmSelection = () => {
  if (selectedImage.value) {
    emit('image-generated', selectedImage.value.url)
  }
}

const previewImage = (image, index) => {
  previewingImage.value = image
  previewingIndex.value = index
  previewVisible.value = true
}

const selectPreviewImage = () => {
  selectImage(previewingImage.value, previewingIndex.value)
  previewVisible.value = false
}

const downloadImage = (image) => {
  const link = document.createElement('a')
  link.href = image.url
  link.download = `ai-generated-${Date.now()}.png`
  document.body.appendChild(link)
  link.click()
  document.body.removeChild(link)
}

const getStyleText = (styleValue) => {
  const styleMap = {
    realistic: 'å†™å®',
    cartoon: 'å¡é€š',
    anime: 'åŠ¨æ¼«',
    painting: 'ç»˜ç”»',
    sketch: 'ç´ æ'
  }
  return styleMap[styleValue] || styleValue
}

const getQualityText = (qualityValue) => {
  const qualityMap = {
    standard: 'æ ‡å‡†',
    high: 'é«˜è´¨é‡',
    ultra: 'è¶…é«˜è´¨é‡'
  }
  return qualityMap[qualityValue] || qualityValue
}

const handleImageLoad = (e) => {
  // å›¾ç‰‡åŠ è½½æˆåŠŸ
}

const handleImageError = (e) => {
  console.error('å›¾ç‰‡åŠ è½½å¤±è´¥:', e.target.src)
}

// åˆå§‹åŒ–æ—¶å¦‚æœæœ‰currentAltï¼Œä½¿ç”¨å®ƒä½œä¸ºæç¤ºè¯
if (props.currentAlt) {
  promptText.value = props.currentAlt
}
</script>

<style lang="scss" scoped>
.ai-generate-panel {
  display: flex;
  flex-direction: column;
  gap: 24px;
  height: 100%;
}

.section-title {
  display: flex;
  align-items: center;
  font-size: 14px;
  font-weight: 600;
  margin-bottom: 12px;
}

.prompt-section {
  .prompt-input-area {
    position: relative;
    margin-bottom: 16px;
    
    .prompt-textarea {
      border-radius: 8px;
      
      :deep(.ant-input) {
        font-size: 13px;
        line-height: 1.5;
      }
    }
    
    .prompt-actions {
      position: absolute;
      top: 8px;
      right: 8px;
      
      :deep(.ant-btn) {
        border-radius: 4px;
        font-size: 11px;
      }
    }
  }

  .quick-prompts {
    display: flex;
    align-items: center;
    gap: 12px;
    flex-wrap: wrap;
    
    .prompts-label {
      font-size: 12px;
      color: #6b7280;
      white-space: nowrap;
    }
    
    .prompt-tag {
      cursor: pointer;
      transition: all 0.2s ease;
      
      &:hover {
        transform: translateY(-1px);
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
    }
  }
}

.params-section {
  .params-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    gap: 16px;
    
    .param-group {
      display: flex;
      flex-direction: column;
      gap: 4px;
      
      .param-label {
        font-size: 12px;
        color: #6b7280;
        font-weight: 500;
      }
      
      .param-select {
        :deep(.ant-select-selector) {
          border-radius: 6px;
          font-size: 12px;
        }
      }
    }
  }
}

.generate-section {
  text-align: center;
  
  .generate-btn {
    border-radius: 8px;
    min-width: 160px;
    height: 40px;
    font-weight: 600;
  }
  
  .generate-cost {
    display: flex;
    align-items: center;
    justify-content: center;
    margin-top: 8px;
  }
}

.results-section {
  flex: 1;
  overflow-y: auto;
  
  .generating-state {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 40px 20px;
    
    .progress-container {
      text-align: center;
      width: 100%;
      max-width: 300px;
      
      .progress-text {
        margin: 20px 0;
      }
      
      .progress-bar {
        width: 100%;
        height: 6px;
        background: #e5e7eb;
        border-radius: 3px;
        overflow: hidden;
        
        .progress-fill {
          height: 100%;
          background: linear-gradient(90deg, #3b82f6, #8b5cf6);
          transition: width 0.5s ease;
          border-radius: 3px;
        }
      }
    }
  }

  .results-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 16px;
    margin-bottom: 20px;
    
    .result-item {
      cursor: pointer;
      border-radius: 12px;
      overflow: hidden;
      transition: all 0.2s ease;
      border: 2px solid transparent;
      
      &:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.12);
      }
      
      &.selected {
        border-color: #8b5cf6;
        box-shadow: 0 0 0 2px rgba(139, 92, 246, 0.2);
      }
      
      .image-wrapper {
        position: relative;
        aspect-ratio: 1;
        overflow: hidden;
        
        .result-image {
          width: 100%;
          height: 100%;
          object-fit: cover;
          transition: transform 0.2s ease;
        }
        
        .image-overlay {
          position: absolute;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: rgba(0, 0, 0, 0.6);
          opacity: 0;
          transition: opacity 0.2s ease;
          display: flex;
          align-items: center;
          justify-content: center;
          
          .image-actions {
            display: flex;
            gap: 8px;
          }
        }
        
        &:hover {
          .result-image {
            transform: scale(1.05);
          }
          
          .image-overlay {
            opacity: 1;
          }
        }
      }
      
      .image-info {
        padding: 12px 16px;
        background: #f9fafb;
        
        .image-size {
          font-size: 12px;
          color: #374151;
          font-weight: 500;
          margin-bottom: 2px;
        }
        
        .image-quality {
          font-size: 11px;
          color: #9ca3af;
        }
      }
    }
  }

  .result-actions {
    text-align: center;
    padding: 20px 0;
    border-top: 1px solid #e5e7eb;
    
    :deep(.ant-btn) {
      border-radius: 8px;
      min-width: 120px;
    }
  }
}

.image-preview {
  text-align: center;
  
  .preview-full-image {
    max-width: 100%;
    max-height: 60vh;
    border-radius: 12px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
    margin-bottom: 24px;
  }
  
  .preview-info {
    margin-bottom: 24px;
    
    .info-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 12px;
      text-align: left;
      
      .info-item {
        display: flex;
        padding: 8px 0;
        border-bottom: 1px solid #f0f0f0;
        
        .info-label {
          width: 60px;
          color: #6b7280;
          font-size: 13px;
          font-weight: 500;
        }
        
        span:last-child {
          flex: 1;
          font-size: 13px;
        }
      }
    }
  }
  
  .preview-actions {
    :deep(.ant-btn) {
      border-radius: 8px;
      min-width: 100px;
    }
  }
}
</style>


================================================
FILE: frontend/src/view/editor/components/media/ImageSearchPanel.vue
================================================
<template>
  <div class="image-search-panel">
    <!-- æœç´¢åŒºåŸŸ -->
    <div class="search-section">
      <div class="search-input-area">
        <a-input-search
          v-model:value="searchQuery"
          placeholder="è¾“å…¥æè¿°è¯ï¼Œå¦‚ï¼šè“å¤©ç™½äº‘ã€ç°ä»£å»ºç­‘ã€å¯çˆ±å°çŒ«..."
          size="large"
          :loading="searching"
          @search="handleSearch"
          @keyup.enter="handleSearch"
        >
          <template #addonBefore>
            <a-select v-model:value="searchSource" style="width: 100px">
              <a-select-option value="unsplash">Unsplash</a-select-option>
              <a-select-option value="pixabay">Pixabay</a-select-option>
              <a-select-option value="pexels">Pexels</a-select-option>
            </a-select>
          </template>
          <template #suffix>
            <i class="fas fa-search text-gray-400"></i>
          </template>
        </a-input-search>
      </div>

      <div class="search-options">
        <div class="option-group">
          <label class="option-label">å°ºå¯¸:</label>
          <a-radio-group v-model:value="sizeFilter" size="small">
            <a-radio-button value="all">å…¨éƒ¨</a-radio-button>
            <a-radio-button value="large">å¤§å›¾</a-radio-button>
            <a-radio-button value="medium">ä¸­å›¾</a-radio-button>
            <a-radio-button value="small">å°å›¾</a-radio-button>
          </a-radio-group>
        </div>

        <div class="option-group">
          <label class="option-label">æ–¹å‘:</label>
          <a-radio-group v-model:value="orientationFilter" size="small">
            <a-radio-button value="all">å…¨éƒ¨</a-radio-button>
            <a-radio-button value="horizontal">æ¨ªå‘</a-radio-button>
            <a-radio-button value="vertical">ç«–å‘</a-radio-button>
          </a-radio-group>
        </div>
      </div>

      <!-- å¿«é€Ÿæ ‡ç­¾ -->
      <div class="quick-tags">
        <span class="tags-label">çƒ­é—¨æ ‡ç­¾:</span>
        <a-space wrap>
          <a-tag 
            v-for="tag in quickTags" 
            :key="tag"
            :color="searchQuery === tag ? 'blue' : 'default'"
            class="quick-tag"
            @click="selectQuickTag(tag)"
          >
            {{ tag }}
          </a-tag>
        </a-space>
      </div>
    </div>

    <!-- æœç´¢ç»“æœåŒºåŸŸ -->
    <div class="results-section">
      <!-- åŠ è½½ä¸­ -->
      <div v-if="searching" class="loading-state">
        <a-spin size="large" />
        <p class="text-gray-600 mt-4">æ­£åœ¨æœç´¢å›¾ç‰‡...</p>
      </div>

      <!-- é”™è¯¯çŠ¶æ€ -->
      <div v-else-if="searchError" class="error-state">
        <i class="fas fa-exclamation-triangle text-red-500 text-4xl mb-4"></i>
        <p class="text-gray-600 mb-4">æœç´¢å‡ºé”™äº†</p>
        <p class="text-sm text-gray-500 mb-4">{{ searchError }}</p>
        <a-button @click="retrySearch">é‡è¯•</a-button>
      </div>

      <!-- æ— ç»“æœ -->
      <div v-else-if="searchResults.length === 0 && hasSearched" class="no-results">
        <i class="fas fa-image text-gray-400 text-4xl mb-4"></i>
        <p class="text-gray-600 mb-2">æ²¡æœ‰æ‰¾åˆ°ç›¸å…³å›¾ç‰‡</p>
        <p class="text-sm text-gray-500">è¯•è¯•å…¶ä»–å…³é”®è¯å§</p>
      </div>

      <!-- æœç´¢ç»“æœç½‘æ ¼ -->
      <div v-else-if="searchResults.length > 0" class="results-grid">
        <div 
          v-for="image in searchResults" 
          :key="image.id"
          class="image-item"
          :class="{ selected: selectedImage?.id === image.id }"
          @click="selectImage(image)"
        >
          <div class="image-wrapper">
            <img 
              :src="image.thumbnailUrl" 
              :alt="image.alt"
              class="result-image"
              @load="handleImageLoad"
              @error="handleImageError"
            />
            <div class="image-overlay">
              <div class="image-actions">
                <a-button type="text" size="small" @click.stop="previewImage(image)">
                  <template #icon><i class="fas fa-eye text-white"></i></template>
                </a-button>
                <a-button type="text" size="small" @click.stop="selectImage(image)">
                  <template #icon><i class="fas fa-check text-white"></i></template>
                </a-button>
              </div>
            </div>
          </div>
          
          <div class="image-info">
            <div class="image-size">{{ image.width }} Ã— {{ image.height }}</div>
            <div class="image-source">{{ image.source }}</div>
          </div>
        </div>
      </div>

      <!-- åŠ è½½æ›´å¤š -->
      <div v-if="searchResults.length > 0 && hasMore" class="load-more">
        <a-button @click="loadMore" :loading="loadingMore">
          <template #icon><i class="fas fa-plus"></i></template>
          åŠ è½½æ›´å¤š
        </a-button>
      </div>
    </div>

    <!-- å›¾ç‰‡é¢„è§ˆæ¨¡æ€æ¡† -->
    <a-modal 
      v-model:open="previewVisible" 
      title="å›¾ç‰‡é¢„è§ˆ" 
      :footer="null" 
      width="80%"
      centered
    >
      <div v-if="previewingImage" class="image-preview">
        <img 
          :src="previewingImage.fullUrl || previewingImage.thumbnailUrl" 
          :alt="previewingImage.alt"
          class="preview-full-image"
        />
        <div class="preview-info">
          <div class="info-row">
            <span class="info-label">å°ºå¯¸:</span>
            <span>{{ previewingImage.width }} Ã— {{ previewingImage.height }}</span>
          </div>
          <div class="info-row">
            <span class="info-label">æ¥æº:</span>
            <span>{{ previewingImage.source }}</span>
          </div>
          <div class="info-row">
            <span class="info-label">ä½œè€…:</span>
            <span>{{ previewingImage.author || 'æœªçŸ¥' }}</span>
          </div>
        </div>
        <div class="preview-actions">
          <a-button type="primary" @click="selectPreviewImage">
            <template #icon><i class="fas fa-check"></i></template>
            é€‰æ‹©æ­¤å›¾ç‰‡
          </a-button>
        </div>
      </div>
    </a-modal>
  </div>
</template>

<script setup>
import { ref, computed } from 'vue'

const props = defineProps({
  currentAlt: {
    type: String,
    default: ''
  }
})

const emit = defineEmits(['image-selected'])

// çŠ¶æ€ç®¡ç†
const searchQuery = ref('')
const searchSource = ref('unsplash')
const sizeFilter = ref('all')
const orientationFilter = ref('all')
const searching = ref(false)
const searchError = ref('')
const hasSearched = ref(false)
const searchResults = ref([])
const selectedImage = ref(null)
const hasMore = ref(false)
const loadingMore = ref(false)
const currentPage = ref(1)
const previewVisible = ref(false)
const previewingImage = ref(null)

// å¿«é€Ÿæ ‡ç­¾
const quickTags = ref([
  'é£æ™¯', 'å»ºç­‘', 'äººç‰©', 'åŠ¨ç‰©', 'æ¤ç‰©', 'ç§‘æŠ€', 
  'ç¾é£Ÿ', 'è¿åŠ¨', 'è‰ºæœ¯', 'è‡ªç„¶', 'åŸå¸‚', 'æµ·æ´‹'
])

// æ–¹æ³•
const handleSearch = () => {
  if (!searchQuery.value.trim()) return
  
  currentPage.value = 1
  searchResults.value = []
  performSearch()
}

const performSearch = async () => {
  searching.value = true
  searchError.value = ''
  hasSearched.value = true

  try {
    // è¿™é‡Œåº”è¯¥è°ƒç”¨å®é™…çš„æœç´¢API
    const params = {
      query: searchQuery.value,
      source: searchSource.value,
      size: sizeFilter.value,
      orientation: orientationFilter.value,
      page: currentPage.value
    }

    // æ¨¡æ‹ŸAPIè°ƒç”¨
    await new Promise(resolve => setTimeout(resolve, 1500))
    
    // æ¨¡æ‹Ÿæœç´¢ç»“æœ
    const mockResults = generateMockResults(searchQuery.value, currentPage.value)
    
    if (currentPage.value === 1) {
      searchResults.value = mockResults
    } else {
      searchResults.value.push(...mockResults)
    }
    
    hasMore.value = mockResults.length === 20 // å‡è®¾æ¯é¡µ20ä¸ªç»“æœ

  } catch (error) {
    console.error('æœç´¢å¤±è´¥:', error)
    searchError.value = error.message || 'æœç´¢å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•'
  } finally {
    searching.value = false
    loadingMore.value = false
  }
}

const generateMockResults = (query, page) => {
  const results = []
  const baseId = (page - 1) * 20
  
  for (let i = 0; i < 20; i++) {
    const id = baseId + i + 1
    const width = 800 + Math.floor(Math.random() * 400)
    const height = 600 + Math.floor(Math.random() * 400)
    
    results.push({
      id: `${query}-${id}`,
      thumbnailUrl: `https://picsum.photos/${width}/${height}?random=${id}`,
      fullUrl: `https://picsum.photos/${width * 2}/${height * 2}?random=${id}`,
      width,
      height,
      alt: `${query} ${id}`,
      source: searchSource.value,
      author: `ä½œè€…${id % 10 + 1}`
    })
  }
  
  return results
}

const selectQuickTag = (tag) => {
  searchQuery.value = tag
  handleSearch()
}

const retrySearch = () => {
  performSearch()
}

const loadMore = () => {
  if (!hasMore.value || loadingMore.value) return
  
  loadingMore.value = true
  currentPage.value++
  performSearch()
}

const selectImage = (image) => {
  selectedImage.value = image
  emit('image-selected', image.fullUrl || image.thumbnailUrl)
}

const previewImage = (image) => {
  previewingImage.value = image
  previewVisible.value = true
}

const selectPreviewImage = () => {
  selectImage(previewingImage.value)
  previewVisible.value = false
}

const handleImageLoad = (e) => {
  // å›¾ç‰‡åŠ è½½æˆåŠŸ
}

const handleImageError = (e) => {
  console.error('å›¾ç‰‡åŠ è½½å¤±è´¥:', e.target.src)
  e.target.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2Y5ZmFmYiIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBkb21pbmFudC1iYXNlbGluZT0ibWlkZGxlIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmb250LXNpemU9IjE0IiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZmlsbD0iIzlmYTJhNyI+5Yqg6L295aSx6LSlPC90ZXh0Pjwvc3ZnPg=='
}

// åˆå§‹åŒ–æ—¶å¦‚æœæœ‰currentAltï¼Œä½¿ç”¨å®ƒä½œä¸ºæœç´¢è¯
if (props.currentAlt) {
  searchQuery.value = props.currentAlt
}
</script>

<style lang="scss" scoped>
.image-search-panel {
  display: flex;
  flex-direction: column;
  height: 100%;
  gap: 20px;
}

.search-section {
  .search-input-area {
    margin-bottom: 16px;
    
    :deep(.ant-input-search) {
      border-radius: 8px;
    }
  }

  .search-options {
    display: flex;
    gap: 24px;
    margin-bottom: 16px;
    
    .option-group {
      display: flex;
      align-items: center;
      gap: 8px;
      
      .option-label {
        font-size: 12px;
        color: #6b7280;
        white-space: nowrap;
      }
    }
  }

  .quick-tags {
    display: flex;
    align-items: center;
    gap: 12px;
    flex-wrap: wrap;
    
    .tags-label {
      font-size: 12px;
      color: #6b7280;
      white-space: nowrap;
    }
    
    .quick-tag {
      cursor: pointer;
      transition: all 0.2s ease;
      
      &:hover {
        transform: translateY(-1px);
      }
    }
  }
}

.results-section {
  flex: 1;
  overflow-y: auto;
  
  .loading-state, .error-state, .no-results {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 60px 20px;
    text-align: center;
  }

  .results-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
    gap: 16px;
    padding: 8px 0;
    
    .image-item {
      cursor: pointer;
      border-radius: 8px;
      overflow: hidden;
      transition: all 0.2s ease;
      border: 2px solid transparent;
      
      &:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      }
      
      &.selected {
        border-color: #3b82f6;
        box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
      }
      
      .image-wrapper {
        position: relative;
        aspect-ratio: 1;
        overflow: hidden;
        
        .result-image {
          width: 100%;
          height: 100%;
          object-fit: cover;
          transition: transform 0.2s ease;
        }
        
        .image-overlay {
          position: absolute;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: rgba(0, 0, 0, 0.5);
          opacity: 0;
          transition: opacity 0.2s ease;
          display: flex;
          align-items: center;
          justify-content: center;
          
          .image-actions {
            display: flex;
            gap: 8px;
          }
        }
        
        &:hover {
          .result-image {
            transform: scale(1.05);
          }
          
          .image-overlay {
            opacity: 1;
          }
        }
      }
      
      .image-info {
        padding: 8px 12px;
        background: #f9fafb;
        
        .image-size {
          font-size: 11px;
          color: #374151;
          font-weight: 500;
        }
        
        .image-source {
          font-size: 10px;
          color: #9ca3af;
          text-transform: uppercase;
        }
      }
    }
  }

  .load-more {
    text-align: center;
    padding: 20px;
    
    :deep(.ant-btn) {
      border-radius: 8px;
      min-width: 120px;
    }
  }
}

.image-preview {
  text-align: center;
  
  .preview-full-image {
    max-width: 100%;
    max-height: 60vh;
    border-radius: 8px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
    margin-bottom: 20px;
  }
  
  .preview-info {
    display: inline-block;
    text-align: left;
    margin-bottom: 20px;
    
    .info-row {
      display: flex;
      margin-bottom: 8px;
      
      .info-label {
        width: 60px;
        color: #6b7280;
        font-size: 14px;
      }
    }
  }
  
  .preview-actions {
    :deep(.ant-btn) {
      border-radius: 8px;
      min-width: 120px;
    }
  }
}
</style>


================================================
FILE: frontend/src/view/editor/components/media/LocalReplacePanel.vue
================================================
<template>
  <div class="local-replace-panel">
    <!-- æ–‡ä»¶é€‰æ‹©åŒºåŸŸ -->
    <div class="upload-section">
      <div class="upload-area" :class="{ 'drag-over': dragOver, 'has-file': selectedFile }" @drop="handleDrop" @dragover="handleDragOver" @dragleave="handleDragLeave" @click="triggerFileSelect">
        <!-- é»˜è®¤çŠ¶æ€ -->
        <div v-if="!selectedFile && !uploading" class="upload-placeholder">
          <div class="upload-icon">
            <i class="fas fa-cloud-upload-alt text-4xl text-blue-500 mb-4"></i>
          </div>
          <div class="upload-text">
            <p class="text-lg font-medium text-gray-700 mb-2">æ‹–æ‹½æ–‡ä»¶åˆ°è¿™é‡Œï¼Œæˆ–ç‚¹å‡»é€‰æ‹©</p>
            <p class="text-sm text-gray-500">æ”¯æŒ {{ acceptedFormats }} æ ¼å¼ï¼Œæœ€å¤§ {{ maxSizeText }}</p>
          </div>
          <div class="upload-actions mt-4">
            <a-button type="primary" @click.stop="triggerFileSelect">
              <template #icon><i class="fas fa-folder-open"></i></template>
              é€‰æ‹©æ–‡ä»¶
            </a-button>
            <a-button @click.stop="pasteFromClipboard" class="ml-2">
              <template #icon><i class="fas fa-paste"></i></template>
              ç²˜è´´å›¾ç‰‡
            </a-button>
          </div>
        </div>

        <!-- æ–‡ä»¶å·²é€‰æ‹©çŠ¶æ€ -->
        <div v-else class="file-preview">
          <div class="preview-container">
            <img v-if="previewUrl && mediaType === 'img'" :src="previewUrl" alt="é¢„è§ˆ" class="preview-image" />
            <video v-else-if="previewUrl && mediaType === 'video'" :src="previewUrl" controls class="preview-video" />
            <audio v-else-if="previewUrl && mediaType === 'audio'" :src="previewUrl" controls class="preview-audio" />
            <div v-else class="file-info">
              <i :class="getFileIcon()" class="text-3xl text-gray-400 mb-2"></i>
              <p class="text-sm font-medium">{{ selectedFile?.name }}</p>
              <p class="text-xs text-gray-400">{{ selectedFile?.type }}</p>
            </div>
          </div>

          <div class="file-actions">
            <div class="file-meta">
              <span class="text-sm text-gray-500">
                {{ formatFileSize(selectedFile?.size) }}
              </span>
            </div>
            <div class="action-buttons">
              <a-button @click.stop="clearSelection" size="small">
                <template #icon><i class="fas fa-times"></i></template>
                æ¸…é™¤
              </a-button>
              <a-button type="primary" @click.stop="confirmReplace" size="small">
                <template #icon><i class="fas fa-check"></i></template>
                ç¡®è®¤æ›¿æ¢
              </a-button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- æç¤ºåŒºåŸŸ -->
    <div v-if="selectedFile" class="tips-section">
      <div class="tip-item">
        <i class="fas fa-info-circle text-blue-500 mr-2"></i>
        <span class="text-sm text-gray-600"> ç‚¹å‡»â€œç¡®è®¤æ›¿æ¢â€åï¼Œç³»ç»Ÿå°†è‡ªåŠ¨å¤„ç†æ–‡ä»¶ä¸Šä¼ å’Œæ›¿æ¢æ“ä½œ </span>
      </div>
      <div class="tip-item">
        <i class="fas fa-clock text-orange-500 mr-2"></i>
        <span class="text-sm text-gray-600"> æ”¯æŒçš„æ ¼å¼ï¼š{{ acceptedFormats }}ï¼Œæœ€å¤§ {{ maxSizeText }} </span>
      </div>
    </div>

    <!-- éšè—çš„æ–‡ä»¶è¾“å…¥ -->
    <input ref="fileInput" type="file" :accept="acceptedMimeTypes" style="display: none" @change="handleFileSelect" />
  </div>
</template>

<script setup>
import { ref, computed, onMounted, onUnmounted } from "vue";
import { message } from "ant-design-vue";

const props = defineProps({
  mediaType: {
    type: String,
    default: "img",
  },
  currentSrc: {
    type: String,
    default: "",
  },
});

const emit = defineEmits(["file-selected", "upload-complete", "replace-confirm"]);

// çŠ¶æ€ç®¡ç†
const dragOver = ref(false);
const selectedFile = ref(null);
const previewUrl = ref("");
const fileInput = ref(null);

// æ–‡ä»¶æ ¼å¼å’Œå¤§å°é™åˆ¶
const formatLimits = {
  img: {
    types: ["image/jpeg", "image/jpg", "image/png", "image/gif", "image/webp", "image/svg+xml", "image/bmp", "image/tiff"],
    formats: "JPG, PNG, GIF, WebP, SVG, BMP, TIFF",
    maxSize: 10 * 1024 * 1024, // 10MB
  },
  video: {
    types: ["video/mp4", "video/webm", "video/ogg", "video/avi", "video/mov", "video/wmv", "video/flv", "video/mkv"],
    formats: "MP4, WebM, OGG, AVI, MOV, WMV, FLV, MKV",
    maxSize: 200 * 1024 * 1024, // 200MB
  },
  audio: {
    types: ["audio/mp3", "audio/mpeg", "audio/wav", "audio/ogg", "audio/aac", "audio/flac", "audio/m4a"],
    formats: "MP3, WAV, OGG, AAC, FLAC, M4A",
    maxSize: 50 * 1024 * 1024, // 50MB
  },
  iframe: {
    types: ["text/html", "text/plain", "application/pdf"],
    formats: "HTML, TXT, PDF",
    maxSize: 5 * 1024 * 1024, // 5MB
  },
  embed: {
    types: ["application/pdf", "application/x-shockwave-flash", "text/html"],
    formats: "PDF, SWF, HTML",
    maxSize: 20 * 1024 * 1024, // 20MB
  },
  object: {
    types: ["application/pdf", "application/x-shockwave-flash", "image/svg+xml"],
    formats: "PDF, SWF, SVG",
    maxSize: 20 * 1024 * 1024, // 20MB
  },
};

// è®¡ç®—å±æ€§
const currentLimit = computed(() => {
  return formatLimits[props.mediaType] || formatLimits.img;
});

const acceptedMimeTypes = computed(() => {
  return currentLimit.value.types.join(",");
});

const acceptedFormats = computed(() => {
  return currentLimit.value.formats;
});

const maxSizeText = computed(() => {
  const mb = currentLimit.value.maxSize / (1024 * 1024);
  return `${mb}MB`;
});

// æ–¹æ³•
const triggerFileSelect = () => {
  fileInput.value?.click();
};

const handleFileSelect = (e) => {
  const file = e.target.files[0];
  if (file) {
    processFile(file);
  }
};

const processFile = (file) => {
  console.log("ProcessFile called:", {
    mediaType: props.mediaType,
    fileType: file.type,
    fileName: file.name,
    currentLimit: currentLimit.value,
  });

  // éªŒè¯æ–‡ä»¶ç±»å‹
  if (!currentLimit.value.types.includes(file.type)) {
    console.error("File type not supported:", file.type, "Expected:", currentLimit.value.types);
    message.error(`ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼ï¼Œè¯·é€‰æ‹© ${acceptedFormats.value} æ ¼å¼çš„æ–‡ä»¶`);
    return;
  }

  // éªŒè¯æ–‡ä»¶å¤§å°
  if (file.size > currentLimit.value.maxSize) {
    message.error(`æ–‡ä»¶å¤§å°ä¸èƒ½è¶…è¿‡ ${maxSizeText.value}`);
    return;
  }

  selectedFile.value = file;
  createPreview(file);
  emit("file-selected", file);
};

const createPreview = (file) => {
  if (file.type.startsWith("image/") || file.type.startsWith("video/") || file.type.startsWith("audio/")) {
    previewUrl.value = URL.createObjectURL(file);
  } else {
    previewUrl.value = "";
  }
};

// è·å–æ–‡ä»¶å›¾æ ‡
const getFileIcon = () => {
  if (!selectedFile.value) return "fas fa-file";

  const type = selectedFile.value.type;
  if (type.startsWith("image/")) return "fas fa-image";
  if (type.startsWith("video/")) return "fas fa-video";
  if (type.startsWith("audio/")) return "fas fa-volume-up";
  return "fas fa-file";
};

const clearSelection = () => {
  selectedFile.value = null;
  previewUrl.value = "";
  if (fileInput.value) {
    fileInput.value.value = "";
  }
};

// å°†æ–‡ä»¶è½¬æ¢ä¸ºbase64
const fileToBase64 = (file) => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result);
    reader.onerror = reject;
    reader.readAsDataURL(file);
  });
};

// ç›´æ¥ç¡®è®¤æ›¿æ¢ï¼Œä¸éœ€è¦ä¸Šä¼ é¢„è§ˆæ­¥éª¤
const confirmReplace = async () => {
  if (!selectedFile.value) return;

  try {
    console.log("å¼€å§‹å¤„ç†æ–‡ä»¶æ›¿æ¢:", selectedFile.value.name, selectedFile.value.type);

    // å°†æ–‡ä»¶è½¬æ¢ä¸ºbase64
    const base64Url = await fileToBase64(selectedFile.value);

    console.log("æ–‡ä»¶è½¬æ¢å®Œæˆï¼Œbase64é•¿åº¦:", base64Url.length);

    emit("replace-confirm", {
      file: selectedFile.value,
      url: base64Url, // ä½¿ç”¨base64è€Œä¸æ˜¯blob URL
      type: selectedFile.value.type,
      name: selectedFile.value.name,
      size: selectedFile.value.size,
    });

    // æ¸…ç†é€‰æ‹©çŠ¶æ€
    clearSelection();
  } catch (error) {
    console.error("æ–‡ä»¶è½¬æ¢å¤±è´¥:", error);
    message.error("æ–‡ä»¶å¤„ç†å¤±è´¥ï¼Œè¯·é‡è¯•");
  }
};

// æ‹–æ‹½å¤„ç†
const handleDragOver = (e) => {
  e.preventDefault();
  dragOver.value = true;
};

const handleDragLeave = (e) => {
  e.preventDefault();
  dragOver.value = false;
};

const handleDrop = (e) => {
  e.preventDefault();
  dragOver.value = false;

  const files = e.dataTransfer.files;
  if (files.length > 0) {
    processFile(files[0]);
  }
};

// ç²˜è´´å¤„ç†
const pasteFromClipboard = async () => {
  try {
    const clipboardItems = await navigator.clipboard.read();
    for (const clipboardItem of clipboardItems) {
      for (const type of clipboardItem.types) {
        if (type.startsWith("image/")) {
          const blob = await clipboardItem.getType(type);
          const file = new File([blob], `clipboard-image.${type.split("/")[1]}`, { type });
          processFile(file);
          return;
        }
      }
    }
    message.info("å‰ªè´´æ¿ä¸­æ²¡æœ‰æ‰¾åˆ°å›¾ç‰‡å†…å®¹");
  } catch (error) {
    console.error("è¯»å–å‰ªè´´æ¿å¤±è´¥:", error);
    message.error("æ— æ³•è¯»å–å‰ªè´´æ¿å†…å®¹");
  }
};

const formatFileSize = (bytes) => {
  if (!bytes) return "0 B";
  const k = 1024;
  const sizes = ["B", "KB", "MB", "GB"];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
};

// å…¨å±€ç²˜è´´ç›‘å¬
const handleGlobalPaste = (e) => {
  if (e.clipboardData?.files.length > 0) {
    const file = e.clipboardData.files[0];
    if (currentLimit.value.types.includes(file.type)) {
      processFile(file);
    }
  }
};

onMounted(() => {
  document.addEventListener("paste", handleGlobalPaste);
});

onUnmounted(() => {
  document.removeEventListener("paste", handleGlobalPaste);
});
</script>

<style lang="scss" scoped>
.local-replace-panel {
  display: flex;
  flex-direction: column;
  gap: 20px;
}

.upload-section {
  .upload-area {
    border: 2px dashed #d1d5db;
    border-radius: 12px;
    padding: 32px;
    text-align: center;
    cursor: pointer;
    transition: all 0.3s ease;
    min-height: 200px;
    display: flex;
    align-items: center;
    justify-content: center;

    &:hover {
      border-color: #3b82f6;
      background-color: #eff6ff;
    }

    &.drag-over {
      border-color: #10b981;
      background-color: #ecfdf5;
      transform: scale(1.02);
    }

    &.has-file {
      border-style: solid;
      border-color: #3b82f6;
      background-color: #f8fafc;
    }
  }

  .upload-placeholder {
    .upload-icon {
      margin-bottom: 16px;
    }

    .upload-actions {
      :deep(.ant-btn) {
        border-radius: 8px;
      }
    }
  }

  .tips-section {
    padding: 16px;
    background: #f8fafc;
    border-radius: 8px;
    margin-top: 16px;

    .tip-item {
      display: flex;
      align-items: center;
      margin-bottom: 8px;

      &:last-child {
        margin-bottom: 0;
      }
    }
  }

  .file-preview {
    width: 100%;

    .preview-container {
      margin-bottom: 16px;

      .preview-image,
      .preview-video {
        max-width: 100%;
        max-height: 200px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      }

      .preview-audio {
        width: 100%;
        max-width: 300px;
        height: 32px;
        margin: 10px 0;
        border-radius: 16px;
      }

      .file-info {
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 20px;
      }
    }

    .file-actions {
      display: flex;
      align-items: center;
      justify-content: space-between;

      .action-buttons {
        :deep(.ant-btn) {
          border-radius: 6px;
          margin-left: 8px;
        }
      }
    }
  }
}

.preview-section {
  border-top: 1px solid #e5e7eb;
  padding-top: 20px;

  .section-title {
    display: flex;
    align-items: center;
    font-size: 16px;
    font-weight: 600;
    margin-bottom: 16px;
  }

  .comparison-view {
    display: flex;
    align-items: center;
    gap: 20px;
    margin-bottom: 24px;

    .comparison-item {
      flex: 1;
      text-align: center;

      .item-label {
        font-size: 12px;
        color: #6b7280;
        margin-bottom: 8px;
        font-weight: 500;
      }

      .item-content {
        background: #f9fafb;
        border-radius: 8px;
        padding: 12px;
        border: 1px solid #e5e7eb;

        .comparison-media {
          max-width: 100%;
          max-height: 120px;
          border-radius: 6px;
        }

        .media-placeholder {
          display: flex;
          flex-direction: column;
          align-items: center;
          padding: 20px;
          color: #9ca3af;
        }
      }
    }

    .comparison-arrow {
      font-size: 20px;
      color: #3b82f6;
    }
  }

  .confirm-actions {
    text-align: center;

    :deep(.ant-btn) {
      border-radius: 8px;
      min-width: 120px;
    }
  }
}
</style>



================================================
FILE: frontend/src/view/editor/composables/useAIPrompts.js
================================================
[Binary file]


================================================
FILE: frontend/src/view/editor/composables/useDragDrop.js
================================================
import { ref } from 'vue'
import { useFileManager } from './useFileManager'
import { useNotification } from './useNotification'

export function useDragDrop() {
  const isDragging = ref(false)
  const dragCounter = ref(0)
  
  const { processDroppedFiles } = useFileManager()
  const { showNotification } = useNotification()
  
  let callbacks = {
    onFileProcessed: null,
    onMultipleFilesProcessed: null
  }
  
  const setCallbacks = (newCallbacks) => {
    callbacks = { ...callbacks, ...newCallbacks }
  }
  
  const initDragDrop = (targetElement) => {
    if (!targetElement) return
    
    // é˜²æ­¢é¡µé¢çš„é»˜è®¤æ‹–æ”¾è¡Œä¸º
    const preventDefaults = (e) => {
      e.preventDefault()
      e.stopPropagation()
    }
    
    // æ‹–æ‹½è¿›å…¥
    const handleDragEnter = (e) => {
      preventDefaults(e)
      
      // æ£€æŸ¥æ˜¯å¦åœ¨MediaEditDialogä¸­ï¼Œå¦‚æœæ˜¯åˆ™ä¸å¤„ç†
      if (e.target.closest('.media-edit-dialog') || document.querySelector('.media-edit-overlay')) {
        return
      }
      
      dragCounter.value++
      isDragging.value = true
      targetElement.classList.add('drag-over')
    }
    
    // æ‹–æ‹½ç¦»å¼€
    const handleDragLeave = (e) => {
      preventDefaults(e)
      dragCounter.value--
      if (dragCounter.value <= 0) {
        isDragging.value = false
        targetElement.classList.remove('drag-over')
      }
    }
    
    // æ‹–æ‹½æ‚¬åœ
    const handleDragOver = (e) => {
      preventDefaults(e)
      e.dataTransfer.dropEffect = 'copy'
    }
    
    // æ–‡ä»¶æ”¾ç½®
    const handleDrop = async (e) => {
      preventDefaults(e)
      isDragging.value = false
      dragCounter.value = 0
      targetElement.classList.remove('drag-over')
      
      // æ£€æŸ¥æ˜¯å¦åœ¨MediaEditDialogä¸­ï¼Œå¦‚æœæ˜¯åˆ™ä¸å¤„ç†
      if (e.target.closest('.media-edit-dialog') || document.querySelector('.media-edit-overlay')) {
        return
      }
      
      const files = Array.from(e.dataTransfer.files)
      
      if (files.length === 0) {
        showNotification('æ²¡æœ‰æ£€æµ‹åˆ°æ–‡ä»¶', 'warning')
        return
      }
      
      // è¿‡æ»¤æ”¯æŒçš„æ–‡ä»¶ç±»å‹
      const supportedFiles = files.filter(file => 
        file.type.includes('text') || 
        file.name.endsWith('.html') ||
        file.name.endsWith('.htm')
      )
      
      if (supportedFiles.length === 0) {
        showNotification('ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹ï¼Œè¯·é€‰æ‹© HTML æˆ–æ–‡æœ¬æ–‡ä»¶', 'error')
        return
      }
      
      if (supportedFiles.length !== files.length) {
        showNotification(`è·³è¿‡äº† ${files.length - supportedFiles.length} ä¸ªä¸æ”¯æŒçš„æ–‡ä»¶`, 'warning')
      }
      
      try {
        showNotification('æ­£åœ¨å¤„ç†æ–‡ä»¶...', 'info', 1)
        const results = await processDroppedFiles(supportedFiles)
        
        const successResults = results.filter(r => r.success)
        const failedResults = results.filter(r => !r.success)
        
        if (failedResults.length > 0) {
          failedResults.forEach(result => {
            showNotification(`å¤„ç†æ–‡ä»¶å¤±è´¥ ${result.filename}: ${result.error}`, 'error')
          })
        }
        
        if (successResults.length > 0) {
          if (successResults.length === 1) {
            // å•ä¸ªæ–‡ä»¶å¤„ç†
            if (callbacks.onFileProcessed) {
              callbacks.onFileProcessed(successResults[0])
            }
          } else {
            // å¤šä¸ªæ–‡ä»¶å¤„ç†
            if (callbacks.onMultipleFilesProcessed) {
              callbacks.onMultipleFilesProcessed(successResults)
            }
          }
        }
        
      } catch (error) {
        showNotification(`å¤„ç†æ–‡ä»¶æ—¶å‘ç”Ÿé”™è¯¯: ${error.message}`, 'error')
      }
    }
    
    // ç»‘å®šäº‹ä»¶
    targetElement.addEventListener('dragenter', handleDragEnter)
    targetElement.addEventListener('dragleave', handleDragLeave)
    targetElement.addEventListener('dragover', handleDragOver)
    targetElement.addEventListener('drop', handleDrop)
    
    // è¿”å›æ¸…ç†å‡½æ•°
    return () => {
      targetElement.removeEventListener('dragenter', handleDragEnter)
      targetElement.removeEventListener('dragleave', handleDragLeave)
      targetElement.removeEventListener('dragover', handleDragOver)
      targetElement.removeEventListener('drop', handleDrop)
    }
  }
  
  const createDragOverlay = () => {
    const overlay = document.createElement('div')
    overlay.className = 'drag-overlay'
    overlay.innerHTML = `
      <div class="drag-overlay-content">
        <i class="fas fa-cloud-upload-alt drag-icon"></i>
        <p class="drag-text">é‡Šæ”¾æ–‡ä»¶ä»¥å¯¼å…¥</p>
        <p class="drag-subtext">æ”¯æŒ HTML å’Œæ–‡æœ¬æ–‡ä»¶</p>
      </div>
    `
    
    const style = document.createElement('style')
    style.textContent = `
      .drag-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(59, 130, 246, 0.1);
        border: 3px dashed #3b82f6;
        z-index: 9999;
        display: flex;
        align-items: center;
        justify-content: center;
        pointer-events: none;
      }
      
      .drag-overlay-content {
        text-align: center;
        color: #3b82f6;
      }
      
      .drag-icon {
        font-size: 48px;
        margin-bottom: 16px;
        display: block;
      }
      
      .drag-text {
        font-size: 18px;
        font-weight: 600;
        margin: 0 0 8px 0;
      }
      
      .drag-subtext {
        font-size: 14px;
        margin: 0;
        opacity: 0.8;
      }
      
      .drag-over {
        background: rgba(59, 130, 246, 0.05);
        border: 2px dashed #3b82f6;
      }
    `
    
    document.head.appendChild(style)
    
    return { overlay, style }
  }
  
  return {
    isDragging,
    dragCounter,
    initDragDrop,
    setCallbacks,
    createDragOverlay
  }
}


================================================
FILE: frontend/src/view/editor/composables/useEditorCore.js
================================================
import { ref, reactive, computed } from 'vue'

export function useEditorCore() {
  // å›è°ƒå‡½æ•°
  let onContentChangeCallback = null
  let onInlineEditCallback = null
  const selectedElement = ref(null)
  const hoveredElement = ref(null)
  const elementPath = ref([])
  const previewAreaRef = ref(null)

  const history = reactive({
    states: [],
    currentIndex: -1
  })

  let editorInstance = null
  let currentEditingElement = null
  let currentEditContainer = null
  let currentEditCleanup = null

  // è®¡ç®—å±æ€§
  const canUndo = computed(() => history.currentIndex > 0)
  const canRedo = computed(() => history.currentIndex < history.states.length - 1)

  const initializeEditor = (previewAreaComponent, htmlContent) => {
    previewAreaRef.value = previewAreaComponent

    // åˆ›å»ºç¼–è¾‘å™¨å®ä¾‹
    editorInstance = {
      previewAreaComponent,
      selectedElement: null,
      hoveredElement: null
    }

    // æ·»åŠ åˆ°å†å²è®°å½•
    addToHistory(htmlContent)

    // æ›´æ–°é¢„è§ˆ
    updatePreview(htmlContent)

    // è®¾ç½®iframeæ¶ˆæ¯ç›‘å¬
    setupIframeListeners()
  }

  const setupIframeListeners = () => {
    if (!previewAreaRef.value) return

    // ç›‘å¬iframeæ¶ˆæ¯
    previewAreaRef.value.onMessage('elementSelected', (data) => {
      selectedElement.value = {
        ...data.element,
        path: data.path
      }
      elementPath.value = data.path.map((selector, index) => ({
        display: selector,
        tagName: selector.split(/[#.:]/)[0],
        index: index
      }))
      console.log('Element selected:', data.element)
    })

    previewAreaRef.value.onMessage('elementDoubleClick', (data) => {
      console.log('Element double clicked:', data.element)
      // è§¦å‘å†…è”ç¼–è¾‘
      startInlineEdit(data.element)
    })

    previewAreaRef.value.onMessage('contentUpdated', (data) => {
      if (data.success) {
        console.log('Content updated successfully')
        // è·å–æ›´æ–°åçš„å†…å®¹
        syncToCode()
      } else {
        console.error('Content update failed:', data.error)
      }
    })

    previewAreaRef.value.onMessage('iframeReady', () => {
      console.log('Iframe ready for interaction')
    })
  }

  const selectElement = (elementInfo) => {
    // é€šè¿‡iframeé€‰æ‹©å…ƒç´ 
    if (previewAreaRef.value && elementInfo.path) {
      previewAreaRef.value.selectElementByPath(elementInfo.path)
    }
  }

  const selectFromPath = (pathIndex) => {
    // æ ¹æ®è·¯å¾„ç´¢å¼•é€‰æ‹©å…ƒç´ 
    if (selectedElement.value && selectedElement.value.path) {
      const targetPath = selectedElement.value.path.slice(0, pathIndex + 1)
      previewAreaRef.value.selectElementByPath(targetPath)
    }
  }

  const updatePreview = (htmlContent) => {
    if (!previewAreaRef.value) return

    // ä½¿ç”¨PreviewAreaç»„ä»¶çš„updatePreviewæ–¹æ³•
    previewAreaRef.value.updatePreview(htmlContent)
  }

  const addToHistory = (content) => {
    // ç§»é™¤å½“å‰ä½ç½®ä¹‹åçš„å†å²è®°å½•
    history.states.splice(history.currentIndex + 1)

    // æ·»åŠ æ–°çŠ¶æ€
    history.states.push(content)
    history.currentIndex = history.states.length - 1

    // é™åˆ¶å†å²è®°å½•æ•°é‡
    if (history.states.length > 50) {
      history.states.shift()
      history.currentIndex--
    }
  }

  const undo = () => {
    if (history.currentIndex > 0) {
      history.currentIndex--
      return history.states[history.currentIndex]
    }
    return null
  }

  const redo = () => {
    if (history.currentIndex < history.states.length - 1) {
      history.currentIndex++
      return history.states[history.currentIndex]
    }
    return null
  }


  const syncToCode = () => {
    // ç”±äºä½¿ç”¨iframeï¼Œæ— æ³•ç›´æ¥è·å–innerHTML
    // è¿™ä¸ªæ–¹æ³•ç°åœ¨ä¸»è¦ç”¨äºç‰ˆæœ¬ç®¡ç†ï¼Œè¿”å›å½“å‰å­˜å‚¨çš„HTMLå†…å®¹
    return history.states[history.currentIndex] || ''
  }

  const clearInlineEdit = () => {
    if (previewAreaRef.value) {
      previewAreaRef.value.clearSelection()
    }
  }

  const startInlineEdit = (elementInfo) => {
    // è§¦å‘å†…è”ç¼–è¾‘äº‹ä»¶ï¼Œç”±ä¸»ç»„ä»¶å¤„ç†
    console.log('å†…è”ç¼–è¾‘è§¦å‘ï¼Œå…ƒç´ ä¿¡æ¯:', elementInfo)

    // é€šè¿‡äº‹ä»¶é€šçŸ¥ä¸»ç»„ä»¶æ˜¾ç¤ºç¼–è¾‘æ¨¡æ€æ¡†
    if (onInlineEditCallback) {
      onInlineEditCallback(elementInfo)
    }
  }

  // ä¸ºå…ƒç´ æ·»åŠ ä¸´æ—¶å”¯ä¸€æ ‡è¯†
  const addTemporaryId = (elementInfo) => {
    const tempId = `edit_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
    elementInfo.tempId = tempId

    console.log('ä¸ºå…ƒç´ æ·»åŠ ä¸´æ—¶ID:', tempId)
    return tempId
  }

  // æ›´æ–°å…ƒç´ å†…å®¹
  const updateElementContent = (elementInfo, newContent) => {
    console.log('æ›´æ–°å…ƒç´ å†…å®¹å¼€å§‹:', elementInfo, newContent)

    // ä¸ºå…ƒç´ æ·»åŠ ä¸´æ—¶å”¯ä¸€æ ‡è¯†ä»¥ç¡®ä¿ç²¾å‡†å®šä½
    let tempId = elementInfo.tempId
    if (!tempId) {
      tempId = addTemporaryId(elementInfo)
    }

    // å¦‚æœè¿˜æ²¡æœ‰DOMè·¯å¾„ï¼Œå°è¯•ç”Ÿæˆä¸€ä¸ª
    if (!elementInfo.domPath && history.states[history.currentIndex]) {
      const domPath = generateDOMPathFromHtml(history.states[history.currentIndex], elementInfo)
      if (domPath) {
        elementInfo.domPath = domPath
        console.log('ä¸ºå…ƒç´ ç”ŸæˆDOMè·¯å¾„:', domPath)
      }
    }

    const selector = generateElementSelector(elementInfo)
    console.log('ä½¿ç”¨é€‰æ‹©å™¨:', selector)

    // é€šè¿‡iframeæ›´æ–°å†…å®¹
    if (previewAreaRef.value) {
      previewAreaRef.value.updateElementContent(selector, newContent)

      // è·å–æ›´æ–°åçš„å®Œæ•´HTMLå†…å®¹
      setTimeout(() => {
        // ç”±äºiframeéš”ç¦»ï¼Œæˆ‘ä»¬éœ€è¦é‡æ–°æ„å»ºHTMLå†…å®¹
        const currentHtml = history.states[history.currentIndex] || ''
        console.log('å½“å‰HTMLå†…å®¹é•¿åº¦:', currentHtml.length)
        const updatedHtml = updateHtmlContent(currentHtml, selector, newContent, tempId, elementInfo)
        console.log('æ›´æ–°åHTMLå†…å®¹é•¿åº¦:', updatedHtml.length)
        console.log('HTMLå†…å®¹æ˜¯å¦æ”¹å˜:', updatedHtml !== currentHtml)

        if (updatedHtml !== currentHtml) {
          // åœ¨ä¿å­˜åˆ°å†å²è®°å½•å‰ï¼Œä»HTMLä¸­ç§»é™¤ä¸´æ—¶æ ‡è¯†
          const cleanHtml = removeTempIdFromHtml(updatedHtml, tempId)
          addToHistory(cleanHtml)
          console.log('è§¦å‘å†…å®¹å˜åŒ–å›è°ƒ')
          if (onContentChangeCallback) {
            onContentChangeCallback(cleanHtml, 'å…ƒç´ å†…å®¹æ›´æ–°')
          }

          // æ¸…ç†ä¸´æ—¶ID
          delete elementInfo.tempId
        } else {
          console.log('HTMLå†…å®¹æœªæ”¹å˜ï¼Œä¸è§¦å‘å›è°ƒ')
          // å³ä½¿å†…å®¹æœªæ”¹å˜ï¼Œä¹Ÿè¦æ¸…ç†ä¸´æ—¶ID
          delete elementInfo.tempId
        }
      }, 100)
    }
  }

  // ä»HTMLä¸­ç§»é™¤ä¸´æ—¶IDæ ‡è®°
  const removeTempIdFromHtml = (html, tempId) => {
    return html.replace(new RegExp(`\\s*data-editor-temp="${tempId}"`, 'g'), '')
  }

  // è¾…åŠ©å‡½æ•°ï¼šé€šè¿‡é€‰æ‹©å™¨æŸ¥æ‰¾å…ƒç´ ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
  const findElementBySelector = (container, selector) => {
    try {
      return container.querySelector(selector)
    } catch (e) {
      console.log('é€‰æ‹©å™¨æŸ¥æ‰¾å¤±è´¥:', selector, e.message)
      return null
    }
  }

  // æ›´æ–°HTMLå†…å®¹ä¸­çš„ç‰¹å®šå…ƒç´ 
  const updateHtmlContent = (htmlContent, selector, newContent, tempId = null, elementInfo = null) => {
    console.log('updateHtmlContent å¼€å§‹æ‰§è¡Œ')
    console.log('è¾“å…¥HTMLé•¿åº¦:', htmlContent.length)
    console.log('é€‰æ‹©å™¨:', selector)
    console.log('æ–°å†…å®¹:', newContent)
    console.log('ä¸´æ—¶ID:', tempId)

    try {
      // åˆ›å»ºä¸€ä¸ªä¸´æ—¶DOMæ¥è§£æå’Œä¿®æ”¹HTML
      const parser = new DOMParser()
      let doc = parser.parseFromString(`<div>${htmlContent}</div>`, 'text/html')
      let container = doc.querySelector('div')

      console.log('å®¹å™¨æ˜¯å¦å­˜åœ¨:', !!container)

      if (container) {
        let targetElement = null

        // å¦‚æœæä¾›äº†ä¸´æ—¶IDï¼Œé¦–å…ˆåœ¨HTMLä¸­æ·»åŠ ä¸´æ—¶æ ‡è®°
        if (tempId && !htmlContent.includes(`data-editor-temp="${tempId}"`)) {
          // å…ˆå°è¯•æ‰¾åˆ°ç›®æ ‡å…ƒç´ å¹¶æ·»åŠ ä¸´æ—¶æ ‡è®°
          const tempContainer = parser.parseFromString(`<div>${htmlContent}</div>`, 'text/html').querySelector('div')
          if (tempContainer) {
            const tempElement = findElementBySelector(tempContainer, selector)
            if (tempElement) {
              tempElement.setAttribute('data-editor-temp', tempId)
              htmlContent = tempContainer.innerHTML
              // é‡æ–°è§£æåŒ…å«ä¸´æ—¶æ ‡è®°çš„HTML
              doc = parser.parseFromString(`<div>${htmlContent}</div>`, 'text/html')
              container = doc.querySelector('div')
              console.log('é‡æ–°è§£æå®¹å™¨ï¼Œæ·»åŠ äº†ä¸´æ—¶ID:', tempId)
            }
          }
        }

        // å¤šç§é€‰æ‹©å™¨ç­–ç•¥ - æŒ‰ç²¾å‡†åº¦æ’åº
        const strategies = [
          tempId ? `[data-editor-temp="${tempId}"]` : null, // 1. ä¸´æ—¶IDé€‰æ‹©å™¨ï¼ˆæœ€ç²¾å‡†ï¼‰
          elementInfo?.domPath ? elementInfo.domPath : null, // 2. DOMè·¯å¾„é€‰æ‹©å™¨ï¼ˆç²¾å‡†ä¸”ç¨³å®šï¼‰
          selector, // 3. å®Œæ•´ç±»åé€‰æ‹©å™¨  
          selector.includes('.') ? selector.split('.').slice(0, 2).join('.') : null, // 4. æ ‡ç­¾å+ä¸»è¦ç±»
          selector.includes('.') ? selector.split('.')[0] : null, // 5. ä»…æ ‡ç­¾åï¼ˆå…œåº•ï¼‰
        ].filter(Boolean)

        for (const strategy of strategies) {
          console.log('å°è¯•é€‰æ‹©å™¨ç­–ç•¥:', strategy)
          targetElement = findElementBySelector(container, strategy)
          if (targetElement) {
            console.log('ç­–ç•¥æˆåŠŸ:', strategy)
            break
          }
        }

        console.log('ç›®æ ‡å…ƒç´ æ˜¯å¦æ‰¾åˆ°:', !!targetElement)
        console.log('ç›®æ ‡å…ƒç´ :', targetElement)

        if (targetElement) {
          const oldContent = targetElement.innerHTML
          console.log('å…ƒç´ åŸå§‹å†…å®¹:', oldContent)

          // æ£€æŸ¥æ˜¯å¦åŒ…å«HTMLæ ‡ç­¾
          if (newContent.includes('<') && newContent.includes('>')) {
            targetElement.innerHTML = newContent
            console.log('ä½¿ç”¨innerHTMLæ›´æ–°')
          } else {
            targetElement.textContent = newContent
            console.log('ä½¿ç”¨textContentæ›´æ–°')
          }

          const newInnerHTML = targetElement.innerHTML
          console.log('å…ƒç´ æ›´æ–°åå†…å®¹:', newInnerHTML)

          const resultHtml = container.innerHTML
          console.log('è¿”å›çš„å®Œæ•´HTML:', resultHtml)
          return resultHtml
        } else {
          console.log('æœªæ‰¾åˆ°ç›®æ ‡å…ƒç´ ï¼Œæ‰€æœ‰é€‰æ‹©å™¨ç­–ç•¥éƒ½å¤±è´¥')
          // æ‰“å°å®¹å™¨çš„HTMLä»¥ä¾¿è°ƒè¯•
          console.log('å®¹å™¨HTML:', container.innerHTML.substring(0, 500) + '...')
        }
      } else {
        console.log('æœªæ‰¾åˆ°å®¹å™¨å…ƒç´ ')
      }
    } catch (error) {
      console.error('æ›´æ–°HTMLå†…å®¹å¤±è´¥:', error)
    }

    console.log('è¿”å›åŸå§‹HTMLå†…å®¹')
    return htmlContent
  }

  // ç”Ÿæˆå…ƒç´ çš„DOMè·¯å¾„é€‰æ‹©å™¨
  const generateDOMPathSelector = (element, container) => {
    const path = []
    let current = element

    while (current && current !== container && current.parentElement) {
      let selector = current.tagName.toLowerCase()

      // è®¡ç®—åŒçº§ç›¸åŒæ ‡ç­¾çš„ç´¢å¼•
      const siblings = Array.from(current.parentElement.children)
      const sameTagSiblings = siblings.filter(sibling =>
        sibling.tagName.toLowerCase() === selector
      )

      if (sameTagSiblings.length > 1) {
        const index = sameTagSiblings.indexOf(current) + 1
        selector += `:nth-child(${index})`
      }

      path.unshift(selector)
      current = current.parentElement
    }

    return path.join(' > ')
  }

  // åŸºäºHTMLå†…å®¹å’Œå…ƒç´ ä¿¡æ¯ç”ŸæˆDOMè·¯å¾„
  const generateDOMPathFromHtml = (htmlContent, elementInfo) => {
    try {
      const parser = new DOMParser()
      const doc = parser.parseFromString(`<div>${htmlContent}</div>`, 'text/html')
      const container = doc.querySelector('div')

      if (!container) return null

      // é¦–å…ˆå°è¯•é€šè¿‡ç°æœ‰é€‰æ‹©å™¨æ‰¾åˆ°å…ƒç´ 
      const basicSelector = generateElementSelector({
        ...elementInfo,
        domPath: null,
        tempId: null
      })
      const targetElement = findElementBySelector(container, basicSelector)

      if (targetElement) {
        const domPath = generateDOMPathSelector(targetElement, container)
        console.log('ç”ŸæˆDOMè·¯å¾„:', domPath)
        return domPath
      }
    } catch (error) {
      console.error('ç”ŸæˆDOMè·¯å¾„å¤±è´¥:', error)
    }

    return null
  }

  // æ ¹æ®å…ƒç´ ä¿¡æ¯ç”Ÿæˆç²¾å‡†é€‰æ‹©å™¨
  const generateElementSelector = (elementInfo) => {
    console.log('generateElementSelector è¾“å…¥:', elementInfo)

    // ä¼˜å…ˆä½¿ç”¨IDé€‰æ‹©å™¨
    if (elementInfo.id) {
      const selector = `#${elementInfo.id}`
      console.log('ä½¿ç”¨IDé€‰æ‹©å™¨:', selector)
      return selector
    }

    // å¦‚æœæœ‰DOMè·¯å¾„ä¿¡æ¯ï¼Œä½¿ç”¨DOMè·¯å¾„é€‰æ‹©å™¨
    if (elementInfo.domPath) {
      console.log('ä½¿ç”¨DOMè·¯å¾„é€‰æ‹©å™¨:', elementInfo.domPath)
      return elementInfo.domPath
    }

    // ç”Ÿæˆä¸´æ—¶å”¯ä¸€æ ‡è®°é€‰æ‹©å™¨
    if (elementInfo.tempId) {
      const selector = `[data-editor-temp="${elementInfo.tempId}"]`
      console.log('ä½¿ç”¨ä¸´æ—¶IDé€‰æ‹©å™¨:', selector)
      return selector
    }

    // å›é€€åˆ°æ”¹è¿›çš„ç±»åé€‰æ‹©å™¨
    let selector = elementInfo.tagName?.toLowerCase() || 'div'
    if (elementInfo.className) {
      // è¿‡æ»¤æ‰ç¼–è¾‘å™¨æ·»åŠ çš„ä¸´æ—¶ç±»åå’ŒåŒ…å«ç‰¹æ®Šå­—ç¬¦çš„ç±»å
      const classes = elementInfo.className
        .split(' ')
        .filter(c => c) // ç§»é™¤ç©ºå­—ç¬¦ä¸²
        .filter(c => !c.includes(':')) // ç§»é™¤åŒ…å«å†’å·çš„ç±»åï¼ˆå¦‚ md:text-7xlï¼‰
        .filter(c => c !== 'hovered-element') // ç§»é™¤æ‚¬åœçŠ¶æ€ç±»
        .filter(c => c !== 'selected-element') // ç§»é™¤é€‰ä¸­çŠ¶æ€ç±»
        .filter(c => !c.startsWith('hover:')) // ç§»é™¤ hover: å‰ç¼€çš„ç±»
        .filter(c => !c.startsWith('focus:')) // ç§»é™¤ focus: å‰ç¼€çš„ç±»
        .filter(c => !c.startsWith('active:')) // ç§»é™¤ active: å‰ç¼€çš„ç±»
        .slice(0, 2) // åªå–å‰2ä¸ªç±»åï¼Œé¿å…é€‰æ‹©å™¨è¿‡äºå¤æ‚

      console.log('è¿‡æ»¤åçš„ç±»å:', classes)

      if (classes.length > 0) {
        selector += '.' + classes.join('.')
        console.log('ä½¿ç”¨ç±»é€‰æ‹©å™¨:', selector)
      } else {
        console.log('ä½¿ç”¨æ ‡ç­¾é€‰æ‹©å™¨:', selector)
      }
    } else {
      console.log('ä½¿ç”¨æ ‡ç­¾é€‰æ‹©å™¨:', selector)
    }

    console.log('æœ€ç»ˆé€‰æ‹©å™¨:', selector)
    return selector
  }

  // è®¾ç½®å†…å®¹å˜åŒ–å›è°ƒ
  const setOnContentChangeCallback = (callback) => {
    onContentChangeCallback = callback
  }

  // è®¾ç½®å†…è”ç¼–è¾‘å›è°ƒ
  const setOnInlineEditCallback = (callback) => {
    onInlineEditCallback = callback
  }

  return {
    selectedElement,
    hoveredElement,
    elementPath,
    canUndo,
    canRedo,
    history,
    initializeEditor,
    updatePreview,
    selectElement,
    selectFromPath,
    addToHistory,
    undo,
    redo,
    syncToCode,
    clearInlineEdit,
    setOnContentChangeCallback,
    setOnInlineEditCallback,
    updateElementContent,
    openAIDialog: () => {
      // ç”±ç»„ä»¶å¤„ç†
    },
    openRichEditor: () => {
      // ç”±ç»„ä»¶å¤„ç†  
    },
    openInlineEditor: startInlineEdit
  }
}


================================================
FILE: frontend/src/view/editor/composables/useFileManager.js
================================================
export function useFileManager() {
  
  const createFileInput = (accept = '*/*') => {
    return new Promise((resolve, reject) => {
      const input = document.createElement('input')
      input.type = 'file'
      input.accept = accept
      input.style.display = 'none'
      
      input.addEventListener('change', (e) => {
        const file = e.target.files[0]
        if (!file) {
          reject(new Error('æœªé€‰æ‹©æ–‡ä»¶'))
          return
        }
        
        const reader = new FileReader()
        reader.onload = (event) => {
          resolve({
            content: event.target.result,
            filename: file.name,
            size: file.size,
            type: file.type
          })
        }
        
        reader.onerror = () => {
          reject(new Error('æ–‡ä»¶è¯»å–å¤±è´¥'))
        }
        
        if (accept === 'text/html' || file.type === 'text/html' || file.name.endsWith('.html')) {
          reader.readAsText(file)
        } else {
          reader.readAsText(file)
        }
        
        // æ¸…ç†
        document.body.removeChild(input)
      })
      
      input.addEventListener('cancel', () => {
        reject(new Error('ç”¨æˆ·å–æ¶ˆé€‰æ‹©'))
        document.body.removeChild(input)
      })
      
      document.body.appendChild(input)
      input.click()
    })
  }
  
  const importHTML = async () => {
    try {
      const result = await createFileInput('text/html,.html')
      
      // éªŒè¯ HTML å†…å®¹
      if (!result.content.trim()) {
        throw new Error('æ–‡ä»¶å†…å®¹ä¸ºç©º')
      }
      
      // ç®€å•çš„ HTML éªŒè¯
      const tempDiv = document.createElement('div')
      tempDiv.innerHTML = result.content
      
      return {
        content: result.content,
        filename: result.filename,
        success: true
      }
    } catch (error) {
      throw error
    }
  }
  
  const exportHTML = (htmlContent, filename = null) => {
    try {
      const defaultFilename = filename || `html-editor-export-${new Date().toISOString().slice(0, 10)}.html`
      
      // åˆ›å»ºå®Œæ•´çš„ HTML æ–‡æ¡£
      const fullHTML = `<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML Editor Export</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
${htmlContent}
</body>
</html>`
      
      // åˆ›å»º Blob
      const blob = new Blob([fullHTML], { type: 'text/html;charset=utf-8' })
      
      // åˆ›å»ºä¸‹è½½é“¾æ¥
      const link = document.createElement('a')
      link.href = URL.createObjectURL(blob)
      link.download = defaultFilename
      link.style.display = 'none'
      
      // è§¦å‘ä¸‹è½½
      document.body.appendChild(link)
      link.click()
      document.body.removeChild(link)
      
      // æ¸…ç† URL
      URL.revokeObjectURL(link.href)
      
      return {
        success: true,
        filename: defaultFilename
      }
    } catch (error) {
      return {
        success: false,
        error: error.message
      }
    }
  }
  
  const processDroppedFiles = async (files) => {
    const results = []
    
    for (const file of files) {
      try {
        const result = await processFile(file)
        results.push(result)
      } catch (error) {
        results.push({
          success: false,
          filename: file.name,
          error: error.message
        })
      }
    }
    
    return results
  }
  
  const processFile = (file) => {
    return new Promise((resolve, reject) => {
      if (!file.type.includes('text') && !file.name.endsWith('.html')) {
        reject(new Error('ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹'))
        return
      }
      
      const reader = new FileReader()
      reader.onload = (event) => {
        resolve({
          success: true,
          content: event.target.result,
          filename: file.name,
          size: file.size,
          type: file.type
        })
      }
      
      reader.onerror = () => {
        reject(new Error('æ–‡ä»¶è¯»å–å¤±è´¥'))
      }
      
      reader.readAsText(file)
    })
  }
  
  const validateHTMLContent = (content) => {
    try {
      const tempDiv = document.createElement('div')
      tempDiv.innerHTML = content
      return {
        valid: true,
        content: tempDiv.innerHTML
      }
    } catch (error) {
      return {
        valid: false,
        error: error.message
      }
    }
  }
  
  return {
    importHTML,
    exportHTML,
    createFileInput,
    processDroppedFiles,
    processFile,
    validateHTMLContent
  }
}


================================================
FILE: frontend/src/view/editor/composables/useFileUpload.js
================================================
[Binary file]


================================================
FILE: frontend/src/view/editor/composables/useNotification.js
================================================
import { message } from 'ant-design-vue'

export function useNotification() {
  
  const showNotification = (content, type = 'info', duration = 3) => {
    switch (type) {
      case 'success':
        message.success(content, duration)
        break
      case 'error':
        message.error(content, duration)
        break
      case 'warning':
        message.warning(content, duration)
        break
      case 'info':
      default:
        message.info(content, duration)
        break
    }
  }
  
  const showSuccess = (content, duration = 3) => {
    showNotification(content, 'success', duration)
  }
  
  const showError = (content, duration = 3) => {
    showNotification(content, 'error', duration)
  }
  
  const showWarning = (content, duration = 3) => {
    showNotification(content, 'warning', duration)
  }
  
  const showInfo = (content, duration = 3) => {
    showNotification(content, 'info', duration)
  }
  
  const showLoading = (content = 'åŠ è½½ä¸­...', duration = 0) => {
    return message.loading(content, duration)
  }
  
  return {
    showNotification,
    showSuccess,
    showError,
    showWarning,
    showInfo,
    showLoading
  }
}


================================================
FILE: frontend/src/view/editor/composables/useVersionManager.js
================================================
import { reactive, computed } from 'vue'
import { useNotification } from './useNotification'
import editorService from '@/services/editor'

export function useVersionManager() {
  const { showNotification } = useNotification()

  // ç‰ˆæœ¬ç®¡ç†çŠ¶æ€
  const versionState = reactive({
    versions: [],
    currentVersionId: null,
    currentContent: null,
    isLoading: false,
    isModified: false,
    conversation_id: null,
    filepath: null
  })

  // è®¡ç®—å±æ€§
  const hasVersions = computed(() => versionState.versions.length > 0)
  const currentVersion = computed(() =>
    versionState.versions.find(v => v.id === versionState.currentVersionId) || null
  )
  const versionCount = computed(() => versionState.versions.length)
  const hasUnsavedChanges = computed(() => versionState.isModified)

  // åˆå§‹åŒ–ç‰ˆæœ¬ç®¡ç†å™¨
  const initialize = async (conversation_id, filepath, initialContent = null) => {
    versionState.conversation_id = conversation_id
    versionState.filepath = filepath
    versionState.currentContent = initialContent
    versionState.isModified = false

    // å¦‚æœæä¾›äº†conversation_idå’Œfilepathï¼ŒåŠ è½½ç‰ˆæœ¬å†å²
    if (conversation_id && filepath) {
      await loadVersions()
    }
  }

  // åŠ è½½ç‰ˆæœ¬åˆ—è¡¨
  const loadVersions = async () => {
    if (!versionState.conversation_id || !versionState.filepath) {
      console.warn('ç¼ºå°‘conversation_idæˆ–filepathï¼Œæ— æ³•åŠ è½½ç‰ˆæœ¬')
      return
    }

    versionState.isLoading = true
    try {
      const versions = await editorService.getVersions({
        conversation_id: versionState.conversation_id,
        filepath: versionState.filepath
      })
      versionState.versions = versions || []

      const activeVersion = versionState.versions.find(v => v.active)
      // å¦‚æœæœ‰ç‰ˆæœ¬ï¼Œé€‰æ‹©æ¿€æ´»ç‰ˆæœ¬
      if (activeVersion) {
        versionState.currentVersionId = activeVersion.id
      }
    } catch (error) {
      console.error('åŠ è½½ç‰ˆæœ¬åˆ—è¡¨å¤±è´¥:', error)
      showNotification('åŠ è½½ç‰ˆæœ¬åˆ—è¡¨å¤±è´¥: ' + error.message, 'error')
      versionState.versions = []
    } finally {
      versionState.isLoading = false
    }
  }

  // åˆ‡æ¢åˆ°æŒ‡å®šç‰ˆæœ¬
  const switchToVersion = async (versionId) => {
    if (!versionId) {
      console.warn('ç‰ˆæœ¬IDæ— æ•ˆ')
      return null
    }

    if (versionId === versionState.currentVersionId) {
      console.log('å·²ç»æ˜¯å½“å‰ç‰ˆæœ¬')
      return versionState.currentContent
    }

    if (!versionState.conversation_id || !versionState.filepath) {
      console.warn('ç¼ºå°‘å¿…è¦å‚æ•°ï¼Œæ— æ³•åˆ‡æ¢ç‰ˆæœ¬')
      return null
    }

    versionState.isLoading = true
    try {
      // è°ƒç”¨åˆ‡æ¢ç‰ˆæœ¬æ¥å£
      const result = await editorService.switchVersion({
        version_id: versionId,
        conversation_id: versionState.conversation_id,
        filepath: versionState.filepath
      })

      // æ›´æ–°æœ¬åœ°çŠ¶æ€
      versionState.currentVersionId = versionId
      versionState.currentContent = result.content
      versionState.isModified = false

      // é‡æ–°åŠ è½½ç‰ˆæœ¬åˆ—è¡¨ä»¥æ›´æ–° active çŠ¶æ€
      await loadVersions()

      const version = versionState.versions.find(v => v.id === versionId)
      showNotification(`Switched to version v${version?.version || versionId}`, 'success')

      return result.content
    } catch (error) {
      console.error('åˆ‡æ¢ç‰ˆæœ¬å¤±è´¥:', error)
      showNotification('Switch to version failed: ' + (error.message || 'Unknown error'), 'error')
      return null
    } finally {
      versionState.isLoading = false
    }
  }

  // ä¿å­˜å½“å‰å†…å®¹ä¸ºæ–°ç‰ˆæœ¬
  const saveCurrentVersion = async (content) => {
    if (!versionState.conversation_id || !versionState.filepath) {
      showNotification('ç¼ºå°‘å¿…è¦å‚æ•°ï¼Œæ— æ³•ä¿å­˜', 'error')
      return false
    }

    versionState.isLoading = true
    try {
      await editorService.saveFile({
        path: versionState.filepath,
        content,
        conversation_id: versionState.conversation_id
      })

      // http.js å·²ç»å¤„ç†äº†å“åº”
      versionState.currentContent = content
      versionState.isModified = false

      // é‡æ–°åŠ è½½ç‰ˆæœ¬åˆ—è¡¨ä»¥è·å–æœ€æ–°ç‰ˆæœ¬
      await loadVersions()

      showNotification('Version saved successfully', 'success')
      return true
    } catch (error) {
      console.error('ä¿å­˜å¤±è´¥:', error)
      showNotification('Save failed: ' + (error.message || 'Unknown error'), 'error')
      return false
    } finally {
      versionState.isLoading = false
    }
  }

  // æ ‡è®°å†…å®¹å·²ä¿®æ”¹
  const markAsModified = (content) => {
    versionState.currentContent = content
    versionState.isModified = true
  }

  // åˆ·æ–°ç‰ˆæœ¬åˆ—è¡¨
  const refreshVersions = async () => {
    await loadVersions()
  }

  // è·å–ç‰ˆæœ¬å†å²ï¼ˆæ ¼å¼åŒ–åçš„ï¼‰
  const getVersionHistory = () => {
    return versionState.versions.map((version, index) => ({
      ...version,
      index,
      isCurrent: version.id === versionState.currentVersionId,
      displayName: `Version ${version.version}`,
      displayTime: formatTime(version.create_at)
    }))
  }

  // æ¯”è¾ƒä¸¤ä¸ªç‰ˆæœ¬
  const compareVersions = async (versionId1, versionId2) => {
    try {
      const [version1Data, version2Data] = await Promise.all([
        editorService.getVersionContent(versionId1),
        editorService.getVersionContent(versionId2)
      ])

      const version1 = versionState.versions.find(v => v.id === versionId1)
      const version2 = versionState.versions.find(v => v.id === versionId2)

      return {
        version1: {
          ...version1,
          content: version1Data.content
        },
        version2: {
          ...version2,
          content: version2Data.content
        },
        contentDiff: calculateDifference(version1Data.content, version2Data.content)
      }
    } catch (error) {
      showNotification('æ¯”è¾ƒç‰ˆæœ¬å¤±è´¥: ' + error.message, 'error')
      return null
    }
  }

  // å¯¼å‡ºç‰ˆæœ¬å†å²
  const exportVersionHistory = async () => {
    if (versionState.versions.length === 0) {
      showNotification('æ²¡æœ‰ç‰ˆæœ¬å†å²å¯å¯¼å‡º', 'warning')
      return
    }

    try {
      // è·å–æ‰€æœ‰ç‰ˆæœ¬çš„è¯¦ç»†å†…å®¹
      const versionsWithContent = await Promise.all(
        versionState.versions.map(async (version) => {
          const versionData = await editorService.getVersionContent(version.id)
          return {
            ...version,
            content: versionData.content
          }
        })
      )

      const exportData = {
        exportTime: new Date().toISOString(),
        conversation_id: versionState.conversation_id,
        filepath: versionState.filepath,
        currentVersionId: versionState.currentVersionId,
        versions: versionsWithContent
      }

      const blob = new Blob([JSON.stringify(exportData, null, 2)], {
        type: 'application/json'
      })

      const url = URL.createObjectURL(blob)
      const link = document.createElement('a')
      link.href = url
      link.download = `editor-history-${versionState.filepath.replace(/[^a-z0-9]/gi, '_')}-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.json`
      link.click()

      URL.revokeObjectURL(url)
      showNotification('ç‰ˆæœ¬å†å²å·²å¯¼å‡º', 'success')
    } catch (error) {
      showNotification('å¯¼å‡ºå¤±è´¥: ' + error.message, 'error')
    }
  }

  // è·å–ç‰ˆæœ¬ç»Ÿè®¡ä¿¡æ¯
  const getVersionStats = () => {
    const stats = {
      totalVersions: versionState.versions.length,
      currentVersionId: versionState.currentVersionId,
      hasUnsavedChanges: hasUnsavedChanges.value,
      oldestVersion: versionState.versions[versionState.versions.length - 1]?.create_at,
      newestVersion: versionState.versions[0]?.create_at,
      filepath: versionState.filepath,
      conversation_id: versionState.conversation_id
    }

    return stats
  }

  // è¾…åŠ©å‡½æ•°
  const formatTime = (timestamp) => {
    if (!timestamp) return ''
    const date = new Date(timestamp)
    const now = new Date()
    const diffMs = now - date
    const diffMins = Math.floor(diffMs / 60000)
    const diffHours = Math.floor(diffMs / 3600000)
    const diffDays = Math.floor(diffMs / 86400000)

    if (diffMins < 1) return 'åˆšåˆš'
    if (diffMins < 60) return `${diffMins}åˆ†é’Ÿå‰`
    if (diffHours < 24) return `${diffHours}å°æ—¶å‰`
    if (diffDays < 7) return `${diffDays}å¤©å‰`

    return date.toLocaleDateString('zh-CN', {
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit'
    })
  }

  const calculateDifference = (content1, content2) => {
    const lines1 = content1.split('\n')
    const lines2 = content2.split('\n')

    return {
      addedLines: Math.max(0, lines2.length - lines1.length),
      removedLines: Math.max(0, lines1.length - lines2.length),
      totalLines1: lines1.length,
      totalLines2: lines2.length,
      similarity: calculateSimilarity(content1, content2)
    }
  }

  const calculateSimilarity = (str1, str2) => {
    if (str1 === str2) return 1.0
    if (str1.length === 0 || str2.length === 0) return 0.0

    const longer = str1.length > str2.length ? str1 : str2
    const shorter = str1.length > str2.length ? str2 : str1

    const editDistance = levenshteinDistance(longer, shorter)
    return (longer.length - editDistance) / longer.length
  }

  const levenshteinDistance = (str1, str2) => {
    const matrix = []

    for (let i = 0; i <= str2.length; i++) {
      matrix[i] = [i]
    }

    for (let j = 0; j <= str1.length; j++) {
      matrix[0][j] = j
    }

    for (let i = 1; i <= str2.length; i++) {
      for (let j = 1; j <= str1.length; j++) {
        if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
          matrix[i][j] = matrix[i - 1][j - 1]
        } else {
          matrix[i][j] = Math.min(
            matrix[i - 1][j - 1] + 1,
            matrix[i][j - 1] + 1,
            matrix[i - 1][j] + 1
          )
        }
      }
    }

    return matrix[str2.length][str1.length]
  }

  // æ¸…ç†ç‰ˆæœ¬ç®¡ç†å™¨çŠ¶æ€
  const cleanup = () => {
    versionState.versions = []
    versionState.currentVersionId = null
    versionState.currentContent = null
    versionState.isModified = false
    versionState.conversation_id = null
    versionState.filepath = null
  }

  return {
    // çŠ¶æ€
    versionState,

    // è®¡ç®—å±æ€§
    hasVersions,
    currentVersion,
    versionCount,
    hasUnsavedChanges,

    // æ ¸å¿ƒæ–¹æ³•
    initialize,
    loadVersions,
    switchToVersion,
    saveCurrentVersion,
    markAsModified,
    refreshVersions,

    // å†å²ç®¡ç†
    getVersionHistory,
    compareVersions,

    // å¯¼å…¥å¯¼å‡º
    exportVersionHistory,

    // ç»Ÿè®¡ä¿¡æ¯
    getVersionStats,

    // æ¸…ç†
    cleanup
  }
}


================================================
FILE: frontend/src/view/editor/render/index.vue
================================================
<template>
  <div class="h-screen flex flex-col">
    <!-- é¡¶éƒ¨å·¥å…·æ  -->
    <RenderToolBar
      :versions="versionList"
      :current-version="currentVersionData"
      :active-tab="activeTab"
      :ai-edit-mode="aiEditMode"
      :advanced-edit-mode="advancedEditMode"
      @version-change="handleVersionChange"
      @tab-change="handleTabChange"
      @save="handleSave"
      @ai-edit-toggle="handleAiEditToggle"
      @advanced-edit-toggle="handleAdvancedEditToggle"
    />

    <!-- ä¸»å†…å®¹åŒºåŸŸ -->
    <div class="flex-1 overflow-hidden">
      <!-- é¢„è§ˆæ¨¡å¼ -->
      <RenderPreview
        v-if="activeTab === 'preview'"
        :html-content="htmlContent"
        :path="props.path"
        :ai-edit-mode="aiEditMode"
        :advanced-edit-mode="advancedEditMode"
        @content-updated="handlePreviewContentUpdate"
        @element-selected="handleElementSelected"
        @media-edit="handleMediaEdit"
        @refresh="handleRefresh"
      />

      <!-- ä»£ç ç¼–è¾‘æ¨¡å¼ -->
      <RenderCodeEditor v-else-if="activeTab === 'code'" :html-content="htmlContent" @content-change="handleContentChange" />
    </div>

    <!-- å¤šåª’ä½“ç¼–è¾‘å¯¹è¯æ¡† -->
    <MediaEditDialog ref="mediaEditDialogRef" @save="handleMediaSave" @close="handleMediaClose" />
  </div>
</template>

<script setup>
import { ref, computed, onMounted, onUnmounted, provide, watch } from "vue";
import { useRoute } from "vue-router";
import fileService from "@/services/files.js";
import { useVersionManager } from "../composables/useVersionManager";
import { useNotification } from "../composables/useNotification";
import { useFileManager } from "../composables/useFileManager";
import RenderToolBar from "./components/RenderToolBar.vue";
import RenderPreview from "./components/RenderPreview.vue";
import RenderCodeEditor from "./components/RenderCodeEditor.vue";
import MediaEditDialog from "../components/MediaEditDialog.vue";
import { useEditorStore } from "@/store/modules/editor";
import emitter from "@/utils/emitter";

const props = defineProps({
  path: {
    type: String,
    required: true,
  },
});

provide("path", props.path);

const route = useRoute();
const { showNotification } = useNotification();
const { exportHTML } = useFileManager();
const editorStore = useEditorStore();

// çŠ¶æ€ç®¡ç†
const htmlContent = ref(``);
const activeTab = ref("preview");
const loading = ref(false);
const aiEditMode = ref(false);
const advancedEditMode = ref(false);

// ç»„ä»¶å¼•ç”¨
const mediaEditDialogRef = ref(null);
const selectedElement = ref(null);

// ç‰ˆæœ¬ç®¡ç†
const versionManager = useVersionManager();
const { initialize, switchToVersion, saveCurrentVersion, markAsModified, getVersionHistory, refreshVersions, versionState, currentVersion, hasVersions } = versionManager;

// è®¡ç®—å±æ€§
const versionList = computed(() => getVersionHistory());
const isLoading = computed(() => versionState.isLoading);
const currentVersionData = computed(() => currentVersion.value);

// æå–å¯¹è¯è·¯å¾„
const extractConversationPath = (filePath) => {
  // Find the index of "Conversation"
  const startIndex = filePath.indexOf("Conversation");
  // If "Conversation" is not found, return null or an appropriate error message
  if (startIndex === -1) {
    return null;
  }
  // Slice the string from the start index to the end
  return filePath.slice(startIndex);
};

// åŠ è½½æ–‡ä»¶å†…å®¹
const loadFileContent = async () => {
  if (!props.path) return;

  loading.value = true;
  try {
    // å¤„ç†è·¯å¾„ï¼Œæå– Conversation éƒ¨åˆ†
    const processedPath = extractConversationPath(props.path) || props.path;
    const response = await fileService.getFileByPath(processedPath);
    const content = response.data;
    const conversation_id = route.params.id;
    if (content) {
      htmlContent.value = content;
      // åˆå§‹åŒ–ç‰ˆæœ¬ç®¡ç†ï¼Œä¼ å…¥åˆå§‹å†…å®¹
      await initialize(conversation_id, processedPath, content);
    }
  } catch (error) {
    console.error("åŠ è½½æ–‡ä»¶å¤±è´¥:", error);
    showNotification("æ–‡ä»¶åŠ è½½å¤±è´¥", "error");
  } finally {
    loading.value = false;
  }
};

// äº‹ä»¶å¤„ç†
const handleVersionChange = async (version) => {
  try {
    const content = await switchToVersion(version.id);
    if (content) {
      htmlContent.value = content;
    }
  } catch (error) {
    console.error("ç‰ˆæœ¬åˆ‡æ¢å¤±è´¥:", error);
    showNotification("ç‰ˆæœ¬åˆ‡æ¢å¤±è´¥", "error");
  }
};

const handleTabChange = (tab) => {
  activeTab.value = tab;

  // å¦‚æœåˆ‡æ¢åˆ°ä»£ç æ¨¡å¼ï¼ŒåŒæ­¥çŠ¶æ€åˆ° store
  if (tab === "code") {
    editorStore.setEditorMode("code");
  } else if (tab === "preview") {
    // æ ¹æ®å½“å‰ç¼–è¾‘æ¨¡å¼çŠ¶æ€åŒæ­¥
    if (aiEditMode.value) {
      editorStore.setEditorMode("ai-edit");
    } else if (advancedEditMode.value) {
      editorStore.setEditorMode("advanced-edit");
    } else {
      editorStore.setEditorMode("preview");
    }
  }
};

// AI ç¼–è¾‘æ¨¡å¼åˆ‡æ¢
const handleAiEditToggle = () => {
  // å¦‚æœå½“å‰æ˜¯é«˜çº§ç¼–è¾‘æ¨¡å¼ï¼Œå…ˆå…³é—­å®ƒ
  if (advancedEditMode.value) {
    advancedEditMode.value = false;
  }

  aiEditMode.value = !aiEditMode.value;

  // åŒæ­¥çŠ¶æ€åˆ° store
  const newMode = aiEditMode.value ? "ai-edit" : "preview";
  editorStore.setEditorMode(newMode);

  console.log("AI ç¼–è¾‘æ¨¡å¼:", aiEditMode.value ? "å¼€å¯" : "å…³é—­", "store mode:", newMode);
};

// é«˜çº§ç¼–è¾‘æ¨¡å¼åˆ‡æ¢
const handleAdvancedEditToggle = () => {
  // å¦‚æœå½“å‰æ˜¯AIç¼–è¾‘æ¨¡å¼ï¼Œå…ˆå…³é—­å®ƒ
  if (aiEditMode.value) {
    aiEditMode.value = false;
  }

  advancedEditMode.value = !advancedEditMode.value;

  // åŒæ­¥çŠ¶æ€åˆ° store
  const newMode = advancedEditMode.value ? "advanced-edit" : "preview";
  editorStore.setEditorMode(newMode);

  console.log("é«˜çº§ç¼–è¾‘æ¨¡å¼:", advancedEditMode.value ? "å¼€å¯" : "å…³é—­", "store mode:", newMode);
};

const handleContentChange = (newContent) => {
  if (newContent !== htmlContent.value) {
    htmlContent.value = newContent;
    // æ ‡è®°å†…å®¹å·²ä¿®æ”¹
    markAsModified(newContent);
  }
};

const handleSave = async () => {
  // ä½¿ç”¨ç‰ˆæœ¬ç®¡ç†å™¨ä¿å­˜
  const saved = await saveCurrentVersion(htmlContent.value);
  if (saved) {
    console.log("æ–‡ä»¶å·²æ‰‹åŠ¨ä¿å­˜");
  }
};

// ä¿å­˜å†…å®¹åˆ°æ–‡ä»¶
const saveContentToFile = async (content) => {
  if (!versionManager.versionState.conversation_id || !versionManager.versionState.filepath) {
    console.warn("æœªåˆå§‹åŒ–ç‰ˆæœ¬ç®¡ç†å™¨ï¼Œè·³è¿‡ä¿å­˜");
    return;
  }

  // ä½¿ç”¨ç‰ˆæœ¬ç®¡ç†å™¨ä¿å­˜
  await saveCurrentVersion(content);
};

// é˜²æŠ–ä¿å­˜å‡½æ•°
let saveTimer = null;

// å†…å®¹æ ¼å¼åŒ–å‡½æ•°ï¼Œç”¨äºç»Ÿä¸€æ¯”è¾ƒ
const normalizeContent = (content) => {
  if (!content) return "";
  return content.trim().replace(/\s+/g, " ");
};

// é¢„è§ˆå†…å®¹æ›´æ–°å¤„ç†
const handlePreviewContentUpdate = (updatedContent) => {
  // console.log("handlePreviewContentUpdate", updatedContent);
  // console.log("htmlContent", htmlContent.value);
  // ä½¿ç”¨ç»Ÿä¸€æ ¼å¼åŒ–åçš„å†…å®¹è¿›è¡Œæ¯”è¾ƒ
  const normalizedUpdated = normalizeContent(updatedContent);
  const normalizedCurrent = normalizeContent(htmlContent.value);
  // console.log("normalized updated:", normalizedUpdated.substring(0, 1200));
  // console.log("normalized current:", normalizedCurrent.substring(0, 1200));
  // console.log("is equal after normalization:", normalizedUpdated === normalizedCurrent);
  // return;
  if (normalizedUpdated === normalizedCurrent) {
    return;
  }

  // ç›´æ¥ä½¿ç”¨iframeè¿”å›çš„å®Œæ•´bodyå†…å®¹ï¼Œä¸é‡å¤æ·»åŠ åŒ…è£…å™¨
  htmlContent.value = updatedContent;
  // æ ‡è®°å†…å®¹å·²ä¿®æ”¹
  markAsModified(updatedContent);

  // é˜²æŠ–ä¿å­˜ï¼Œé¿å…é¢‘ç¹è°ƒç”¨æ¥å£
  if (saveTimer) {
    clearTimeout(saveTimer);
  }
  saveTimer = setTimeout(() => {
    saveContentToFile(updatedContent);
    saveTimer = null;
  }, 500);
};

// å…ƒç´ é€‰æ‹©å¤„ç†
const handleElementSelected = (data) => {
  selectedElement.value = data.element;
  console.log("é€‰ä¸­å…ƒç´ :", data.element);
};

// å¤šåª’ä½“ç¼–è¾‘å¤„ç†
const handleMediaEdit = (data) => {
  console.log("å¤šåª’ä½“ç¼–è¾‘:", data);
  if (mediaEditDialogRef.value) {
    mediaEditDialogRef.value.show(data.element, data.mediaType);
  }
};

// å¤šåª’ä½“ä¿å­˜å¤„ç†
const handleMediaSave = async (data) => {
  console.log("å¤šåª’ä½“ä¿å­˜:", data);
  const { element, newSrc, mediaType } = data;
  console.log("å¤šåª’ä½“ä¿å­˜:", element, element.src);

  // åœ¨htmlContentä¸­æ›¿æ¢å¯¹åº”çš„åª’ä½“å…ƒç´ 
  let updatedContent = htmlContent.value;
  element.src = newSrc;
  if (element.src && newSrc) {
    // ç®€å•çš„å­—ç¬¦ä¸²æ›¿æ¢
    updatedContent = updatedContent.replace(element.src, newSrc);
    htmlContent.value = updatedContent;
    // ä¿å­˜åª’ä½“æ›´æ”¹
    markAsModified(updatedContent);
    await saveContentToFile(updatedContent);
    showNotification("åª’ä½“å·²æ›´æ–°", "success");
  }
};

// å¤šåª’ä½“ç¼–è¾‘å…³é—­å¤„ç†
const handleMediaClose = () => {
  console.log("å¤šåª’ä½“ç¼–è¾‘å¯¹è¯æ¡†å…³é—­");
};

// å¤„ç†åˆ·æ–°è¯·æ±‚ - AIä¿®æ”¹æˆåŠŸåé‡æ–°åŠ è½½æ–‡ä»¶
const handleRefresh = async () => {
  console.log("[index.vue] Refresh requested, reloading file content...");
  showNotification("AIä¿®æ”¹æˆåŠŸ, æ­£åœ¨é‡æ–°åŠ è½½...", "info");

  // é‡æ–°åŠ è½½æ–‡ä»¶
  await loadFileContent();

  // åˆ·æ–°ç‰ˆæœ¬åˆ—è¡¨
  await refreshVersions();

  console.log("[index.vue] File reloaded successfully");
};

// æ¸…ç†äº‹ä»¶ç›‘å¬
onUnmounted(() => {
  emitter.off("coding-message-sent", handleCodingMessageSent);
});

// ç›‘å¬pathå˜åŒ–
watch(
  () => props.path,
  async (newPath, oldPath) => {
    if (newPath && newPath !== oldPath) {
      console.log("[index.vue] Path changed from", oldPath, "to", newPath);
      await loadFileContent();
      await refreshVersions();
    }
  }
);

// ç”Ÿå‘½å‘¨æœŸ
onMounted(async () => {
  // é¡µé¢åˆ·æ–°åæ¸…ç†ä¸´æ—¶çŠ¶æ€
  editorStore.clearSelection();
  console.log("Cleared temporary selection states on page refresh");

  // ä» store æ¢å¤ç¼–è¾‘æ¨¡å¼çŠ¶æ€
  const storedMode = editorStore.editorMode;
  console.log("Restoring editor mode from store:", storedMode);

  if (storedMode === "ai-edit") {
    aiEditMode.value = true;
    advancedEditMode.value = false;
  } else if (storedMode === "advanced-edit") {
    aiEditMode.value = false;
    advancedEditMode.value = true;
  } else if (storedMode === "code") {
    activeTab.value = "code";
  } else {
    // é»˜è®¤é¢„è§ˆæ¨¡å¼
    aiEditMode.value = false;
    advancedEditMode.value = false;
    activeTab.value = "preview";
  }

  // å¦‚æœæœ‰è·¯å¾„å‚æ•°ï¼Œå°è¯•åŠ è½½æ–‡ä»¶
  if (props.path) {
    await loadFileContent();
  }

  // ç›‘å¬codingæ¶ˆæ¯å‘é€äº‹ä»¶
  emitter.on("coding-message-sent", handleCodingMessageSent);
});

// å¤„ç†codingæ¶ˆæ¯å‘é€äº‹ä»¶
const handleCodingMessageSent = async (data) => {
  console.log("[index.vue] Received coding-message-sent event:", data);
  const currentConversationId = route.params.id;
  console.log("currentConversationId", currentConversationId);
  // åªæœ‰å½“å‰å¯¹è¯IDåŒ¹é…æ—¶æ‰é‡æ–°åŠ è½½
  if (data.conversationId === currentConversationId) {
    // é‡æ–°åŠ è½½æ–‡ä»¶å†…å®¹
    await loadFileContent();
    // åˆ·æ–°ç‰ˆæœ¬åˆ—è¡¨
    await refreshVersions();

    console.log("[index.vue] File and versions reloaded after coding message");
  }
};
</script>

<style lang="scss" scoped>
.h-screen {
  height: 100vh;
}
</style>



================================================
FILE: frontend/src/view/editor/render/components/EditInput.vue
================================================
<template>
  <div v-if="visible" class="edit-input-container" :style="containerStyle" @click.stop>
    <input ref="editInputRef" v-model="editRequest" class="edit-input" placeholder="è¾“å…¥ä¿®æ”¹éœ€æ±‚..." @keydown.enter="handleSend" @keydown.esc="handleCancel" :disabled="loading" />
    <button class="send-button" @click="handleSend" :disabled="!editRequest.trim() || loading" :class="{ loading: loading }">
      <span v-if="!loading" class="send-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
          <path
            d="M3.478 2.405a.75.75 0 00-.926.94l2.432 7.905H13.5a.75.75 0 010 1.5H4.984l-2.432 7.905a.75.75 0 00.926.94 60.519 60.519 0 0018.445-8.986.75.75 0 000-1.218A60.517 60.517 0 003.478 2.405z"
          />
        </svg>
      </span>
      <span v-else class="loading-spinner"></span>
    </button>
  </div>
</template>

<script setup>
import { ref, computed, watch, nextTick, inject } from "vue";
import { useRoute } from "vue-router";
import instance from "@/utils/http";
import { message } from "ant-design-vue";

const route = useRoute();

const path = inject("path");

const props = defineProps({
  // æ˜¯å¦æ˜¾ç¤º
  visible: {
    type: Boolean,
    default: false,
  },
  // é€‰ä¸­å…ƒç´ 
  selectedElement: {
    type: Object,
    default: null,
  },
  // ä½ç½®ä¿¡æ¯
  position: {
    type: Object,
    default: () => ({ top: 0, left: 0, width: 0, height: 0 }),
  },
  // iframeå…ƒç´ å¼•ç”¨
  iframeElement: {
    type: HTMLIFrameElement,
    default: null,
  },
});

const emit = defineEmits(["modified", "cancel", "refresh"]);

// è¾“å…¥æ¡†å¼•ç”¨
const editInputRef = ref(null);
const editRequest = ref("");
const loading = ref(false);

// è®¡ç®—å®¹å™¨æ ·å¼
const containerStyle = computed(() => {
  const { top, left, width, height } = props.position;

  // è®¾ç½®å®¹å™¨å®½åº¦ï¼Œæœ€å° 280px
  const containerWidth = Math.max(width, 280);

  // è·å– iframe çš„å°ºå¯¸ä½œä¸ºè¾¹ç•Œ
  const iframeRect = props.iframeElement?.getBoundingClientRect();
  const maxWidth = iframeRect?.width || window.innerWidth;
  const maxHeight = iframeRect?.height || window.innerHeight;

  // è¾“å…¥æ¡†é«˜åº¦ï¼ˆåŒ…æ‹¬paddingå’Œborderï¼‰
  const inputHeight = 44; // æ ¹æ®æ ·å¼è®¡ç®—å¾—å‡º
  const margin = 8; // è·ç¦»å…ƒç´ çš„é—´è·

  // è®¡ç®—æ°´å¹³ä½ç½®
  let finalLeft = left + (width - containerWidth) / 2; // é»˜è®¤å±…ä¸­å¯¹é½

  // ç¡®ä¿ä¸è¶…å‡ºå·¦è¾¹ç•Œ
  if (finalLeft < margin) {
    finalLeft = margin;
  }

  // ç¡®ä¿ä¸è¶…å‡ºå³è¾¹ç•Œ
  if (finalLeft + containerWidth > maxWidth - margin) {
    finalLeft = maxWidth - containerWidth - margin;
  }

  // è®¡ç®—å‚ç›´ä½ç½®
  let finalTop = top + height + margin; // é»˜è®¤åœ¨å…ƒç´ ä¸‹æ–¹
  let placement = "bottom"; // è®°å½•æ”¾ç½®ä½ç½®

  // æ£€æŸ¥ä¸‹æ–¹ç©ºé—´æ˜¯å¦è¶³å¤Ÿ
  const bottomSpace = maxHeight - (top + height);
  const topSpace = top;

  // å¦‚æœä¸‹æ–¹ç©ºé—´ä¸è¶³ä½†ä¸Šæ–¹ç©ºé—´è¶³å¤Ÿï¼Œåˆ™æ˜¾ç¤ºåœ¨ä¸Šæ–¹
  if (bottomSpace < inputHeight + margin * 2 && topSpace > inputHeight + margin * 2) {
    finalTop = top - inputHeight - margin;
    placement = "top";
  }

  // å¦‚æœä¸Šä¸‹éƒ½ä¸å¤Ÿï¼Œé€‰æ‹©ç©ºé—´è¾ƒå¤§çš„ä¸€ä¾§ï¼Œå¹¶è°ƒæ•´åˆ°å¯è§†åŒºåŸŸå†…
  if (bottomSpace < inputHeight + margin * 2 && topSpace < inputHeight + margin * 2) {
    if (bottomSpace >= topSpace) {
      // ä½¿ç”¨ä¸‹æ–¹ï¼Œä½†ç¡®ä¿ä¸è¶…å‡ºåº•éƒ¨
      finalTop = Math.min(top + height + margin, maxHeight - inputHeight - margin);
    } else {
      // ä½¿ç”¨ä¸Šæ–¹ï¼Œä½†ç¡®ä¿ä¸è¶…å‡ºé¡¶éƒ¨
      finalTop = Math.max(margin, top - inputHeight - margin);
    }
  }

  return {
    position: "absolute",
    top: `${finalTop}px`,
    left: `${finalLeft}px`,
    width: `${containerWidth}px`,
    // æ·»åŠ æ•°æ®å±æ€§ç”¨äºè°ƒè¯•
    "data-placement": placement,
  };
});

// ç›‘å¬æ˜¾ç¤ºçŠ¶æ€ï¼Œè‡ªåŠ¨èšç„¦
watch(
  () => props.visible,
  (newVal) => {
    if (newVal) {
      editRequest.value = "";
      nextTick(() => {
        editInputRef.value?.focus();
      });
    }
  }
);

// å–æ¶ˆç¼–è¾‘
const handleCancel = () => {
  editRequest.value = "";
  emit("cancel");
};

// å‘é€ä¿®æ”¹è¯·æ±‚
const handleSend = async () => {
  if (!editRequest.value.trim() || loading.value) return;

  const request = editRequest.value.trim();
  loading.value = true;

  const conversation_id = route.params.id;
  const agent_id = route.params.agentId;

  try {
    // è·å–é€‰ä¸­å…ƒç´ çš„HTMLå’Œç›¸å…³ä¿¡æ¯
    const elementHtml = props.selectedElement?.outerHTML || "";
    const elementInfo = {
      tagName: props.selectedElement?.tagName,
      id: props.selectedElement?.id,
      className: props.selectedElement?.className,
      innerHTML: props.selectedElement?.innerHTML,
    };

    // è°ƒç”¨AIç¼–è¾‘æ¥å£
    const options = {
      requirement: request,
      selection: elementHtml,
      conversation_id,
      filepath: path,
      element: elementInfo,
      agent_id: agent_id,
    };
    // const response = await instance.post("/api/agent/coding/ai", options);
    const response = await instance.post("/api/agent/coding/sse", options);
    console.log("response", response);

    if (response && response.status === "success") {
      message.success("ä¿®æ”¹æˆåŠŸ");
      // æ¸…ç©ºè¾“å…¥æ¡†
      editRequest.value = "";
      // è§¦å‘åˆ·æ–°äº‹ä»¶ï¼Œè®©çˆ¶ç»„ä»¶é‡æ–°åŠ è½½æ–‡ä»¶
      emit("refresh");
    } else {
      message.error(response.data?.message || "ä¿®æ”¹å¤±è´¥ï¼Œè¯·é‡è¯•");
    }
  } catch (error) {
    console.error("Edit request failed:", error);
    message.error(error.response?.data?.message || "ä¿®æ”¹è¯·æ±‚å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥");
  } finally {
    loading.value = false;
  }
};
</script>

<style lang="scss" scoped>
.edit-input-container {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 6px;
  background: white;
  border: 2px solid #3b82f6;
  border-radius: 8px;
  box-shadow:
    0 4px 12px rgba(0, 0, 0, 0.15),
    0 0 0 1px rgba(59, 130, 246, 0.1);
  pointer-events: auto;
  z-index: 1000; // æé«˜ z-index ç¡®ä¿æ˜¾ç¤ºåœ¨å…¶ä»–å…ƒç´ ä¸Šæ–¹
  animation: slideUp 0.2s ease;
  position: relative;

  // æ·»åŠ æŒ‡å‘ç®­å¤´
  &::before {
    content: "";
    position: absolute;
    width: 0;
    height: 0;
    border-style: solid;
  }

  // æ ¹æ®æ”¾ç½®ä½ç½®ä½¿ç”¨ä¸åŒçš„åŠ¨ç”»å’Œç®­å¤´æ–¹å‘
  &[data-placement="top"] {
    animation: slideDown 0.2s ease;

    // ä¸‹æ–¹ç®­å¤´
    &::before {
      bottom: -8px;
      left: 50%;
      transform: translateX(-50%);
      border-width: 8px 8px 0 8px;
      border-color: #3b82f6 transparent transparent transparent;
    }

    &::after {
      content: "";
      position: absolute;
      bottom: -6px;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-style: solid;
      border-width: 6px 6px 0 6px;
      border-color: white transparent transparent transparent;
    }
  }

  &[data-placement="bottom"] {
    animation: slideUp 0.2s ease;

    // ä¸Šæ–¹ç®­å¤´
    &::before {
      top: -8px;
      left: 50%;
      transform: translateX(-50%);
      border-width: 0 8px 8px 8px;
      border-color: transparent transparent #3b82f6 transparent;
    }

    &::after {
      content: "";
      position: absolute;
      top: -6px;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-style: solid;
      border-width: 0 6px 6px 6px;
      border-color: transparent transparent white transparent;
    }
  }

  .edit-input {
    flex: 1;
    padding: 6px 10px;
    border: 1px solid #e5e7eb;
    border-radius: 4px;
    font-size: 13px;
    outline: none;
    transition: border-color 0.2s;

    &:focus {
      border-color: #3b82f6;
    }

    &:disabled {
      background: #f3f4f6;
      cursor: not-allowed;
    }
  }

  .send-button {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 32px;
    height: 32px;
    padding: 0;
    background: #3b82f6;
    border: none;
    border-radius: 4px;
    color: white;
    cursor: pointer;
    transition: all 0.2s;

    &:hover:not(:disabled) {
      background: #2563eb;
      transform: scale(1.1);
    }

    &:disabled {
      background: #9ca3af;
      cursor: not-allowed;
    }

    &.loading {
      background: #60a5fa;
    }

    .send-icon {
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;

      svg {
        width: 100%;
        height: 100%;
      }
    }

    .loading-spinner {
      width: 16px;
      height: 16px;
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-top-color: white;
      border-radius: 50%;
      animation: spin 0.6s linear infinite;
    }
  }
}

@keyframes slideUp {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes slideDown {
  from {
    opacity: 0;
    transform: translateY(-10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}
</style>



================================================
FILE: frontend/src/view/editor/render/components/InteractionLayer.vue
================================================
<template>
  <div class="interaction-layer" ref="layerRef">
    <!-- æ‚¬åœæŒ‡ç¤ºå™¨ -->
    <div v-if="hoverIndicator.visible" class="hover-indicator" :style="hoverIndicator.style" />

    <!-- é€‰ä¸­æŒ‡ç¤ºå™¨ -->
    <div v-if="selectionIndicator.visible" class="selection-indicator" :style="selectionIndicator.style">
      <!-- è°ƒæ•´å¤§å°æŠŠæ‰‹ -->
      <template v-if="showResizeHandles && false">
        <div v-for="handle in resizeHandles" :key="handle.position" :class="['resize-handle', `handle-${handle.position}`]" @mousedown.stop="startResize($event, handle.position)" />
      </template>

      <!-- å…ƒç´ ä¿¡æ¯æç¤º -->
      <div v-if="showElementInfo" class="element-info">
        {{ selectionIndicator.elementInfo }}
      </div>
    </div>

    <!-- ç¼–è¾‘è¾“å…¥ç»„ä»¶ -->
    <EditInput
      v-if="false"
      :visible="selectionIndicator.visible"
      :selected-element="selectionIndicator.element"
      :position="editInputPosition"
      :iframe-element="iframeElement"
      @refresh="handleRefresh"
      @cancel="handleEditCancel"
    />

    <!-- å¯¹é½è¾…åŠ©çº¿ -->
    <template v-if="alignmentGuides.length > 0">
      <div v-for="(guide, index) in alignmentGuides" :key="`guide-${index}`" class="alignment-guide" :class="guide.type" :style="guide.style" />
    </template>

    <!-- æ‹–æ‹½é¢„è§ˆ -->
    <div v-if="dragPreview.visible" class="drag-preview" :style="dragPreview.style" />
  </div>
</template>

<script setup>
import { ref, reactive, computed, watch, onMounted, onUnmounted } from "vue";
import EditInput from "./EditInput.vue";

const props = defineProps({
  // iframeå…ƒç´ å¼•ç”¨
  iframeElement: {
    type: HTMLIFrameElement,
    default: null,
  },
  // æ˜¯å¦æ˜¾ç¤ºè°ƒæ•´å¤§å°æŠŠæ‰‹
  enableResize: {
    type: Boolean,
    default: true,
  },
  // æ˜¯å¦æ˜¾ç¤ºå…ƒç´ ä¿¡æ¯
  showElementInfo: {
    type: Boolean,
    default: true,
  },
  // æ˜¯å¦å¯ç”¨å¯¹é½è¾…åŠ©çº¿
  enableAlignmentGuides: {
    type: Boolean,
    default: true,
  },
});

const emit = defineEmits(["element-selected", "element-hover", "element-resize", "element-drag", "element-modified", "refresh"]);

// ç»„ä»¶å¼•ç”¨
const layerRef = ref(null);

// æ‚¬åœæŒ‡ç¤ºå™¨
const hoverIndicator = reactive({
  visible: false,
  style: {},
  element: null,
});

// é€‰ä¸­æŒ‡ç¤ºå™¨
const selectionIndicator = reactive({
  visible: false,
  style: {},
  element: null,
  elementInfo: "",
});

// æ‹–æ‹½é¢„è§ˆ
const dragPreview = reactive({
  visible: false,
  style: {},
});

// å¯¹é½è¾…åŠ©çº¿
const alignmentGuides = ref([]);

// è°ƒæ•´å¤§å°æŠŠæ‰‹
const resizeHandles = [
  { position: "tl", cursor: "nw-resize" },
  { position: "tr", cursor: "ne-resize" },
  { position: "bl", cursor: "sw-resize" },
  { position: "br", cursor: "se-resize" },
  { position: "t", cursor: "n-resize" },
  { position: "r", cursor: "e-resize" },
  { position: "b", cursor: "s-resize" },
  { position: "l", cursor: "w-resize" },
];

// æ˜¯å¦æ˜¾ç¤ºè°ƒæ•´å¤§å°æŠŠæ‰‹
const showResizeHandles = computed(() => {
  return props.enableResize && selectionIndicator.visible && selectionIndicator.element && ["IMG", "VIDEO", "IFRAME", "DIV"].includes(selectionIndicator.element?.tagName);
});

// å½“å‰æ“ä½œçŠ¶æ€
const operationState = reactive({
  isResizing: false,
  isDragging: false,
  resizeHandle: null,
  startPos: { x: 0, y: 0 },
  startSize: { width: 0, height: 0 },
  startOffset: { top: 0, left: 0 },
});

/**
 * ç»Ÿä¸€çš„ä½ç½®è®¡ç®—æ–¹æ³•
 * å°†å…ƒç´ åœ¨iframeä¸­çš„ä½ç½®è½¬æ¢ä¸ºç›¸å¯¹äºäº¤äº’å±‚çš„ä½ç½®
 */
const calculateRelativePosition = (element) => {
  if (!element || !props.iframeElement) return null;

  // è·å–iframeçš„windowå’Œdocument
  const iframeWindow = props.iframeElement.contentWindow;
  const iframeDocument = props.iframeElement.contentDocument;

  if (!iframeWindow || !iframeDocument) return null;

  // è·å–å…ƒç´ ç›¸å¯¹äºiframeè§†å£çš„ä½ç½®
  const rect = element.getBoundingClientRect();

  // è·å–iframeå†…éƒ¨çš„æ»šåŠ¨ä½ç½®
  const scrollTop = iframeWindow.scrollY || iframeDocument.documentElement.scrollTop || iframeDocument.body.scrollTop || 0;
  const scrollLeft = iframeWindow.scrollX || iframeDocument.documentElement.scrollLeft || iframeDocument.body.scrollLeft || 0;

  // è®¡ç®—å…ƒç´ åœ¨iframeæ–‡æ¡£ä¸­çš„ç»å¯¹ä½ç½®
  const elementTop = rect.top + scrollTop;
  const elementLeft = rect.left + scrollLeft;

  // è¿”å›ç›¸å¯¹äºiframeè§†å£çš„ä½ç½®ï¼ˆä¸åŒ…æ‹¬æ»šåŠ¨ï¼‰
  return {
    top: elementTop - scrollTop, // è¿™ç­‰åŒäº rect.top
    left: elementLeft - scrollLeft, // è¿™ç­‰åŒäº rect.left
    width: rect.width,
    height: rect.height,
  };
};

// è®¡ç®—ç¼–è¾‘è¾“å…¥æ¡†ä½ç½®
const editInputPosition = computed(() => {
  if (!selectionIndicator.visible) {
    return { top: 0, left: 0, width: 0, height: 0 };
  }

  // ç›´æ¥ä½¿ç”¨é€‰ä¸­æŒ‡ç¤ºå™¨çš„æ ·å¼å€¼ï¼Œå·²ç»è€ƒè™‘äº†iframeåç§»
  const top = parseFloat(selectionIndicator.style.top) || 0;
  const left = parseFloat(selectionIndicator.style.left) || 0;
  const width = parseFloat(selectionIndicator.style.width) || 0;
  const height = parseFloat(selectionIndicator.style.height) || 0;

  return { top, left, width, height };
});

/**
 * æ›´æ–°æ‚¬åœæŒ‡ç¤ºå™¨
 */
const updateHoverIndicator = (elementInfo) => {
  if (!elementInfo || elementInfo.element === selectionIndicator.element) {
    hoverIndicator.visible = false;
    return;
  }

  // å°è¯•ç›´æ¥ä½¿ç”¨ iframeManager ä¼ é€’è¿‡æ¥çš„ rect
  if (elementInfo.rect) {
    // iframeManager.js ä¸­çš„ rect åŒ…å«äº† scrollY/scrollX
    // æˆ‘ä»¬éœ€è¦å»é™¤è¿™äº›åç§»
    const iframeWindow = props.iframeElement.contentWindow;
    const scrollTop = iframeWindow.scrollY || 0;
    const scrollLeft = iframeWindow.scrollX || 0;

    hoverIndicator.visible = true;
    hoverIndicator.element = elementInfo.element;
    hoverIndicator.style = {
      top: `${elementInfo.rect.top - scrollTop}px`,
      left: `${elementInfo.rect.left - scrollLeft}px`,
      width: `${elementInfo.rect.width}px`,
      height: `${elementInfo.rect.height}px`,
    };
  } else {
    // å¤‡ç”¨æ–¹æ¡ˆï¼šç›´æ¥ä½¿ç”¨å…ƒç´ çš„ getBoundingClientRect
    const rect = elementInfo.element.getBoundingClientRect();
    hoverIndicator.visible = true;
    hoverIndicator.element = elementInfo.element;
    hoverIndicator.style = {
      top: `${rect.top}px`,
      left: `${rect.left}px`,
      width: `${rect.width}px`,
      height: `${rect.height}px`,
    };
  }
};

/**
 * æ›´æ–°é€‰ä¸­æŒ‡ç¤ºå™¨
 */
const updateSelectionIndicator = (elementInfo) => {
  console.log("elementInfo", elementInfo);
  if (!elementInfo || !elementInfo.element) {
    selectionIndicator.visible = false;
    return;
  }

  // ä¸ hover æŒ‡ç¤ºå™¨ç›¸åŒçš„å¤„ç†é€»è¾‘
  if (elementInfo.rect) {
    const iframeWindow = props.iframeElement.contentWindow;
    const scrollTop = iframeWindow.scrollY || 0;
    const scrollLeft = iframeWindow.scrollX || 0;

    selectionIndicator.visible = true;
    selectionIndicator.element = elementInfo.element;
    selectionIndicator.style = {
      top: `${elementInfo.rect.top - scrollTop}px`,
      left: `${elementInfo.rect.left - scrollLeft}px`,
      width: `${elementInfo.rect.width}px`,
      height: `${elementInfo.rect.height}px`,
    };
  } else {
    const rect = elementInfo.element.getBoundingClientRect();
    selectionIndicator.visible = true;
    selectionIndicator.element = elementInfo.element;
    selectionIndicator.style = {
      top: `${rect.top}px`,
      left: `${rect.left}px`,
      width: `${rect.width}px`,
      height: `${rect.height}px`,
    };
  }

  // æ›´æ–°å…ƒç´ ä¿¡æ¯
  if (props.showElementInfo) {
    const tag = elementInfo.tagName?.toLowerCase() || elementInfo.element?.tagName?.toLowerCase() || "";
    const id = elementInfo.id || elementInfo.element?.id || "";
    const className = elementInfo.className || elementInfo.element?.className || "";
    const idStr = id ? `#${id}` : "";
    const classStr = className ? `.${className.split(" ").filter(Boolean).join(".")}` : "";
    selectionIndicator.elementInfo = `${tag}${idStr}${classStr}`;
  }
};

/**
 * æ¸…é™¤æ‰€æœ‰æŒ‡ç¤ºå™¨
 */
const clearIndicators = () => {
  hoverIndicator.visible = false;
  selectionIndicator.visible = false;
  dragPreview.visible = false;
  alignmentGuides.value = [];
};

/**
 * å¼€å§‹è°ƒæ•´å¤§å°
 */
const startResize = (event, handle) => {
  event.preventDefault();

  operationState.isResizing = true;
  operationState.resizeHandle = handle;
  operationState.startPos = {
    x: event.clientX,
    y: event.clientY,
  };

  const rect = selectionIndicator.element.getBoundingClientRect();
  operationState.startSize = {
    width: rect.width,
    height: rect.height,
  };
  operationState.startOffset = {
    top: rect.top,
    left: rect.left,
  };

  // æ·»åŠ å…¨å±€äº‹ä»¶ç›‘å¬
  document.addEventListener("mousemove", handleResizeMove);
  document.addEventListener("mouseup", handleResizeEnd);

  // æ·»åŠ resizeç±»
  document.body.style.cursor = resizeHandles.find((h) => h.position === handle).cursor;
  document.body.classList.add("resizing");
};

/**
 * å¤„ç†è°ƒæ•´å¤§å°ç§»åŠ¨
 */
const handleResizeMove = (event) => {
  if (!operationState.isResizing) return;

  const deltaX = event.clientX - operationState.startPos.x;
  const deltaY = event.clientY - operationState.startPos.y;

  const handle = operationState.resizeHandle;
  let newWidth = operationState.startSize.width;
  let newHeight = operationState.startSize.height;
  let newTop = operationState.startOffset.top;
  let newLeft = operationState.startOffset.left;

  // æ ¹æ®æŠŠæ‰‹ä½ç½®è®¡ç®—æ–°å°ºå¯¸
  if (handle.includes("r")) {
    newWidth = Math.max(50, operationState.startSize.width + deltaX);
  }
  if (handle.includes("l")) {
    newWidth = Math.max(50, operationState.startSize.width - deltaX);
    newLeft = operationState.startOffset.left + deltaX;
  }
  if (handle.includes("b")) {
    newHeight = Math.max(50, operationState.startSize.height + deltaY);
  }
  if (handle.includes("t")) {
    newHeight = Math.max(50, operationState.startSize.height - deltaY);
    newTop = operationState.startOffset.top + deltaY;
  }

  // æ›´æ–°é€‰ä¸­æŒ‡ç¤ºå™¨æ ·å¼
  selectionIndicator.style = {
    top: `${newTop}px`,
    left: `${newLeft}px`,
    width: `${newWidth}px`,
    height: `${newHeight}px`,
  };

  // è§¦å‘resizeäº‹ä»¶
  emit("element-resize", {
    element: selectionIndicator.element,
    width: newWidth,
    height: newHeight,
    top: newTop,
    left: newLeft,
  });

  // æ˜¾ç¤ºå¯¹é½è¾…åŠ©çº¿
  if (props.enableAlignmentGuides) {
    updateAlignmentGuides(newLeft, newTop, newWidth, newHeight);
  }
};

/**
 * ç»“æŸè°ƒæ•´å¤§å°
 */
const handleResizeEnd = () => {
  operationState.isResizing = false;
  operationState.resizeHandle = null;

  // ç§»é™¤å…¨å±€äº‹ä»¶ç›‘å¬
  document.removeEventListener("mousemove", handleResizeMove);
  document.removeEventListener("mouseup", handleResizeEnd);

  // æ¢å¤å…‰æ ‡
  document.body.style.cursor = "";
  document.body.classList.remove("resizing");

  // æ¸…é™¤å¯¹é½è¾…åŠ©çº¿
  alignmentGuides.value = [];
};

/**
 * å¤„ç†å…ƒç´ ä¿®æ”¹å®Œæˆ
 */
const handleRefresh = () => {
  emit("refresh");
};

/**
 * å¤„ç†ç¼–è¾‘å–æ¶ˆ
 */
const handleEditCancel = () => {
  // å¯ä»¥åœ¨è¿™é‡Œå¤„ç†å–æ¶ˆé€»è¾‘
};

/**
 * æ›´æ–°å¯¹é½è¾…åŠ©çº¿
 */
const updateAlignmentGuides = (left, top, width, height) => {
  const guides = [];
  const threshold = 5; // å¯¹é½é˜ˆå€¼

  // è·å–iframeä¸­çš„å…¶ä»–å…ƒç´ 
  if (!props.iframeElement) return;

  const iframeDoc = props.iframeElement.contentDocument;
  const elements = iframeDoc.querySelectorAll("*");

  elements.forEach((el) => {
    if (el === selectionIndicator.element) return;

    const rect = el.getBoundingClientRect();
    const elLeft = rect.left;
    const elTop = rect.top;
    const elRight = rect.right;
    const elBottom = rect.bottom;

    // å‚ç›´å¯¹é½çº¿
    if (Math.abs(left - elLeft) < threshold) {
      guides.push({
        type: "vertical",
        style: {
          left: `${elLeft}px`,
          top: `${Math.min(top, elTop)}px`,
          height: `${Math.abs(top - elTop) + height}px`,
        },
      });
    }

    // æ°´å¹³å¯¹é½çº¿
    if (Math.abs(top - elTop) < threshold) {
      guides.push({
        type: "horizontal",
        style: {
          top: `${elTop}px`,
          left: `${Math.min(left, elLeft)}px`,
          width: `${Math.abs(left - elLeft) + width}px`,
        },
      });
    }
  });

  alignmentGuides.value = guides;
};

/**
 * å¤„ç†iframeæ»šåŠ¨
 */
const handleIframeScroll = () => {
  // æ»šåŠ¨æ—¶ï¼Œé‡æ–°è®¡ç®—æŒ‡ç¤ºå™¨ä½ç½®
  // å› ä¸º getBoundingClientRect è¿”å›çš„æ˜¯ç›¸å¯¹äºè§†å£çš„ä½ç½®ï¼Œæ»šåŠ¨åä¼šè‡ªåŠ¨æ›´æ–°
  if (selectionIndicator.visible && selectionIndicator.element) {
    const rect = selectionIndicator.element.getBoundingClientRect();
    selectionIndicator.style = {
      top: `${rect.top}px`,
      left: `${rect.left}px`,
      width: `${rect.width}px`,
      height: `${rect.height}px`,
    };
  }

  if (hoverIndicator.visible && hoverIndicator.element) {
    const rect = hoverIndicator.element.getBoundingClientRect();
    hoverIndicator.style = {
      top: `${rect.top}px`,
      left: `${rect.left}px`,
      width: `${rect.width}px`,
      height: `${rect.height}px`,
    };
  }
};

// æš´éœ²æ–¹æ³•ç»™çˆ¶ç»„ä»¶
defineExpose({
  updateHoverIndicator,
  updateSelectionIndicator,
  clearIndicators,
  handleIframeScroll,
});

// ç”Ÿå‘½å‘¨æœŸ
onMounted(() => {
  // ç›‘å¬çª—å£å¤§å°å˜åŒ–
  window.addEventListener("resize", clearIndicators);
});

onUnmounted(() => {
  window.removeEventListener("resize", clearIndicators);

  // æ¸…ç†å¯èƒ½å­˜åœ¨çš„å…¨å±€äº‹ä»¶
  document.removeEventListener("mousemove", handleResizeMove);
  document.removeEventListener("mouseup", handleResizeEnd);
});
</script>

<style lang="scss" scoped>
.interaction-layer {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  pointer-events: none; /* å±‚æœ¬èº«ä¸æ‹¦æˆªäº‹ä»¶ */
  z-index: 10;
  overflow: visible; /* å…è®¸å†…å®¹è¶…å‡ºï¼Œæ¯”å¦‚ç¼–è¾‘æ¡† */
}

// æ‚¬åœæŒ‡ç¤ºå™¨
.hover-indicator {
  position: absolute;
  border: 1px dashed #3b82f6;
  pointer-events: none;
  animation: fadeIn 0.2s ease;

  &::before {
    content: "";
    position: absolute;
    inset: -2px;
    background: rgba(59, 130, 246, 0.1);
  }
}

// é€‰ä¸­æŒ‡ç¤ºå™¨
.selection-indicator {
  position: absolute;
  border: 2px solid #3b82f6;
  pointer-events: none; /* æ”¹ä¸ºnoneï¼Œåªæœ‰resize handleså¯äº¤äº’ */
  animation: fadeIn 0.2s ease;

  &::before {
    content: "";
    position: absolute;
    inset: -2px;
    background: rgba(59, 130, 246, 0.05);
    pointer-events: none;
  }
}

// å…ƒç´ ä¿¡æ¯æç¤º
.element-info {
  position: absolute;
  top: -24px;
  left: -2px;
  padding: 2px 8px;
  background: #3b82f6;
  color: white;
  font-size: 11px;
  font-family: "Monaco", "Menlo", monospace;
  border-radius: 3px;
  white-space: nowrap;
  user-select: none;
  pointer-events: none;

  &::after {
    content: "";
    position: absolute;
    top: 100%;
    left: 8px;
    border: 4px solid transparent;
    border-top-color: #3b82f6;
  }
}

// è°ƒæ•´å¤§å°æŠŠæ‰‹
.resize-handle {
  position: absolute;
  width: 8px;
  height: 8px;
  background: white;
  border: 2px solid #3b82f6;
  border-radius: 2px;
  pointer-events: auto;

  &:hover {
    background: #3b82f6;
    transform: scale(1.2);
  }

  // æŠŠæ‰‹ä½ç½®
  &.handle-tl {
    top: -4px;
    left: -4px;
    cursor: nw-resize;
  }

  &.handle-tr {
    top: -4px;
    right: -4px;
    cursor: ne-resize;
  }

  &.handle-bl {
    bottom: -4px;
    left: -4px;
    cursor: sw-resize;
  }

  &.handle-br {
    bottom: -4px;
    right: -4px;
    cursor: se-resize;
  }

  &.handle-t {
    top: -4px;
    left: 50%;
    transform: translateX(-50%);
    cursor: n-resize;
  }

  &.handle-r {
    right: -4px;
    top: 50%;
    transform: translateY(-50%);
    cursor: e-resize;
  }

  &.handle-b {
    bottom: -4px;
    left: 50%;
    transform: translateX(-50%);
    cursor: s-resize;
  }

  &.handle-l {
    left: -4px;
    top: 50%;
    transform: translateY(-50%);
    cursor: w-resize;
  }
}

// å¯¹é½è¾…åŠ©çº¿
.alignment-guide {
  position: absolute;
  pointer-events: none;

  &.vertical {
    width: 1px;
    background: #ef4444;
    opacity: 0.6;
  }

  &.horizontal {
    height: 1px;
    background: #ef4444;
    opacity: 0.6;
  }
}

// æ‹–æ‹½é¢„è§ˆ
.drag-preview {
  position: absolute;
  border: 2px dashed #3b82f6;
  background: rgba(59, 130, 246, 0.1);
  pointer-events: none;
  transition: all 0.1s ease;
}

// åŠ¨ç”»
@keyframes fadeIn {
  from {
    opacity: 0;
    transform: scale(0.95);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}

// å…¨å±€æ ·å¼ï¼ˆè°ƒæ•´å¤§å°æ—¶ï¼‰
:global(.resizing) {
  user-select: none !important;

  * {
    user-select: none !important;
  }
}
</style>



================================================
FILE: frontend/src/view/editor/render/components/RenderCodeEditor.vue
================================================
<template>
  <div class="code-editor-container">
    <!-- ä»£ç ç¼–è¾‘å™¨ä¿¡æ¯æ  -->
    <div class="editor-info-bar">
      <div class="info-left">
        <i class="fas fa-code text-green-500 mr-2"></i>
        <span class="font-medium text-gray-700">HTML Editor</span>
      </div>
      <div class="info-right">
        <a-space>
          <span class="text-sm text-gray-500"> lines: {{ lineCount }} | characters: {{ charCount }} </span>
          <a-button size="small" type="text" @click="formatCode" :loading="formatting">
            <template #icon>
              <i class="fas fa-magic mr-2"></i>
            </template>
            Format
          </a-button>
          <a-button size="small" type="text" @click="toggleWordWrap">
            <template #icon>
              <i class="fas fa-expand-arrows-alt mr-2"></i>
            </template>
            {{ wordWrap ? "Cancel Wrap" : "Auto Wrap" }}
          </a-button>
          <a-button size="small" type="text" @click="toggleTheme">
            <template #icon>
              <i :class="isDarkTheme ? 'fas fa-sun mr-2' : 'fas fa-moon mr-2'"></i>
            </template>
            {{ isDarkTheme ? "Light" : "Dark" }}
          </a-button>
        </a-space>
      </div>
    </div>

    <!-- ä»£ç ç¼–è¾‘åŒºåŸŸ -->
    <div class="editor-content-wrapper">
      <Codemirror
        v-model="internalContent"
        placeholder="åœ¨æ­¤è¾“å…¥æˆ–ç²˜è´´ HTML ä»£ç ..."
        :style="{ height: '100%', width: '100%' }"
        :autofocus="true"
        :tab-size="2"
        :extensions="extensions"
        @change="handleChange"
        @ready="handleReady"
        ref="cmRef"
      />
    </div>

    <!-- åº•éƒ¨çŠ¶æ€æ  -->
    <div class="editor-status-bar">
      <div class="status-left">
        <span class="text-xs text-gray-500"> HTML | UTF-8 | {{ cursorLine }}:{{ cursorColumn }} </span>
      </div>
      <div class="status-right">
        <a-space size="small">
          <span v-if="hasUnsavedChanges" class="text-xs text-orange-500">
            <i class="fas fa-circle mr-1"></i>
            æœªä¿å­˜
          </span>
          <span class="text-xs text-gray-500"> æœ€åä¿®æ”¹: {{ lastModified }} </span>
        </a-space>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, computed, watch, onMounted, onUnmounted } from "vue";
import { Codemirror } from "vue-codemirror";
import { html } from "@codemirror/lang-html";
import { oneDark } from "@codemirror/theme-one-dark";
import { EditorView } from "@codemirror/view";
import { EditorState } from "@codemirror/state";

const props = defineProps({
  htmlContent: {
    type: String,
    default: "",
  },
});

const emit = defineEmits(["content-change"]);

// å“åº”å¼çŠ¶æ€
const cmRef = ref(null);
const internalContent = ref("");
const wordWrap = ref(false);
const formatting = ref(false);
const hasUnsavedChanges = ref(false);
const lastModified = ref("");
const cursorLine = ref(1);
const cursorColumn = ref(1);
const isDarkTheme = ref(true);

// è®¡ç®—å±æ€§
const lineCount = computed(() => {
  return Math.max(1, internalContent.value.split("\n").length);
});

const charCount = computed(() => {
  return internalContent.value.length;
});

// è‡ªå®šä¹‰äº®è‰²ä¸»é¢˜
const lightTheme = EditorView.theme({
  "&": {
    color: "#374151",
    backgroundColor: "#ffffff",
    fontSize: "14px",
    fontFamily: "'Monaco', 'Consolas', 'Ubuntu Mono', monospace",
    height: "100%",
  },
  ".cm-content": {
    caretColor: "#f6c82c",
    padding: "16px",
    minHeight: "400px", // å¢åŠ æœ€å°é«˜åº¦ä»¥ç¡®ä¿æœ‰è¶³å¤Ÿç©ºé—´
  },
  ".cm-editor": {
    border: "1px solid #e5e7eb",
    borderRadius: "8px",
    height: "100%",
  },
  ".cm-scroller": {
    overflow: "auto",
    maxHeight: "100%",
  },
  ".cm-focused": {
    outline: "none",
    borderColor: "#f6c82c",
  },
  ".cm-gutters": {
    backgroundColor: "#f9fafb",
    color: "#9ca3af",
    border: "none",
    borderRight: "1px solid #e5e7eb",
  },
  ".cm-activeLineGutter": {
    backgroundColor: "#f3f4f6",
    color: "#374151",
  },
  ".cm-activeLine": {
    backgroundColor: "rgba(246, 200, 44, 0.1)",
  },
  ".cm-selectionMatch": {
    backgroundColor: "rgba(246, 200, 44, 0.2)",
  },
  ".cm-searchMatch": {
    backgroundColor: "rgba(246, 200, 44, 0.3)",
  },
});

// æš—è‰²ä¸»é¢˜æ‰©å±•
const darkTheme = EditorView.theme({
  "&": {
    fontSize: "14px",
    fontFamily: "'Monaco', 'Consolas', 'Ubuntu Mono', monospace",
    height: "100%",
  },
  ".cm-content": {
    caretColor: "#f6c82c",
    padding: "16px",
    minHeight: "400px", // å¢åŠ æœ€å°é«˜åº¦ä»¥ç¡®ä¿æœ‰è¶³å¤Ÿç©ºé—´
  },
  ".cm-editor": {
    border: "1px solid #374151",
    borderRadius: "8px",
    height: "100%",
  },
  ".cm-scroller": {
    overflow: "auto",
    maxHeight: "100%",
  },
  ".cm-focused": {
    outline: "none",
    borderColor: "#f6c82c",
  },
  ".cm-activeLine": {
    backgroundColor: "rgba(246, 200, 44, 0.1)",
  },
  ".cm-selectionMatch": {
    backgroundColor: "rgba(246, 200, 44, 0.2)",
  },
  ".cm-searchMatch": {
    backgroundColor: "rgba(246, 200, 44, 0.3)",
  },
});

// ç¼–è¾‘å™¨æ‰©å±•é…ç½®
const extensions = computed(() => {
  const baseExtensions = [
    html(),
    EditorView.updateListener.of((update) => {
      if (update.selectionSet) {
        updateCursorPosition();
      }
    }),
  ];

  if (wordWrap.value) {
    baseExtensions.push(EditorView.lineWrapping);
  }

  if (isDarkTheme.value) {
    baseExtensions.push(oneDark, darkTheme);
  } else {
    baseExtensions.push(lightTheme);
  }

  return baseExtensions;
});

// æ›´æ–°æœ€åä¿®æ”¹æ—¶é—´
const updateLastModified = () => {
  const now = new Date();
  lastModified.value = now.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit", second: "2-digit" });
};

// åˆå§‹åŒ–å†…å®¹
watch(
  () => props.htmlContent,
  (newContent) => {
    if (newContent !== internalContent.value) {
      internalContent.value = newContent;
      hasUnsavedChanges.value = false;
      updateLastModified();
    }
  },
  { immediate: true }
);

// CodeMirror å†…å®¹å˜åŒ–å¤„ç†
const handleChange = (value) => {
  internalContent.value = value;
  hasUnsavedChanges.value = true;
  updateLastModified();

  // é˜²æŠ–å‘å°„äº‹ä»¶
  clearTimeout(handleChange.timer);
  handleChange.timer = setTimeout(() => {
    emit("content-change", value);
    hasUnsavedChanges.value = false;
  }, 1000);
};

// ç¼–è¾‘å™¨å‡†å¤‡å°±ç»ª
const handleReady = (payload) => {
  console.log("CodeMirror ready:", payload);
};

// æ›´æ–°å…‰æ ‡ä½ç½®
const updateCursorPosition = () => {
  if (!cmRef.value) return;

  try {
    const view = cmRef.value.view;
    if (view) {
      const selection = view.state.selection.main;
      const line = view.state.doc.lineAt(selection.head);
      cursorLine.value = line.number;
      cursorColumn.value = selection.head - line.from + 1;
    }
  } catch (error) {
    console.log("Failed to update cursor position:", error);
  }
};

// åˆ‡æ¢è‡ªåŠ¨æ¢è¡Œ
const toggleWordWrap = () => {
  wordWrap.value = !wordWrap.value;
};

// åˆ‡æ¢ä¸»é¢˜
const toggleTheme = () => {
  isDarkTheme.value = !isDarkTheme.value;
};

// æ ¼å¼åŒ–ä»£ç 
const formatCode = async () => {
  formatting.value = true;
  try {
    // ç®€å•çš„HTMLæ ¼å¼åŒ–
    let formatted = internalContent.value;

    // ç§»é™¤å¤šä½™ç©ºç™½
    formatted = formatted.replace(/>\s+</g, "><");

    // æ·»åŠ æ¢è¡Œå’Œç¼©è¿›
    let indentLevel = 0;
    const lines = [];
    const tokens = formatted.match(/<\/?[^>]+>|[^<]+/g) || [];

    for (const token of tokens) {
      if (token.startsWith("</")) {
        indentLevel = Math.max(0, indentLevel - 1);
        lines.push("  ".repeat(indentLevel) + token.trim());
      } else if (token.startsWith("<") && !token.endsWith("/>")) {
        lines.push("  ".repeat(indentLevel) + token.trim());
        if (!token.match(/^<(area|base|br|col|embed|hr|img|input|link|meta|param|source|track|wbr)/i)) {
          indentLevel++;
        }
      } else {
        const trimmed = token.trim();
        if (trimmed) {
          lines.push("  ".repeat(indentLevel) + trimmed);
        }
      }
    }

    internalContent.value = lines.join("\n");
    handleChange(internalContent.value);
  } catch (error) {
    console.error("æ ¼å¼åŒ–å¤±è´¥:", error);
  } finally {
    formatting.value = false;
  }
};

// ç»„ä»¶æŒ‚è½½
onMounted(() => {
  updateLastModified();

  // æ·»åŠ çª—å£å¤±ç„¦äº‹ä»¶ï¼Œè‡ªåŠ¨ä¿å­˜
  const handleBeforeUnload = (event) => {
    if (hasUnsavedChanges.value) {
      event.preventDefault();
      event.returnValue = "æœ‰æœªä¿å­˜çš„æ›´æ”¹ï¼Œç¡®å®šè¦ç¦»å¼€å—ï¼Ÿ";
    }
  };

  window.addEventListener("beforeunload", handleBeforeUnload);

  // ç»„ä»¶å¸è½½æ—¶ç§»é™¤äº‹ä»¶ç›‘å¬
  onUnmounted(() => {
    window.removeEventListener("beforeunload", handleBeforeUnload);
  });
});
</script>

<style lang="scss" scoped>
.code-editor-container {
  height: 100%;
  max-height: 100vh; // é™åˆ¶æœ€å¤§é«˜åº¦ä¸ºè§†çª—é«˜åº¦
  display: flex;
  flex-direction: column;
  background: #ffffff;
  overflow: hidden; // é˜²æ­¢å®¹å™¨æ»šåŠ¨
}

.editor-info-bar {
  background: #f9fafb;
  border-bottom: 1px solid #e5e7eb;
  padding: 8px 16px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  min-height: 40px;

  .info-left {
    display: flex;
    align-items: center;
    font-size: 13px;
    color: #374151;
  }

  .info-right {
    :deep(.ant-btn) {
      color: #6b7280;
      border-color: transparent;

      &:hover {
        color: #f6c82c;
        background: rgba(246, 200, 44, 0.1);
        border-color: transparent;
      }
    }
  }
}

.editor-content-wrapper {
  flex: 1;
  min-height: 0; // é‡è¦ï¼šå…è®¸flexå­å…ƒç´ æ”¶ç¼©
  overflow: hidden;

  :deep(.vue-codemirror) {
    height: 100%;
    overflow: hidden;
  }

  :deep(.cm-editor) {
    height: 100%;
    border: none !important;
    border-radius: 0 !important;
    overflow: hidden;
  }

  :deep(.cm-scroller) {
    font-family: "Monaco", "Consolas", "Ubuntu Mono", monospace;
    height: 100%;
    overflow: auto; // ç¡®ä¿ç¼–è¾‘å™¨å†…éƒ¨å¯æ»šåŠ¨
    max-height: calc(100vh - 200px); // é™åˆ¶æœ€å¤§é«˜åº¦ï¼Œç•™å‡ºå·¥å…·æ å’ŒçŠ¶æ€æ ç©ºé—´
  }

  :deep(.cm-content) {
    min-height: 100%;
    padding: 16px;
  }
}

.editor-status-bar {
  background: #f6c82c;
  padding: 4px 16px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  min-height: 22px;
  font-size: 12px;
  color: #ffffff;
}

// å“åº”å¼è®¾è®¡
@media (max-width: 768px) {
  .editor-info-bar {
    padding: 6px 12px;

    .info-right {
      display: none; // åœ¨å°å±å¹•ä¸Šéšè—å·¥å…·æŒ‰é’®
    }
  }
}
</style>



================================================
FILE: frontend/src/view/editor/render/components/RenderPreview.vue
================================================
<template>
  <div class="render-preview-container">
    <!-- é¢„è§ˆå†…å®¹åŒº -->
    <div class="preview-content-wrapper">
      <div class="preview-frame-container">
        <!-- iframeå®¹å™¨ -->
        <div class="iframe-wrapper">
          <iframe ref="previewIframe" class="preview-iframe" @load="onIframeLoad" />

          <!-- äº¤äº’å±‚ -->
          <InteractionLayer
            v-if="aiEditMode || advancedEditMode"
            ref="interactionLayerRef"
            :iframe-element="previewIframe"
            :enable-resize="advancedEditMode"
            :show-element-info="advancedEditMode"
            :enable-alignment-guides="false"
            @element-selected="handleElementSelected"
            @element-hover="handleElementHover"
            @element-resize="handleElementResize"
            @refresh="handleRefresh"
          />
        </div>

        <!-- åŠ è½½çŠ¶æ€ -->
        <div v-if="loading" class="preview-loading">
          <div class="loading-spinner">
            <i class="fas fa-spinner fa-spin text-blue-500 text-2xl mb-2"></i>
            <span class="text-gray-600">æ­£åœ¨åŠ è½½é¢„è§ˆ...</span>
          </div>
        </div>

        <!-- é”™è¯¯çŠ¶æ€ -->
        <div v-if="error" class="preview-error">
          <div class="error-content">
            <i class="fas fa-exclamation-triangle text-red-500 text-2xl mb-2"></i>
            <span class="text-red-600 mb-2">é¢„è§ˆåŠ è½½å¤±è´¥</span>
            <button @click="retryLoad" class="retry-button">
              <i class="fas fa-redo mr-1"></i>
              é‡è¯•
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, watch, onMounted, onUnmounted, nextTick } from "vue";
import { createPreviewHTML } from "../utils/previewTemplates.js";
import { createIframeManager } from "../utils/iframeManager.js";
import { cleanContent } from "../utils/contentCleaner.js";
import InteractionLayer from "./InteractionLayer.vue";
import { useEditorStore } from "@/store/modules/editor";

const props = defineProps({
  htmlContent: {
    type: String,
    default: "",
  },
  path: {
    type: String,
    default: "",
  },
  aiEditMode: {
    type: Boolean,
    default: false,
  },
  advancedEditMode: {
    type: Boolean,
    default: false,
  },
});

const emit = defineEmits(["content-updated", "element-selected", "media-edit", "refresh"]);

// ç»„ä»¶å¼•ç”¨
const previewIframe = ref(null);
const interactionLayerRef = ref(null);

// çŠ¶æ€ç®¡ç†
const loading = ref(false);
const error = ref(false);
const isIframeReady = ref(false);

// iframeç®¡ç†å™¨å®ä¾‹
let iframeManager = null;

// iframeåŠ è½½å®Œæˆäº‹ä»¶
const onIframeLoad = async () => {
  // é¿å…é‡å¤å¤„ç†
  if (iframeManager) {
    return;
  }

  const iframe = previewIframe.value;
  if (!iframe) {
    console.warn("Iframe element not found");
    return;
  }

  try {
    loading.value = false;
    error.value = false;
    isIframeReady.value = true;

    // ç­‰å¾…ä¸‹ä¸€ä¸ªtickç¡®ä¿DOMæ›´æ–°
    await nextTick();

    // åˆå§‹åŒ–iframeç®¡ç†å™¨
    initializeIframeManager();

    // å¦‚æœæœ‰åˆå§‹å†…å®¹ï¼Œæ›´æ–°å®ƒ
    if (props.htmlContent) {
      // å»¶è¿Ÿä¸€ä¸‹ç¡®ä¿ç®¡ç†å™¨å®Œå…¨åˆå§‹åŒ–
      setTimeout(() => {
        updateIframeContent();
      }, 100);
    }

    console.log("RenderPreview iframe loaded successfully");
  } catch (err) {
    console.error("RenderPreview iframe load error:", err);
    error.value = true;
    loading.value = false;
  }
};

// åˆå§‹åŒ–iframeç®¡ç†å™¨
const initializeIframeManager = () => {
  // é”€æ¯æ—§çš„ç®¡ç†å™¨
  if (iframeManager) {
    iframeManager.destroy();
    iframeManager = null;
  }

  // æ£€æŸ¥iframeæ˜¯å¦å­˜åœ¨
  if (!previewIframe.value) {
    console.error("Cannot initialize iframe manager: iframe element not found");
    return;
  }

  try {
    iframeManager = createIframeManager(previewIframe.value, {
      editable: false, // é»˜è®¤ä¸å¯ç”¨ç¼–è¾‘ï¼Œç”±ç”¨æˆ·æ‰‹åŠ¨æ§åˆ¶
      injectStyles: false,
    });

    // è®¾ç½®äº‹ä»¶å›è°ƒ
    iframeManager.on("contentChange", handleContentChange);
    iframeManager.on("elementClick", handleIframeElementClick);
    iframeManager.on("elementHover", handleIframeElementHover);
    iframeManager.on("scroll", handleIframeScroll);
    iframeManager.on("editModeChange", handleEditModeChange);
    iframeManager.on("mediaElementDoubleClick", handleMediaElementDoubleClick);
  } catch (error) {
    console.error("Failed to initialize iframe manager:", error);
    iframeManager = null;
  }
};

// å¤„ç†å†…å®¹å˜åŒ–
let isUpdatingFromExternal = false;

const handleContentChange = (cleanContent) => {
  // åœ¨ç¼–è¾‘æ¨¡å¼ä¸‹ï¼Œä¸è‡ªåŠ¨ä¿å­˜ï¼Œç­‰å¾…ç”¨æˆ·é€€å‡ºæ—¶æ‰ä¿å­˜
  // å¦‚æœæ­£åœ¨è¿›è¡Œå¤–éƒ¨æ›´æ–°ï¼Œä¸è§¦å‘ä¿å­˜
  if (!isUpdatingFromExternal && !isEditingMode.value) {
    emit("content-updated", cleanContent);
  }
};

// å¤„ç†ç¼–è¾‘æ¨¡å¼å˜åŒ–
const handleEditModeChange = (editMode) => {
  // ç¼–è¾‘æ¨¡å¼å˜åŒ–ç”±çˆ¶ç»„ä»¶é€šè¿‡ props æ§åˆ¶
};

// å¤„ç†å¤šåª’ä½“å…ƒç´ åŒå‡»äº‹ä»¶
const handleMediaElementDoubleClick = (mediaInfo, event) => {
  return false;
  console.log("[RenderPreview2] Media element double clicked:", {
    mediaInfo,
    mediaType: mediaInfo.mediaType,
    src: mediaInfo.src,
    editorId: mediaInfo.editorId,
    element: mediaInfo.element,
  });

  // è§¦å‘åª’ä½“ç¼–è¾‘äº‹ä»¶
  emit("media-edit", {
    element: mediaInfo,
    mediaType: mediaInfo.mediaType,
    event: event,
  });
};

// ç¼–è¾‘æ¨¡å¼æ§åˆ¶ï¼ˆç”±çˆ¶ç»„ä»¶è§¦å‘ï¼‰
const enterEditMode = (mode) => {
  if (!iframeManager) {
    console.warn("iframeManager not ready");
    return false;
  }

  const success = iframeManager.enterEditMode();
  if (!success) {
    console.error("Failed to enter edit mode");
  }
  return success;
};

const exitEditMode = (shouldSave = false) => {
  if (!iframeManager) {
    console.warn("iframeManager not ready");
    return null;
  }

  const completeHTML = iframeManager.exitEditMode();
  // console.log("[RenderPreview] Complete HTML:", completeHTML);

  // åªæœ‰åœ¨éœ€è¦ä¿å­˜æ—¶æ‰è§¦å‘ä¿å­˜
  if (completeHTML && shouldSave) {
    console.log("[RenderPreview] Saving content on exit");
    emit("content-updated", completeHTML);
  } else if (completeHTML) {
    console.log("[RenderPreview] Exiting without save");
  }

  return completeHTML;
};

// è·å–ç¼–è¾‘å™¨store
const editorStore = useEditorStore();

// å¤„ç†å…ƒç´ ç‚¹å‡»
const handleIframeElementClick = (elementInfo, event) => {
  if (!elementInfo || (!props.aiEditMode && !props.advancedEditMode)) return;

  // æ›´æ–°äº¤äº’å±‚çš„é€‰ä¸­æŒ‡ç¤ºå™¨
  if (interactionLayerRef.value) {
    interactionLayerRef.value.updateSelectionIndicator(elementInfo);
  }

  // åªæœ‰åœ¨AIç¼–è¾‘æ¨¡å¼ä¸‹æ‰å¤„ç†canvasæˆªå±å’Œå·¦ä¾§é¢„è§ˆé€»è¾‘
  if (props.aiEditMode && elementInfo.screenshot) {
    editorStore.setSelectedElement({
      ...elementInfo,
      path: props.path || "",
      html: elementInfo.element?.outerHTML?.substring(0, 500) || "",
    });
  }

  emit("element-selected", elementInfo);
};

// å¤„ç†å…ƒç´ æ‚¬åœ
const handleIframeElementHover = (elementInfo, event) => {
  if (!elementInfo || elementInfo.element === document.body || (!props.aiEditMode && !props.advancedEditMode)) return;

  // æ›´æ–°äº¤äº’å±‚çš„æ‚¬åœæŒ‡ç¤ºå™¨
  if (interactionLayerRef.value) {
    interactionLayerRef.value.updateHoverIndicator(elementInfo);
  }
};

// å¤„ç†iframeæ»šåŠ¨
const handleIframeScroll = (scrollInfo) => {
  // æ›´æ–°äº¤äº’å±‚æŒ‡ç¤ºå™¨ä½ç½®
  if (interactionLayerRef.value && (props.aiEditMode || props.advancedEditMode)) {
    interactionLayerRef.value.handleIframeScroll();
  }
};

// å¤„ç†å…ƒç´ é€‰ä¸­ï¼ˆæ¥è‡ªäº¤äº’å±‚ï¼‰
const handleElementSelected = (elementInfo) => {
  if (props.aiEditMode || props.advancedEditMode) {
    emit("element-selected", elementInfo);
  }
};

// å¤„ç†å…ƒç´ æ‚¬åœï¼ˆæ¥è‡ªäº¤äº’å±‚ï¼‰
const handleElementHover = (elementInfo) => {
  if (props.aiEditMode || props.advancedEditMode) {
    // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ é¢å¤–çš„é€»è¾‘
  }
};

// å¤„ç†å…ƒç´ è°ƒæ•´å¤§å°
const handleElementResize = (resizeInfo) => {
  if (!props.advancedEditMode) return;

  const { element, width, height } = resizeInfo;

  // æ›´æ–°å…ƒç´ å°ºå¯¸
  if (element) {
    element.style.width = `${width}px`;
    element.style.height = `${height}px`;

    // è§¦å‘å†…å®¹æ›´æ–°
    if (iframeManager) {
      iframeManager.handleContentChange();
    }
  }
};

// å¤„ç†åˆ·æ–°è¯·æ±‚
const handleRefresh = () => {
  console.log("[RenderPreview] Refresh requested, emitting to parent...");
  emit("refresh");
};

// æ›´æ–°iframeå†…å®¹
const updateIframeContent = () => {
  if (!isIframeReady.value) {
    console.warn("Iframe not ready yet");
    return;
  }

  if (!iframeManager) {
    console.warn("Iframe manager not initialized, trying to initialize...");
    initializeIframeManager();
    if (!iframeManager) {
      console.error("Failed to initialize iframe manager");
      return;
    }
  }

  try {
    // ä½¿ç”¨ç®€åŒ–çš„HTMLæ¨¡æ¿ï¼ˆä¸åŒ…å«äº¤äº’è„šæœ¬ï¼‰
    // const fullHtml = createPreviewHTML(props.htmlContent);
    const fullHtml = props.htmlContent;

    // é€šè¿‡iframeç®¡ç†å™¨å†™å…¥å†…å®¹å¹¶å¢å¼º
    iframeManager.writeContent(fullHtml);

    // å»¶è¿Ÿè°ƒæ•´é«˜åº¦ï¼Œç­‰å¾…å†…å®¹æ¸²æŸ“å®Œæˆ
    setTimeout(() => {
      adjustIframeHeight();
    }, 500);
  } catch (err) {
    console.error("Failed to update iframe content:", err);
    error.value = true;
  }
};

// é‡è¯•åŠ è½½
const retryLoad = () => {
  error.value = false;
  loading.value = true;

  // é‡æ–°åŠ è½½iframe
  const iframe = previewIframe.value;
  if (iframe) {
    iframe.src = "about:blank";
    setTimeout(() => {
      updateIframeContent();
    }, 100);
  }
};

// é˜²æŠ–å®šæ—¶å™¨
let contentUpdateTimer = null;

// ç›‘å¬HTMLå†…å®¹å˜åŒ–
watch(
  () => props.htmlContent,
  (newContent, oldContent) => {
    // é¿å…åœ¨ç”¨æˆ·ç¼–è¾‘æ—¶é‡æ–°åŠ è½½å†…å®¹å¯¼è‡´æ ·å¼é”™ä¹±
    if (newContent && newContent !== oldContent && isIframeReady.value && iframeManager) {
      // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨
      if (contentUpdateTimer) {
        clearTimeout(contentUpdateTimer);
      }

      // é˜²æŠ–æ›´æ–°ï¼Œé¿å…å¿«é€Ÿåˆ‡æ¢æ—¶çš„å†²çª
      contentUpdateTimer = setTimeout(() => {
        // æ ‡è®°ä¸ºå¤–éƒ¨æ›´æ–°
        isUpdatingFromExternal = true;
        updateIframeContent();
        // é‡ç½®æ ‡è®°
        setTimeout(() => {
          isUpdatingFromExternal = false;
        }, 1000);
        contentUpdateTimer = null;
      }, 150); // 150ms é˜²æŠ–
    }
  }
);

// ç›‘å¬ç¼–è¾‘æ¨¡å¼å˜åŒ–
watch([() => props.aiEditMode, () => props.advancedEditMode], ([aiEdit, advancedEdit], [prevAiEdit, prevAdvancedEdit]) => {
  if (!iframeManager) return;

  const isAnyEditMode = aiEdit || advancedEdit;
  const wasAnyEditMode = prevAiEdit || prevAdvancedEdit;

  // ä»ä¸€ä¸ªç¼–è¾‘æ¨¡å¼åˆ‡æ¢åˆ°å¦ä¸€ä¸ªç¼–è¾‘æ¨¡å¼æ—¶ï¼Œä¸éœ€è¦é€€å‡ºå†è¿›å…¥
  const isSwitchingBetweenEditModes = isAnyEditMode && wasAnyEditMode && (aiEdit !== prevAiEdit || advancedEdit !== prevAdvancedEdit);

  if (isAnyEditMode && !wasAnyEditMode) {
    // ä»é¢„è§ˆæ¨¡å¼è¿›å…¥ç¼–è¾‘æ¨¡å¼
    enterEditMode(aiEdit ? "ai" : "advanced");
  } else if (!isAnyEditMode && wasAnyEditMode) {
    // ä»ç¼–è¾‘æ¨¡å¼å›åˆ°é¢„è§ˆæ¨¡å¼
    // åªæœ‰ä»é«˜çº§ç¼–è¾‘æ¨¡å¼é€€å‡ºæ—¶æ‰ä¿å­˜
    const shouldSave = prevAdvancedEdit;
    console.log("[RenderPreview] Exiting edit mode, shouldSave:", shouldSave, "was advanced edit:", prevAdvancedEdit);
    exitEditMode(shouldSave);
  } else if (isSwitchingBetweenEditModes) {
    // åœ¨ä¸åŒç¼–è¾‘æ¨¡å¼ä¹‹é—´åˆ‡æ¢ï¼Œä¸è§¦å‘ä¿å­˜ï¼Œåªæ˜¯æ¨¡å¼åˆ‡æ¢
    console.log("[RenderPreview] Switching between edit modes without save");
  }
});

// åŠ¨æ€è°ƒæ•´ iframe é«˜åº¦
const adjustIframeHeight = () => {
  const iframe = previewIframe.value;
  if (!iframe) return;

  try {
    const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
    if (iframeDoc && iframeDoc.body) {
      // è·å–å†…å®¹å®é™…é«˜åº¦
      const contentHeight = Math.max(iframeDoc.body.scrollHeight, iframeDoc.body.offsetHeight, iframeDoc.documentElement.scrollHeight, iframeDoc.documentElement.offsetHeight);

      // è®¾ç½®æœ€å°é«˜åº¦ï¼Œä½†ä¸è¶…è¿‡è§†çª—é«˜åº¦
      const minHeight = Math.max(500, contentHeight);
      const maxHeight = window.innerHeight - 120;
      console.log("minHeight", minHeight);
      console.log("maxHeight", maxHeight);

      iframe.style.height = Math.min(minHeight, maxHeight) + "px";
    }
  } catch (err) {
    // è·¨åŸŸæˆ–å…¶ä»–é”™è¯¯æ—¶ä½¿ç”¨é»˜è®¤é«˜åº¦
    console.log("Cannot access iframe content for height adjustment");
  }
};

// ç»„ä»¶æŒ‚è½½
onMounted(async () => {
  loading.value = true;

  // ç­‰å¾…DOMæ¸²æŸ“
  await nextTick();

  // åˆå§‹åŒ–iframe
  const iframe = previewIframe.value;
  if (iframe) {
    // è®¾ç½®srcä¸ºabout:blankä¼šè§¦å‘loadäº‹ä»¶
    iframe.src = "about:blank";
  } else {
    console.error("Iframe element not found on mount");
    error.value = true;
    loading.value = false;
  }

  // ç›‘å¬çª—å£å¤§å°å˜åŒ–
  const handleResize = () => {
    adjustIframeHeight();
  };

  window.addEventListener("resize", handleResize);

  // æ¸…ç†äº‹ä»¶ç›‘å¬
  onUnmounted(() => {
    window.removeEventListener("resize", handleResize);
  });
});

// æ›´æ–°å¤šåª’ä½“å…ƒç´ srcçš„æ–¹æ³•ï¼ˆä¾›å¤–éƒ¨è°ƒç”¨ï¼‰
const updateMediaElementSrc = (oldSrc, newSrc, mediaType) => {
  console.log("[RenderPreview2] updateMediaElementSrc called:", { oldSrc, newSrc, mediaType });

  if (!iframeManager) {
    console.warn("[RenderPreview2] iframeManager not ready for media src update");
    return false;
  }

  const result = iframeManager.updateMediaElementBySrc(oldSrc, newSrc, mediaType);
  console.log("[RenderPreview2] updateMediaElementSrc result:", result);
  return result;
};

// é€šè¿‡ç¼–è¾‘å™¨IDæ›´æ–°å¤šåª’ä½“å…ƒç´ ï¼ˆæ›´ç²¾ç¡®çš„æ–¹å¼ï¼‰
const updateMediaElementById = (editorId, newSrc) => {
  console.log("[RenderPreview2] updateMediaElementById called:", { editorId, newSrc });

  if (!iframeManager) {
    console.warn("[RenderPreview2] iframeManager not ready for media ID update");
    return false;
  }

  const result = iframeManager.updateMediaElementById(editorId, newSrc);
  console.log("[RenderPreview2] updateMediaElementById result:", result);
  return result;
};

// æš´éœ²æ–¹æ³•ç»™çˆ¶ç»„ä»¶
defineExpose({
  updateMediaElementSrc,
  updateMediaElementById,
  enterEditMode,
  exitEditMode,
});

// ç»„ä»¶å¸è½½
onUnmounted(() => {
  isIframeReady.value = false;

  // æ¸…ç†é˜²æŠ–å®šæ—¶å™¨
  if (contentUpdateTimer) {
    clearTimeout(contentUpdateTimer);
    contentUpdateTimer = null;
  }

  // æ¸…ç†iframeç®¡ç†å™¨
  if (iframeManager) {
    iframeManager.destroy();
    iframeManager = null;
  }
});
</script>

<style lang="scss" scoped>
.render-preview-container {
  height: 100%;
  display: flex;
  flex-direction: column;
  background: #f8fafc;
}

.preview-content-wrapper {
  flex: 1;
  min-height: 0; // é‡è¦ï¼šå…è®¸flexå­å…ƒç´ æ”¶ç¼©
  padding: 16px;
  overflow: hidden;
  /* ç§»é™¤å›ºå®šé«˜åº¦ï¼Œè®©å®ƒè‡ªé€‚åº”çˆ¶å®¹å™¨ */
}

.preview-frame-container {
  width: 100%;
  height: 100%;
  position: relative;
  background: white;
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  overflow: hidden;
  display: flex;
  flex-direction: column;
}

.iframe-wrapper {
  position: relative;
  width: 100%;
  height: 100%;
  flex: 1;
  overflow: hidden;
}

.preview-iframe {
  width: 100%;
  height: 100%;
  border: none;
  display: block;
  border-radius: 8px;
  min-height: 500px; /* æœ€å°é«˜åº¦ */
}

.preview-loading {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(255, 255, 255, 0.9);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 10;
}

.loading-spinner {
  display: flex;
  flex-direction: column;
  align-items: center;
  text-align: center;
}

.preview-error {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(255, 255, 255, 0.95);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 10;
}

.error-content {
  display: flex;
  flex-direction: column;
  align-items: center;
  text-align: center;
}

.retry-button {
  margin-top: 12px;
  padding: 8px 16px;
  background: #3b82f6;
  color: white;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
  transition: background-color 0.2s;

  &:hover {
    background: #2563eb;
  }

  &:active {
    transform: translateY(1px);
  }
}

// å“åº”å¼è®¾è®¡
@media (max-width: 768px) {
  .preview-content-wrapper {
    padding: 12px;
  }
}
</style>



================================================
FILE: frontend/src/view/editor/render/components/RenderToolBar.vue
================================================
<template>
  <div class="render-toolbar">
    <div class="toolbar-content">
      <!-- å·¦ä¾§ç‰ˆæœ¬é€‰æ‹© -->
      <div class="toolbar-left">
        <a-select v-model:value="selectedVersionId" class="version-selector" :placeholder="getVersionPlaceholder()" @change="handleVersionSelect">
          <template #suffixIcon>
            <i class="fas fa-history text-gray-400"></i>
          </template>
          <a-select-option v-for="version in versions" :key="version.id" :value="version.id">
            <div class="version-option">
              <span class="version-number">v{{ version.version }}</span>
              <span class="version-status" v-if="version.active">
                <i class="fas fa-dot-circle"></i>
              </span>
              <span class="version-status" v-else>
                <i class="fas fa-save"></i>
              </span>
              <span class="version-time">{{ formatTimeShort(version.create_at) }}</span>
            </div>
          </a-select-option>
        </a-select>
      </div>

      <!-- ä¸­é—´æ ‡ç­¾é¡µ -->
      <div class="toolbar-center">
        <div class="tab-group">
          <button class="tab-button" :class="{ active: activeTab === 'preview' }" @click="$emit('tab-change', 'preview')">
            <i class="fas fa-eye mr-2"></i>
            Preview
          </button>
          <button class="tab-button" :class="{ active: activeTab === 'code' }" @click="$emit('tab-change', 'code')">
            <i class="fas fa-code mr-2"></i>
            Code
          </button>
        </div>
      </div>

      <!-- å³ä¾§æ“ä½œæŒ‰é’® -->
      <div class="toolbar-right">
        <div class="edit-buttons">
          <button @click="$emit('ai-edit-toggle')" :class="['edit-button', { active: aiEditMode }]">
            <i class="fas fa-robot mr-2"></i>
            AI
          </button>
          <button @click="$emit('advanced-edit-toggle')" :class="['edit-button', { active: advancedEditMode }]">
            <i class="fas fa-code mr-2"></i>
            Advanced
          </button>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, watch } from "vue";

const props = defineProps({
  versions: {
    type: Array,
    default: () => [],
  },
  currentVersion: {
    type: Object,
    default: null,
  },
  activeTab: {
    type: String,
    default: "preview",
  },
  aiEditMode: {
    type: Boolean,
    default: false,
  },
  advancedEditMode: {
    type: Boolean,
    default: false,
  },
});

const emit = defineEmits(["version-change", "tab-change", "save", "ai-edit-toggle", "advanced-edit-toggle"]);

const selectedVersionId = ref(null);

// ç›‘å¬å½“å‰ç‰ˆæœ¬å˜åŒ–
watch(
  () => props.currentVersion,
  (newVersion) => {
    if (newVersion) {
      selectedVersionId.value = newVersion.id;
    }
  },
  { immediate: true }
);

// å¤„ç†ç‰ˆæœ¬é€‰æ‹©
const handleVersionSelect = (versionId) => {
  const version = props.versions.find((v) => v.id === versionId);
  if (version) {
    emit("version-change", version);
  }
};

// è·å–ç‰ˆæœ¬å ä½ç¬¦æ–‡æœ¬
const getVersionPlaceholder = () => {
  if (!props.versions || props.versions.length === 0) {
    return "No versions";
  }

  const currentVersion = props.versions.find((v) => v.isCurrent);
  if (currentVersion) {
    return `Current: v${currentVersion.index + 1}`;
  }

  return `Total: ${props.versions.length}`;
};

// æ ¼å¼åŒ–æ—¶é—´ - ç®€çŸ­ç‰ˆæœ¬
const formatTimeShort = (timestamp) => {
  if (!timestamp) return "";
  const date = new Date(timestamp);
  const now = new Date();
  const diff = now - date;

  // å°äº1åˆ†é’Ÿ
  if (diff < 60000) {
    return "just now";
  }
  // å°äº1å°æ—¶
  if (diff < 3600000) {
    const minutes = Math.floor(diff / 60000);
    return `${minutes} min ago`;
  }
  // å°äº24å°æ—¶
  if (diff < 86400000) {
    const hours = Math.floor(diff / 3600000);
    return `${hours} hr ago`;
  }
  // å°äº30å¤©
  if (diff < 2592000000) {
    const days = Math.floor(diff / 86400000);
    return `${days} day ago`;
  }
  // æ˜¾ç¤ºæœˆæ—¥
  return date.toLocaleDateString("zh-CN", {
    month: "numeric",
    day: "numeric",
  });
};
</script>

<style lang="scss" scoped>
.render-toolbar {
  background: #ffffff;
  border-bottom: 1px solid #e5e7eb;
  padding: 0 24px;
  min-height: 64px;
  display: flex;
  align-items: center;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
}

.toolbar-content {
  width: 100%;
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.toolbar-left {
  flex: 1;
  max-width: 180px;

  .version-selector {
    width: 100%;

    :deep(.ant-select-selector) {
      background: #ffffff;
      border: 1px solid #d1d5db;
      color: #374151;
      border-radius: 8px;
      transition: all 0.3s ease;

      &:hover,
      &:focus {
        background: #ffffff;
        border-color: #f6c82c;
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(246, 200, 44, 0.15);
      }
    }

    :deep(.ant-select-selection-item) {
      color: #374151 !important;
    }

    :deep(.ant-select-arrow) {
      color: #6b7280;
    }

    :deep(.ant-select-focused .ant-select-selector) {
      border-color: #f6c82c !important;
      box-shadow: 0 0 0 2px rgba(246, 200, 44, 0.2) !important;
    }

    :deep(.ant-select-selection-placeholder) {
      color: #6b7280 !important;
      font-size: 13px;
    }
  }
}

.version-option {
  display: flex;
  align-items: center;
  gap: 8px;

  .version-number {
    font-weight: 600;
    color: #1f2937;
    font-size: 13px;
    font-family: "Monaco", "Consolas", monospace;
    min-width: 24px;
  }

  .version-status {
    i {
      font-size: 10px;
      color: #3b82f6;

      &.fa-save {
        color: #10b981;
      }
    }
  }

  .version-time {
    font-size: 11px;
    color: #6b7280;
    margin-left: auto;
  }
}

.toolbar-center {
  flex: 0 0 auto;
  display: flex;
  justify-content: center;
  max-width: 200px;
}

.tab-group {
  display: flex;
  background: #f9fafb;
  border-radius: 50px;
  padding: 4px;
  gap: 4px;
  border: 1px solid #e5e7eb;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  min-width: 140px;
}

.tab-button {
  display: flex;
  align-items: center;
  padding: 8px 16px;
  border: none;
  background: transparent;
  color: #6b7280;
  border-radius: 50px;
  cursor: pointer;
  transition: all 0.3s ease;
  font-size: 13px;
  font-weight: 500;
  min-width: 60px;
  justify-content: center;

  &:hover {
    background: #e5e7eb;
    color: #374151;
    transform: translateY(-1px);
  }

  &.active {
    background: #232425;
    color: #ffffff;
    font-weight: 600;
    transform: translateY(-2px);
  }

  i {
    font-size: 13px;
    margin-right: 6px;
  }
}

.toolbar-right {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: flex-end;
  gap: 12px;
  max-width: 200px;
}

.action-button {
  border-radius: 8px;
  transition: all 0.3s ease;
  font-weight: 500;

  &.save-button {
    background: #f6c82c;
    border: 1px solid #f6c82c;
    color: #ffffff;
    font-weight: 600;

    &:hover {
      background: #f5c321;
      border-color: #f5c321;
      color: #ffffff;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(246, 200, 44, 0.3);
    }
  }
}

.edit-buttons {
  display: flex;
  gap: 8px;
}

.edit-button {
  display: flex;
  align-items: center;
  padding: 8px 12px;
  border: 1px solid #d1d5db;
  background: #ffffff;
  color: #6b7280;
  border-radius: 6px;
  cursor: pointer;
  transition: all 0.3s ease;
  font-size: 12px;
  font-weight: 500;

  &:hover {
    background: #f9fafb;
    color: #374151;
    border-color: #9ca3af;
    transform: translateY(-1px);
  }

  &.active {
    background: #3b82f6;
    color: #ffffff;
    border-color: #3b82f6;
    font-weight: 600;
    box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
    transform: translateY(-1px);
  }

  i {
    font-size: 12px;
    margin-right: 4px;
  }
}

// å“åº”å¼è®¾è®¡
@media (max-width: 1024px) {
  .toolbar-left,
  .toolbar-right {
    max-width: 200px;
  }
}

@media (max-width: 768px) {
  .render-toolbar {
    padding: 0 16px;
    min-height: 56px;
  }

  .toolbar-content {
    flex-wrap: wrap;
    gap: 12px;
  }

  .toolbar-left,
  .toolbar-center,
  .toolbar-right {
    flex: none;
  }

  .toolbar-left {
    order: 1;
    width: 100%;
    max-width: none;
  }

  .toolbar-center {
    order: 2;
    max-width: none;
  }

  .toolbar-right {
    order: 3;
    max-width: none;
    flex-direction: column;
    gap: 8px;
  }

  .edit-buttons {
    flex-wrap: wrap;
    justify-content: center;
  }

  .edit-button {
    font-size: 11px;
    padding: 6px 8px;
  }
}
</style>



================================================
FILE: frontend/src/view/editor/render/utils/contentCleaner.js
================================================
/**
 * å†…å®¹æ¸…ç†å·¥å…·
 * è´Ÿè´£æ¸…ç†HTMLå†…å®¹ä¸­çš„æ³¨å…¥å…ƒç´ ã€æ ·å¼å’Œå±æ€§
 */

// éœ€è¦æ¸…ç†çš„å…ƒç´ IDåˆ—è¡¨
const INJECTED_IDS = [
  'iframe-injected-styles',
  'iframe-injected-script',
  'editing-tooltip'
];

// éœ€è¦æ¸…ç†çš„ç±»ååˆ—è¡¨
const INJECTED_CLASSES = [
  'iframe-hover-element',
  'iframe-selected-element',
  'selected-element',
  'editing-element',
  'hover-element',
  'hovered-element'
];

// éœ€è¦æ¸…ç†çš„å±æ€§
const ATTRIBUTES_TO_CLEAN = {
  contenteditable: ['true', 'false'],
  tabindex: ['-1']
};

// éœ€è¦æ¸…ç†çš„å†…è”æ ·å¼
const INLINE_STYLES_TO_CLEAN = [
  'outline',
  'min-height',
  'cursor',
  'box-shadow',
  'transition'
];

/**
 * æ¸…ç†HTMLå†…å®¹
 * @param {Document|Element} source - è¦æ¸…ç†çš„æºï¼ˆdocumentæˆ–elementï¼‰
 * @param {Object} options - æ¸…ç†é€‰é¡¹
 * @returns {string} æ¸…ç†åçš„HTMLå­—ç¬¦ä¸²
 */
export function cleanContent(source, options = {}) {
  const {
    removeScripts = true,
    removeStyles = true,
    removeEditableAttr = true,
    removeInjectedClasses = true,
    removeInlineStyles = true,
    customCleaners = []
  } = options;

  // ç¡®å®šè¦å¤„ç†çš„å…ƒç´ 
  let element;
  if (source.nodeType === Node.DOCUMENT_NODE) {
    element = source.body.cloneNode(true);
  } else if (source.nodeType === Node.ELEMENT_NODE) {
    element = source.cloneNode(true);
  } else {
    throw new Error('Source must be a Document or Element');
  }

  // æ‰§è¡Œæ¸…ç†æ­¥éª¤
  if (removeScripts) {
    cleanScripts(element);
  }

  if (removeStyles) {
    cleanStyles(element);
  }

  if (removeEditableAttr) {
    cleanEditableAttributes(element);
  }

  if (removeInjectedClasses) {
    cleanClasses(element);
  }

  if (removeInlineStyles) {
    cleanInlineStyles(element);
  }

  // æ‰§è¡Œè‡ªå®šä¹‰æ¸…ç†å™¨
  customCleaners.forEach(cleaner => {
    if (typeof cleaner === 'function') {
      cleaner(element);
    }
  });

  return element.innerHTML;
}

/**
 * æ¸…ç†è„šæœ¬å…ƒç´ 
 */
function cleanScripts(element) {
  // åªç§»é™¤æˆ‘ä»¬æ³¨å…¥çš„è„šæœ¬ï¼Œä¿ç•™ç”¨æˆ·çš„è„šæœ¬
  element.querySelectorAll('script').forEach(script => {
    // åªç§»é™¤å¸¦æœ‰ç‰¹å®šIDçš„æ³¨å…¥è„šæœ¬
    if (INJECTED_IDS.includes(script.id)) {
      script.remove();
    }
  });
}

/**
 * æ¸…ç†æ ·å¼å…ƒç´ 
 */
function cleanStyles(element) {
  // ç§»é™¤æ³¨å…¥çš„styleæ ‡ç­¾
  INJECTED_IDS.forEach(id => {
    const style = element.querySelector(`#${id}`);
    if (style) {
      style.remove();
    }
  });

  // ç§»é™¤åŒ…å«ç‰¹å®šå†…å®¹çš„styleæ ‡ç­¾
  element.querySelectorAll('style').forEach(style => {
    const content = style.textContent;
    if (content.includes('iframe-hover-element') ||
      content.includes('iframe-selected-element') ||
      content.includes('contenteditable')) {
      style.remove();
    }
  });
}

/**
 * æ¸…ç†å¯ç¼–è¾‘å±æ€§
 */
function cleanEditableAttributes(element) {
  // æ¸…ç†æ ¹å…ƒç´ çš„contenteditable
  if (element.getAttribute('contenteditable') === 'true') {
    element.removeAttribute('contenteditable');
  }

  // æ¸…ç†æ‰€æœ‰å­å…ƒç´ çš„contenteditable
  element.querySelectorAll('[contenteditable]').forEach(el => {
    const value = el.getAttribute('contenteditable');
    if (ATTRIBUTES_TO_CLEAN.contenteditable.includes(value)) {
      el.removeAttribute('contenteditable');
    }
  });

  // æ¸…ç†tabindex
  element.querySelectorAll('[tabindex]').forEach(el => {
    const value = el.getAttribute('tabindex');
    if (ATTRIBUTES_TO_CLEAN.tabindex.includes(value)) {
      el.removeAttribute('tabindex');
    }
  });
}

/**
 * æ¸…ç†æ³¨å…¥çš„ç±»å
 */
function cleanClasses(element) {
  // æ¸…ç†æ ¹å…ƒç´ çš„ç±»
  INJECTED_CLASSES.forEach(className => {
    element.classList.remove(className);
  });

  // æ¸…ç†æ‰€æœ‰å­å…ƒç´ çš„ç±»
  element.querySelectorAll('*').forEach(el => {
    INJECTED_CLASSES.forEach(className => {
      el.classList.remove(className);
    });

    // å¦‚æœå…ƒç´ æ²¡æœ‰ç±»äº†ï¼Œç§»é™¤classå±æ€§
    if (el.classList.length === 0) {
      el.removeAttribute('class');
    }
  });
}

/**
 * æ¸…ç†å†…è”æ ·å¼
 */
function cleanInlineStyles(element) {
  // æ¸…ç†æ ¹å…ƒç´ çš„æ ·å¼
  cleanElementInlineStyles(element);

  // æ¸…ç†æ‰€æœ‰å­å…ƒç´ çš„æ ·å¼
  element.querySelectorAll('*').forEach(el => {
    cleanElementInlineStyles(el);
  });
}

/**
 * æ¸…ç†å•ä¸ªå…ƒç´ çš„å†…è”æ ·å¼
 */
function cleanElementInlineStyles(element) {
  if (!element.style) return;

  INLINE_STYLES_TO_CLEAN.forEach(prop => {
    element.style.removeProperty(prop);
  });

  // å¦‚æœstyleå±æ€§ä¸ºç©ºï¼Œç§»é™¤å®ƒ
  if (element.getAttribute('style') === '') {
    element.removeAttribute('style');
  }
}

/**
 * åˆ›å»ºè‡ªå®šä¹‰æ¸…ç†å™¨
 */
export function createCustomCleaner(selector, action) {
  return (element) => {
    element.querySelectorAll(selector).forEach(el => {
      action(el);
    });
  };
}

/**
 * æ™ºèƒ½æ£€æµ‹å¹¶æ¸…ç†HTMLå†…å®¹
 * è‡ªåŠ¨æ£€æµ‹æ˜¯å®Œæ•´HTMLæ–‡æ¡£è¿˜æ˜¯ç‰‡æ®µ
 */
export function smartCleanContent(htmlString, options = {}) {
  const isCompleteHTML = htmlString.trim().toLowerCase().startsWith('<!doctype') ||
    htmlString.includes('<html');

  if (isCompleteHTML) {
    // è§£æå®Œæ•´HTML
    const parser = new DOMParser();
    const doc = parser.parseFromString(htmlString, 'text/html');

    // æ¸…ç†headä¸­çš„æ³¨å…¥å†…å®¹
    cleanHeadContent(doc.head);

    // æ¸…ç†body
    const cleanedBody = cleanContent(doc, options);

    // é‡æ–°ç»„è£…HTML
    return assembleHTML(doc, cleanedBody);
  } else {
    // å¤„ç†HTMLç‰‡æ®µ
    const wrapper = document.createElement('div');
    wrapper.innerHTML = htmlString;
    return cleanContent(wrapper, options);
  }
}

/**
 * æ¸…ç†headå†…å®¹
 */
function cleanHeadContent(head) {
  if (!head) return;

  // ç§»é™¤æ³¨å…¥çš„styleæ ‡ç­¾
  head.querySelectorAll('style').forEach(style => {
    if (style.id && INJECTED_IDS.includes(style.id)) {
      style.remove();
    }

    // æ£€æŸ¥å†…å®¹
    const content = style.textContent;
    if (content.includes('contenteditable') ||
      content.includes('iframe-hover-element')) {
      style.remove();
    }
  });
}

/**
 * é‡æ–°ç»„è£…HTMLæ–‡æ¡£
 */
function assembleHTML(doc, bodyContent) {
  const htmlParts = [];

  // DOCTYPE
  htmlParts.push('<!DOCTYPE html>');

  // HTMLæ ‡ç­¾å’Œå±æ€§
  const htmlAttrs = Array.from(doc.documentElement.attributes)
    .map(attr => `${attr.name}="${attr.value}"`)
    .join(' ');
  htmlParts.push(`<html${htmlAttrs ? ' ' + htmlAttrs : ''}>`);

  // HEAD
  htmlParts.push('<head>');
  htmlParts.push(doc.head.innerHTML);
  htmlParts.push('</head>');

  // BODY
  const bodyAttrs = Array.from(doc.body.attributes)
    .filter(attr => attr.name !== 'contenteditable')
    .map(attr => `${attr.name}="${attr.value}"`)
    .join(' ');
  htmlParts.push(`<body${bodyAttrs ? ' ' + bodyAttrs : ''}>`);
  htmlParts.push(bodyContent);
  htmlParts.push('</body>');

  htmlParts.push('</html>');

  return htmlParts.join('\n');
}

/**
 * æ¯”è¾ƒæ¸…ç†å‰åçš„å·®å¼‚ï¼ˆç”¨äºè°ƒè¯•ï¼‰
 */
export function compareBeforeAfter(original, cleaned) {
  const changes = {
    removedScripts: [],
    removedStyles: [],
    removedClasses: [],
    removedAttributes: [],
    modified: false
  };

  // ç®€å•çš„æ–‡æœ¬æ¯”è¾ƒ
  if (original !== cleaned) {
    changes.modified = true;

    // ç»Ÿè®¡ç§»é™¤çš„å†…å®¹
    const scriptMatches = original.match(/<script[^>]*>[\s\S]*?<\/script>/gi) || [];
    const cleanedScripts = cleaned.match(/<script[^>]*>[\s\S]*?<\/script>/gi) || [];
    changes.removedScripts = scriptMatches.length - cleanedScripts.length;

    const styleMatches = original.match(/<style[^>]*>[\s\S]*?<\/style>/gi) || [];
    const cleanedStyles = cleaned.match(/<style[^>]*>[\s\S]*?<\/style>/gi) || [];
    changes.removedStyles = styleMatches.length - cleanedStyles.length;
  }

  return changes;
}

/**
 * å¯¼å‡ºé»˜è®¤æ¸…ç†å‡½æ•°
 */
export default cleanContent;


================================================
FILE: frontend/src/view/editor/render/utils/iframeManager.js
================================================
/**
 * iframe ç®¡ç†å™¨
 * è´Ÿè´£å¤„ç†iframeçš„DOMæ“ä½œã€å†…å®¹æ³¨å…¥ã€äº‹ä»¶ç›‘å¬ç­‰
 */

import { snapdom } from '@zumer/snapdom';

export class IframeManager {
  constructor(iframe, options = {}) {
    this.iframe = iframe;
    this.document = null;
    this.window = null;
    this.options = {
      editable: true,
      ...options
    };

    // æ³¨å…¥çš„å…ƒç´ ID
    this.INJECTED_STYLE_ID = 'iframe-injected-styles';
    this.INJECTED_SCRIPT_ID = 'iframe-injected-script';

    // äº‹ä»¶å›è°ƒ
    this.callbacks = {
      onContentChange: null,
      onElementClick: null,
      onElementHover: null,
      onScroll: null,
      onEditModeChange: null,
      onMediaElementDoubleClick: null
    };

    // ç¼–è¾‘çŠ¶æ€
    this.isEditingMode = false;

    // å†…å®¹å˜åŒ–ç›‘å¬å™¨
    this.mutationObserver = null;
    this.contentChangeTimer = null;
    this.lastContent = null; // è®°å½•ä¸Šæ¬¡çš„å†…å®¹ï¼Œç”¨äºæ¯”è¾ƒæ˜¯å¦çœŸçš„å˜åŒ–äº†
    this.originalBodyStyle = null; // è®°å½•åŸå§‹bodyæ ·å¼

    // è®°å½•åŸå§‹çš„headå…ƒç´ ä¿¡æ¯ï¼Œç”¨äºè¯†åˆ«åŠ¨æ€æ·»åŠ çš„å†…å®¹
    this.originHeadElementSet = new Set();
  }

  /**
   * é‡ç½® iframeï¼Œæ¸…ç†æ‰€æœ‰å†…å®¹å’Œè„šæœ¬çŠ¶æ€
   */
  resetIframe() {
    if (!this.iframe) return;
    console.log(`[resetIframe] Resetting iframe for ${this.iframe}`);
    try {
      this.cleanup();
      this.iframe.src = 'about:blank';
      this.iframe.contentWindow?.location.reload?.();

    } catch (error) {
      console.error('Error resetting iframe:', error);
    }
  }

  /**
   * æ¸…ç†ç®¡ç†å™¨çŠ¶æ€
   */
  cleanup() {
    // åœæ­¢è§‚å¯Ÿ
    if (this.mutationObserver) {
      this.mutationObserver.disconnect();
      this.mutationObserver = null;
    }

    // æ¸…é™¤å®šæ—¶å™¨
    if (this.contentChangeTimer) {
      clearTimeout(this.contentChangeTimer);
      this.contentChangeTimer = null;
    }

    // é‡ç½®çŠ¶æ€
    this.isEditingMode = false;
    this.document = null;
    this.window = null;
    this.lastContent = null;
    this.originHeadElementSet.clear();
  }

  /**
   * å†™å…¥ HTML å†…å®¹
   */
  writeContent(html) {
    if (!this.iframe) {
      console.error('Cannot write content: iframe not found');
      return;
    }

    try {
      this.resetIframe();

      // å…ˆä»HTMLæºç ä¸­è§£æåŸå§‹headå…ƒç´ 
      this.parseOriginalHeadElements(html);

      setTimeout(() => {
        const doc = this.iframe.contentDocument || this.iframe.contentWindow?.document;
        if (!doc) {
          console.error('Cannot access iframe document');
          return;
        }

        doc.open();

        if (html.includes('<!DOCTYPE') || html.includes('<html')) {
          doc.write(html);
        } else {
          doc.write(`<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>${html}</body>
</html>`);
        }

        doc.close();

        this.document = doc;
        this.window = this.iframe.contentWindow;

        this.waitForContent();
      }, 50);
    } catch (error) {
      console.error('Error writing iframe content:', error);
    }
  }

  /**
   * ä»HTMLæºç ä¸­è§£æåŸå§‹headå…ƒç´ 
   */
  parseOriginalHeadElements(html) {
    this.originHeadElementSet.clear();

    try {
      // ä½¿ç”¨DOMParserè§£æHTML
      const parser = new DOMParser();
      const doc = parser.parseFromString(html, 'text/html');

      if (doc && doc.head) {
        const headElements = doc.head.querySelectorAll('style, link[rel="stylesheet"], script');
        console.log(`[parseOriginalHeadElements] Found ${headElements.length} original head elements in source HTML`);

        headElements.forEach(element => {
          const identifier = this.getElementIdentifier(element);
          if (identifier) {
            this.originHeadElementSet.add(identifier);
            console.log(`[parseOriginalHeadElements] Added: ${identifier}`);
          }
        });

        console.log(`[parseOriginalHeadElements] Total recorded: ${this.originHeadElementSet.size} elements`);
      }
    } catch (error) {
      console.error('[parseOriginalHeadElements] Error parsing HTML:', error);
    }
  }

  /**
   * è·å–å…ƒç´ çš„å”¯ä¸€æ ‡è¯†
   * ç®—æ³•é€»è¾‘ï¼š
   * 1. å–å…ƒç´ çš„outerHTMLå‰200ä¸ªå­—ç¬¦
   * 2. ç”Ÿæˆä¸€ä¸ªç®€å•çš„å“ˆå¸Œå€¼
   * 3. è¿”å›æ ¼å¼ä¸º `${tagName}-${hash}` çš„å­—ç¬¦ä¸²
   */
  getElementIdentifier(element) {
    if (!element) return null;

    const tagName = element.tagName.toLowerCase();
    const encodedHtml = element.outerHTML.substring(0, 200);

    let hash = 0;
    for (let i = 0; i < encodedHtml.length; i++) {
      const char = encodedHtml.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32bit integer
    }
    const identifier = `${tagName}-${hash}`;
    // console.log('identifier', identifier);
    return identifier;
  }

  /**
   * ç­‰å¾…å†…å®¹åŠ è½½å®Œæˆ
   */
  waitForContent() {
    let attempts = 0;
    const maxAttempts = 50; // æœ€å¤šå°è¯•50æ¬¡

    const checkContent = () => {
      attempts++;

      if (!this.document) {
        console.error('Document reference lost');
        return;
      }

      // æ£€æŸ¥bodyæ˜¯å¦å­˜åœ¨
      if (this.document.body) {
        // è®°å½•åˆå§‹å†…å®¹
        this.lastContent = this.document.body.innerHTML;

        // å¢å¼ºåŠŸèƒ½
        this.enhance();
      } else if (attempts < maxAttempts) {
        // ç»§ç»­ç­‰å¾…
        setTimeout(checkContent, 20);
      } else {
        console.error('Timeout waiting for iframe body');
      }
    };

    // æ ¹æ®documentçŠ¶æ€å†³å®šä½•æ—¶å¼€å§‹æ£€æŸ¥
    if (this.document.readyState === 'loading') {
      this.document.addEventListener('DOMContentLoaded', checkContent);
    } else {
      // ç«‹å³å¼€å§‹æ£€æŸ¥
      setTimeout(checkContent, 10);
    }
  }

  /**
   * å¢å¼º iframe åŠŸèƒ½
   */
  enhance() {
    // å†æ¬¡æ£€æŸ¥bodyæ˜¯å¦å­˜åœ¨
    if (!this.document || !this.document.body) {
      console.warn('Document body not ready for enhancement');
      return;
    }
    // è®¾ç½®äº‹ä»¶ç›‘å¬
    this.setupEventListeners();
  }

  /**
   * å¯ç”¨ç¼–è¾‘åŠŸèƒ½
   */
  enableEditing() {
    if (!this.document.body) return;

    // ä¿å­˜åŸå§‹bodyæ ·å¼
    this.originalBodyStyle = this.document.body.getAttribute('style') || '';

    // åªè®¾ç½®contentEditableï¼Œä¸ä¿®æ”¹å…¶ä»–æ ·å¼
    this.document.body.contentEditable = 'true';

    // åªåœ¨æ²¡æœ‰è®¾ç½®çš„æƒ…å†µä¸‹æ·»åŠ æœ€å°é«˜åº¦
    if (!this.document.body.style.minHeight) {
      this.document.body.style.minHeight = '100vh';
    }

    // é˜²æ­¢ç¼–è¾‘æ—¶çš„é»˜è®¤èšç„¦æ¡†
    this.document.body.addEventListener('focus', () => {
      this.document.body.style.outline = 'none';
    });
  }

  /**
   * ç¦ç”¨ç¼–è¾‘åŠŸèƒ½
   */
  disableEditing() {
    if (!this.document.body) return;

    this.document.body.contentEditable = 'false';
    this.isEditingMode = false;

    // åœæ­¢å†…å®¹ç›‘å¬
    if (this.mutationObserver) {
      this.mutationObserver.disconnect();
      this.mutationObserver = null;
    }

    // æ¸…é™¤é˜²æŠ–å®šæ—¶å™¨
    if (this.contentChangeTimer) {
      clearTimeout(this.contentChangeTimer);
      this.contentChangeTimer = null;
    }
  }

  /**
   * è¿›å…¥ç¼–è¾‘æ¨¡å¼
   */
  enterEditMode() {
    if (!this.document || !this.document.body) {
      console.warn('Cannot enter edit mode: document not ready');
      return false;
    }

    if (this.isEditingMode) {
      return true; // å·²ç»åœ¨ç¼–è¾‘æ¨¡å¼
    }

    this.isEditingMode = true;
    this.enableEditing();
    this.setupContentMonitor();

    // è§¦å‘ç¼–è¾‘æ¨¡å¼å›è°ƒ
    if (this.callbacks.onEditModeChange) {
      this.callbacks.onEditModeChange(true);
    }

    return true;
  }

  /**
   * é€€å‡ºç¼–è¾‘æ¨¡å¼
   */
  exitEditMode() {
    if (!this.isEditingMode) {
      return null; // ä¸åœ¨ç¼–è¾‘æ¨¡å¼
    }

    // è·å–å®Œæ•´HTMLå†…å®¹
    const completeHTML = this.getCompleteHTML();

    this.disableEditing();

    // è§¦å‘ç¼–è¾‘æ¨¡å¼å›è°ƒ
    if (this.callbacks.onEditModeChange) {
      this.callbacks.onEditModeChange(false);
    }

    return completeHTML;
  }

  /**
   * è®¾ç½®äº‹ä»¶ç›‘å¬
   */
  setupEventListeners() {
    // ç‚¹å‡»äº‹ä»¶ - ä¸è¦é˜»æ­¢é»˜è®¤è¡Œä¸ºï¼Œå¦åˆ™æ— æ³•ç¼–è¾‘
    this.document.addEventListener('click', async (e) => {
      // åªåœ¨é€‰æ‹©å…ƒç´ æ—¶è§¦å‘ï¼Œä¸å½±å“ç¼–è¾‘
      if (this.callbacks.onElementClick) {
        const elementInfo = this.getElementInfo(e.target);

        // ä½¿ç”¨ snapdom è·å–å…ƒç´ æˆªå›¾
        try {
          const result = await snapdom(e.target, {
            format: 'png',
            quality: 0.9
          });

          // ä½¿ç”¨ toCanvas è·å– canvas å…ƒç´ ï¼Œç„¶åè½¬æ¢ä¸º base64
          const canvas = await result.toCanvas();
          const imageBase64 = canvas.toDataURL('image/png');
          elementInfo.screenshot = imageBase64;

          console.log('Element screenshot captured:', {
            element: e.target.tagName,
            id: e.target.id,
            class: e.target.className,
            imageSize: imageBase64.length
          });
        } catch (error) {
          console.error('Failed to capture element screenshot:', error);
          elementInfo.screenshot = null;
        }

        this.callbacks.onElementClick(elementInfo, e);
      }
    });

    // åŒå‡»äº‹ä»¶ - å¤„ç†å¤šåª’ä½“å…ƒç´ å¿«é€Ÿç¼–è¾‘
    this.document.addEventListener('dblclick', (e) => {
      e.preventDefault();
      e.stopPropagation();

      if (this.isMediaElement(e.target)) {
        // å¤šåª’ä½“å…ƒç´ ï¼Œè§¦å‘åª’ä½“ç¼–è¾‘å›è°ƒ
        if (this.callbacks.onMediaElementDoubleClick) {
          const elementInfo = this.getElementInfo(e.target);
          this.callbacks.onMediaElementDoubleClick({
            ...elementInfo,
            mediaType: e.target.tagName.toLowerCase()
          }, e);
        }
      }
    });

    // é¼ æ ‡ç§»åŠ¨äº‹ä»¶ï¼ˆæ‚¬åœï¼‰
    this.document.addEventListener('mousemove', (e) => {
      if (this.callbacks.onElementHover) {
        const elementInfo = this.getElementInfo(e.target);
        this.callbacks.onElementHover(elementInfo, e);
      }
    });

    // æ»šåŠ¨äº‹ä»¶
    this.window.addEventListener('scroll', (e) => {
      if (this.callbacks.onScroll) {
        this.callbacks.onScroll({
          scrollTop: this.window.scrollY,
          scrollLeft: this.window.scrollX
        }, e);
      }
    });

    // é”®ç›˜äº‹ä»¶
    this.document.addEventListener('keydown', (e) => {
      // é˜»æ­¢ä¸€äº›é»˜è®¤è¡Œä¸º
      if (e.key === 'Tab') {
        e.preventDefault();
        // æ’å…¥åˆ¶è¡¨ç¬¦
        document.execCommand('insertText', false, '\t');
      }
    });
  }

  /**
   * è®¾ç½®å†…å®¹ç›‘å¬
   */
  setupContentMonitor() {
    if (!this.document.body) {
      console.warn('Document body not available for content monitoring');
      return;
    }

    // ä½¿ç”¨ MutationObserver ç›‘å¬DOMå˜åŒ–
    this.mutationObserver = new MutationObserver((mutations) => {
      // è¿‡æ»¤æ‰åªæ˜¯æ ·å¼å˜åŒ–çš„mutation
      const hasContentChange = mutations.some(mutation => {
        // å¿½ç•¥åªæ˜¯å±æ€§å˜åŒ–çš„æƒ…å†µ
        if (mutation.type === 'attributes') {
          const attr = mutation.attributeName;
          // å¿½ç•¥æ ·å¼å’Œcontenteditableå±æ€§çš„å˜åŒ–
          if (attr === 'style' || attr === 'contenteditable' || attr === 'data-editor-id') {
            return false;
          }
        }
        // æ–‡æœ¬å†…å®¹æˆ–å­èŠ‚ç‚¹å˜åŒ–æ‰ç®—çœŸæ­£çš„å†…å®¹å˜åŒ–
        return mutation.type === 'characterData' || mutation.type === 'childList';
      });

      if (hasContentChange) {
        this.handleContentChange();
      }
    });

    this.mutationObserver.observe(this.document.body, {
      childList: true,
      subtree: true,
      characterData: true,
      attributes: true,
      attributeOldValue: true, // å¯ç”¨æ—§å€¼è®°å½•
      attributeFilter: ['src', 'href', 'alt', 'title', 'class'] // ç›‘å¬è¿™äº›å±æ€§çš„å˜åŒ–
    });

    // ç›‘å¬inputäº‹ä»¶ï¼ˆæ›´å³æ—¶çš„å“åº”ï¼‰
    this.document.body.addEventListener('input', () => {
      this.handleContentChange();
    });
  }

  /**
   * å¤„ç†å†…å®¹å˜åŒ–
   */
  handleContentChange() {
    // é˜²æŠ–å¤„ç†
    if (this.contentChangeTimer) {
      clearTimeout(this.contentChangeTimer);
    }

    this.contentChangeTimer = setTimeout(() => {
      if (this.callbacks.onContentChange) {
        const cleanContent = this.getCleanContent();

        // åªæœ‰å†…å®¹çœŸæ­£å˜åŒ–æ—¶æ‰è§¦å‘å›è°ƒ
        // ä½¿ç”¨trim()æ¯”è¾ƒï¼Œå¿½ç•¥ç©ºç™½å­—ç¬¦å·®å¼‚
        if (cleanContent.trim() !== this.lastContent?.trim()) {
          this.lastContent = cleanContent;
          this.callbacks.onContentChange(cleanContent);
        }
      }
    }, 800); // å¢åŠ é˜²æŠ–æ—¶é—´ï¼Œé¿å…é¢‘ç¹è§¦å‘
  }

  /**
   * è·å–å…ƒç´ ä¿¡æ¯
   */
  getElementInfo(element) {
    if (!element) return null;

    const rect = element.getBoundingClientRect();
    const computedStyle = this.window.getComputedStyle(element);
    const attrs = this.getElementAttributes(element);

    // ä¸ºå¤šåª’ä½“å…ƒç´ ç‰¹åˆ«å¤„ç† src å±æ€§
    let currentSrc = null;
    if (this.isMediaElement(element)) {
      currentSrc = this.getMediaElementSrc(element);
      // ä¸ºå¤šåª’ä½“å…ƒç´ æ·»åŠ å”¯ä¸€æ ‡è¯†ç¬¦ï¼ˆå¦‚æœè¿˜æ²¡æœ‰çš„è¯ï¼‰
      this.ensureMediaElementId(element);
    }

    return {
      element,
      tagName: element.tagName,
      id: element.id,
      className: element.className,
      innerHTML: element.innerHTML,
      textContent: element.textContent,
      attributes: attrs,
      // ç›´æ¥æä¾›å¸¸ç”¨çš„åª’ä½“å±æ€§
      src: currentSrc || attrs.src,
      href: attrs.href,
      data: attrs.data,
      alt: attrs.alt,
      title: attrs.title,
      // æ·»åŠ ç¼–è¾‘å™¨ä¸“ç”¨çš„ID
      editorId: attrs['data-editor-id'] || this.generateElementId(),
      rect: {
        top: rect.top + this.window.scrollY,
        left: rect.left + this.window.scrollX,
        width: rect.width,
        height: rect.height,
        bottom: rect.bottom + this.window.scrollY,
        right: rect.right + this.window.scrollX
      },
      style: {
        display: computedStyle.display,
        position: computedStyle.position,
        zIndex: computedStyle.zIndex
      },
      isEditable: element.isContentEditable,
      path: this.getElementPath(element)
    };
  }

  /**
   * è·å–å…ƒç´ å±æ€§
   */
  getElementAttributes(element) {
    const attrs = {};
    for (let attr of element.attributes) {
      attrs[attr.name] = attr.value;
    }
    return attrs;
  }

  /**
   * è·å–å…ƒç´ è·¯å¾„
   */
  getElementPath(element) {
    const path = [];
    let current = element;

    while (current && current !== this.document.body) {
      const tagName = current.tagName.toLowerCase();
      const id = current.id ? `#${current.id}` : '';
      const className = current.className ? `.${current.className.split(' ').join('.')}` : '';
      path.unshift(`${tagName}${id}${className}`);
      current = current.parentElement;
    }

    return path.join(' > ');
  }

  /**
   * æ£€æŸ¥æ˜¯å¦ä¸ºå¤šåª’ä½“å…ƒç´ 
   */
  isMediaElement(element) {
    if (!element || !element.tagName) return false;
    const mediaTypes = ['IMG', 'VIDEO', 'AUDIO', 'EMBED', 'OBJECT', 'IFRAME'];
    return mediaTypes.includes(element.tagName.toUpperCase());
  }

  /**
   * è·å–å¤šåª’ä½“å…ƒç´ çš„æ­£ç¡® src å€¼
   */
  getMediaElementSrc(element) {
    if (!element || !this.isMediaElement(element)) return null;

    const tagName = element.tagName.toUpperCase();
    let srcValue = null;

    try {
      // æ ¹æ®å…ƒç´ ç±»å‹è·å–å¯¹åº”çš„ src å±æ€§
      switch (tagName) {
        case 'IMG':
        case 'VIDEO':
        case 'AUDIO':
        case 'IFRAME':
          // ä¼˜å…ˆä½¿ç”¨ DOM å±æ€§ï¼ˆå·²è§£æçš„ç»å¯¹è·¯å¾„ï¼‰
          srcValue = element.src;
          // å¦‚æœ DOM å±æ€§ä¸ºç©ºï¼Œä½¿ç”¨ç‰¹æ€§å€¼
          if (!srcValue) {
            srcValue = element.getAttribute('src');
          }
          break;
        case 'EMBED':
          srcValue = element.src || element.getAttribute('src');
          break;
        case 'OBJECT':
          srcValue = element.data || element.getAttribute('data');
          break;
      }

      // å¦‚æœè·å–åˆ°ç›¸å¯¹è·¯å¾„ï¼Œè½¬æ¢ä¸ºç»å¯¹è·¯å¾„
      if (srcValue && !this.isAbsoluteUrl(srcValue)) {
        const originalSrc = srcValue;
        srcValue = this.resolveUrl(srcValue);
      }

    } catch (error) {
      // é™çº§åˆ°ç‰¹æ€§å€¼
      srcValue = element.getAttribute('src') || element.getAttribute('data') || element.getAttribute('href');
    }
    return srcValue;
  }

  /**
   * æ£€æŸ¥æ˜¯å¦ä¸ºç»å¯¹URL
   */
  isAbsoluteUrl(url) {
    if (!url) return false;
    return /^https?:\/\//.test(url) || /^data:/.test(url) || /^blob:/.test(url);
  }

  /**
   * è§£æç›¸å¯¹URLä¸ºç»å¯¹URL
   */
  resolveUrl(url) {
    if (!url || this.isAbsoluteUrl(url)) return url;

    try {
      // ä½¿ç”¨iframeçš„baseURIè§£æç›¸å¯¹è·¯å¾„
      const baseUrl = this.document.baseURI || this.window.location.href;
      return new URL(url, baseUrl).href;
    } catch (error) {
      console.warn('Error resolving URL:', error);
      return url;
    }
  }

  /**
   * æ›´æ–°å¤šåª’ä½“å…ƒç´ çš„ src
   */
  updateMediaElementSrc(element, newSrc) {
    if (!element || !this.isMediaElement(element)) {
      console.warn('[updateMediaElementSrc] Invalid media element for src update:', element);
      return false;
    }

    const tagName = element.tagName.toUpperCase();
    const oldSrc = this.getMediaElementSrc(element);

    console.log(`[updateMediaElementSrc] Updating ${tagName} element:`, {
      element,
      oldSrc,
      newSrc,
      editorId: element.getAttribute('data-editor-id')
    });

    try {
      // æ ¹æ®å…ƒç´ ç±»å‹è®¾ç½®å¯¹åº”çš„å±æ€§
      switch (tagName) {
        case 'IMG':
        case 'VIDEO':
        case 'AUDIO':
        case 'IFRAME':
        case 'EMBED':
          console.log(`[updateMediaElementSrc] Setting src attribute: ${newSrc}`);
          // åŒæ—¶æ›´æ–° DOM å±æ€§å’Œ HTML ç‰¹æ€§
          element.src = newSrc;
          element.setAttribute('src', newSrc);
          console.log(`[updateMediaElementSrc] DOM src after update:`, element.src);
          console.log(`[updateMediaElementSrc] HTML src after update:`, element.getAttribute('src'));
          break;
        case 'OBJECT':
          console.log(`[updateMediaElementSrc] Setting data attribute: ${newSrc}`);
          element.data = newSrc;
          element.setAttribute('data', newSrc);
          console.log(`[updateMediaElementSrc] DOM data after update:`, element.data);
          console.log(`[updateMediaElementSrc] HTML data after update:`, element.getAttribute('data'));
          break;
        default:
          console.warn('[updateMediaElementSrc] Unsupported media element type:', tagName);
          return false;
      }

      // éªŒè¯æ›´æ–°æ˜¯å¦æˆåŠŸ
      const verifyNewSrc = this.getMediaElementSrc(element);
      console.log(`[updateMediaElementSrc] Verification - new src:`, verifyNewSrc);

      if (verifyNewSrc !== newSrc) {
        console.warn(`[updateMediaElementSrc] Src update may have failed. Expected: ${newSrc}, Got: ${verifyNewSrc}`);
      }

      // è§¦å‘å†…å®¹å˜åŒ–äº‹ä»¶
      console.log('[updateMediaElementSrc] Triggering content change event');
      this.handleContentChange();
      return true;

    } catch (error) {
      console.error('[updateMediaElementSrc] Error updating media element src:', error);
      return false;
    }
  }

  /**
   * ä¸ºå¤šåª’ä½“å…ƒç´ ç¡®ä¿æœ‰å”¯ä¸€æ ‡è¯†ç¬¦
   */
  ensureMediaElementId(element) {
    if (!element || !this.isMediaElement(element)) return;

    let editorId = element.getAttribute('data-editor-id');
    if (!editorId) {
      editorId = this.generateElementId();
      element.setAttribute('data-editor-id', editorId);
    }
    return editorId;
  }

  /**
   * ç”Ÿæˆå”¯ä¸€çš„å…ƒç´ ID
   */
  generateElementId() {
    return 'media-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
  }

  /**
   * é€šè¿‡ç¼–è¾‘å™¨IDæŸ¥æ‰¾å¹¶æ›´æ–°å¤šåª’ä½“å…ƒç´ 
   */
  updateMediaElementById(editorId, newSrc) {
    if (!editorId || !newSrc) {
      console.warn('[updateMediaElementById] Invalid parameters:', { editorId, newSrc });
      return false;
    }

    console.log(`[updateMediaElementById] Searching for element with editorId: ${editorId}`);

    try {
      const selector = `[data-editor-id="${editorId}"]`;
      console.log(`[updateMediaElementById] Using selector: ${selector}`);

      const element = this.document.querySelector(selector);
      console.log(`[updateMediaElementById] Found element:`, element);

      if (element) {
        const isMedia = this.isMediaElement(element);
        console.log(`[updateMediaElementById] Is media element: ${isMedia}`);
        console.log(`[updateMediaElementById] Element tagName: ${element.tagName}`);

        if (isMedia) {
          console.log(`[updateMediaElementById] Calling updateMediaElementSrc with newSrc: ${newSrc}`);
          return this.updateMediaElementSrc(element, newSrc);
        } else {
          console.warn('[updateMediaElementById] Element found but not a media element:', element);
          return false;
        }
      } else {
        console.warn(`[updateMediaElementById] No element found with editorId: ${editorId}`);
        // è®©æˆ‘ä»¬æ£€æŸ¥ä¸€ä¸‹æ–‡æ¡£ä¸­æ˜¯å¦æœ‰ä»»ä½•å¸¦ data-editor-id çš„å…ƒç´ 
        const allElementsWithId = this.document.querySelectorAll('[data-editor-id]');
        console.log(`[updateMediaElementById] All elements with data-editor-id:`, allElementsWithId);
        allElementsWithId.forEach((el, index) => {
          console.log(`  [${index}] tagName: ${el.tagName}, editorId: ${el.getAttribute('data-editor-id')}`);
        });
        return false;
      }
    } catch (error) {
      console.error('[updateMediaElementById] Error finding media element by ID:', error);
      return false;
    }
  }

  /**
   * é€šè¿‡é€‰æ‹©å™¨æŸ¥æ‰¾å¹¶æ›´æ–°å¤šåª’ä½“å…ƒç´ 
   */
  updateMediaElementBySrc(oldSrc, newSrc, mediaType) {
    if (!oldSrc || !newSrc) {
      console.warn('[updateMediaElementBySrc] Invalid src values for media update:', { oldSrc, newSrc, mediaType });
      return false;
    }

    console.log(`[updateMediaElementBySrc] Updating media element:`, { oldSrc, newSrc, mediaType });

    // æ„å»ºå¯èƒ½çš„é€‰æ‹©å™¨
    const selectors = [];
    const tagName = mediaType ? mediaType.toUpperCase() : null;

    if (tagName && tagName !== 'OBJECT') {
      selectors.push(`${tagName}[src="${oldSrc}"]`);
    }
    if (tagName === 'OBJECT') {
      selectors.push(`OBJECT[data="${oldSrc}"]`);
    }

    // å¦‚æœæ²¡æœ‰æŒ‡å®šç±»å‹ï¼Œå°è¯•æ‰€æœ‰å¯èƒ½çš„åª’ä½“ç±»å‹
    if (!tagName) {
      selectors.push(
        `img[src="${oldSrc}"]`,
        `video[src="${oldSrc}"]`,
        `audio[src="${oldSrc}"]`,
        `iframe[src="${oldSrc}"]`,
        `embed[src="${oldSrc}"]`,
        `object[data="${oldSrc}"]`
      );
    }

    console.log(`[updateMediaElementBySrc] Using selectors:`, selectors);

    // å°è¯•æ‰¾åˆ°å¹¶æ›´æ–°å…ƒç´ 
    for (const selector of selectors) {
      try {
        console.log(`[updateMediaElementBySrc] Trying selector: ${selector}`);
        const elements = this.document.querySelectorAll(selector);
        console.log(`[updateMediaElementBySrc] Found ${elements.length} elements with selector: ${selector}`);

        if (elements.length > 0) {
          let updated = false;
          elements.forEach((element, index) => {
            console.log(`[updateMediaElementBySrc] Updating element ${index}:`, element);
            if (this.updateMediaElementSrc(element, newSrc)) {
              updated = true;
            }
          });
          if (updated) {
            console.log(`[updateMediaElementBySrc] Successfully updated ${elements.length} media element(s) from ${oldSrc} to ${newSrc}`);
            return true;
          }
        }
      } catch (error) {
        console.warn('[updateMediaElementBySrc] Error with selector:', selector, error);
      }
    }

    console.warn(`[updateMediaElementBySrc] Could not find media element to update with src: ${oldSrc}`);

    // è®©æˆ‘ä»¬çœ‹çœ‹æ–‡æ¡£ä¸­æ‰€æœ‰çš„åª’ä½“å…ƒç´ 
    const allMediaElements = this.document.querySelectorAll('img, video, audio, iframe, embed, object');
    console.log(`[updateMediaElementBySrc] All media elements in document (${allMediaElements.length}):`, allMediaElements);
    allMediaElements.forEach((el, index) => {
      const currentSrc = this.getMediaElementSrc(el);
      console.log(`  [${index}] ${el.tagName}: ${currentSrc}`);
    });

    return false;
  }

  /**
   * è·å–å¹²å‡€çš„å†…å®¹ï¼ˆç§»é™¤æ³¨å…¥çš„å…ƒç´ ï¼‰
   */
  getCleanContent() {
    if (!this.document || !this.document.body) {
      console.warn('Document body not available for content cleaning');
      return '';
    }

    // å…‹éš†body
    const bodyClone = this.document.body.cloneNode(true);

    // ç§»é™¤æ³¨å…¥çš„æ ·å¼
    const injectedStyle = bodyClone.querySelector(`#${this.INJECTED_STYLE_ID}`);
    if (injectedStyle) {
      injectedStyle.remove();
    }

    // åªç§»é™¤æˆ‘ä»¬æ³¨å…¥çš„è„šæœ¬ï¼Œä¿ç•™ç”¨æˆ·çš„è„šæœ¬
    bodyClone.querySelectorAll('script').forEach(script => {
      if (script.id === this.INJECTED_SCRIPT_ID) {
        script.remove();
      }
    });

    // æ¸…ç†contentEditableå±æ€§
    if (bodyClone.getAttribute('contenteditable') === 'true') {
      bodyClone.removeAttribute('contenteditable');
    }

    // æ¸…ç†æˆ‘ä»¬åœ¨enableEditingä¸­æ·»åŠ çš„æ ·å¼
    if (bodyClone.style.outline === 'none') {
      bodyClone.style.removeProperty('outline');
    }
    if (bodyClone.style.minHeight === '100vh') {
      bodyClone.style.removeProperty('min-height');
    }

    // æ¸…ç†ç©ºçš„styleå±æ€§
    if (bodyClone.getAttribute('style') === '') {
      bodyClone.removeAttribute('style');
    }

    // æ¸…ç†data-editor-idå±æ€§
    bodyClone.querySelectorAll('[data-editor-id]').forEach(el => {
      el.removeAttribute('data-editor-id');
    });

    return bodyClone.innerHTML;
  }

  /**
   * è·å–å®Œæ•´çš„HTMLæ–‡æ¡£ï¼ˆç§»é™¤æ³¨å…¥çš„å…ƒç´ ï¼‰
   */
  getCompleteHTML() {
    const document = this.iframe.contentDocument || this.iframe.contentWindow?.document;

    if (!document) {
      console.warn('[getCompleteHTML] Document not available for HTML extraction');
      return '';
    }

    // å…ˆè·å–åŸå§‹æ–‡æ¡£çš„HTMLå­—ç¬¦ä¸²
    const originalHTML = document.documentElement.outerHTML;

    // åˆ›å»ºä¸€ä¸ªæ–°çš„Documentæ¥å¤„ç†
    const parser = new DOMParser();
    const tempDoc = parser.parseFromString(`<!DOCTYPE html>${originalHTML}`, 'text/html');

    if (!tempDoc || !tempDoc.documentElement) {
      console.warn('[getCompleteHTML] Failed to create temp document');
      return `<!DOCTYPE html>\n${originalHTML}`;
    }

    // æ¸…ç†åŠ¨æ€æ·»åŠ çš„å…ƒç´ 
    // åªç§»é™¤ä¸åœ¨åŸå§‹HTMLä¸­çš„å…ƒç´ 
    if (this.originHeadElementSet && this.originHeadElementSet.size > 0) {
      const tempHead = tempDoc.querySelector('head');
      if (tempHead) {
        // ç§»é™¤ head ä¸­åŠ¨æ€æ·»åŠ çš„æ ·å¼
        const headElements = tempHead.querySelectorAll('style, link[rel="stylesheet"], script');
        for (const element of headElements) {
          const identifier = this.getElementIdentifier(element);
          if (!this.originHeadElementSet.has(identifier)) {
            console.log('[getCompleteHTML] Removing dynamic element:', element.outerHTML.substring(0, 100), this.originHeadElementSet);
            element.remove();
          }
        }
      }
    }
    // æ¸…ç†ç¼–è¾‘å™¨ç›¸å…³çš„å±æ€§å’Œæ ·å¼
    this.cleanDocumentForSave(tempDoc);

    // è·å–æœ€ç»ˆHTML
    const finalHTML = tempDoc.documentElement.outerHTML;
    console.log("final html", finalHTML.substring(0, 500));
    return `<!DOCTYPE html>\n${finalHTML}`;
  }


  /**
   * æ¸…ç†æ–‡æ¡£ä»¥ä¾¿ä¿å­˜
   */
  cleanDocumentForSave(doc) {
    // ç§»é™¤ç¼–è¾‘å™¨æ³¨å…¥çš„å…ƒç´ ï¼ˆå¦‚æœå­˜åœ¨çš„è¯ï¼‰
    const injectedIds = [this.INJECTED_STYLE_ID, this.INJECTED_SCRIPT_ID];
    injectedIds.forEach(id => {
      const element = doc.querySelector(`#${id}`);
      if (element) element.remove();
    });

    // æ¸…ç†ç¼–è¾‘å™¨æ·»åŠ çš„å±æ€§
    doc.querySelectorAll('[data-editor-id]').forEach(el => {
      el.removeAttribute('data-editor-id');
    });

    // æ¸…ç†contentEditableå±æ€§ï¼ˆåœ¨enableEditingä¸­è®¾ç½®ï¼‰
    doc.querySelectorAll('[contenteditable="true"]').forEach(el => {
      el.removeAttribute('contenteditable');
    });

    // æ¸…ç†bodyçš„ç¼–è¾‘æ ·å¼ï¼ˆåœ¨enableEditingä¸­è®¾ç½®ï¼‰
    if (doc.body) {
      // åªæ¸…ç†æˆ‘ä»¬ç¡®å®æ·»åŠ çš„æ ·å¼
      if (doc.body.style.outline === 'none') {
        doc.body.style.removeProperty('outline');
      }
      if (doc.body.style.minHeight === '100vh') {
        doc.body.style.removeProperty('min-height');
      }
      // æ¸…ç†ç©ºçš„styleå±æ€§
      if (doc.body.getAttribute('style') === '') {
        doc.body.removeAttribute('style');
      }
    }
  }

  /**
   * è®¾ç½®å›è°ƒå‡½æ•°
   */
  on(event, callback) {
    const eventName = `on${event.charAt(0).toUpperCase()}${event.slice(1)}`;
    if (eventName in this.callbacks) {
      this.callbacks[eventName] = callback;
    }
  }

  /**
   * é”€æ¯
   */
  destroy() {
    // ä½¿ç”¨ç»Ÿä¸€çš„æ¸…ç†æ–¹æ³•
    this.cleanup();

    // æ¸…ç†å›è°ƒ
    this.callbacks = {
      onContentChange: null,
      onElementClick: null,
      onElementHover: null,
      onScroll: null,
      onEditModeChange: null,
      onMediaElementDoubleClick: null
    };

    // æ¸…ç†å¼•ç”¨
    this.iframe = null;
  }
}

/**
 * åˆ›å»ºiframeç®¡ç†å™¨å®ä¾‹
 */
export const createIframeManager = (iframe, options) => {
  return new IframeManager(iframe, options);
};


================================================
FILE: frontend/src/view/editor/render/utils/previewTemplates.js
================================================
/**
 * HTML é¢„è§ˆæ¨¡æ¿å·¥å…·
 * æä¾›å¯å¤ç”¨çš„ HTML æ¨¡æ¿ç”ŸæˆåŠŸèƒ½
 */

// åŸºç¡€é¢„è§ˆæ ·å¼ï¼ˆä¸åŒ…å«äº¤äº’æ ·å¼ï¼‰
export const PREVIEW_STYLES = `
  body {
    margin: 0;
    padding: 20px;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    line-height: 1.6;
    color: #333;
    background: #fff;
  }
  * {
    box-sizing: border-box;
  }
  img {
    max-width: 100%;
    height: auto;
  }
  table {
    border-collapse: collapse;
    width: 100%;
    margin-bottom: 1rem;
  }
  th, td {
    border: 1px solid #ddd;
    padding: 8px;
    text-align: left;
  }
  th {
    background-color: #f2f2f2;
    font-weight: bold;
  }
  pre {
    background: #f5f5f5;
    padding: 1rem;
    border-radius: 4px;
    overflow-x: auto;
  }
  code {
    background: #f5f5f5;
    padding: 2px 4px;
    border-radius: 2px;
    font-family: 'Monaco', 'Consolas', monospace;
  }
  blockquote {
    border-left: 4px solid #ddd;
    padding-left: 1rem;
    margin-left: 0;
    color: #666;
  }
`

/**
 * æ£€æµ‹æ˜¯å¦ä¸ºå®Œæ•´çš„HTMLæ–‡æ¡£
 * @param {string} content - HTMLå†…å®¹
 * @returns {boolean}
 */
export const isCompleteHTML = (content) => {
  if (!content) return false;
  const trimmed = content.trim().toLowerCase();
  return trimmed.startsWith('<!doctype') ||
    trimmed.includes('<html') ||
    (trimmed.includes('<head') && trimmed.includes('<body'));
};

/**
 * æå–HTMLæ–‡æ¡£çš„bodyå†…å®¹
 * @param {string} html - å®Œæ•´çš„HTMLæ–‡æ¡£
 * @param {boolean} includeScripts - æ˜¯å¦ä¿ç•™scriptæ ‡ç­¾
 * @returns {string} bodyå†…å®¹
 */
export const extractBodyContent = (html, includeScripts = true) => {
  const bodyMatch = html.match(/<body[^>]*>([\s\S]*)<\/body>/i);
  let content = bodyMatch ? bodyMatch[1] : html;

  // å¦‚æœä¸éœ€è¦scriptsï¼Œç§»é™¤å®ƒä»¬
  if (!includeScripts) {
    content = content.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '');
  }

  return content;
};

/**
 * æå–HTMLæ–‡æ¡£çš„headå†…å®¹
 * @param {string} html - å®Œæ•´çš„HTMLæ–‡æ¡£
 * @returns {string} headå†…å®¹
 */
export const extractHeadContent = (html) => {
  const headMatch = html.match(/<head[^>]*>([\s\S]*)<\/head>/i);
  return headMatch ? headMatch[1] : '';
};

/**
 * åˆ›å»ºé¢„è§ˆ HTML æ–‡æ¡£
 * @param {string} content - HTML å†…å®¹
 * @param {Object} options - é€‰é¡¹
 * @param {string} options.customStyles - è‡ªå®šä¹‰æ ·å¼
 * @param {boolean} options.preserveHead - æ˜¯å¦ä¿ç•™åŸå§‹headå†…å®¹
 * @returns {string} å®Œæ•´çš„ HTML æ–‡æ¡£
 */
export const createPreviewHTML = (content, options = {}) => {
  const { customStyles = '', preserveHead = false } = options;

  // æ£€æµ‹æ˜¯å¦ä¸ºå®Œæ•´HTML
  if (isCompleteHTML(content)) {
    if (preserveHead) {
      // ä¿ç•™åŸå§‹HTMLç»“æ„ï¼Œåªæ³¨å…¥å¿…è¦çš„æ ·å¼
      const headContent = extractHeadContent(content);
      const bodyContent = extractBodyContent(content);

      // è§£æHTMLå±æ€§
      const htmlMatch = content.match(/<html([^>]*)>/i);
      const htmlAttrs = htmlMatch ? htmlMatch[1] : ' lang="zh-CN"';

      // è§£æbodyå±æ€§
      const bodyMatch = content.match(/<body([^>]*)>/i);
      const bodyAttrs = bodyMatch ? bodyMatch[1] : '';

      // æ£€æŸ¥headå†…å®¹æ˜¯å¦å·²ç»åŒ…å«æˆ‘ä»¬çš„æ ·å¼
      const hasPreviewStyles = headContent.includes('/* åŸºç¡€ç¼–è¾‘æ ·å¼ */');

      return [
        '<!DOCTYPE html>',
        `<html${htmlAttrs}>`,
        '<head>',
        headContent,
        !hasPreviewStyles ? `<style>${PREVIEW_STYLES}</style>` : '',
        customStyles ? `<style>${customStyles}</style>` : '',
        '</head>',
        `<body${bodyAttrs}>`,
        bodyContent,
        '</body>',
        '</html>'
      ].filter(Boolean).join('\n');
    } else {
      // æå–bodyå†…å®¹å’Œscriptæ ‡ç­¾
      const bodyContent = extractBodyContent(content, true);
      const headContent = extractHeadContent(content);

      // å¦‚æœæœ‰headå†…å®¹ï¼Œä¿ç•™å…¶ä¸­çš„ä¾èµ–
      if (headContent) {
        // æå–é‡è¦çš„ä¾èµ–ï¼ˆscriptå’Œlinkæ ‡ç­¾ï¼‰
        const dependencies = extractDependencies(headContent);
        return createStandardHTMLWithDeps(bodyContent, customStyles, dependencies);
      } else {
        return createStandardHTML(bodyContent, customStyles);
      }
    }
  } else {
    // HTMLç‰‡æ®µï¼Œä½¿ç”¨æ ‡å‡†æ¨¡æ¿
    return createStandardHTML(content, customStyles);
  }
};

/**
 * åˆ›å»ºæ ‡å‡†HTMLæ¨¡æ¿
 * @param {string} bodyContent - bodyå†…å®¹
 * @param {string} customStyles - è‡ªå®šä¹‰æ ·å¼
 * @returns {string} å®Œæ•´çš„HTMLæ–‡æ¡£
 */
const createStandardHTML = (bodyContent, customStyles = '') => {
  const styles = [PREVIEW_STYLES, customStyles].filter(Boolean).join('\n');

  return [
    '<!DOCTYPE html>',
    '<html lang="zh-CN">',
    '<head>',
    '<meta charset="UTF-8">',
    '<meta name="viewport" content="width=device-width, initial-scale=1.0">',
    '<title>HTML Preview</title>',
    `<style>${styles}</style>`,
    '</head>',
    '<body>',
    bodyContent,
    '</body>',
    '</html>'
  ].join('\n');
};

/**
 * åˆ›å»ºé™æ€é¢„è§ˆ HTMLï¼ˆæ— äº¤äº’ï¼‰
 * @param {string} content - HTML å†…å®¹
 * @param {string} customStyles - è‡ªå®šä¹‰æ ·å¼
 * @returns {string} HTML æ–‡æ¡£
 */
export const createStaticPreviewHTML = (content, customStyles = '') => {
  return createPreviewHTML(content, {
    customStyles,
    preserveHead: false
  });
};

/**
 * åˆ›å»ºä¿ç•™åŸå§‹ç»“æ„çš„é¢„è§ˆHTML
 * @param {string} content - HTML å†…å®¹
 * @param {string} customStyles - è‡ªå®šä¹‰æ ·å¼
 * @returns {string} HTML æ–‡æ¡£
 */
export const createPreservingPreviewHTML = (content, customStyles = '') => {
  return createPreviewHTML(content, {
    customStyles,
    preserveHead: true
  });
};

/**
 * æå–HTMLä¸­çš„ä¾èµ–ï¼ˆscriptå’Œlinkæ ‡ç­¾ï¼‰
 * @param {string} headContent - headå†…å®¹
 * @returns {string} ä¾èµ–æ ‡ç­¾
 */
const extractDependencies = (headContent) => {
  const scripts = headContent.match(/<script[^>]*>.*?<\/script>/gis) || [];
  const links = headContent.match(/<link[^>]*>/gi) || [];
  const styles = headContent.match(/<style[^>]*>.*?<\/style>/gis) || [];
  // ä¿ç•™æ‰€æœ‰çš„link, styleå’Œscriptæ ‡ç­¾
  return [...links, ...styles, ...scripts].join('\n');
};

/**
 * åˆ›å»ºå¸¦ä¾èµ–çš„æ ‡å‡†HTMLæ¨¡æ¿
 * @param {string} bodyContent - bodyå†…å®¹
 * @param {string} customStyles - è‡ªå®šä¹‰æ ·å¼
 * @param {string} dependencies - ä¾èµ–æ ‡ç­¾
 * @returns {string} å®Œæ•´çš„HTMLæ–‡æ¡£
 */
const createStandardHTMLWithDeps = (bodyContent, customStyles = '', dependencies = '') => {
  const styles = [PREVIEW_STYLES, customStyles].filter(Boolean).join('\n');

  return [
    '<!DOCTYPE html>',
    '<html lang="zh-CN">',
    '<head>',
    '<meta charset="UTF-8">',
    '<meta name="viewport" content="width=device-width, initial-scale=1.0">',
    '<title>HTML Preview</title>',
    dependencies, // å…ˆåŠ è½½ä¾èµ–
    `<style>${styles}</style>`,
    '</head>',
    '<body>',
    bodyContent,
    '</body>',
    '</html>'
  ].filter(Boolean).join('\n');
};


================================================
FILE: frontend/src/view/lemon/index.vue
================================================
<template>
  <div class="lemon-container" :class="{ 'mobile-menu-open': isMobileMenuOpen }">
    <SidebarMain />
    <div class="lemon-content">
      <div v-if="isMobileMenuOpen" class="mobile-overlay" @click="closeMobileMenu"></div>
      <router-view />
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted, onUnmounted, watch } from 'vue'
import SidebarMain from '@/view/menu/index.vue'
import emitter from '@/utils/emitter'

import { useRoute } from 'vue-router';
const route = useRoute();

import { useChatStore } from '@/store/modules/chat';
const chatStore = useChatStore();
const isCollapsed = ref(false);
const isMobileMenuOpen = ref(false);

const toggleCollapse = () => {
  isCollapsed.value = !isCollapsed.value;
}

// å¤„ç†ç§»åŠ¨ç«¯èœå•çŠ¶æ€å˜åŒ–
const handleMobileMenuToggle = (show) => {
  if (typeof show === 'boolean') {
    isMobileMenuOpen.value = show
  } else {
    isMobileMenuOpen.value = !isMobileMenuOpen.value
  }
}

// å…³é—­ç§»åŠ¨ç«¯èœå•
const closeMobileMenu = () => {
  emitter.emit('toggleMobileMenu', false)
}

const init = async () => {
  let mode = localStorage.getItem('mode') || 'task';
  await chatStore.init(mode);
}

onMounted(() => {
  init();
  // ç›‘å¬ç§»åŠ¨ç«¯èœå•åˆ‡æ¢äº‹ä»¶
  emitter.on('mobileMenuStateChange', handleMobileMenuToggle);
});

onUnmounted(() => {
  emitter.off('mobileMenuStateChange', handleMobileMenuToggle);
});
</script>

<style lang="scss" scoped>
.menu-switch {
  cursor: pointer;
}

.lemon-container {
  display: flex;
  justify-content: center;
  width: 100%;
  height: 100vh;
  background: #f8f8f7;
  overflow-x: hidden;
}

.lemon-content {
  width: 100%;
  height: 100%;
  display: flex;
  overflow-y: auto;
  transition: transform 0.3s ease;
}

/* ç§»åŠ¨ç«¯æ¨æ‹‰å¼å¸ƒå±€ */
@media (max-width: 768px) {
  .lemon-container {
    position: relative;
  }
  
  .lemon-content {
    transform: translateX(0);
    width: 100vw;
    position: relative;
  }
  
  /* å½“ç§»åŠ¨ç«¯èœå•æ‰“å¼€æ—¶ï¼Œæ¨åŠ¨ä¸»å†…å®¹ */
  .lemon-container.mobile-menu-open .lemon-content {
    transform: translateX(70%);
  }
  
  /* ç§»åŠ¨ç«¯è’™å±‚ */
  .mobile-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: rgba(0, 0, 0, 0.3);
    z-index: 999;
    cursor: pointer;
    opacity: 0;
    animation: fadeIn 0.3s ease forwards;
  }
  
  @keyframes fadeIn {
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  }
}

@media screen and (max-width: 768px) {
  .preview {
    position: absolute;
    z-index: 999;
    margin: 0px;
    width: 100vw !important;
    height: 100vh !important;
    border-radius: 0px;
    max-width: 100vh !important;
    border: unset !important;
    box-shadow: unset !important;
  }
}
</style>


================================================
FILE: frontend/src/view/lemon/components/ChatHeader.vue
================================================
<template>
  <div class="chat-header">
    <div class="header-left">
      <h1 class="chat-title">{{ title }}</h1>
    </div>

    <div class="header-right">
      <!-- <div class="share-btn" @click="$emit('share')">
        <Share />
        <span style="min-width: max-content;">{{ $t('lemon.chatHeader.share') }}</span>
      </div> -->
      <div class="search-file-btn btn ">
        <a-tooltip :title="$t('lemon.chatHeader.viewAllFiles')" placement="bottom" :arrow="false">
          <SearchFile @click="handleFileExplorer" />
        </a-tooltip>
      </div>
      <!-- <div class="collect-btn btn" @click="handleCollect" :class="{ 'favorite': isFavorite }">
        <a-tooltip :title="favoriteTitle" placement="bottom" :arrow="false">
          <Collect @click="$emit('collect')" />
        </a-tooltip>
      </div> -->
      <div class="more-btn btn" @click="handleMore">
        <a-tooltip :title="$t('lemon.chatHeader.moreOptions')" placement="bottom" :arrow="false">
          <More />
        </a-tooltip>
        <div class="more-menu" v-if="showMore">
          <div class="edit-name" @click="handleEditName">
            <Edit />
            <span>{{ $t('lemon.chatHeader.rename') }}</span>
            <div style="width: 16px; height: 16px;"></div>
          </div>
        </div>
      </div>
    </div>
    <a-modal 
      v-model:open="open" 
      :title="$t('lemon.chatHeader.editTitle')" 
      centered  
      :width="400" 
      class="edit-title-modal" 
      :footer="null"
    > 
      <span class="edit-title">{{ $t('lemon.chatHeader.enterNewTitle') }}</span>
      <a-input v-model:value="titleValue" class="edit-title-input" />
      <footer>
        <div class="footer-btn">
          <div class="cancel-btn" @click="handleCancel">{{ $t('lemon.chatHeader.cancel') }}</div>
          <div class="confirm-btn" @click="handleOk">{{ $t('lemon.chatHeader.confirm') }}</div>
        </div>
      </footer>
    </a-modal>
  </div>
</template>

<script setup>
import emitter from '@/utils/emitter'
import { ShareAltOutlined, ToolOutlined } from '@ant-design/icons-vue'
import workspaceService from '@/services/workspace'
import { useChatStore } from '@/store/modules/chat'
import Share from '@/assets/svg/share.svg'
import Collect from '@/assets/svg/collect.svg'
import SearchFile from '@/assets/svg/searchFile.svg'
import { useI18n } from 'vue-i18n'
import More from '@/assets/svg/more.svg'
import Edit from '@/assets/svg/edit.svg'
const { t } = useI18n()
import { ref, onMounted, onUnmounted, computed } from 'vue'

const handleTerminal = () => {
  emitter.emit('preview-close', false)
  emitter.emit('terminal-visible', true)
}
const handleFileExplorer = () => {
  emitter.emit('file-explorer-visible', true)
}

import { storeToRefs } from 'pinia'
const chatStore = useChatStore()
const { chat } = storeToRefs(chatStore)

const props = defineProps({
  title: {
    type: String,
    default: ''
  }
})

const titleValue = ref('')
const showMore = ref(false)

const isFavorite = computed(() => chat.value.is_favorite)
const favoriteTitle = computed(() => isFavorite.value ? t('lemon.chatHeader.unfavorite') : t('lemon.chatHeader.favorite'))
const handleCollect = () => {
  if (isFavorite.value) {
    chatStore.unfavorite()
  } else {
    chatStore.favorite()
  }
}
const handleMore = () => {
  showMore.value = !showMore.value
}

const open = ref(false)

const handleEditName = () => {
  open.value = true
  titleValue.value = chatStore.chat.title;
}

const handleOk = () => {
  open.value = false
  chatStore.updateConversationTitle(titleValue.value)
}

const handleCancel = () => {
  open.value = false
}

const handleClickOutside = (event) => {
  const moreBtn = document.querySelector('.more-btn');
  if (moreBtn && !moreBtn.contains(event.target)) {
    showMore.value = false;
  }
};

// åœ¨ç»„ä»¶æŒ‚è½½æ—¶æ·»åŠ äº‹ä»¶ç›‘å¬
onMounted(() => {
  document.addEventListener('click', handleClickOutside);
});

// åœ¨ç»„ä»¶å¸è½½æ—¶ç§»é™¤äº‹ä»¶ç›‘å¬
onUnmounted(() => {
  document.removeEventListener('click', handleClickOutside);
});

defineEmits(['share'])

</script>

<style lang="scss" scoped>
.chat-header {
  padding-top: .75rem;
  padding-bottom: .25rem;
  background: #f8f8f7;
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-direction: row;
  gap: 4px;
  position: sticky;
  top: 0;
  z-index: 10;
}

.header-left {
  overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.chat-title {
  font-size: 18px;
  font-weight: 500;
  color: #34322d;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  width: 100%;
  font-family: -apple-system, BlinkMacSystemFont, Segoe UI Variable Display, Segoe UI, Helvetica, Apple Color Emoji, Arial, sans-serif, Segoe UI Emoji, Segoe UI Symbol;
  margin: 0;
}

.header-right {
  display: flex;
  align-items: center;
  gap: .5rem;

  .share-btn {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 100%;
    height: 100%;
    padding: 0;
    border-radius: 100px;
    gap: .25rem;
    outline: 1px solid #0000000f;
    outline-offset: -1px;
    align-items: center;
    padding: 0 .75rem;
    height: 2rem;
    cursor: pointer;
  }

  .btn {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 28px;
    height: 28px;
    border-radius: .5rem;
    padding: 5px;
    cursor: pointer;
  }
}

.more-menu {
  position: absolute;
  right: -50px;
  top: 50px;
  background: #fff;
  border-radius: .75rem;
  cursor: pointer;
  border: 1px solid #0000001f;
  min-width: max-content;

  .edit-name {
    display: flex;
    align-items: center;
    gap: .75rem;
    border-radius: .75rem;
    padding: 12px 16px;
    cursor: pointer;
  }
}

.favorite {
  color: #efa201 !important;
  svg {
    stroke: #efa201 !important;
    fill: #efa201 !important;
  }
}

.action-btn {
  padding: 6px 12px;
  border: 1px solid #e6e6e6;
  border-radius: 4px;
  background: transparent;
  color: #1f2329;
  font-size: 14px;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 4px;

  &:hover {
    background: #f5f5f5;
  }

  i {
    font-size: 16px;
  }
}

.status-indicator {
  padding: 4px 16px;
  border-radius: 16px;
  font-size: 14px;
  font-weight: 500;
  background-color: #e0e0e0;
  color: #757575;
}

.edit-title {
  font-size: 13px;
  font-weight: 400;
  color: #858481;
}

.edit-title-input {
  margin-top: 10px;
}

.footer-btn {
  display: flex;
  padding-top: 1.25rem;
  gap: .5rem;
  justify-content: flex-end;

  .cancel-btn {
    cursor: pointer;
    font-size: 13px;
    font-weight: 400;
    color: #535350;
    font-size: .875rem;
    line-height: 1.25rem;
    padding-top: .5rem;
    padding-bottom: .5rem;
    padding-left: .75rem;
    padding-right: .75rem;
    border: 1px solid #0000001f;
    border-radius: 10px;
  }

  .confirm-btn {
    cursor: pointer;
    font-size: 13px;
    font-weight: 400;
    background: #1a1a19;
    color: #fff;
    font-size: .875rem;
    line-height: 1.25rem;
    padding-top: .5rem;
    padding-bottom: .5rem;
    padding-left: .75rem;
    padding-right: .75rem;
    border: 1px solid #ffffff33;
    border-radius: 10px;
  }
}

@media screen and (max-width: 768px) {
  .chat-title {
    padding-inline-start: 1.75rem;
    width: 150px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .share-btn {
    outline: none !important;
    padding: 5px !important;
    width: 28px !important;
    height: 28px !important;
    display: flex !important;
    span {
      display: none;
    }
  }
  .more-menu {
    right: -10px !important;
    left: auto;
  }
}

@media (hover: hover) and (pointer: fine) {
  .share-btn:hover {
    background: #37352f14;
  }
  .btn:hover {
    background: #37352f14;
  }
  .edit-name:hover {
    background: #37352f0f;
  }
  .confirm-btn:hover {
    opacity: .85;
  }
  .cancel-btn:hover {
    background: #37352f14;
  }
}
</style>
<style lang="scss">
.edit-title-modal {
  .ant-modal-header {
    margin-bottom: 5px !important;
  }
  .ant-modal-content {
    border-radius: 20px !important;
  }
}
</style>


================================================
FILE: frontend/src/view/lemon/components/ChatInput.vue
================================================
<template>
  <div class="chat-input">
    <!-- é€‰ä¸­å…ƒç´ é¢„è§ˆç»„ä»¶ -->
    <SelectionPreview />
    <div class="input-wrapper">
      <div class="input-area">
        <ChatInputFile v-model:fileList="fileList" v-model:conversation_id="conversation_id" />
        <div class="input-container">
          <a-textarea class="input-textarea" v-model:value="messageText" :placeholder="placeholder"
            :auto-size="{ minRows: 2, maxRows: 8 }" @keydown="keydown" />
          <div class="input-actions">
            <div class="left-actions">
              <!-- ç¬¬ä¸€è¡ŒæŒ‰é’® -->
              <div class="button-row first-row">
                <!-- æ–‡ä»¶ä¸Šä¼  -->
                <ChatInputUpload v-model:fileList="fileList" v-model:conversation_id="conversation_id"
                  :isPublic="isPublic" />
                <ModelSelect/>
                <!-- æ¨¡å¼åˆ‡æ¢å™¨ - å“åº”å¼ -->
                <ModeSelector v-model:modelValue="workMode" :disabled="hasTwinsId" @modeChange="handleModeChange" />

                <!-- <div class="visibility-toggle">
                  <a-select v-if="!isMobile" v-model:value="isPublic" class="visibility-select"
                    :options="visibilityOptions" @change="handleVisibilityChange" :dropdownMatchSelectWidth="false"
                    :bordered="false">
                    <template #option="{ value, label, desc }">
                      <div class="custom-option">
                        <span class="radio-circle">
                          <span v-if="isPublic === value" class="inner-circle" />
                        </span>
                        <div class="option-texts">
                          <div style="display: flex; align-items: center; gap: 8px">
                            {{ label }}
                            <a-tag v-if="!value" size="small" class="pro-tag">Pro+</a-tag>
                          </div>
                          <div class="desc">{{ desc }}</div>
                        </div>
                      </div>
                    </template>
                  </a-select>
                  <div v-else class="mobile-visibility-trigger" @click="openVisibilityModal">
                    <span class="visibility-name">{{visibilityOptions.find((opt) => opt.value === isPublic)?.label ||
                      "Public" }}</span>
                    <DownOutlined class="dropdown-icon" />
                  </div>
                </div> -->
                <div class="mcp-button-container" v-if="!isTwins && workMode !== 'chat'">
                  <!-- MCPæœåŠ¡å™¨ -->
                  <a-dropdown :trigger="['click']" placement="top" class="mcp-dropdown">
                    <a-button class="mcp-button"
                      :class="{ 'mcp-button-active': selectedMcpServerIds && selectedMcpServerIds.length > 0 }">
                      <template #icon>
                        <CloudServerOutlined />
                      </template>
                      MCP
                    </a-button>
                    <template #overlay>
                      <a-menu :selectedKeys="mcpMenuSelectedKeys" multiple class="mcp-server-menu"
                        @click="handleMcpMenuClick">
                        <a-menu-item key="disable">
                          <span>Close MCP</span>
                        </a-menu-item>
                        <a-menu-divider />
                        <a-menu-item v-for="server in mcpServers" :key="server.id" class="mcp-server-item">
                          <span>{{ server.name }}</span>
                          <CheckOutlined v-if="selectedMcpServerIds && selectedMcpServerIds.includes(server.id)"
                            class="check-icon" />
                        </a-menu-item>
                      </a-menu>
                    </template>
                  </a-dropdown>
                </div>
              </div>

              <!-- ç¬¬äºŒè¡ŒæŒ‰é’®
              <div class="button-row second-row" v-if="chatMode === 'task'">
                

                
              </div> -->
            </div>
            <!-- {{ messageStatus }} -->
            <a-button v-if="messageStatus" @click="handleSend" class="send-button" :disabled="!messageText">
              <template #icon>
                <SendIcon />
              </template>
            </a-button>
            <!-- åœæ­¢æŒ‰é’® -->
            <button v-else class="stop-button" @click="handleStop">
              <div></div>
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- ç§»åŠ¨ç«¯å¯è§†é€‰æ‹©å¼¹çª— -->
  <teleport to="body">
    <div v-if="showVisibilityModal" class="mobile-modal-overlay" @click="closeVisibilityModal">
      <div class="mobile-visibility-selector" @click.stop>
        <div class="modal-header">
          <h3>Visibility</h3>
          <a-button type="text" @click="closeVisibilityModal" class="close-btn">
            <CloseOutlined />
          </a-button>
        </div>
        <div class="option-list">
          <div v-for="option in visibilityOptions" :key="option.value" class="option-item"
            :class="{ selected: option.value === isPublic }" @click="handleMobileVisibilitySelect(option.value)">
            <div class="option-info">
              <span class="option-circle">
                <span v-if="isPublic === option.value" class="option-inner-circle" />
              </span>
              <div class="option-texts">
                <div class="option-label">
                  {{ option.label }}
                  <a-tag v-if="!option.value" size="small" class="pro-tag-mobile">Pro+</a-tag>
                </div>
                <div class="option-desc">{{ option.desc }}</div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </teleport>

  <!-- å‡çº§å¼¹çª— -->
  <a-modal v-model:open="showUpgradeModal" :title="upgradeTitle" centered width="1200px" :footer="null"
    @cancel="closeModal">
    <!-- è´­ä¹°ç§¯åˆ†æŒ‰é’® -->
    <div class="buy-credits">
      <div class="upgrade-des-wrapper">
        <span v-if="upgradeDes" class="upgrade-des">{{ upgradeDes }}</span>
        <span v-if="upgradeDes1" class="upgrade-des">{{ upgradeDes1 }}</span>
      </div>
      <a-button v-if="membership?.planName" type="primary" @click="showRechargeModal = true">Buy credits</a-button>
    </div>
    <Pricing isWindow="true" showTitle="false" @close_window="closeModal" />
  </a-modal>

  <RechargeModal v-model:open="showRechargeModal" />
</template>
<script setup>
import { ref, computed, onMounted, onUnmounted, watch, h } from "vue";
import { useRoute, useRouter } from "vue-router";
import { useI18n } from "vue-i18n";
import { notification, message } from "ant-design-vue";
import SendIcon from '@/assets/svg/send-icon.svg';
import {
  PaperClipOutlined,
  CloudServerOutlined,
  CheckOutlined,
  MessageOutlined,
  ToolOutlined,
  PlayCircleOutlined,
  TeamOutlined,
  SyncOutlined,
  ForkOutlined,
  RobotOutlined,
  BulbOutlined,
  DownOutlined,
  CloseOutlined,
} from "@ant-design/icons-vue";

import ChatInputFile from "./ChatInputFileList.vue";
import ChatInputUpload from "./ChatInputUpload.vue";
import SelectionPreview from "./SelectionPreview.vue";
import ModeSelector from "./ModeSelector.vue";

import ModelSelect from "./ModelSelect.vue";
import Pricing from "@/view/pay/components/pricing.vue";
import RechargeModal from "@/view/pay/components/rechargeProducts.vue";

import emitter from "@/utils/emitter";
import mcpService from "@/services/mcp";
import files from "@/services/files";
import agentService from "@/services/agent";
import chatService from "@/services/chat";
import modelService from "@/services/default-model-setting";

import { storeToRefs } from "pinia";
import { useUserStore } from "@/store/modules/user";
import { useChatStore } from "@/store/modules/chat";

const { t } = useI18n();
const router = useRouter();
const route = useRoute();

//Upgrade required
const upgradeTitle = ref("Upgrade required");

const userStore = useUserStore();
const { user, membership, points } = storeToRefs(userStore);

const chatStore = useChatStore();
const { agent, chat, model_id } = storeToRefs(chatStore);

// ---------------- çŠ¶æ€å®šä¹‰ ------------------
const messageText = ref("");
const fileList = ref([]);
const currentMode = ref("text");
const isPublic = ref(true); // é»˜è®¤ public
const showRechargeModal = ref(false);

// å·¥ä½œæ¨¡å¼
const workMode = ref(localStorage.getItem("workMode") || "twins"); // ä»ç¼“å­˜è¯»å–ï¼Œé»˜è®¤Autoæ¨¡å¼
const isManualWorkModeChange = ref(false); // æ ‡è®°æ˜¯å¦ä¸ºæ‰‹åŠ¨åˆ‡æ¢æ¨¡å¼

const mcpServers = ref([]);
const selectedMcpServerIds = ref([]);

const emit = defineEmits(["send", "modeChange"]);

// const visibilityOptions = computed(() => {
//   // å¦‚æœå½“å‰ agent æ˜¯ç§æœ‰çš„ï¼Œæ˜¾ç¤ºæç¤ºä¿¡æ¯å’Œæ‰€æœ‰é€‰é¡¹ï¼ˆPublic ä¸ºåªè¯»ï¼‰
//   if (agent.value && agent.value.is_public === false) {
//     return [
//       {
//         value: "disabled-info",
//         label: "Info",
//         desc: "Agent is Personal, so conversation must be Personal",
//         disabled: true,
//         isInfo: true
//       },
//       {
//         value: true,
//         label: "Public",
//         desc: "Anyone can view and remix",
//         disabled: true,
//         isReadonly: true
//       },
//       {
//         value: false,
//         label: "Personal",
//         desc: "Only visible to yourself",
//       },
//     ];
//   }

//   // é»˜è®¤æƒ…å†µä¸‹æ˜¾ç¤ºæ‰€æœ‰é€‰é¡¹
//   return [
//     {
//       value: true,
//       label: "Public",
//       desc: "Anyone can view and remix",
//     },
//     {
//       value: false,
//       label: "Personal",
//       desc: "Only visible to yourself",
//     },
//   ];
// });

const visibilityOptions = [
  {
    value: true,
    label: "Public",
    desc: "Anyone can view and remix",
  },
  {
    value: false,
    label: "Personal",
    desc: "Only visible to yourself",
  },
];

const showUpgradeModal = ref(false);
const upgradeDes = ref("");
const upgradeDes1 = ref("");

// ç§»åŠ¨ç«¯ç›¸å…³çŠ¶æ€
const isMobile = ref(window.innerWidth <= 768); // åˆå§‹åŒ–æ—¶ç«‹å³æ£€æµ‹
const showVisibilityModal = ref(false);

// ---------------- è®¡ç®—å±æ€§ ------------------
const isLogin = computed(() => !!user.value.id);

const chatMode = computed(() => chatStore.mode);

// æ ¹æ® workMode åŠ¨æ€è¿”å› placeholder
const placeholder = computed(() => {
  return t(`lemon.welcome.placeholders.${workMode.value}`) || t("lemon.welcome.placeholder");
});

// æ£€æŸ¥æ˜¯å¦ä¸º twins æ¨¡å¼ï¼ˆåŸºäºæ¨¡å¼é€‰æ‹©å™¨çš„å€¼ï¼‰
const isTwins = computed(() => {
  return workMode.value === 'twins';
});

// æ£€æŸ¥å½“å‰å¯¹è¯æ˜¯å¦æœ‰ twins_idï¼ˆç”¨äºåˆ¤æ–­æ˜¯å¦ç¦ç”¨æ¨¡å¼åˆ‡æ¢ï¼‰
const hasTwinsId = computed(() => {
  // å¦‚æœå½“å‰å¯¹è¯æ²¡æœ‰ twins_id ä½†æœ‰æ™®é€šæ¶ˆæ¯ï¼Œåˆ™ä¸èƒ½åˆ‡æ¢åˆ° twins æ¨¡å¼
  const hasRegularMessages = (chatStore.messages?.length || 0) > 0;
  const currentHasTwinsId = chatStore.chat?.twins_id;

  console.log("hasTwinsId check:", {
    hasRegularMessages,
    currentHasTwinsId,
    twinsChatMessagesLength: chatStore.twinsChatMessages?.length || 0
  });

  // åªæœ‰çœŸæ­£æœ‰ twins_id çš„å¯¹è¯æ‰è¿”å› true
  return currentHasTwinsId && (chatStore.twinsChatMessages?.length || 0) > 0;
});

// ç›‘å¬ twins_id å˜åŒ–ï¼Œè‡ªåŠ¨è®¾ç½® workMode
watch([hasTwinsId, () => chatStore.messages?.length || 0, () => chatStore.chat?.twins_id], (newVal, oldVal) => {
  // å¦‚æœæ˜¯æ‰‹åŠ¨åˆ‡æ¢æ¨¡å¼ï¼Œè·³è¿‡è‡ªåŠ¨è®¾ç½®é€»è¾‘
  if (isManualWorkModeChange.value) {
    return;
  }

  // å¦‚æœæ˜¯é¦–æ¬¡æ‰§è¡Œï¼ˆoldVal ä¸º undefinedï¼‰ï¼Œä¸æ‰§è¡Œè‡ªåŠ¨è®¾ç½®
  // è®©ç»„ä»¶ä½¿ç”¨ localStorage ä¸­çš„åˆå§‹å€¼
  if (!oldVal) {
    return;
  }

  const currentHasTwinsId = chatStore.chat?.twins_id;
  const hasRegularMessages = (chatStore.messages?.length || 0) > 0;

  if (hasTwinsId.value && workMode.value !== 'twins') {
    // å¦‚æœå½“å‰å¯¹è¯æœ‰ twins_idï¼Œè‡ªåŠ¨è®¾ç½®ä¸º twins æ¨¡å¼
    workMode.value = 'twins';
    localStorage.setItem("workMode", 'twins');
  } else if (!currentHasTwinsId && hasRegularMessages && workMode.value === 'twins') {
    // å¦‚æœæ²¡æœ‰ twins_id ä½†æœ‰æ™®é€šæ¶ˆæ¯ï¼Œä¸”å½“å‰æ˜¯twinsæ¨¡å¼ï¼Œåˆ™åˆ‡æ¢åˆ° auto æ¨¡å¼
    workMode.value = 'auto';
    localStorage.setItem("workMode", 'auto');
  }
}, { immediate: true });

const conversation_id = computed(() => route.params.id || null);

const mcpMenuSelectedKeys = computed(() => {
  return selectedMcpServerIds.value.length === 0 ? ["disable"] : selectedMcpServerIds.value;
});

const messageStatus = computed(() => {
  const chat = chatStore.list.find((c) => c.conversation_id === chatStore.chat?.conversation_id);
  console.log(" chat?.status", chat?.status);
  console.log(" chatStore.chat?.conversation_id ", chatStore.chat?.conversation_id);
  return chat?.status != "running";
});

// ç§»åŠ¨ç«¯æ£€æµ‹
const checkMobile = () => {
  const newIsMobile = window.innerWidth <= 768;
  if (isMobile.value !== newIsMobile) {
    isMobile.value = newIsMobile;
  }
};

// ç§»åŠ¨ç«¯å¼¹çª—æ§åˆ¶å‡½æ•°
const openVisibilityModal = () => {
  showVisibilityModal.value = true;
};

const closeVisibilityModal = () => {
  const modalSelector = document.querySelector(".mobile-visibility-selector");
  if (modalSelector) {
    modalSelector.classList.add("closing");
  }
  setTimeout(() => {
    showVisibilityModal.value = false;
  }, 250);
};

// ç§»åŠ¨ç«¯é€‰é¡¹é€‰æ‹©å¤„ç†
const handleMobileVisibilitySelect = (value) => {
  // è¿‡æ»¤æ‰ä¿¡æ¯æç¤ºé€‰é¡¹
  if (value === "disabled-info") {
    return;
  }
  handleVisibilityChange(value);
  closeVisibilityModal();
};

// ---------------- ç”Ÿå‘½å‘¨æœŸ ------------------
// ç›‘å¬ localStorage å˜åŒ–
const handleStorageChange = (e) => {
  if (e.key === 'workMode' && e.newValue) {
    // è®¾ç½®æ‰‹åŠ¨åˆ‡æ¢æ ‡å¿—ï¼Œé˜²æ­¢ watch è¦†ç›–
    isManualWorkModeChange.value = true;
    workMode.value = e.newValue;

    // å»¶è¿Ÿé‡ç½®æ ‡å¿—ï¼Œç»™ watch è¶³å¤Ÿçš„æ—¶é—´æ£€æµ‹åˆ°
    setTimeout(() => {
      isManualWorkModeChange.value = false;
    }, 100);
  }
};

onMounted(async () => {
  checkMobile();
  // ç›‘å¬çª—å£å¤§å°å˜åŒ–
  window.addEventListener("resize", checkMobile);
  // ç›‘å¬ localStorage å˜åŒ–
  window.addEventListener("storage", handleStorageChange);

  // ç«‹å³æ³¨å†Œæ‰€æœ‰ç›‘å¬å™¨ï¼Œä¸è¦ç­‰å¾…å¼‚æ­¥æ“ä½œ
  emitter.on("changeMessageText", (text) => {
    messageText.value = text;
  });

  emitter.on("showUpgrade", () => {
    upgradeTitle.value = "";
    upgradeDes.value = "You don't have enough credits, and the prediction can't complete the task. ";
    upgradeDes1.value = "Please upgrade or purchase more credits.";
    showUpgradeModal.value = true;
  });

  // ç›‘å¬èœå•å‘é€çš„ workMode æ›´æ–°äº‹ä»¶
  emitter.on("updateWorkMode", (newWorkMode) => {
    // è®¾ç½®æ‰‹åŠ¨åˆ‡æ¢æ ‡å¿—ï¼Œé˜²æ­¢ watch è¦†ç›–
    isManualWorkModeChange.value = true;
    workMode.value = newWorkMode;

    // å»¶è¿Ÿé‡ç½®æ ‡å¿—ï¼Œç»™ watch è¶³å¤Ÿçš„æ—¶é—´æ£€æµ‹åˆ°
    setTimeout(() => {
      isManualWorkModeChange.value = false;
    }, 100);
  });

  // æ£€æŸ¥æ˜¯å¦æœ‰æ¥è‡ªè½åœ°é¡µçš„é¢„å¡«å……é—®é¢˜
  const prefillQuestion = sessionStorage.getItem('prefillQuestion');
  const prefillQuestionSource = sessionStorage.getItem('prefillQuestionSource');

  if (prefillQuestion && prefillQuestionSource === 'landing') {
    // é¢„å¡«å……åˆ°è¾“å…¥æ¡†
    messageText.value = prefillQuestion;

    // æ¸…é™¤ sessionStorage ä¸­çš„æ•°æ®ï¼Œé¿å…é‡å¤ä½¿ç”¨
    sessionStorage.removeItem('prefillQuestion');
    sessionStorage.removeItem('prefillQuestionSource');
  }

  // æœ€åå†æ‰§è¡Œå¼‚æ­¥æ“ä½œ
  await initModel();
  await fetchMcpServers();
});

onUnmounted(() => {
  window.removeEventListener("resize", checkMobile);
  window.removeEventListener("storage", handleStorageChange);
  // æ¸…ç† emitter äº‹ä»¶ç›‘å¬å™¨
  emitter.off("changeMessageText");
  emitter.off("showUpgrade");
  emitter.off("updateWorkMode");
});

// ---------------- ç›‘å¬è·¯ç”± ------------------
watch(
  () => route.params.agentId,
  () => {
    console.log("agent.value æ”¹å˜", agent.value);
    if (agent.value) {
      selectedMcpServerIds.value = agent.value.mcp_server_ids || [];
    }
  }
);

// ---------------- MCP ------------------
const fetchMcpServers = async () => {
  const servers = await mcpService.activate_servers();
  if (Array.isArray(servers)) mcpServers.value = servers;
  if (agent.value) selectedMcpServerIds.value = agent.value.mcp_server_ids || [];
};

const handleMcpMenuClick = ({ key }) => {
  if (key === "disable") {
    selectedMcpServerIds.value = [];
  } else {
    const index = selectedMcpServerIds.value.indexOf(key);
    index !== -1 ? selectedMcpServerIds.value.splice(index, 1) : selectedMcpServerIds.value.push(key);
  }
  localStorage.setItem("selectedMcpServerIds", JSON.stringify(selectedMcpServerIds.value));
  if (agent.value) {
    agent.value.mcp_server_ids = selectedMcpServerIds.value;
    updateAgent();
  }
};

const updateAgent = async () => {
  if (agent.value) {
    await agentService.update(agent.value.id, agent.value.name, agent.value.describe, agent.value.mcp_server_ids, agent.value.is_public);
    emitter.emit("updateAgentList");
  }
};

const updateChat = async () => {
  if (chat.value) {
    chatStore.updateConversationVisibilityById(chat.value.is_public, chat.value.conversation_id);
  }
};

// -------------- å‡½æ•°å®šä¹‰ ------------------

const closeModal = () => {
  showUpgradeModal.value = false;
};

// å¤„ç†æ¨¡å¼åˆ‡æ¢ (ç®€åŒ–ç‰ˆï¼Œä¸»è¦é€»è¾‘å·²ç§»åˆ° ModeSelector ç»„ä»¶)
const handleModeChange = (mode) => {
  console.log("Mode changed to:", mode);
  // å‘çˆ¶ç»„ä»¶æŠ›å‡ºæ¨¡å¼åˆ‡æ¢äº‹ä»¶
  emit("modeChange", mode);
};
const handleVisibilityChange = (value) => {
  console.log("handleVisibilityChange", value);

  // // è¿‡æ»¤æ‰ä¿¡æ¯æç¤ºé€‰é¡¹
  // if (value === "disabled-info") {
  //   return;
  // }

  // // å¦‚æœ agent æ˜¯ç§æœ‰çš„ï¼Œä¸å…è®¸è®¾ç½® conversation ä¸ºå…¬å¼€
  // if (agent.value && agent.value.is_public === false && value === true) {
  //   return; // é™é»˜é˜»æ­¢ï¼Œå› ä¸ºé€‰é¡¹å·²ç»æ˜¾ç¤ºä¸ºåªè¯»
  // }

  // if (!value) {
  //   // åˆ¤æ–­ æ˜¯ä¸æ˜¯ ä¼šå‘˜
  //   if (!membership.value?.planName) {
  //     isPublic.value = true;
  //     upgradeTitle.value = "Upgrade required";
  //     upgradeDes.value = "";
  //     showUpgradeModal.value = true;
  //     return;
  //   }
  // }
  // agent.value.is_public = value;
  // updateAgent();
  // updateChat();

  if (!value) {
    // åˆ¤æ–­ æ˜¯ä¸æ˜¯ ä¼šå‘˜
    if (!membership.value?.planName) {
      isPublic.value = true;
      upgradeTitle.value = "Upgrade required";
      upgradeDes.value = "";
      showUpgradeModal.value = true;
      return;
    }
  }
  agent.value.is_public = value;
  updateAgent();
};

// ç›‘å¬ agent.value
watch(
  () => agent.value,
  (newValue) => {
    if (agent.value && agent.value.is_public !== undefined) {
      isPublic.value = agent.value?.is_public;
    } else {
      isPublic.value = true;
    }
  },
  {
    immediate: true,
  }
);

// ç›‘å¬ agent å˜åŒ–ï¼Œå¦‚æœ agent æ˜¯ç§æœ‰çš„ï¼Œå¼ºåˆ¶è®¾ç½® conversation ä¸ºç§æœ‰
// watch(
//   () => agent.value,
//   (newAgent) => {
//     if (newAgent && newAgent.is_public === false) {
//       // å¦‚æœ agent æ˜¯ç§æœ‰çš„ï¼Œå¼ºåˆ¶å°† conversation è®¾ç½®ä¸ºç§æœ‰
//       if (isPublic.value === true) {
//         isPublic.value = false;
//         if (chat.value) {
//           chat.value.is_public = false;
//           updateChat();
//         }
//       }
//     }
//   },
//   {
//     immediate: true,
//   }
// );

const modelList = ref([]);
const initModel = async () => {
  console.log("membership.value", membership.value);

  // è®¾ç½®é»˜è®¤æ¨¡å‹ä¸º deepseek-v3
  const setDefaultModel = (models) => {
    if (models.length > 0 && !model_id.value) {
        const defaultId = models[0].id * 1;
        model_id.value = defaultId;
        console.log("æœªæ‰¾åˆ° kimi-k2 æ¨¡å‹ï¼Œä½¿ç”¨ç¬¬ä¸€ä¸ªæ¨¡å‹:", defaultId);
    }
  };

  // Step 1: è¯»å–æœ¬åœ°ç¼“å­˜
  const cachedData = localStorage.getItem("modelList");
  if (cachedData) {
    try {
      modelList.value = JSON.parse(cachedData);
      setDefaultModel(modelList.value);
    } catch (e) {
      console.error("Failed to parse cached modelList", e);
    }
  }

  // Step 2: è·å–æ¥å£æ•°æ®ï¼ˆç”¨äºåˆ·æ–°ï¼‰
  try {
    const res = await modelService.getModels();

    if (Array.isArray(res)) {
      modelList.value = res;
      localStorage.setItem("modelList", JSON.stringify(res));
      setDefaultModel(res);
    }
  } catch (e) {
    console.error("Failed to fetch models from API", e);
  }
};
// ---------------- å‘é€ä¸åœæ­¢ ------------------
const handleSend = () => {
  const text = messageText.value.trim();
  if (!text) return;

  if (points.value.total <= 100) {
    // handleNotification("/setting/usage", t("auth.insufficientPoints"), t("auth.insufficientPointsPleaseGoToUpgradeOrPurchase"));
    upgradeDes.value = "You donâ€™t have enough credits, and the prediction canâ€™t complete the task. ";
    upgradeDes1.value = "Please upgrade or purchase more credits.";
    upgradeTitle.value = "";
    showUpgradeModal.value = true;
    return;
  }
  console.log("workMode.value", workMode.value);

  // åœ¨ chat æˆ– twins æ¨¡å¼ä¸‹æ¸…ç©ºæ–‡ä»¶åˆ—è¡¨
  // if (workMode.value === 'chat' || workMode.value === 'twins') {
  //   fileList.value = [];
  // }

  emit("send", {
    text,
    mode: currentMode.value,
    files: fileList.value,
    mcp_server_ids: selectedMcpServerIds.value,
    is_public: isPublic.value,
    workMode: workMode.value,
  });

  messageText.value = "";
  fileList.value = [];
};

const handleStop = () => {
  chatStore.handleStop();
};

const handleNotification = (path, title, text) => {
  const key = `jump-${Date.now()}`;
  notification.warning({
    message: title,
    key,
    description: h(
      "span",
      {
        style: { textDecoration: "underline", cursor: "pointer", color: "#1677ff" },
      },
      text
    ),
    duration: 2,
    onClick: () => {
      notification.close(key);
      router.push(path);
    },
  });
};

// è‡ªå®šä¹‰æ¨¡å¼å›¾æ ‡ç»„ä»¶ - ä½¿ç”¨å¯¹è¯æ°”æ³¡+å³ä¸‹è§’å›¾æ ‡çš„ç»„åˆæ¨¡å¼
const ModeIcon = ({ type }) => {
  // åˆ›å»ºå¤åˆå›¾æ ‡çš„é€šç”¨å‡½æ•°
  const createCompositeIcon = (overlayIcon) => {
    return h(
      "div",
      {
        style: {
          position: "relative",
          display: "inline-flex",
          alignItems: "center",
          justifyContent: "center",
          width: "16px",
          height: "16px",
        },
      },
      [
        // èƒŒæ™¯å¯¹è¯æ°”æ³¡ - é»‘è‰²
        h(MessageOutlined, {
          style: {
            fontSize: "16px",
            color: "#000",
          },
        }),
        // å³ä¸‹è§’å åŠ å›¾æ ‡ - ç°è‰²
        h(overlayIcon, {
          style: {
            position: "absolute",
            bottom: "-2px",
            right: "-2px",
            fontSize: "8px",
            color: "#999",
            background: "#fff",
            borderRadius: "50%",
            padding: "1px",
          },
        }),
      ]
    );
  };

  // æ ¹æ®ç±»å‹è¿”å›å¯¹åº”çš„å¤åˆå›¾æ ‡
  switch (type) {
    case "chat":
      // Chatä¿æŒç®€å•çš„å¯¹è¯æ°”æ³¡ - é»‘è‰²
      return h(MessageOutlined, { style: { fontSize: "16px", color: "#000" } });

    case "task":
      // Task: å¯¹è¯æ°”æ³¡ + å³ä¸‹è§’ç¯æ³¡å›¾æ ‡ï¼ˆè¡¨ç¤ºæ™ºèƒ½æƒ³æ³•å’Œè§£å†³æ–¹æ¡ˆï¼‰
      return createCompositeIcon(BulbOutlined);

    case "auto":
      // Auto: å¯¹è¯æ°”æ³¡ + å³ä¸‹è§’åŒæ­¥å›¾æ ‡
      return createCompositeIcon(SyncOutlined);

    case "twins":
      // Twins: å¯¹è¯æ°”æ³¡ + å³ä¸‹è§’åˆ†å‰å›¾æ ‡ï¼ˆè¡¨ç¤ºåˆ†æ”¯åä½œï¼‰
      return createCompositeIcon(ForkOutlined);

    default:
      return h(MessageOutlined, { style: { fontSize: "16px", color: "#000" } });
  }
};

// ---------------- è¾“å…¥æ¡†æŒ‰é”®äº‹ä»¶ ------------------
const keydown = (e) => {
  if ((e.shiftKey && e.key === "Enter") || e.isComposing) return;

  if (e.key === "Enter") {
    e.preventDefault();
    // åªæœ‰æ»¡è¶³ messageStatus æ‰èƒ½å‘é€
    console.log("Enter messageStatus.value", messageStatus.value);
    if (messageStatus.value) {
      handleSend();
    }
  }
};
</script>

<style lang="scss" scoped>
.mcp-button-container {
  button {
    display: flex;
    align-items: center;
    justify-content: space-between;
  }
}

.visibility-select .desc {
  font-size: 12px;
  color: #888;
}

.upgrade-des {
  font-size: 16px;
  color: #1a1a19;
  font-weight: 500;
}

.upgrade-des-wrapper {
  width: 100%;
  text-align: center;
  display: flex;
  flex-direction: column;
}

.buy-credits {
  display: flex;
  width: 100%;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 8px;
}

.custom-option {
  display: flex;
  align-items: flex-start;
  gap: 8px;
  padding: 4px 0;
}

.radio-circle {
  width: 16px;
  height: 16px;
  border: 2px solid #333;
  border-radius: 50%;
  margin-top: 3px;
  position: relative;
}

.inner-circle {
  position: absolute;
  top: 1.5px;
  left: 1.5px;
  width: 8px;
  height: 8px;
  background-color: #333;
  border-radius: 50%;
}

.option-texts {
  display: flex;
  flex-direction: column;
}

.pro-tag {
  font-size: 12px !important;
  padding: 0 6px !important;
  height: 18px !important;
  line-height: 1 !important;
  border-radius: 4px !important;
  background-color: #1a1a19 !important;
  color: #fff !important;
  border: 1px solid #1a1a19 !important;
  display: inline-flex !important;
  align-items: center !important;
  justify-content: center !important;
}

/* ä¿¡æ¯æç¤ºé€‰é¡¹æ ·å¼ - ç®€åŒ–ç‰ˆ */
.info-option {}

.disabled-option {
  cursor: not-allowed !important;
  opacity: 0.5;
  color: #999 !important;
}

.readonly-option {
  cursor: not-allowed !important;
  opacity: 0.6;
  background-color: #f9f9f9 !important;
}

.info-icon {
  width: 16px;
  height: 16px;
  border: 1px solid #333;
  border-radius: 50%;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  font-weight: bold;
  color: #333;
  background-color: #fff;
  margin-top: 3px;
}

.info-icon-mobile {
  width: 16px;
  height: 16px;
  border: 1px solid #333;
  border-radius: 50%;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  font-weight: bold;
  color: #333;
  background-color: #fff;
  margin-top: 3px;
}

/* ç§»åŠ¨ç«¯ä¿¡æ¯é€‰é¡¹æ ·å¼ */
.info-item {
  background-color: #f5f5f5 !important;
  cursor: default !important;
}

.disabled-item {
  cursor: not-allowed !important;
  opacity: 0.5;
  color: #999 !important;
}

.readonly-item {
  cursor: not-allowed !important;
  opacity: 0.6;
  background-color: #f9f9f9 !important;
}

.info-item:hover {
  background-color: #f5f5f5 !important;
}

.readonly-item:hover {
  background-color: #f9f9f9 !important;
}

.mcp-server-menu {
  width: 250px;
}

.mcp-server-menu .ant-menu-item-selected {
  background-color: #e6f7ff !important;
}

.mcp-server-item {
  border-color: #0000000f;
}

::v-deep(.ant-dropdown-menu-item-selected) {
  background-color: #0000000f !important;
  color: #333 !important;
}

.check-icon {
  color: #1890ff;
}

.mcp-button {
  border-color: #0000000f;
  border-radius: 6px;
}

.mcp-button-active {
  background-color: #e6f7ff;
  border-color: #1890ff !important;
  color: #1890ff;
}

:deep(.ant-dropdown-menu-title-content) {
  display: flex;
  justify-content: space-between;
}

:deep(.ant-dropdown-menu-item) {
  margin-bottom: 4px !important;
}

.upload-button {
  border-color: #0000000f;
  border-radius: 6px;
}

.send-button {
  width: 32px;
  height: 31px;
  border-radius: 8px;
  border: unset !important;
  background-color: rgba(255, 199, 0, 1);
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.15s ease;
  width: 32px;
  height: 32px;
}

.send-button:hover:not(:disabled) {
  background: rgba(255, 199, 0, 1);
  transform: translateY(-1px);
}

.stop-button {
  background: rgba(255, 199, 0, 1);
  border-radius: 8px;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 32px;
  height: 32px;
  cursor: pointer;
  border: unset !important;

  div {
    width: 10px;
    height: 10px;
    background: white;
  }
}

/* ç¦ç”¨çŠ¶æ€ä¸‹çš„æ ·å¼ */
.send-button:disabled,
.send-button[disabled] {
  background: #37352f14;
  /* æµ…ç°è‰²èƒŒæ™¯ */
  border: 0px solid #37352f14;
  /* è¾¹æ¡†é¢œè‰² */
  color: #a8a8a8;
  /* æ–‡å­—é¢œè‰²å˜æµ… */
  cursor: not-allowed;
  /* é¼ æ ‡æ‚¬åœæ—¶æ˜¾ç¤ºç¦ç”¨çŠ¶æ€ */

  svg {
    fill: #b9b9b7;
  }
}

.input-textarea {
  //height: 46px!important;
  //max-height: 240px;
}

.input-textarea::-webkit-scrollbar {
  width: 2px;
}

.input-textarea::-webkit-scrollbar-thumb {
  background-color: #d9d9d9;
  border-radius: 3px;
}

.input-textarea::-webkit-scrollbar-track {
  background-color: #f5f5f5;
}


@media (min-width: 640px) {
  .chat-input {
    max-width: 1039px !important;
    min-width: 390px !important;
  }
}

.chat-input {
  border-radius: 22px;
  position: sticky;
  bottom: 0;
  padding-bottom: 0.75rem;
  background: #f8f8f7;
  padding-top: 0.75rem;
}

.input-wrapper {
  margin: 0 auto;
  width: 100%;
}

.input-area {
  // display: flex;
  // gap: 0;
  // background: #fff;
  // align-items: flex-end;
  // border: 1px solid rgb(229, 231, 235);
  // border-radius: 22px;
  // padding: 0.75rem;
  // transition: border-color 0.3s;


  display: flex;
  flex-direction: column;
  min-height: 140px;
  padding: 20px 20px 12px 20px;
  line-height: 20px;
  border-radius: 16px;
  background-color: rgba(255, 255, 255, 1);
  color: rgba(255, 255, 255, 1);
  font-size: 14px;
  text-align: center;
  box-shadow: 0px 1px 10px 0px rgba(0, 0, 0, 0.03);
  font-family: PingFangSC-regular;
  border: 1px solid rgba(236, 236, 236, 1);

}

.input-container {
  flex: 1;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  width: 100%;
}

:deep(.ant-input) {
  border: none !important;
  box-shadow: none !important;
  padding: 0 8px;

  &:focus {
    box-shadow: none !important;
  }
}

.input-actions {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-top: 8px;
}

.left-actions {
  display: flex;
  align-items: center;
  gap: 12px;
}

/* PCç«¯æ ·å¼ï¼šæŒ‰é’®æ˜¾ç¤ºä¸ºä¸€è¡Œ */
.chat-input .left-actions {
  display: flex;
  flex-direction: row;
  align-items: center;
  gap: 12px;
}

.chat-input .left-actions .button-row {
  display: contents;
  /* è®©button-rowå®¹å™¨ä¸å½±å“å¸ƒå±€ */
}

.mode-switcher {
  margin-right: 0;
  border: none;
  box-shadow: none;
}

.model-option {
  display: flex;
  align-items: center;
  padding: 4px 8px;
}

.model-logo {
  width: 24px;
  height: 24px;
  border-radius: 4px;
  margin-right: 10px;
  object-fit: cover;
  background-color: #f0f0f0;
}

.model-name {
  font-weight: 500;
  color: #333;
}
</style>
<style>
.model-select .ant-select-selector {
  border: 1px solid #e9ecef !important;
  border-radius: 6px !important;
}

/* ä¸ºvisibility-selectæ·»åŠ è¾¹æ¡† */
.visibility-select .ant-select-selector {
  border: 1px solid #e9ecef !important;
  border-radius: 6px !important;
}

/* ç»Ÿä¸€æ‰€æœ‰Ant Designç»„ä»¶çš„åœ†è§’ */
:deep(.ant-select-selector),
:deep(.ant-btn),
:deep(.ant-dropdown-trigger) {
  border-radius: 6px !important;
}

/* ç§»åŠ¨ç«¯è§¦å‘å™¨æ ·å¼ */
.mobile-visibility-trigger {
  display: flex;
  align-items: center;
  justify-content: space-between;
  width: 100%;
  height: 24px;
  padding: 0 2px;
  background: #fff;
  border: 1px solid #d9d9d9;
  border-radius: 4px;
  cursor: pointer;
  font-size: 10px;
}

.mobile-visibility-trigger .visibility-name {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  flex: 1;
  margin-right: 2px;
}

.mobile-visibility-trigger .dropdown-icon {
  font-size: 8px;
  color: #999;
}

/* ç§»åŠ¨ç«¯è‡ªå®šä¹‰æ¨¡æ€æ¡†æ ·å¼ */
.mobile-modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.45);
  z-index: 10000;
  display: flex;
  align-items: flex-end;
  justify-content: center;
  animation: fadeIn 0.3s ease-out;
}

/* ç§»åŠ¨ç«¯æ¨¡æ€æ¡†å†…å®¹æ ·å¼ */
.mobile-visibility-selector {
  background: #fff;
  border-radius: 12px 12px 0 0;
  padding: 0;
  max-height: 50vh;
  min-height: 200px;
  width: 100%;
  max-width: 100%;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  animation: slideUpIn 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
}

.mobile-visibility-selector.closing {
  animation: slideDownOut 0.25s cubic-bezier(0.4, 0, 0.2, 1);
}

.modal-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px 20px;
  border-bottom: 1px solid #f0f0f0;
  flex-shrink: 0;
}

.modal-header h3 {
  margin: 0;
  font-size: 16px;
  font-weight: 600;
}

.close-btn {
  padding: 4px !important;
  color: #999 !important;
}

.option-list {
  flex: 1;
  overflow-y: auto;
  min-height: 0;
  -webkit-overflow-scrolling: touch;
  padding-bottom: 16px;
}

.option-item {
  display: flex;
  align-items: center;
  padding: 12px 20px;
  cursor: pointer;
  transition: background-color 0.2s;
}

.option-item:hover {
  background-color: #f5f5f5;
}

.option-item.selected {
  background-color: #e6f7ff;
}

.option-info {
  display: flex;
  align-items: flex-start;
  gap: 12px;
  width: 100%;
}

.option-circle {
  width: 16px;
  height: 16px;
  border: 2px solid #333;
  border-radius: 50%;
  margin-top: 3px;
  position: relative;
  flex-shrink: 0;
}

.option-inner-circle {
  position: absolute;
  top: 1.5px;
  left: 1.5px;
  width: 8px;
  height: 8px;
  background-color: #333;
  border-radius: 50%;
}

.option-texts {
  display: flex;
  flex-direction: column;
  flex: 1;
}

.option-label {
  font-size: 14px;
  font-weight: 500;
  color: #333;
  display: flex;
  align-items: center;
  gap: 8px;
}

.option-desc {
  font-size: 12px;
  color: #888;
  margin-top: 2px;
}

.pro-tag-mobile {
  font-size: 10px !important;
  padding: 0 4px !important;
  height: 16px !important;
  line-height: 1 !important;
  border-radius: 3px !important;
  background-color: #1a1a19 !important;
  color: #fff !important;
  border: 1px solid #1a1a19 !important;
  display: inline-flex !important;
  align-items: center !important;
  justify-content: center !important;
}

/* åŠ¨ç”»å…³é”®å¸§ */
@keyframes slideUpIn {
  from {
    transform: translateY(100%);
  }

  to {
    transform: translateY(0);
  }
}

@keyframes slideDownOut {
  from {
    transform: translateY(0);
  }

  to {
    transform: translateY(100%);
  }
}

@keyframes fadeIn {
  from {
    opacity: 0;
  }

  to {
    opacity: 1;
  }
}

/** é€‚é…ç§»åŠ¨è®¾å¤‡å±å¹• - é™å®šåœ¨chat-inputç»„ä»¶å†… */
@media (max-width: 768px) {
  .chat-input .input-actions {
    height: auto;
    gap: 50px;

    span {
      height: 24px !important;
      max-height: 24px !important;
      line-height: 24px !important;
    }
  }

  .chat-input .left-actions {
    height: auto;
    flex: 1;
    max-width: calc(100% - 48px);
    display: flex !important;
    flex-direction: column !important;
    gap: 4px !important;
    align-items: flex-start !important;
  }

  .chat-input .left-actions .button-row {
    display: flex !important;
    align-items: center;
    gap: 4px;
    height: 24px;
  }

  .chat-input .left-actions .first-row {
    justify-content: flex-start;
  }

  .chat-input .left-actions .second-row {
    justify-content: flex-start;
  }

  /* ç¬¬ä¸€è¡ŒæŒ‰é’®æ ·å¼ */
  .chat-input .left-actions .first-row>* {
    height: 24px;
    display: flex;
    align-items: center;
  }

  /* ç¬¬äºŒè¡ŒæŒ‰é’®æ ·å¼ */
  .chat-input .left-actions .second-row>* {
    height: 24px;
    display: flex;
    align-items: center;
  }

  /* ç¬¬ä¸€è¡Œï¼šä¸Šä¼ æŒ‰é’® */
  .chat-input .left-actions .first-row .chat-input-upload {
    width: auto;
    flex: 0 0 auto;
    justify-content: center;
  }

  /* ç¬¬ä¸€è¡Œï¼šæ¨¡å¼é€‰æ‹©å™¨ */
  .chat-input .left-actions .first-row .mode-selector-wrapper {
    flex: 0 0 auto;
    min-width: 60px;
    max-width: 90px;
    pointer-events: auto !important;
    position: relative !important;
  }

  .chat-input .left-actions .mode-selector-wrapper .mobile-mode-trigger {
    width: 100% !important;
    font-size: 10px !important;
    padding: 0 4px !important;
    pointer-events: auto !important;
    cursor: pointer !important;
    position: relative !important;
    z-index: 1 !important;
  }

  .chat-input .left-actions .mode-selector-wrapper .mobile-mode-trigger .mode-name {
    max-width: none !important;
    flex: 1 !important;
    color: #333 !important;
    line-height: 24px !important;
    pointer-events: none !important;
  }

  .chat-input .left-actions .mode-selector-wrapper .mobile-mode-trigger .dropdown-icon {
    font-size: 10px !important;
    color: #666 !important;
    pointer-events: none !important;
  }

  /* ç¬¬ä¸€è¡Œï¼šå¯è§†åŒ–é€‰æ‹© */
  .chat-input .left-actions .first-row .visibility-toggle {
    flex: 0 0 auto;
    min-width: 60px;
    max-width: 80px;
  }

  /* ç¬¬ä¸€è¡Œï¼šMCPæŒ‰é’® */
  .chat-input .left-actions .first-row .mcp-button-container {
    flex: 0 0 auto;
    min-width: 50px;
  }

  /** é’ˆå¯¹å¯è§†é€‰æ‹©ä¸‹æ‹‰æ¡†çš„ç‰¹æ®Šæ ·å¼ - é™å®šåœ¨chat-inputå†… */
  .chat-input .left-actions .visibility-select .ant-select-selection-item {
    font-size: 10px !important;
    padding-inline-end: 0px !important;
    line-height: 24px !important;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .chat-input .left-actions .visibility-select .ant-select-selector {
    padding: 0px 2px !important;
  }

  .chat-input .left-actions .visibility-select .ant-select-arrow {
    display: none !important;
  }

  /** å¯è§†é€‰æ‹©æ ·å¼ - é™å®šåœ¨chat-inputå†… */
  .chat-input .left-actions .visibility-toggle {
    height: 24px;
    font-size: 11px;
    width: 100%;

    div {
      height: 24px !important;
      max-height: 24px !important;
      width: 100% !important;
    }

    .mobile-visibility-trigger {
      width: 100% !important;
      font-size: 10px !important;
      padding: 0 4px !important;
      pointer-events: auto !important;
      cursor: pointer !important;
      position: relative !important;
      z-index: 1 !important;
    }

    .mobile-visibility-trigger .visibility-name {
      flex: 1 !important;
      color: #333 !important;
      line-height: 24px !important;
      pointer-events: none !important;
    }

    .mobile-visibility-trigger .dropdown-icon {
      font-size: 10px !important;
      color: #666 !important;
      pointer-events: none !important;
    }
  }

  /** MCPæŒ‰é’®æ ·å¼ - é™å®šåœ¨chat-inputå†… */
  .chat-input .left-actions .mcp-button {
    height: 24px !important;
    max-height: 24px !important;
    font-size: 10px !important;
    padding: 0px 2px !important;

    .anticon {
      display: none !important;
    }
  }
}
</style>



================================================
FILE: frontend/src/view/lemon/components/ChatInputFileList.vue
================================================
<template>
    <div style="overflow: auto;width: 100%;min-width: 0;">
        <div class="upload-fileList">
            <div class="upload-fileList-item" v-for="(file, index) in fileList" :key="index">
                <fileSvg :url="file.name" :is-update="true" class="file-icon" />
                <div style="min-width: 0;width: 100%;text-align: left;">
                    <div style="display: flex;width: 100%;    align-items: center;" v-if="!file.uploading">
                        <div class="file-name">{{ file.name }}</div>
                        <div class="delete-button" @click="handleDelete(file)">
                            <deleteFile />
                        </div>
                    </div>
                    <div style="display: flex; width: 100%; align-items: center; color: #34322d;" v-else>
                        <div class="loading-spinner"></div>
                        <div style="margin-left: 8px;">Uploading...</div>
                    </div>
                    <div v-if="!file.uploading">
                        <div class="file-size">{{ formatFileSize(file.size) }}</div>
                    </div>
                </div>

            </div>
        </div>
    </div>
</template>
<script setup>
import fileSvg from '@/components/fileClass/fileSvg.vue';
import deleteFile from "@/assets/message/deleteFile.svg";
import files from '@/services/files';

const props = defineProps({
    fileList: {
        type: Array,
        default: () => [],
    },
    conversation_id: {
        type: String,
        default: '',
    }
});

const emit = defineEmits(['update:fileList']);
const handleDelete = (file) => {
    console.log('delete file', file);
    files.deleteFile(file.id, props.conversation_id);
    emit('update:fileList', props.fileList.filter(f => f.id !== file.id))
};

const formatFileSize = (size) => {
    if (size < 1024) return `${size} B`;
    if (size < 1024 * 1024) return `${(size / 1024).toFixed(2)} KB`;
    return `${(size / (1024 * 1024)).toFixed(2)} MB`;
};

</script>
<style lang="scss" scoped>
.upload-fileList {
    display: flex;
    gap: .75rem;
    ;
}

.upload-fileList-item {
    padding: .5rem;
    border-radius: 10px;
    gap: .375rem;
    cursor: pointer;
    width: 280px;
    min-width: 280px;
    display: flex;
    background-color: #37352f0f;
    font-family: ui-serif;

    .file-icon {
        min-width: 28px;
        min-height: 28px;
    }

    .file-name {
        color: #34322d;
        font-size: .875rem;
        line-height: 1.25rem;
        white-space: nowrap;
        text-overflow: ellipsis;
        overflow: hidden;
        width: 100%;
    }

    .file-size {
        font-size: .75rem;
        line-height: 1rem;
        color: #858481;

    }

    .delete-button {
        padding: 2px;
        background-color: #858481;
        border-radius: 99999px;
        color: #fff;
        width: fit-content;
        height: fit-content;
        display: none;
    }

    &:hover {
        .delete-button {
            display: flex;
        }
    }
}

.loading-spinner {
    width: 16px;
    height: 16px;
    border: 2px solid #34322d;
    border-top-color: transparent;
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

@keyframes spin {
    to {
        transform: rotate(360deg);
    }
}
</style>


================================================
FILE: frontend/src/view/lemon/components/ChatInputUpload.vue
================================================
<template>
    <a-upload :file-list="fileList" :before-upload="beforeUpload" :show-upload-list="false" :disabled="uploadDisabled">
        <a-button type="text" class="upload-button" @click="handleUploadClick">
            <template #icon>
                <PaperClipIcon />
            </template>
        </a-button>
    </a-upload>
</template>
<script setup>
import { ref } from 'vue';
import { Modal } from 'ant-design-vue';
import PaperClipIcon from '@/assets/svg/paperclip-icon.svg';
import files from '@/services/files';
import { useChatStore } from '@/store/modules/chat';
import { storeToRefs } from 'pinia';

const props = defineProps({
    fileList: {
        type: Array,
        default: () => []
    },
    conversation_id: {
        type: String,
        default: ''
    },
    isPublic: {
        type: Boolean,
        default: false
    }
})

// ä»æµè§ˆå™¨ç¼“å­˜ä¸­è·å–æ˜¯å¦å·²ç»æ˜¾ç¤ºè¿‡å…¬å¼€æç¤º
const getHasShownPublicWarning = () => {
    return localStorage.getItem('hasShownPublicWarning') === 'true';
};

// è®¾ç½®å·²æ˜¾ç¤ºè¿‡å…¬å¼€æç¤ºåˆ°æµè§ˆå™¨ç¼“å­˜
const setHasShownPublicWarning = (value) => {
    localStorage.setItem('hasShownPublicWarning', value.toString());
};

const hasShownPublicWarning = ref(getHasShownPublicWarning());
const uploadDisabled = ref(false); // æ§åˆ¶ä¸Šä¼ ç»„ä»¶æ˜¯å¦å¯ç”¨

const chatStore = useChatStore();
const { chat } = storeToRefs(chatStore);

const emit = defineEmits(['update:fileList']);

// å¤„ç†ä¸Šä¼ æŒ‰é’®ç‚¹å‡»äº‹ä»¶
const handleUploadClick = async (e) => {
    // å¦‚æœæ˜¯å…¬å¼€æ¨¡å¼ä¸”æ˜¯é¦–æ¬¡ä¸Šä¼ ï¼Œæ˜¾ç¤ºè­¦å‘Š
    if (props.isPublic && !hasShownPublicWarning.value) {
        e.stopPropagation(); // é˜»æ­¢é»˜è®¤çš„æ–‡ä»¶é€‰æ‹©è¡Œä¸º
        
        const confirmed = await new Promise((resolve) => {
            Modal.confirm({
                title: 'Public File Upload Warning',
                content: 'You have selected public mode. The uploaded files will be made public. Please confirm to continue?',
                okText: 'Continue',
                cancelText: 'Cancel',
                centered: true,
                onOk: () => {
                    hasShownPublicWarning.value = true;
                    setHasShownPublicWarning(true); // ä¿å­˜åˆ°æµè§ˆå™¨ç¼“å­˜
                    resolve(true);
                },
                onCancel: () => {
                    resolve(false);
                }
            });
        });
        
        // å¦‚æœç”¨æˆ·ç¡®è®¤ï¼Œè§¦å‘æ–‡ä»¶é€‰æ‹©
        if (confirmed) {
            // æ‰‹åŠ¨è§¦å‘æ–‡ä»¶é€‰æ‹©
            const input = e.target.closest('.ant-upload').querySelector('input[type="file"]');
            if (input) {
                input.click();
            }
        }
        return;
    }
    // å¦‚æœä¸éœ€è¦è­¦å‘Šï¼Œè®©é»˜è®¤è¡Œä¸ºç»§ç»­
};
const beforeUpload = async (file) => {
    // ç»™æ¯ä¸ªæ–‡ä»¶ç”Ÿæˆä¸€ä¸ªå”¯ä¸€æ ‡è¯†ï¼Œæ–¹ä¾¿åç»­æ›¿æ¢çŠ¶æ€
    file.uid = Date.now() + Math.random();

    // åœ¨æ–‡ä»¶åˆ—è¡¨é‡ŒåŠ å…¥"ä¸Šä¼ ä¸­"çŠ¶æ€çš„ä¸´æ—¶æ–‡ä»¶
    const uploadingFile = {
        uid: file.uid,
        name: file.name,
        size: file.size,
        uploading: true,
        error: false,
    };

    // å…ˆæ›´æ–°åˆ—è¡¨ï¼Œæ·»åŠ ä¸Šä¼ ä¸­æ¡ç›®
    emit('update:fileList', [...props.fileList, uploadingFile]);
    
    try {
        // ä¸Šä¼ åˆ° agent conversationï¼ˆå½“å‰ conversation_idï¼‰
        const agentFormData = new FormData();
        agentFormData.append('conversation_id', props.conversation_id || '');
        agentFormData.append('files', file);

        const agentResult = await files.uploadFile(agentFormData);
        let agentUpload = agentResult[0];

        // ä¸Šä¼ æˆåŠŸï¼Œæ›¿æ¢åˆ—è¡¨ä¸­å¯¹åº”çš„ä¸´æ—¶æ–‡ä»¶ï¼ˆä½¿ç”¨ agent çš„ä¸Šä¼ ç»“æœï¼‰
        const newFileList = props.fileList
            .filter((f) => f.uid !== file.uid) // å…ˆç§»é™¤ä¸´æ—¶æ–‡ä»¶
            .concat({
                name: agentUpload.name,
                size: file.size,
                url: agentUpload.url,
                id: agentUpload.id,
                workspace_dir: agentUpload.workspace_dir,
                uploading: false,
                error: false,
            });
        console.log('newFileList', newFileList);
        emit('update:fileList', newFileList);
    } catch (e) {
        // ä¸Šä¼ å¤±è´¥ï¼Œæ›´æ–°å¯¹åº”æ–‡ä»¶çŠ¶æ€
        console.log('ä¸Šä¼ å¤±è´¥ï¼Œæ›´æ–°å¯¹åº”æ–‡ä»¶çŠ¶æ€', e);
        const newFileList = props.fileList.map((f) => {
            if (f.uid === file.uid) {
                return { ...f, uploading: false, error: true };
            }
            return f;
        });
        emit('update:fileList', newFileList);
    }
    return false; // é˜»æ­¢é»˜è®¤ä¸Šä¼ 
};
</script>
<style scoped>
    .upload-button {
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .upload-button :deep(.anticon) {
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .upload-button :deep(svg) {
        width: 24px;
        height: 24px;
        display: block;
    }

    @media (max-width: 768px) {
        .upload-button {
            font-size: 11px!important;
            height: 24px!important;
            width: 100%!important;
            padding: 0 4px!important;
        }
    }
</style>


================================================
FILE: frontend/src/view/lemon/components/ChatMessages.vue
================================================
<template>
  <div class="chat-messages" ref="chatMessagesRef">
    <div class="message-list">
      <!-- è‡ªåŠ¨åˆ¤æ–­æ˜¯å¦æ˜¾ç¤ºéª¨æ¶å± -->
      <!-- {{ chat }} -->
      <div v-if="isLoading">
        <a-skeleton v-for="n in 5" :key="n" active title class="skeleton-message" />
      </div>
      <div class="message-piece">
        <!-- é Twins æ¨¡å¼ï¼šæ­£å¸¸å•æ æ˜¾ç¤º -->
        <div v-if="!isTwins">
          <template v-if="!isLoading">
            <div v-for="message in messages" :key="message.id" class="message-item" :class="message.role">
              <div style="display: flex; align-items: center; justify-content: flex-end" v-if="message?.meta?.screenshot || message?.meta?.json?.screenshot">
                <ChatReference :meta="message?.meta?.json || message?.meta" />
              </div>
              <div class="message-options" v-if="!isPlanOrUpdateStatus(message)">
                <div v-if="message.role === 'assistant'" class="message-title">
                  <img src="@/assets/image/lemon.jpg" alt="" />
                  <!-- LemonAI -->
                </div>
                <div v-else></div>

                <div style="display: flex; align-items: center; justify-content: flex-end">
                  <div class="message-time display-none">
                    {{ formatTimeWithHMS(message.timestamp, t) }}
                  </div>
                  <div class="copy-button display-none" @click="copyMessage(message)" v-if="message.role === 'user'">
                    <CopyOutlined />
                  </div>
                </div>
              </div>
              <Message :message="message" />
            </div>
          </template>
        </div>

        <!-- Twins æ¨¡å¼ï¼šåŒæ æ°´å¹³å±•ç¤º -->
        <template v-else-if="!isLoading">
          <!-- åŒæ æ¨¡å¼ -->
          <div v-if="isLeftColumnVisible && isRightColumnVisible" class="twins-container both-visible">
            <!-- å·¦æ ï¼šChat æ¶ˆæ¯ -->
            <div class="twins-column-wrapper">
              <div class="twins-column chat-column" ref="chatColumnRef">
                <div class="column-header">
                  <span><strong>Chat</strong> <span class="description">get an answer from LLM</span></span>
                  <a-switch :checked="isLeftColumnVisible" @change="toggleLeftColumn" size="small" />
                </div>
                <div class="column-content">
                  <!-- {{ twinsChatMessages }} -->
                  <div v-for="chatMessage in twinsChatMessages" :key="chatMessage.id" class="message-item" :class="chatMessage.role">
                    <div style="display: flex; align-items: center; justify-content: flex-end" v-if="chatMessage?.meta?.screenshot || chatMessage?.meta?.json?.screenshot">
                      <ChatReference :meta="chatMessage?.meta?.json || chatMessage?.meta" />
                    </div>
                    <div class="message-options" v-if="!isPlanOrUpdateStatus(chatMessage)">
                      <div v-if="chatMessage.role === 'assistant'" class="message-title">
                        <img src="@/assets/image/lemon.jpg" alt="" />
                      </div>
                      <div v-else></div>

                      <div style="display: flex; align-items: center; justify-content: flex-end">
                        <div class="message-time display-none">
                          {{ formatTimeWithHMS(chatMessage.timestamp, t) }}
                        </div>
                        <div class="copy-button display-none" @click="copyMessage(chatMessage)" v-if="chatMessage.role === 'user'">
                          <CopyOutlined />
                        </div>
                      </div>
                    </div>
                    <Message :message="chatMessage" />
                  </div>
                </div>
              </div>
              <!-- å•æ æ¨¡å¼å·¦æ  Token consumption display -->
              <div v-if="chatTokenCount && chatTokenCount.total > 0" class="token-consumption twins-token-left">
                <a-tag>
                  <span>Chat Tokens: {{ chatTokenCount.total }}</span>
                  <span> <ArrowUpOutlined /> {{ chatTokenCount.input_tokens }} </span>
                  <span> <ArrowDownOutlined /> {{ chatTokenCount.output_tokens }} </span>
                </a-tag>
              </div>
              <!-- å·¦æ æ»šåŠ¨åˆ°åº•éƒ¨æŒ‰é’® -->
              <div class="column-scroll-to-bottom" @click="scrollToBottomLeft" v-if="isLeftColumnVisible">
                <Down />
              </div>
            </div>

            <!-- å³æ ï¼šAgent æ¶ˆæ¯ -->
            <div class="twins-column-wrapper">
              <div class="twins-column agent-column" ref="agentColumnRef">
                <div class="column-header">
                  <span><strong>Agent</strong> <span class="description">get an answer from agentic with tools</span></span>
                  <a-switch :checked="isRightColumnVisible" @change="toggleRightColumn" size="small" />
                </div>
                <!-- {{ messages }} -->
                <div class="column-content">
                  <div v-for="message in messages" :key="message.id" class="message-item" :class="message.role">
                    <div style="display: flex; align-items: center; justify-content: flex-end" v-if="message?.meta?.screenshot || message?.meta?.json?.screenshot">
                      <ChatReference :meta="message?.meta?.json || message?.meta" />
                    </div>
                    <div class="message-options" v-if="!isPlanOrUpdateStatus(message)">
                      <div v-if="message.role === 'assistant'" class="message-title">
                        <img src="@/assets/image/lemon.jpg" alt="" />
                      </div>
                      <div v-else></div>

                      <div style="display: flex; align-items: center; justify-content: flex-end">
                        <div class="message-time display-none">
                          {{ formatTimeWithHMS(message.timestamp, t) }}
                        </div>
                        <div class="copy-button display-none" @click="copyMessage(message)" v-if="message.role === 'user'">
                          <CopyOutlined />
                        </div>
                      </div>
                    </div>
                    <Message :message="message" />
                  </div>
                </div>
              </div>
              <!-- å•æ æ¨¡å¼å³æ  Token consumption display -->
              <div v-if="agentTokenCount && agentTokenCount.total > 0" class="token-consumption twins-token-right">
                <a-tag>
                  <span v-if="chatStore.chat.model_name">Model: {{ chatStore.chat.model_name }}</span>
                  <span>Agent Tokens: {{ agentTokenCount.total }}</span>
                  <span> <ArrowUpOutlined /> {{ agentTokenCount.input_tokens }} </span>
                  <span> <ArrowDownOutlined /> {{ agentTokenCount.output_tokens }} </span>
                </a-tag>
              </div>
              <!-- å³æ æ»šåŠ¨åˆ°åº•éƒ¨æŒ‰é’® -->
              <div class="column-scroll-to-bottom" @click="scrollToBottomRight" v-if="isRightColumnVisible">
                <Down />
              </div>
            </div>
          </div>

          <!-- å•æ æ¨¡å¼ï¼šåªæ˜¾ç¤ºå·¦æ  (Chat) -->
          <div v-else-if="isLeftColumnVisible" class="twins-container single-column">
            <div class="twins-column-wrapper">
              <div class="twins-column chat-column" ref="chatColumnRef">
                <div class="column-header merged-header">
                  <div class="header-section">
                    <span><strong>Chat</strong> <span class="description">get an answer from LLM</span></span>
                    <a-switch :checked="isLeftColumnVisible" @change="toggleLeftColumn" size="small" />
                  </div>
                  <div class="header-section">
                    <span class="inactive-title"><strong>Agent</strong> <span class="description">get an answer from agentic with tools</span></span>
                    <a-switch :checked="isRightColumnVisible" @change="toggleRightColumn" size="small" />
                  </div>
                </div>
                <div class="column-content">
                  <!-- {{ twinsChatMessages }} -->
                  <div v-for="chatMessage in twinsChatMessages" :key="chatMessage.id" class="message-item" :class="chatMessage.role">
                    <div style="display: flex; align-items: center; justify-content: flex-end" v-if="chatMessage?.meta?.screenshot || chatMessage?.meta?.json?.screenshot">
                      <ChatReference :meta="chatMessage?.meta?.json || chatMessage?.meta" />
                    </div>
                    <div class="message-options" v-if="!isPlanOrUpdateStatus(chatMessage)">
                      <div v-if="chatMessage.role === 'assistant'" class="message-title">
                        <img src="@/assets/image/lemon.jpg" alt="" />
                      </div>
                      <div v-else></div>

                      <div style="display: flex; align-items: center; justify-content: flex-end">
                        <div class="message-time display-none">
                          {{ formatTimeWithHMS(chatMessage.timestamp, t) }}
                        </div>
                        <div class="copy-button display-none" @click="copyMessage(chatMessage)" v-if="chatMessage.role === 'user'">
                          <CopyOutlined />
                        </div>
                      </div>
                    </div>
                    <Message :message="chatMessage" />
                  </div>
                </div>
              </div>
              <!-- å·¦æ  Token consumption display -->
              <div v-if="chatTokenCount && chatTokenCount.total > 0" class="token-consumption twins-token-left">
                <a-tag>
                  <span>Chat Tokens: {{ chatTokenCount.total }}</span>
                  <span> <ArrowUpOutlined /> {{ chatTokenCount.input_tokens }} </span>
                  <span> <ArrowDownOutlined /> {{ chatTokenCount.output_tokens }} </span>
                </a-tag>
              </div>
              <!-- å·¦æ æ»šåŠ¨åˆ°åº•éƒ¨æŒ‰é’® -->
              <div class="column-scroll-to-bottom" @click="scrollToBottomLeft" v-if="isLeftColumnVisible">
                <Down />
              </div>
            </div>
          </div>

          <!-- å•æ æ¨¡å¼ï¼šåªæ˜¾ç¤ºå³æ  (Agent) -->
          <div v-else class="twins-container single-column">
            <div class="twins-column-wrapper">
              <div class="twins-column agent-column" ref="agentColumnRef">
                <div class="column-header merged-header">
                  <div class="header-section">
                    <span class="inactive-title"><strong>Chat</strong> <span class="description">get an answer from LLM</span></span>
                    <a-switch :checked="isLeftColumnVisible" @change="toggleLeftColumn" size="small" />
                  </div>
                  <div class="header-section">
                    <span><strong>Agent</strong> <span class="description">get an answer from agentic with tools</span></span>
                    <a-switch :checked="isRightColumnVisible" @change="toggleRightColumn" size="small" />
                  </div>
                </div>
                <div class="column-content">
                  <div v-for="message in messages" :key="message.id" class="message-item" :class="message.role">
                    <div style="display: flex; align-items: center; justify-content: flex-end" v-if="message?.meta?.screenshot || message?.meta?.json?.screenshot">
                      <ChatReference :meta="message?.meta?.json || message?.meta" />
                    </div>
                    <div class="message-options" v-if="!isPlanOrUpdateStatus(message)">
                      <div v-if="message.role === 'assistant'" class="message-title">
                        <img src="@/assets/image/lemon.jpg" alt="" />
                      </div>
                      <div v-else></div>

                      <div style="display: flex; align-items: center; justify-content: flex-end">
                        <div class="message-time display-none">
                          {{ formatTimeWithHMS(message.timestamp, t) }}
                        </div>
                        <div class="copy-button display-none" @click="copyMessage(message)" v-if="message.role === 'user'">
                          <CopyOutlined />
                        </div>
                      </div>
                    </div>
                    <Message :message="message" />
                  </div>
                </div>
              </div>
              <!-- å³æ  Token consumption display -->
              <div v-if="agentTokenCount && agentTokenCount.total > 0" class="token-consumption twins-token-right">
                <a-tag>
                  <span v-if="chatStore.chat.model_name">Model: {{ chatStore.chat.model_name }}</span>
                  <span>Agent Tokens: {{ agentTokenCount.total }}</span>
                  <span> <ArrowUpOutlined /> {{ agentTokenCount.input_tokens }} </span>
                  <span> <ArrowDownOutlined /> {{ agentTokenCount.output_tokens }} </span>
                </a-tag>
              </div>
              <!-- å³æ æ»šåŠ¨åˆ°åº•éƒ¨æŒ‰é’® -->
              <div class="column-scroll-to-bottom" @click="scrollToBottomRight" v-if="isRightColumnVisible">
                <Down />
              </div>
            </div>
          </div>
        </template>
      </div>
    </div>

    <!-- Token consumption display - é twins æ¨¡å¼ -->
    <div v-if="!isTwins && tokenCount && tokenCount.total > 0" class="token-consumption">
      <a-tag>
        <span v-if="chatStore.chat.model_name">Model: {{ chatStore.chat.model_name }}</span>
        <span>Tokens: {{ tokenCount.total }}</span>
        <span> <ArrowUpOutlined /> {{ tokenCount.input_tokens }} </span>
        <span> <ArrowDownOutlined /> {{ tokenCount.output_tokens }} </span>
      </a-tag>
    </div>
  </div>
</template>

<script setup>
import Message from "../message/index.vue";
import { CopyOutlined, ArrowUpOutlined, ArrowDownOutlined } from "@ant-design/icons-vue";
import Down from "@/assets/svg/down.svg";
import { message as messageUtil } from "ant-design-vue";
import { useChatStore } from "@/store/modules/chat";
import { useI18n } from "vue-i18n";
import { onMounted, onBeforeUnmount, computed, ref, nextTick, watch } from "vue";
import { formatTimeWithHMS } from "@/utils/time";
import ChatReference from "./ChatReference.vue";
import { storeToRefs } from "pinia";
import emitter from "@/utils/emitter";
const { t } = useI18n();
const chatStore = useChatStore();
const { chat } = storeToRefs(chatStore);

const props = defineProps({
  messages: {
    type: Array,
    default: () => [],
  },
  twinsChatMessages: {
    type: Array,
    default: () => [],
  },
  mode: {
    type: String,
    default: "task",
  },
});

//åˆ¤æ–­å½“å‰æ˜¯ä¸æ˜¯ twins æ¨¡å¼
const isTwins = computed(() => {
  try {
    // ä¼˜å…ˆæ ¹æ® twinsChatMessages åˆ¤æ–­ï¼Œå› ä¸º twins_id å¯èƒ½æ›´æ–°ä¸åŠæ—¶
    return (props.twinsChatMessages && props.twinsChatMessages.length > 0) || (chat.value?.twins_id !== null && chat.value?.twins_id !== "" && chat.value?.twins_id);
  } catch (error) {
    console.warn("Error in isTwins computed:", error);
    return false;
  }
});

const chatMessagesRef = ref(null);
const chatColumnRef = ref(null);
const agentColumnRef = ref(null);

// è‡ªåŠ¨æ»šåŠ¨çŠ¶æ€ç®¡ç†
const leftAutoScrollEnabled = ref(true);
const rightAutoScrollEnabled = ref(true);

// æš´éœ²åˆ°windowå¯¹è±¡ä»¥ä¾¿storeè®¿é—®
if (typeof window !== "undefined") {
  window.twinsAutoScrollState = {
    isLeftEnabled: () => leftAutoScrollEnabled.value,
    isRightEnabled: () => rightAutoScrollEnabled.value,
    setLeftScrolling: (value) => {
      isAutoScrollingLeft.value = value;
    },
    setRightScrolling: (value) => {
      isAutoScrollingRight.value = value;
    },
  };
}

// è®°å½•ä¸Šä¸€æ¬¡æ»šåŠ¨ä½ç½®ï¼Œç”¨äºæ£€æµ‹æ»šåŠ¨æ–¹å‘
let lastLeftScrollTop = 0;
let lastRightScrollTop = 0;

// è‡ªåŠ¨æ»šåŠ¨æ ‡è®°ï¼Œé¿å…æŠŠè‡ªåŠ¨æ»šåŠ¨è¯¯åˆ¤ä¸ºç”¨æˆ·æ»šåŠ¨
const isAutoScrollingLeft = ref(false);
const isAutoScrollingRight = ref(false);

// æ ç›®æ˜¾ç¤ºå¼€å…³çŠ¶æ€
const isLeftColumnVisible = ref(true); // AI LLM æ ç›®å¼€å…³
const isRightColumnVisible = ref(true); // AI Agent æ ç›®å¼€å…³

// å­˜å‚¨äº‹ä»¶ç›‘å¬å™¨çš„å¼•ç”¨ï¼Œç”¨äºæ¸…ç†
const scrollListeners = {
  left: null,
  right: null,
};

// å¼€å…³åˆ‡æ¢å‡½æ•°ï¼Œç¡®ä¿è‡³å°‘æœ‰ä¸€ä¸ªæ ç›®å¯è§
const toggleLeftColumn = (value) => {
  if (value) {
    // å¼€å¯å·¦æ 
    isLeftColumnVisible.value = true;
  } else {
    // å…³é—­å·¦æ ï¼Œè‡ªåŠ¨å¼€å¯å³æ 
    isLeftColumnVisible.value = false;
    isRightColumnVisible.value = true;
  }
};

// å…³é—­å…¶ä»–çª—å£çš„å‡½æ•°
const closeOtherWindows = () => {
  emitter.emit("preview-close", false);
  emitter.emit("terminal-visible", false);
  emitter.emit("fullPreviewVisable-close");
};

const toggleRightColumn = (value) => {
  if (value) {
    // å¼€å¯å³æ 
    isRightColumnVisible.value = true;
  } else {
    // å…³é—­å³æ ï¼Œè‡ªåŠ¨å¼€å¯å·¦æ 
    isRightColumnVisible.value = false;
    isLeftColumnVisible.value = true;
    // åœ¨twinsæ¨¡å¼ä¸‹å…³é—­Agentæ æ—¶ï¼Œå…³é—­é¢„è§ˆå¼¹çª—
    if (isTwins.value) {
      closeOtherWindows();
    }
  }
};

const isTimedOut = ref(false);
// è‡ªåŠ¨åˆ¤æ–­æ˜¯å¦åŠ è½½ä¸­
const isLoading = computed(() => {
  return props.mode === "task" && props.messages.length === 0 && !isTimedOut.value;
});

// Agent æ¨¡å¼çš„ tokenCount (åŸæœ‰é€»è¾‘)
const agentTokenCount = computed(() => {
  const { input_tokens = 0, output_tokens = 0 } = chatStore.chat || {};
  return {
    input_tokens,
    output_tokens,
    total: input_tokens + output_tokens,
  };
});

// Chat æ¨¡å¼çš„ tokenCount (ä» twinsConversationList è·å–)
const chatTokenCount = computed(() => {
  if (!isTwins.value || !chatStore.chat.twins_id) {
    return { input_tokens: 0, output_tokens: 0, total: 0 };
  }

  const twinsInfo = chatStore.twinsConversationList[chatStore.chat.twins_id];
  return twinsInfo
    ? {
        input_tokens: twinsInfo.input_tokens,
        output_tokens: twinsInfo.output_tokens,
        total: twinsInfo.total,
      }
    : { input_tokens: 0, output_tokens: 0, total: 0 };
});

// é twins æ¨¡å¼ä½¿ç”¨åŸæœ‰é€»è¾‘
const tokenCount = computed(() => agentTokenCount.value);

const isPlanOrUpdateStatus = (message) => {
  return ["plan", "update_status", "stop", "error", "coding", "progress"].includes(message.meta?.action_type);
};

const copyMessage = (message) => {
  navigator.clipboard
    .writeText(message.content)
    .then(() => {
      messageUtil.success(t("lemon.message.copySuccess"));
    })
    .catch((err) => {
      console.error("Failed to copy:", err);
      messageUtil.error(t("lemon.message.copyError"));
    });
};

// æ»šåŠ¨åˆ°åº•éƒ¨å‡½æ•°
const scrollToBottomLeft = () => {
  const leftColumn = chatColumnRef.value;
  if (!leftColumn) return;

  const columnContent = leftColumn.querySelector('.column-content');
  if (!columnContent) return;

  columnContent.scrollTop = columnContent.scrollHeight - columnContent.clientHeight;

  // æ‰‹åŠ¨æ»šåŠ¨åˆ°åº•éƒ¨åå¯ç”¨è‡ªåŠ¨æ»šåŠ¨
  leftAutoScrollEnabled.value = true;
  console.log("Left auto scroll enabled - manual scroll to bottom");
};

const scrollToBottomRight = () => {
  const rightColumn = agentColumnRef.value;
  if (!rightColumn) return;

  const columnContent = rightColumn.querySelector('.column-content');
  if (!columnContent) return;

  columnContent.scrollTop = columnContent.scrollHeight - columnContent.clientHeight;

  // æ‰‹åŠ¨æ»šåŠ¨åˆ°åº•éƒ¨åå¯ç”¨è‡ªåŠ¨æ»šåŠ¨
  rightAutoScrollEnabled.value = true;
  console.log("Right auto scroll enabled - manual scroll to bottom");
};

let debounceTimer;
const handleScroll = () => {
  const container = chatMessagesRef.value;
  if (!container) return;

  clearTimeout(debounceTimer);
  debounceTimer = setTimeout(() => {
    const isNearBottom = container.scrollHeight - container.scrollTop - container.clientHeight <= 5;
    chatStore.isScrolledToBottom = isNearBottom;
  }, 100);
};

// æ¸…ç†æ»šåŠ¨ç›‘å¬å™¨
const cleanupScrollListeners = () => {
  if (scrollListeners.left) {
    const leftColumn = document.querySelector('.twins-column.chat-column .column-content');
    if (leftColumn) {
      leftColumn.removeEventListener("scroll", scrollListeners.left);
    }
    scrollListeners.left = null;
  }
  if (scrollListeners.right) {
    const rightColumn = document.querySelector('.twins-column.agent-column .column-content');
    if (rightColumn) {
      rightColumn.removeEventListener("scroll", scrollListeners.right);
    }
    scrollListeners.right = null;
  }
};

// è®¾ç½® Twins æ¨¡å¼çš„æ»šåŠ¨ç›‘å¬
const setupTwinsScrollListeners = () => {
    if (!isTwins.value) return;
    
    // å…ˆæ¸…ç†æ—§çš„ç›‘å¬å™¨
    cleanupScrollListeners();
    
    // ç­‰å¾… DOM æ›´æ–°åå†æŸ¥æ‰¾å…ƒç´ 
    nextTick(() => {
      try {
        const leftColumn = document.querySelector('.twins-column.chat-column .column-content');
        const rightColumn = document.querySelector('.twins-column.agent-column .column-content');

        console.log('setupTwinsScrollListeners', {
          leftColumn,
          rightColumn,
          isLeftVisible: isLeftColumnVisible.value,
          isRightVisible: isRightColumnVisible.value
        });


        if (leftColumn && isLeftColumnVisible.value) {
          const handleLeftScroll = () => {
            try {
              const currentScrollTop = leftColumn.scrollTop;
              const distanceFromBottom = leftColumn.scrollHeight - leftColumn.scrollTop - leftColumn.clientHeight;

              // æ£€æµ‹æ»šåŠ¨æ–¹å‘ - å¦‚æœå¾€ä¸Šæ»šåŠ¨å°±åœæ­¢è‡ªåŠ¨æ»šåŠ¨
              if (currentScrollTop < lastLeftScrollTop && !isAutoScrollingLeft.value) {
                console.log('ğŸ”º ç”¨æˆ·å¾€ä¸Šæ»šåŠ¨äº† (Left) - ç¦ç”¨è‡ªåŠ¨æ»šåŠ¨');
                // ç”¨æˆ·å¾€ä¸Šæ»šåŠ¨ï¼Œç«‹å³ç¦ç”¨è‡ªåŠ¨æ»šåŠ¨
                if (leftAutoScrollEnabled.value) {
                  leftAutoScrollEnabled.value = false;
                  console.log('Left auto scroll disabled - user scrolled up');
                }
              }

              // æ›´æ–°ä¸Šä¸€æ¬¡æ»šåŠ¨ä½ç½®
              lastLeftScrollTop = currentScrollTop;

              // æ£€æŸ¥æ˜¯å¦åœ¨åº•éƒ¨ï¼Œå¦‚æœåœ¨åº•éƒ¨åˆ™é‡æ–°å¯ç”¨è‡ªåŠ¨æ»šåŠ¨
              if (distanceFromBottom <= 10 && !leftAutoScrollEnabled.value) {
                leftAutoScrollEnabled.value = true;
                console.log("Left auto scroll enabled - user at bottom");
              }
            } catch (error) {
              console.warn("Left scroll handler error:", error);
            }
          };

        scrollListeners.left = handleLeftScroll;
        leftColumn.addEventListener("scroll", handleLeftScroll, { passive: true });
        // åˆå§‹æ£€æŸ¥
        setTimeout(handleLeftScroll, 100);
      }

      if (rightColumn && isRightColumnVisible.value) {
        const handleRightScroll = () => {
          try {
            const currentScrollTop = rightColumn.scrollTop;
            const distanceFromBottom = rightColumn.scrollHeight - rightColumn.scrollTop - rightColumn.clientHeight;

            // æ£€æµ‹æ»šåŠ¨æ–¹å‘ - å¦‚æœå¾€ä¸Šæ»šåŠ¨å°±åœæ­¢è‡ªåŠ¨æ»šåŠ¨
            if (currentScrollTop < lastRightScrollTop && !isAutoScrollingRight.value) {
              console.log("ğŸ”º ç”¨æˆ·å¾€ä¸Šæ»šåŠ¨äº† (Right) - ç¦ç”¨è‡ªåŠ¨æ»šåŠ¨");
              // ç”¨æˆ·å¾€ä¸Šæ»šåŠ¨ï¼Œç«‹å³ç¦ç”¨è‡ªåŠ¨æ»šåŠ¨
              if (rightAutoScrollEnabled.value) {
                rightAutoScrollEnabled.value = false;
                console.log("Right auto scroll disabled - user scrolled up");
              }
            }

            // æ›´æ–°ä¸Šä¸€æ¬¡æ»šåŠ¨ä½ç½®
            lastRightScrollTop = currentScrollTop;

            // æ£€æŸ¥æ˜¯å¦åœ¨åº•éƒ¨ï¼Œå¦‚æœåœ¨åº•éƒ¨åˆ™é‡æ–°å¯ç”¨è‡ªåŠ¨æ»šåŠ¨
            if (distanceFromBottom <= 10 && !rightAutoScrollEnabled.value) {
              rightAutoScrollEnabled.value = true;
              console.log("Right auto scroll enabled - user at bottom");
            }
          } catch (error) {
            console.warn("Right scroll handler error:", error);
          }
        };

        scrollListeners.right = handleRightScroll;
        rightColumn.addEventListener("scroll", handleRightScroll, { passive: true });
        // åˆå§‹æ£€æŸ¥
        setTimeout(handleRightScroll, 100);
      }
    } catch (error) {
      console.warn("setupTwinsScrollListeners error:", error);
    }
  });
};

onMounted(() => {
  setTimeout(() => {
    isTimedOut.value = true;
  }, 5000); // 5ç§’

  const container = chatMessagesRef.value;
  if (container) {
    container.addEventListener("scroll", handleScroll);
  }

  // å»¶è¿Ÿè®¾ç½®ç›‘å¬å™¨ï¼Œç¡®ä¿ DOM å·²æ¸²æŸ“
  setTimeout(setupTwinsScrollListeners, 500);

  // ç›‘å¬æ ç›®æ˜¾ç¤ºçŠ¶æ€å˜åŒ–ï¼Œé‡æ–°è®¾ç½®æ»šåŠ¨ç›‘å¬
  watch([isLeftColumnVisible, isRightColumnVisible], () => {
    if (isTwins.value) {
      console.log("Column visibility changed, re-setting scroll listeners");
      setTimeout(setupTwinsScrollListeners, 100);
    }
  });

  // ç›‘å¬ä¼šè¯å˜åŒ–ï¼Œé‡ç½®æ ç›®æ˜¾ç¤ºçŠ¶æ€
  watch(
    () => chat.value?.conversation_id,
    (newConversationId, oldConversationId) => {
      if (newConversationId !== oldConversationId && newConversationId) {
        console.log("Conversation changed, resetting column visibility");
        // é‡ç½®ä¸ºé»˜è®¤çŠ¶æ€
        isLeftColumnVisible.value = true;
        isRightColumnVisible.value = true;
      }
    }
  );
});

onBeforeUnmount(() => {
  const container = chatMessagesRef.value;
  if (container) {
    container.removeEventListener("scroll", handleScroll);
  }

  // æ¸…ç† twins æ¨¡å¼çš„æ»šåŠ¨ç›‘å¬å™¨
  cleanupScrollListeners();
});
</script>

<style lang="scss" scoped>
.message-title {
  font-size: 16px;
  font-weight: 700;
  color: #111827;
  display: flex;

  img {
    width: 24px;
    height: 24px;
    margin-right: 8px;
  }
}

.chat-messages {
  flex: 1;
  height: 100%;
  display: flex;
  flex-direction: column;
}

/* é twins æ¨¡å¼ä¸‹ï¼Œmessage-list éœ€è¦æ»šåŠ¨ */
.chat-messages:not(:has(.twins-container)) {
  overflow-y: auto;
  scrollbar-width: none;
  -ms-overflow-style: none;
  padding-bottom: 20px;
}

.chat-messages:not(:has(.twins-container))::-webkit-scrollbar {
  display: none;
}

/* twins æ¨¡å¼ä¸‹ï¼Œoverflow ç”±å„ä¸ª column-content æ§åˆ¶ */
.chat-messages:has(.twins-container) {
  overflow: visible;
}

.message-list {
  display: flex;
  flex-direction: column;
  height: 100%;
  overflow: auto;
  scrollbar-width: none; /* Firefox */
  -ms-overflow-style: none; /* IE and Edge */
}

.message-list::-webkit-scrollbar {
  display: none; /* Chrome, Safari, Opera */
}
.message-piece {
  display: flex;
  flex-direction: column;
  width: 100%;

  > div {
    width: 100%;
  }
}

/* Twins åŒæ å¸ƒå±€æ ·å¼ */
.twins-container {
  display: flex;
  gap: 16px;
  width: 100%;
  height: 100%;
}

.twins-column-wrapper {
  position: relative;
  transition: all 0.3s ease;
  flex: 1;
  min-width: 0;
}

/* å½“ä¸¤ä¸ªæ ç›®éƒ½æ˜¾ç¤ºæ—¶ï¼Œå„å 50% */
.twins-container.both-visible .twins-column-wrapper {
  flex: 1;
}

/* å•æ æ¨¡å¼ï¼šå ç”¨å…¨éƒ¨ç©ºé—´ */
.twins-container.single-column .twins-column-wrapper {
  flex: 1;
  width: 100%;
}

/* åˆå¹¶æ ‡é¢˜æ æ ·å¼ */
.merged-header {
  display: flex !important;
  justify-content: space-between !important;
  align-items: center;
  background: #f8f9fa;
  padding: 12px 16px;
  border-bottom: 1px solid #f0f0f0;
  font-weight: 600;
  font-size: 14px;
  color: #666;
  z-index: 1;
}

.header-section {
  display: flex;
  align-items: center;
  gap: 8px;
}

.inactive-title {
  color: #999 !important;
  font-weight: 400 !important;
}

.description {
  font-weight: 400;
  color: #888;
  font-size: 12px;
  margin-left: 4px;
}

/* ç§»é™¤æ—§çš„æŠ˜å æ ·å¼ï¼Œå› ä¸ºä¸å†éœ€è¦ */

.twins-column {
  width: 100%;
  border: 1px solid #f0f0f0;
  border-radius: 8px;
  max-height: calc(100vh - 250px);
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.twins-column::-webkit-scrollbar {
  display: none; /* Chromeã€Safari å’Œ Opera */
}

.column-header {
  position: sticky;
  top: 0;
  background: #f8f9fa;
  padding: 12px 16px;
  border-bottom: 1px solid #f0f0f0;
  font-weight: 600;
  font-size: 14px;
  color: #666;
  z-index: 11;
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-shrink: 0;
}

.column-content {
  flex: 1;
  overflow-y: auto;
  /* éšè—æ»šåŠ¨æ¡ä½†ä¿æŒæ»šåŠ¨åŠŸèƒ½ */
  scrollbar-width: none; /* Firefox */
  -ms-overflow-style: none; /* IE å’Œ Edge */
}

.column-content::-webkit-scrollbar {
  display: none; /* Chromeã€Safari å’Œ Opera */
}

.twins-column .message-item {
  padding: 8px 16px;
  border-bottom: 1px solid #f5f5f5;
}

.twins-column .message-item:last-child {
  border-bottom: none;
}

.column-scroll-to-bottom {
  position: absolute;
  bottom: 80px; /* è°ƒæ•´ä½ç½®é¿å…é®æŒ¡ tokens */
  right: 16px;
  border: 1px solid #0000000f;
  background: #fff;
  border-radius: 50%;
  width: 36px;
  height: 36px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  box-shadow:
    0px 5px 16px 0px #00000014,
    0px 0px 1.25px 0px #00000014;
  z-index: 10;
}

.message-item {
  display: flex;
  flex-direction: column !important;
  gap: 2px;

  &.assistant {
    align-self: flex-start;
    width: 100%;
  }

  &.user {
    width: 100%;
    align-self: flex-end;
    align-items: flex-end;

    .message-content {
      background: #fff;
      border: 1px solid #0000000f;
      border-radius: 12px;
      color: #34322d;
      font-size: 16px;
      width: fit-content;
      max-width: 100%;
    }
  }

  &:hover {
    .message-options {
      .display-none {
        display: flex;
      }
    }
  }
}

.message-options {
  display: flex;
  flex-direction: row;
  color: #858481;
  font-size: 12px;
  align-items: center;
  gap: 2px;
  padding: 0px 12px;
  justify-content: space-between;
  height: 24px;

  .display-none {
    display: none;
  }

  .copy-button {
    right: 8px;
    bottom: 8px;
    width: 24px;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    color: #999;
    transition: color 0.2s;

    &:hover {
      color: #666;
    }

    .icon-copy {
      font-size: 16px;
    }
  }
}

.token-consumption {
  display: flex;
  justify-content: flex-end;
  gap: 8px;
  font-size: 12px;
  color: #858481;
  background-color: #f9f9f9;
  margin: 8px 0;
}

:deep(.token-consumption .ant-tag) {
  display: flex;
  gap: 8px;
  padding: 4px 8px;
  font-family: "Courier New", Courier, monospace;
}

.skeleton-message {
  margin-bottom: 16px;
}

.reference {
  border: 1px solid #0000000f;
  border-radius: 8px;
  padding: 10px;
  display: inline-block;
  margin-bottom: 8px;
  max-width: 80%;
}
</style>



================================================
FILE: frontend/src/view/lemon/components/ChatPanel.vue
================================================
[Binary file]


================================================
FILE: frontend/src/view/lemon/components/ChatReference.vue
================================================
<template>
  <div v-if="meta && meta.screenshot" class="chat-reference">
    <div class="reference-header">
      <div class="reference-title">
        <i class="fas fa-file-image"></i>
        <span class="filename">{{ extractConversationPath(meta.filepath) }}</span>
      </div>
    </div>

    <div v-if="meta.screenshot" class="reference-content">
      <div class="reference-image-container">
        <img :src="meta.screenshot" :alt="meta.filepath" class="reference-image" />
      </div>
    </div>
  </div>
</template>

<script setup>
import { defineProps } from "vue";

const extractConversationPath = (filePath) => {
  const startIndex = filePath.indexOf("Conversation");
  if (startIndex === -1) {
    return null;
  }
  return filePath.slice(startIndex);
};
defineProps({
  meta: {
    type: Object,
    default: () => ({}),
  },
});
</script>

<style lang="scss" scoped>
.chat-reference {
  background: white;
  border-radius: 8px;
  box-shadow: 0 1px 4px rgba(0, 0, 0, 0.08);
  margin-bottom: 8px;
  overflow: hidden;
  border: 1px solid #e5e7eb;
  max-width: 70%;
}

.reference-header {
  padding: 8px 12px;
  border-bottom: 1px solid #f0f0f0;
  background: #fafafa;
}

.reference-title {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 12px;
  font-weight: 500;
  color: #333;

  i {
    color: #1890ff;
    font-size: 11px;
  }

  .filename {
    word-break: break-all;
    line-height: 1.4;
  }
}

.reference-content {
  padding: 8px;
  display: flex;
  justify-content: center;
  align-items: center;
}

.reference-image-container {
  display: inline-block;
  max-width: 100%;
  border-radius: 4px;
  overflow: hidden;
  border: 1px solid #e5e7eb;
}

.reference-image {
  display: block;
  max-width: 100%;
  width: auto;
  height: auto;
  object-fit: contain;
  background: #f5f5f5;
}

@media (max-width: 768px) {
  .chat-reference {
    max-width: 100%;
  }

  .reference-header {
    padding: 6px 10px;
  }

  .reference-content {
    padding: 6px;
  }

  .reference-image {
    max-height: 100px;
  }
}
</style>



================================================
FILE: frontend/src/view/lemon/components/ChatTree.vue
================================================
<template>
  <div v-if="messages.length > 0" :key="currentMessage.id" class="message-item">
    <div :class="currentMessage.role">
      <template v-if="currentMessage.role === 'user'">
        <div class="message-user">
          <template v-if="!isEditing">
            <p class="user-input">{{ currentMessage.content }}</p>
          </template>
          <template v-else>
            <a-textarea v-model:value="editedContent" :autosize="true" class="edit-input" />
          </template>
        </div>
      </template>

      <template v-else-if="currentMessage.role === 'assistant'">
        <div class="message-assistant">
          <Markdown
            :content="currentMessage.content"
            :class="{
              'result-streaming': currentMessage.id === chatInfo.cursorKey,
              'result-streaming-wait': currentMessage.id === chatInfo.cursorKey && currentMessage.content === '',
            }"
          />
        </div>
      </template>

      <div class="change-btns" :class="buttonGroupClass">
        <template v-if="!isEditing">
          <LeftRight :messages="messages" v-model:currentMessageIndex="currentMessageIndex" @changeChat="handleChangeChat" />
          <div class="message-options" v-if="currentMessage.id !== chatInfo.cursorKey">
            <circleSvg class="icon" v-if="currentMessage.role === 'assistant'" @click="handleRetryAnswer(currentMessage)" />
            <editSvg class="icon" v-if="currentMessage.role === 'user'" @click="startEdit" />
            <copySvg class="icon" @click="copyText(currentMessage.content)" />
          </div>
        </template>
        <template v-else>
          <div class="edit-actions">
            <button @click="cancelEdit" class="cancel-button">Cancel</button>
            <button type="primary" @click="submitEdit" class="submit-button">Send</button>
          </div>
        </template>
      </div>
    </div>

    <ChatTree v-model:messages="currentMessage.children" :parentPid="currentMessage.id" :parentMessageIndex="currentMessageIndex" :parentContent="currentMessage.content" />
  </div>
</template>
<script setup>
import { ref, computed, nextTick } from "vue";
import { v4 as uuid } from "uuid";
import Markdown from "@/components/markdown/index.vue";
import LeftRight from "@/components/menu/LeftRight.vue";
import editSvg from "@/assets/svg/edit.svg";
import copySvg from "@/assets/filePreview/copy.svg";
import circleSvg from "@/assets/svg/circle.svg";
import chatService from "@/services/chat";
import seeAgent from "@/services/see-agent";
import { message as ano } from "ant-design-vue";
import { storeToRefs } from "pinia";
import { useChatStore } from "@/store/modules/chat";

const chatStore = useChatStore();
const { chatInfo } = storeToRefs(chatStore);

const props = defineProps({
  messages: { type: Array, default: () => [] },
  parentMessageIndex: { type: Number, default: 0 },
  parentPid: { type: [String, Number], default: "" },
  parentContent: { type: String, default: "" },
});
const emit = defineEmits(["update:currentMessageIndex", "update:messages"]);

const currentMessageIndex = ref(0);
const editedContent = ref("");
const isEditing = ref(false);

const currentMessage = computed(() => {
  const activeIndex = props.messages.findIndex((msg) => msg.is_active);
  const index = activeIndex !== -1 ? activeIndex : 0;
  currentMessageIndex.value = index;
  chatInfo.value.pid = props.messages[index].id;
  return props.messages[index];
});

const buttonGroupClass = computed(() => (currentMessage.value.role === "user" ? "user-options" : "assistant-options"));

function copyText(text) {
  navigator.clipboard.writeText(text);
  ano.success("Copy success");
}

function startEdit() {
  editedContent.value = currentMessage.value.content;
  isEditing.value = true;
}

function cancelEdit() {
  isEditing.value = false;
}

async function submitEdit() {
  isEditing.value = false;
  const pid = currentMessage.value.pid === -1 ? -1 : props.parentPid;
  chatInfo.value.pid = pid;
  await seeAgent.sendMessage(editedContent.value, chatStore.chat.conversation_id, [], []);
  deactivateAllMessages();
  currentMessageIndex.value = props.messages.length - 1;
}

function handleChangeChat(index) {
  activateMessageAt(index);
  chatService.changeChat(chatStore.chat.conversation_id, props.messages[index].pid, props.messages[index].id);
}

function handleRetryAnswer(message) {
  deactivateAllMessages();
  const assistantKey = uuid();
  chatInfo.value.cursorKey = assistantKey;

  chatInfo.value.msgList.push({
    id: assistantKey,
    role: "assistant",
    content: "",
    status: "success",
    meta: JSON.stringify({ pid: message.pid, is_active: true }),
  });

  nextTick(async () => {
    currentMessageIndex.value = props.messages.length - 1;
    await seeAgent.reAnswer(message.pid, message.content, chatStore.chat.conversation_id, assistantKey);
  });
}

function deactivateAllMessages() {
  chatInfo.value.msgList.forEach((msg) => {
    msg.is_active = false;
    msg.meta = JSON.stringify({ ...JSON.parse(msg.meta || "{}"), is_active: false });
  });
}

function activateMessageAt(index) {
  deactivateAllMessages();
  const id = props.messages[index].id;
  chatInfo.value.msgList.forEach((msg) => {
    if (msg.id === id) {
      msg.is_active = true;
      msg.meta = JSON.stringify({ ...JSON.parse(msg.meta || "{}"), is_active: true });
    }
  });
  chatInfo.value.pid = id;
}
</script>
<style lang="scss" scoped>
.message-item {
  display: flex;
  flex-direction: column;

  .user,
  .assistant {
    width: 100%;
    margin-bottom: 20px;
  }

  .user {
    text-align: end;

    .message-user {
      display: flex;
      justify-content: flex-end;
      color: #34322d;
      font-size: 16px;

      .user-input {
        background: #fff;
        padding: 10px 20px;
        max-width: 500px;
        border: 1px solid #0000000f;
        border-radius: 12px;
        text-align: start;
      }
    }

    &:hover {
      .message-options {
        display: flex;
      }
    }
  }

  .assistant {
    .message-assistant {
      font-size: 16px;
      color: #34322d;
    }

    &:hover {
      .message-options {
        display: flex;
      }
    }
  }

  &:hover {
    .message-options .display-none {
      display: flex;
      gap: 10px;
      align-items: center;
    }
  }
}

.change-btns {
  display: flex;
  width: 100%;
  padding: 8px 0;
  align-items: center;
  min-height: 46px;

  .message-options {
    display: none;
    gap: 10px;
  }
}

.user-options {
  justify-content: flex-end;
  gap: 10px;
}

.icon {
  width: 24px;
  height: 24px;
  padding: 4px;

  &:hover {
    cursor: pointer;
    background-color: #eeeeec;
    border-radius: 6px;
  }
}

.result-streaming-wait:after,
.result-streaming > :not(ol):not(ul):not(pre):last-child:after,
.result-streaming > ol:last-child li:last-child:after,
.result-streaming > pre:last-child code:after,
.result-streaming > ul:last-child li:last-child:after {
  content: "|";
  vertical-align: baseline;
  margin-left: 0.25rem;
  font-weight: bold;
  color: #000;
  animation: smoothBlink 0.8s ease-in-out infinite;
  text-shadow: 0 0 4px rgba(255, 255, 255, 0.5);
}

@keyframes smoothBlink {
  0%,
  100% {
    opacity: 1;
  }

  50% {
    opacity: 0.3;
  }
}

@media (max-width: 768px) {
  .result-streaming-wait:after,
  .result-streaming > :not(ol):not(ul):not(pre):last-child:after,
  .result-streaming > ol:last-child li:last-child:after,
  .result-streaming > pre:last-child code:after,
  .result-streaming > ul:last-child li:last-child:after {
    font-size: 0.9em;
  }
}

.user-input-edit {
  background: #fff;
  border: 1px solid #0000000f;
  border-radius: 12px;
  color: #34322d;
  font-size: 16px;
  padding: 12px;
  max-width: 100%;
}

.edit-actions {
  display: flex;
  gap: 10px;
  margin-top: 10px;
}

.cancel-button,
.submit-button {
  margin-right: 10px;
  background-color: #0000000f;
  border: 1px solid #0000000f;
  border-radius: 6px;
  padding: 4px 10px;
  color: #34322d;
  font-size: 16px;
  cursor: pointer;
  box-shadow: 0 0 10px 0 rgba(0, 0, 0, 0.1);
}

.edit-input {
  display: flex;
  min-width: 600px;
  max-width: 600px;
  width: auto;
  font-size: 16px;
}
</style>



================================================
FILE: frontend/src/view/lemon/components/ConfirmPrompt.vue
================================================
<template>
  <div class="confirm-prompt">
    <div class="confirm-content">
      <div class="confirm-icon">
        <span class="material-icon">ğŸ“‹</span>
      </div>
      <div class="confirm-message">{{ message }}</div>
      <div class="confirm-actions">
        <button class="action-button reject" @click="$emit('reject')">æ‹’ç»</button>
        <button class="action-button accept" @click="$emit('accept')">æ¥å—</button>
      </div>
    </div>
  </div>
</template>

<script setup>
defineProps({
  message: {
    type: String,
    default: ''
  }
})

defineEmits(['accept', 'reject'])
</script>

<style lang="scss" scoped>
.confirm-prompt {
  position: absolute;
  bottom: 20px;
  left: 0;
  right: 0;
  display: flex;
  justify-content: center;
  pointer-events: none;
}

.confirm-content {
  background: white;
  border-radius: 8px;
  padding: 16px;
  display: flex;
  align-items: center;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  max-width: 800px;
  width: 100%;
  margin: 0 20px;
  pointer-events: auto;
}

.confirm-icon {
  margin-right: 12px;
  color: #666;
}

.confirm-message {
  flex: 1;
  font-size: 14px;
  color: #333;
}

.confirm-actions {
  display: flex;
  gap: 8px;
}

.action-button {
  padding: 6px 16px;
  border-radius: 4px;
  font-size: 14px;
  border: none;
  cursor: pointer;

  &.reject {
    background: #f5f5f5;
    color: #333;

    &:hover {
      background: #e9e9e9;
    }
  }

  &.accept {
    background: #0066ff;
    color: white;

    &:hover {
      background: #0055dd;
    }
  }
}
</style>


================================================
FILE: frontend/src/view/lemon/components/ConversationList.vue
================================================
<template>
  <div class="conversation-list">
    <div v-for="conversation in conversations" :key="conversation.id" class="conversation-item"
      :class="{ active: activeId === conversation.id }" @click="$emit('select', conversation.id)">
      <div class="conversation-title">{{ conversation.title }}</div>
      <div class="conversation-preview">{{ conversation.preview }}</div>
      <div class="conversation-date">{{ conversation.date }}</div>
    </div>
  </div>
</template>

<script setup>
defineProps({
  conversations: {
    type: Array,
    default: () => []
  },
  activeId: {
    type: [Number, String],
    default: null
  }
})

defineEmits(['select'])
</script>

<style lang="scss" scoped>
.conversation-list {
  flex: 1;
  overflow-y: auto;
}

.conversation-item {
  padding: 12px 16px;
  cursor: pointer;
  border-bottom: 1px solid #f0f0f0;

  &:hover {
    background: #f5f5f5;
  }

  &.active {
    background: #e6f4ff;
  }
}

.conversation-title {
  font-size: 14px;
  font-weight: 500;
  margin-bottom: 4px;
}

.conversation-preview {
  font-size: 12px;
  color: #666;
  margin-bottom: 4px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.conversation-date {
  font-size: 12px;
  color: #999;
}
</style>


================================================
FILE: frontend/src/view/lemon/components/LoadingDots.vue
================================================
<template>
    <div class="loading-dots">
      <span class="dot">Â·</span>
      <span class="dot">Â·</span>
      <span class="dot">Â·</span>
    </div>
  </template>
  
  <script>
  export default {
    name: "LoadingDots",
  };
  </script>
  
  <style scoped>
  .loading-dots {
    font-size: 24px;
    color: #333;
    white-space: nowrap;
    display: flex;
    align-items: center;
    height: 36px;
  }
  
  .dot {
    display: inline-block;
    animation: dot-jump 1s infinite ease-in-out both;
  }
  .dot:nth-child(1){
    animation-delay: 0s;
  }
  
  .dot:nth-child(2) {
    animation-delay: 0.2s;
  }
  
  .dot:nth-child(3) {
    animation-delay: 0.4s;
  }
  
  @keyframes dot-jump {
    0%,
    80%,
    100% {
      transform: scale(1);
    }
    40% {
      transform: scale(1.5);
    }
  }
  </style>


================================================
FILE: frontend/src/view/lemon/components/ModelSelect.vue
================================================
<template>
  <!-- æ¡Œé¢ç«¯é€‰æ‹©å™¨ -->
  <a-select
    v-if="!isMobile"
    ref="selectRef"
    class="model-select"
    @change="changeModel"
    :value="selectedModel"
    :placeholder="$t('lemon.input.chooseModel')"
    style="max-width: 200px; width: 100%"
    :options="groupedOptions"
    optionLabelProp="label"
    :fieldNames="{ label: 'label', value: 'value' }"
    :dropdownMatchSelectWidth="false"
    :dropdownRender="dropdownRender"
    :open="dropdownOpen"
    @dropdownVisibleChange="onDropdownVisibleChange"
  >
    <template #option="{ label, logo_url, requires_membership, disabled, priceLabel, priceColor, requiresLogin, is_subscribe }">
      <div 
        style="display: flex; align-items: center; justify-content: space-between; width: 100%"
        :style="{ opacity: disabled ? 0.5 : 1 }"
      >
        <div style="display: flex; align-items: center">
          <img
            v-if="logo_url"
            :src="logo_url"
            alt="logo"
            style="max-width: 20px; height: 20px; margin-right: 8px"
          />
          <span>{{ label }}</span>
        </div>
        <div style="display: flex; align-items: center; gap: 6px;">
          <a-tag v-if="requiresLogin" size="small" class="model-tag-login">
            {{ $t('lemon.model.requiresLogin') }}
          </a-tag>
        </div>
      </div>
    </template>
  </a-select>

  <!-- ç§»åŠ¨ç«¯æŒ‰é’®è§¦å‘å™¨ -->
  <div v-else class="mobile-model-trigger" @click="openMobileModal">
    <div class="selected-model">
      <img
        v-if="currentModelInfo?.logo_url"
        :src="currentModelInfo.logo_url"
        alt="logo"
        class="model-logo"
      />
      <span class="model-name">{{ currentModelInfo?.model_name || 'Select Model' }}</span>
    </div>
    <DownOutlined class="dropdown-icon" />
  </div>

  <!-- ç§»åŠ¨ç«¯åº•éƒ¨å¼¹å‡ºé€‰æ‹©å™¨ -->
  <teleport to="body">
    <div v-if="showMobileModal" class="mobile-modal-overlay" @click="closeMobileModal">
      <div class="mobile-model-selector" @click.stop>
        <!-- å¤´éƒ¨ -->
        <div class="modal-header">
          <h3>{{ $t('lemon.input.chooseModel') }}</h3>
          <a-button type="text" @click="closeMobileModal" class="close-btn">
            <CloseOutlined />
          </a-button>
        </div>
        <div class="model-list">
          <div v-for="group in groupedOptions" :key="group.label" class="platform-group">
            <div class="platform-header">
              <span class="platform-name">{{ group.label }}</span>
            </div>
            <div 
              v-for="option in group.options" 
              :key="option.value"
              class="model-item"
              :class="{ 
                'selected': option.value === selectedModel,
                'disabled': option.disabled
              }"
              @click="handleMobileModelSelect(option)"
            >
              <div class="model-info">
                <img
                  v-if="option.logo_url"
                  :src="option.logo_url"
                  alt="logo"
                  class="model-logo"
                />
                <span class="model-name">{{ option.label || option.model_name || 'Unknown Model' }}</span>
              </div>
              <div class="model-tags">
                <a-tag v-if="option.requiresLogin" size="small" class="model-tag-login">
                  {{ $t('lemon.model.requiresLogin') }}
                </a-tag>
                <a-tag v-if="option.requires_membership" size="small" class="model-tag-pro">
                  Pro+
                </a-tag>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </teleport>
    <!-- å‡çº§å¼¹çª— -->
    <a-modal
    v-model:open="showUpgradeModal"
    :title="upgradeTitle"
    centered
    width="1200px"
    :footer="null"
    @cancel="closeModal"
  >
  <Pricing  isWindow="true"  showTitle="false" @close_window="closeModal" />
  </a-modal>

  <!-- ç™»å½•æç¤ºå¼¹çª— -->
  <a-modal
    v-model:open="showLoginPrompt"
    :title="$t('lemon.model.loginRequired')"
    centered
    width="400px"
    :footer="null"
    @cancel="closeLoginPrompt"
  >
    <div style="text-align: center; padding: 20px 0;">
      <p style="margin-bottom: 20px; font-size: 16px;">{{ $t('lemon.model.loginRequiredDescription') }}</p>
      <p style="margin-bottom: 20px; color: #666;">{{ $t('lemon.model.pleaseLoginFirst') }}</p>
      <a-button type="primary" @click="handleGoToLogin" style="margin-right: 12px;">
        {{ $t('lemon.model.goToLogin') }}
      </a-button>
      <a-button @click="closeLoginPrompt">
        {{ $t('lemon.common.cancel') }}
      </a-button>
    </div>
  </a-modal>
</template>

<script setup>
import { ref, computed, onMounted, onUnmounted, watchEffect, nextTick, h } from 'vue'
import { useChatStore } from '@/store/modules/chat'
import { storeToRefs } from 'pinia'
import { DownOutlined, CloseOutlined } from '@ant-design/icons-vue'

import { useUserStore } from '@/store/modules/user';
import modelService from '@/services/default-model-setting'
import Pricing from '@/view/pay/components/pricing.vue';
import i18n from '@/locals';

const userStore = useUserStore();
const { membership } = storeToRefs(userStore);

// Pinia store
const chatStore = useChatStore()
const { model_id } = storeToRefs(chatStore)

const modelList = ref([])
const selectedModelValue = ref(null)
const selectRef = ref(null)
const dropdownOpen = ref(false)

const showUpgradeModal = ref(false);
const upgradeTitle = ref("Upgrade")
const showLoginPrompt = ref(false)

// ç§»åŠ¨ç«¯ç›¸å…³çŠ¶æ€
const showMobileModal = ref(false)
const isMobile = ref(false)

// ç™»å½•çŠ¶æ€æ£€æŸ¥
const isLoggedIn = computed(() => {
  return !!localStorage.getItem('access_token')
})

// ç™»å½•æç¤ºå¼¹çª—
const showLoginModal = ref(false)

// ç§»åŠ¨ç«¯æ£€æµ‹
const checkMobile = () => {
  isMobile.value = window.innerWidth <= 768
}

// å½“å‰é€‰ä¸­æ¨¡å‹ä¿¡æ¯ (will be defined after selectedModel)
let currentModelInfo


//åˆ¤æ–­æ˜¯ä¸æ˜¯ä¼šå‘˜
const isMember = computed(() => {
  if(membership.value){
    return true
  }
  return false
})

const closeModal = () => {
  showUpgradeModal.value = false;
};

// å…³é—­ç™»å½•æç¤ºå¼¹çª—
const closeLoginPrompt = () => {
  showLoginPrompt.value = false;
};

// è·³è½¬åˆ°ç™»å½•é¡µé¢
const handleGoToLogin = () => {
  closeLoginPrompt();
  // è¿™é‡Œå¯ä»¥æ ¹æ®é¡¹ç›®çš„è·¯ç”±é…ç½®è·³è½¬åˆ°ç™»å½•é¡µé¢
  // ä¾‹å¦‚: router.push('/login') æˆ–è€…å…¶ä»–ç™»å½•é€»è¾‘
  console.log('è·³è½¬åˆ°ç™»å½•é¡µé¢');
};

// ç§»åŠ¨ç«¯æ¨¡å‹é€‰æ‹©å¤„ç†
const handleMobileModelSelect = (option) => {
  // å¦‚æœéœ€è¦ç™»å½•ä½†æœªç™»å½•ï¼Œæ˜¾ç¤ºç™»å½•æç¤º
  if (option.requiresLogin) {
    closeMobileModal()
    showLoginPrompt.value = true
    return
  }
  
  // å¦‚æœé€‰æ‹©çš„æ˜¯ Pro+ æ¨¡å‹ä¸”ç”¨æˆ·ä¸æ˜¯ä¼šå‘˜ï¼Œå¼¹å‡ºå‡çº§å¼¹çª—
  if (option.requires_membership && !isMember.value) {
    closeMobileModal()
    showUpgradeModal.value = true
    return
  }
  
  // é€‰æ‹©æ¨¡å‹
  changeModel(option.value)
  closeMobileModal()
}

// ç§»åŠ¨ç«¯å‡çº§æŒ‰é’®å¤„ç†
const handleMobileUpgrade = () => {
  closeMobileModal()
  showUpgradeModal.value = true
}

// æ‰“å¼€ç§»åŠ¨ç«¯æ¨¡æ€æ¡†
const openMobileModal = () => {
  showMobileModal.value = true
}

// å…³é—­ç§»åŠ¨ç«¯æ¨¡æ€æ¡†
const closeMobileModal = () => {
  // æ·»åŠ å…³é—­åŠ¨ç”»ç±»
  const modalSelector = document.querySelector('.mobile-model-selector')
  if (modalSelector) {
    modalSelector.classList.add('closing')
  }
  
  // å»¶è¿Ÿå…³é—­æ¨¡æ€æ¡†ä»¥å®ŒæˆåŠ¨ç”»
  setTimeout(() => {
    showMobileModal.value = false
  }, 250)
}

// å¤„ç†ä¸‹æ‹‰æ¡†å¯è§æ€§å˜åŒ–
const onDropdownVisibleChange = (visible) => {
  dropdownOpen.value = visible;
};

// åˆå§‹åŒ–æ¨¡å‹åˆ—è¡¨
const initModel = async () => {
  console.log('membership.value', membership.value) 
  // Step 1: è¯»å–æœ¬åœ°ç¼“å­˜
  const cachedData = localStorage.getItem('modelList')
  if (cachedData) {
    try {
      modelList.value = JSON.parse(cachedData)

      // å¦‚æœ model_id è¿˜æ²¡è®¾ç½®ï¼Œé»˜è®¤è®¾ç½®ä¸ºç¬¬ä¸€ä¸ªæ¨¡å‹çš„ ID
      if (modelList.value.length > 0 && !model_id.value) {
        const defaultId = modelList.value[0].id * 1
        model_id.value = defaultId
        selectedModelValue.value = defaultId
      }
    } catch (e) {
      console.error('Failed to parse cached modelList', e)
    }
  }

  // Step 2: è·å–æ¥å£æ•°æ®ï¼ˆç”¨äºåˆ·æ–°ï¼‰
  try {
    const res = await modelService.getModels()

    if (Array.isArray(res)) {
      modelList.value = res
      localStorage.setItem('modelList', JSON.stringify(res))

      if (res.length > 0 && !model_id.value) {
        const defaultId = res[0].id * 1
        model_id.value = defaultId
        selectedModelValue.value = defaultId
      }
    }
  } catch (e) {
    console.error('Failed to fetch models from API', e)
  }
}


// åˆ‡æ¢æ¨¡å‹
const changeModel = (modelId) => {
  const id = modelId * 1
  const selectedModelData = modelList.value.find(model => model.id === id)
  
  // å¦‚æœéœ€è¦ç™»å½•ä½†æœªç™»å½•ï¼Œæ˜¾ç¤ºç™»å½•æç¤º
  if (selectedModelData && selectedModelData.is_subscribe && !isLoggedIn.value) {
    showLoginPrompt.value = true
    return // ä¸åˆ‡æ¢æ¨¡å‹
  }
  
  // å¦‚æœé€‰æ‹©çš„æ˜¯ Pro+ æ¨¡å‹ä¸”ç”¨æˆ·ä¸æ˜¯ä¼šå‘˜ï¼Œå¼¹å‡ºå‡çº§å¼¹çª—
  if (selectedModelData && selectedModelData.requires_membership && !isMember.value) {
    showUpgradeModal.value = true
    return // ä¸åˆ‡æ¢æ¨¡å‹
  }
  
  selectedModelValue.value = id
  model_id.value = id
}

// å½“å‰é€‰ä¸­æ¨¡å‹
const selectedModel = computed(() => {
  // ç¡®ä¿ modelList å·²åˆå§‹åŒ–ä¸”ä¸ä¸ºç©º
  if (!modelList.value || modelList.value.length === 0) {
    return null
  }
  
  const currentModelId = selectedModelValue.value ?? model_id.value ?? modelList.value[0]?.id ?? null
  
  // å¦‚æœæœ‰é€‰ä¸­çš„æ¨¡å‹ï¼Œæ£€æŸ¥ç”¨æˆ·æ˜¯å¦æœ‰æƒé™ä½¿ç”¨
  if (currentModelId && modelList.value.length > 0) {
    const currentModel = modelList.value.find(model => model.id === currentModelId)
    
    // å¦‚æœå½“å‰æ¨¡å‹éœ€è¦ç™»å½•ä½†ç”¨æˆ·æœªç™»å½•ï¼Œåˆ™é€‰æ‹©ç¬¬ä¸€ä¸ªä¸éœ€è¦ç™»å½•çš„æ¨¡å‹
    if (currentModel && currentModel.is_subscribe && !isLoggedIn.value) {
      const availableModel = modelList.value.find(model => !model.is_subscribe)
      return availableModel ? availableModel.id : null
    }
    
    // å¦‚æœå½“å‰æ¨¡å‹éœ€è¦ä¼šå‘˜æƒé™ä½†ç”¨æˆ·ä¸æ˜¯ä¼šå‘˜ï¼Œåˆ™é€‰æ‹©ç¬¬ä¸€ä¸ªå¯ç”¨çš„æ¨¡å‹
    if (currentModel && currentModel.requires_membership && !isMember.value) {
      const availableModel = modelList.value.find(model => !model.requires_membership && (!model.is_subscribe || isLoggedIn.value))
      return availableModel ? availableModel.id : null
    }
  }
  
  return currentModelId
})

// å½“å‰é€‰ä¸­æ¨¡å‹ä¿¡æ¯
currentModelInfo = computed(() => {
  const currentId = selectedModel.value
  if (!currentId || !modelList.value || modelList.value.length === 0) {
    return null
  }
  return modelList.value.find(model => model.id === currentId)
})

// æ¨¡æ‹Ÿä»·æ ¼ç­‰çº§æ˜ å°„ - ç¡®ä¿4ä¸ªç­‰çº§éƒ½æœ‰åˆ†é…
const getPriceLevel = (price_level_description) => {
  const map = {
    cheap: { label: "Cheapest", color: "#52c41a" },
    normal: { label: "Cheap", color: "#1890ff" },
    expensive: { label: "Expensive", color: "#722ed1" },
    very_expensive: { label: "Very Expensive", color: "#ff4d4f" },
  };

  return map[price_level_description] || { label: "Unknown", color: "#d9d9d9" };
};

// åˆ†ç»„çš„ options åˆ—è¡¨
const groupedOptions = computed(() => {
  const modelsWithPrice = modelList.value.map(model => {
    const priceInfo = getPriceLevel(model.price_level_description)
    const requiresLogin = model.is_subscribe && !isLoggedIn.value
    return {
      label: model.model_name,
      requires_membership: model.requires_membership,
      value: model.id,
      logo_url: model.logo_url,
      disabled: requiresLogin, // éœ€è¦ç™»å½•ä½†æœªç™»å½•çš„æ¨¡å‹è®¾ä¸ºç¦ç”¨
      priceLevel: priceInfo.level,
      priceLabel: priceInfo.label,
      priceColor: priceInfo.color,
      platform_name: model.platform_name,
      platform_id: model.platform_id,
      is_subscribe: model.is_subscribe,
      requiresLogin: requiresLogin
    }
  })
  
  // æŒ‰å¹³å°åˆ†ç»„
  const groupedByPlatform = modelsWithPrice.reduce((groups, model) => {
    const platformName = model.platform_name || 'Other'
    if (!groups[platformName]) {
      groups[platformName] = []
    }
    groups[platformName].push(model)
    return groups
  }, {})
  
  // è½¬æ¢ä¸º Ant Design Select çš„åˆ†ç»„æ ¼å¼
  const result = Object.keys(groupedByPlatform).map(platformName => ({
    label: platformName,
    options: groupedByPlatform[platformName].sort((a, b) => a.priceLevel - b.priceLevel)
  }))
  
  console.log('groupedOptions:', result)
  return result
})

// æ‰å¹³çš„ options åˆ—è¡¨ï¼ˆç”¨äºç§»åŠ¨ç«¯å’Œå…¶ä»–éœ€è¦æ‰å¹³åˆ—è¡¨çš„åœ°æ–¹ï¼‰
const flatOptions = computed(() => {
  return groupedOptions.value.flatMap(group => group.options)
})

// å¤„ç†å‡çº§æŒ‰é’®ç‚¹å‡»
const handleUpgrade = () => {
  // å…³é—­ä¸‹æ‹‰æ¡†
  dropdownOpen.value = false;
  // æ˜¾ç¤ºå‡çº§å¼¹çª—
  showUpgradeModal.value = true;
}

// è‡ªå®šä¹‰ä¸‹æ‹‰æ¡†æ¸²æŸ“
const dropdownRender = ({ menuNode }) => {
  const headerElements = [
    h('span', {
      style: {
        fontSize: '14px',
        fontWeight: '500',
        color: '#333'
      }
    }, i18n.global.t('lemon.model.models'))
  ]
  
  
  return h('div', [
    // æ ‡é¢˜æ  - å§‹ç»ˆæ˜¾ç¤º
    h('div', {
      class: 'model-dropdown-header',
      style: {
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
        padding: '8px 12px',
        borderBottom: '1px solid #f0f0f0',
        backgroundColor: '#fafafa',
        marginBottom: '8px'
      }
    }, headerElements),
    // åŸæœ‰çš„é€‰é¡¹åˆ—è¡¨
    menuNode
  ])
}

onMounted(() => {
  initModel()
  checkMobile()
  // ç›‘å¬çª—å£å¤§å°å˜åŒ–
  window.addEventListener('resize', checkMobile)
})

// ç»„ä»¶é”€æ¯æ—¶æ¸…ç†äº‹ä»¶ç›‘å¬
onUnmounted(() => {
  window.removeEventListener('resize', checkMobile)
})

// ä½¿ç”¨ä¸€ä¸ªæ ‡å¿—æ¥é¿å…å¾ªç¯è§¦å‘
let isUpdatingFromWatchEffect = false

// ç›‘å¬ selectedModel å˜åŒ–ï¼Œè‡ªåŠ¨åŒæ­¥ model_id
watchEffect(() => {
  if (isUpdatingFromWatchEffect) return
  
  const selected = selectedModel.value
  // æ·»åŠ  null æ£€æŸ¥ï¼Œç¡®ä¿ selected ä¸ä¸º null ä¸”ä¸å½“å‰ model_id ä¸åŒ
  if (selected && selected !== model_id.value && modelList.value && modelList.value.length > 0) {
    // ä½¿ç”¨ nextTick ç¡®ä¿åœ¨ä¸‹ä¸€ä¸ªäº‹ä»¶å¾ªç¯ä¸­æ‰§è¡Œï¼Œé¿å…åœ¨è®¡ç®—å±æ€§è®¡ç®—è¿‡ç¨‹ä¸­ä¿®æ”¹å“åº”å¼æ•°æ®
    nextTick(() => {
      isUpdatingFromWatchEffect = true
      changeModel(selected)
      // åœ¨ä¸‹ä¸€æ¬¡äº‹ä»¶å¾ªç¯åé‡ç½®æ ‡å¿—
      nextTick(() => {
        isUpdatingFromWatchEffect = false
      })
    })
  }
})
</script>

<style scoped>
.model-select {
  width: 200px;
}

.model-tag-free {
  margin-left: 8px;
  font-size: 12px !important;
  padding: 0 6px !important;
  height: 18px !important;
  line-height: 1 !important;
  border-radius: 4px !important;
  background-color: #f0f0f0 !important;
  color: #333 !important;
  border: 1px solid #d9d9d9 !important;
  display: inline-flex !important;
  align-items: center !important;
  justify-content: center !important;
}

.model-tag-pro {
  margin-left: 8px;
  font-size: 12px !important;
  padding: 0 6px !important;
  height: 18px !important;
  line-height: 1 !important;
  border-radius: 4px !important;
  background-color: #1a1a19 !important;
  color: #fff !important;
  border: 1px solid #1a1a19 !important;
  display: inline-flex !important;
  align-items: center !important;
  justify-content: center !important;
}

.model-tag-login {
  margin-left: 8px;
  font-size: 12px !important;
  padding: 0 6px !important;
  height: 18px !important;
  line-height: 1 !important;
  border-radius: 4px !important;
  background-color: #ff7875 !important;
  color: #fff !important;
  border: 1px solid #ff7875 !important;
  display: inline-flex !important;
  align-items: center !important;
  justify-content: center !important;
}

.model-price-tag {
  font-size: 12px !important;
  padding: 0 6px !important;
  height: 18px !important;
  line-height: 1 !important;
  border-radius: 4px !important;
  display: inline-flex !important;
  align-items: center !important;
  justify-content: center !important;
  font-weight: 600 !important;
  border: unset !important;
  background-color: unset !important;
}

::v-deep(.ant-select-dropdown .ant-select-item-option-selected) {
  background-color: #e6f7ff !important;
}

::v-deep(.ant-select-dropdown .ant-select-item-option) {
  padding: 8px 12px !important;
}

::v-deep(.ant-select-dropdown .ant-select-item-group) {
  padding: 0 !important;
}

::v-deep(.ant-select-dropdown .ant-select-item-group-list) {
  margin: 0 !important;
}

::v-deep(.ant-select-dropdown .ant-select-item-group .ant-select-item-group-list .ant-select-item-option) {
  padding-left: 20px !important;
}

::v-deep(.ant-select-dropdown .ant-select-item-group .ant-select-item-group-list .ant-select-item-option:first-child) {
  margin-top: 4px !important;
}

::v-deep(.ant-select-dropdown .ant-select-item-group .ant-select-item-group-list .ant-select-item-option:last-child) {
  margin-bottom: 8px !important;
}

.model-dropdown-header {
  position: sticky;
  top: 0;
  z-index: 10;
}

/* ç§»åŠ¨ç«¯è§¦å‘å™¨æ ·å¼ */
.mobile-model-trigger {
  display: flex;
  align-items: center;
  justify-content: space-between;
  width: 90px;
  height: 24px;
  padding: 0 4px;
  background: #fff;
  border: 1px solid #d9d9d9;
  border-radius: 4px;
  cursor: pointer;
  font-size: 11px;
}

.mobile-model-trigger .selected-model {
  display: flex;
  align-items: center;
  gap: 4px;
  overflow: hidden;
  width: 100%;
}

.mobile-model-trigger .model-logo {
  width: 14px;
  height: 14px;
  border-radius: 2px;
}

.mobile-model-trigger .model-name {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: fit-content;
}

.mobile-model-trigger .dropdown-icon {
  font-size: 10px;
  color: #999;
}

/* ç§»åŠ¨ç«¯æ¨¡æ€æ¡†å†…å®¹æ ·å¼ */
.mobile-model-selector {
  background: #fff;
  border-radius: 12px 12px 0 0;
  padding: 0;
  max-height: 60vh;
  min-height: 300px;
  width: 100%;
  max-width: 100%;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  animation: slideUpIn 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
}

.mobile-model-selector.closing {
  animation: slideDownOut 0.25s cubic-bezier(0.4, 0, 0.2, 1);
}

.modal-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px 20px;
  border-bottom: 1px solid #f0f0f0;
  flex-shrink: 0;
}

.modal-header h3 {
  margin: 0;
  font-size: 16px;
  font-weight: 600;
}

.close-btn {
  padding: 4px !important;
  color: #999 !important;
}

.upgrade-section {
  padding: 16px 20px;
  border-bottom: 1px solid #f0f0f0;
  flex-shrink: 0;
}

.model-list {
  flex: 1;
  overflow-y: auto;
  min-height: 0;
  -webkit-overflow-scrolling: touch;
  padding-bottom: 20px;
  box-sizing: content-box;
}

.model-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px 20px;
  cursor: pointer;
  transition: background-color 0.2s;
}

.model-item:hover {
  background-color: #f5f5f5;
}

.model-item.selected {
  background-color: #e6f7ff;
}

.model-item.disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.model-item.disabled:hover {
  background-color: transparent;
}

.model-info {
  display: flex;
  align-items: center;
  gap: 12px;
  flex: 1;
}

.model-info .model-logo {
  width: 24px;
  height: 24px;
  border-radius: 4px;
}

.model-info .model-name {
  font-size: 14px;
  font-weight: 500;
  color: #333;
  line-height: 1.5;
}

.model-tags {
  display: flex;
  align-items: center;
  gap: 6px;
}

.platform-group {
  margin-bottom: 8px;
}

.platform-header {
  padding: 8px 20px;
  background-color: #f5f5f5;
  border-bottom: 1px solid #f0f0f0;
  position: sticky;
  top: 0;
  z-index: 10;
}

.platform-name {
  font-size: 13px;
  font-weight: 600;
  color: #666;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

/* ç§»åŠ¨ç«¯æ ·å¼ä¼˜åŒ– - ä¿ç•™åŸæœ‰æ¡Œé¢ç«¯æ ·å¼ */
@media screen and (max-width: 768px) {
  .model-select {
    width: 90px!important;
    height: 24px;
    font-size: 11px;
    
    div{
      height: 24px!important;
      max-height: 24px!important;
      width: 40px!important;
    }
  }
  
  /* ä¿®æ”¹ant-selectç›¸å…³æ ·å¼ */
  .model-select .ant-select-selection-item{
    font-size: 11px;
    padding-inline-end: 0px!important;
    line-height: 24px!important;
  }
  .model-select .ant-select-selector{
    padding: 0px 4px!important;
  }
  .model-select .ant-select-arrow{
    display: none!important;
  }
}

</style>

<style>
.ant-select-item-option-selected,
.ant-select-dropdown-menu-item-selected,
.ant-select-dropdown-menu-item-active {
  background-color: rgba(0, 0, 0, 0.0588235294) !important;
  color: #333 !important;
}

/* ç§»åŠ¨ç«¯è‡ªå®šä¹‰æ¨¡æ€æ¡†æ ·å¼ */
.mobile-modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.45);
  z-index: 10000;
  display: flex;
  align-items: flex-end;
  justify-content: center;
  animation: fadeIn 0.3s ease-out;
}

/* åº•éƒ¨å¼¹å‡ºåŠ¨ç”»å…³é”®å¸§ */
@keyframes slideUpIn {
  from {
    transform: translateY(100%);
  }
  to {
    transform: translateY(0);
  }
}

@keyframes slideDownOut {
  from {
    transform: translateY(0);
  }
  to {
    transform: translateY(100%);
  }
}


@keyframes fadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}
</style>



================================================
FILE: frontend/src/view/lemon/components/ModeSelector.vue
================================================
<template>
  <div class="mode-selector-wrapper">
    <!-- æ¡Œé¢ç«¯ä¸‹æ‹‰æ¡† -->
    <a-select
      v-if="!isMobile"
      :value="modelValue"
      class="mode-select-dropdown"
      :options="workModeOptions"
      @change="handleModeChange"
      :dropdownMatchSelectWidth="false"
      :bordered="false"
      :disabled="disabled"
    >
      <template #option="{ value, label }">
        <div class="mode-option">
          <!-- <span class="mode-circle">
            <span v-if="modelValue === value" class="mode-inner-circle" />
          </span> -->
          <div class="mode-texts">
            <div class="mode-label">{{ label }}</div>
          </div>
        </div>
      </template>
    </a-select>

    <!-- ç§»åŠ¨ç«¯è§¦å‘å™¨ -->
    <div v-else class="mobile-mode-trigger" :class="{ 'disabled': disabled }" @click="handleClick">
      <span class="mode-name">{{ workModeOptions.find((opt) => opt.value === modelValue)?.label || "Auto" }}</span>
      <DownOutlined class="dropdown-icon" />
    </div>

    <!-- ç§»åŠ¨ç«¯æ¨¡å¼é€‰æ‹©å¼¹çª— -->
    <teleport to="body">
      <div v-if="showModeModal" class="mode-modal-overlay" @click="closeModeModal">
        <div class="mode-modal-content" @click.stop>
          <div class="modal-header">
            <h3>Mode</h3>
            <a-button type="text" @click="closeModeModal" class="close-btn">
              <CloseOutlined />
            </a-button>
          </div>
          <div class="option-list">
            <div v-for="option in workModeOptions" :key="option.value" class="option-item" :class="{ selected: option.value === modelValue }" @click="handleMobileModeSelect(option.value)">
              <div class="option-info">
                <span class="option-circle">
                  <span v-if="modelValue === option.value" class="option-inner-circle" />
                </span>
                <div class="option-texts">
                  <div class="option-label">{{ option.label }}</div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </teleport>

    <!-- Twins Mode Info Modal -->
    <a-modal v-model:open="showTwinsInfoModal" title="Twins Chat Mode" centered width="500px" :footer="null" @cancel="closeTwinsInfoModal">
      <div style="padding: 20px 0;">
        <div style="text-align: center; margin-bottom: 20px;">
          <p style="font-weight: 500;">
            You need to create a new conversation task to use this feature
          </p>
        </div>
        <div style="display: flex; gap: 12px; justify-content: center;">
          <a-button @click="closeTwinsInfoModal">Cancel</a-button>
          <a-button type="primary" @click="confirmTwinsMode">Create New Task</a-button>
        </div>
      </div>
    </a-modal>
  </div>
</template>

<script setup>
import { ref, computed, watch, onMounted, onUnmounted } from 'vue';
import { useRoute, useRouter } from 'vue-router';
import { DownOutlined, CloseOutlined } from '@ant-design/icons-vue';
import { useChatStore } from '@/store/modules/chat';
import emitter from '@/utils/emitter';

const props = defineProps({
  modelValue: {
    type: String,
    default: 'twins'
  },
  disabled: {
    type: Boolean,
    default: false
  }
});

const emit = defineEmits(['update:modelValue', 'modeChange']);

const route = useRoute();
const router = useRouter();
const chatStore = useChatStore();

// å·¥ä½œæ¨¡å¼é€‰é¡¹
const workModeOptions = [
  { value: 'twins', label: 'Twins Chat' },
  { value: 'task', label: 'Evolving Agent' },
  { value: 'chat', label: 'AI Chat' },
  { value: 'auto', label: 'Adaptive' }
];

// ç§»åŠ¨ç«¯ç›¸å…³çŠ¶æ€
const isMobile = ref(window.innerWidth <= 768); // åˆå§‹åŒ–æ—¶ç«‹å³æ£€æµ‹
const showModeModal = ref(false);
const showTwinsInfoModal = ref(false);

// ç§»åŠ¨ç«¯æ£€æµ‹
const checkMobile = () => {
  const newIsMobile = window.innerWidth <= 768;
  if (isMobile.value !== newIsMobile) {
    isMobile.value = newIsMobile;
  }
};

// ç§»åŠ¨ç«¯å¼¹çª—æ§åˆ¶å‡½æ•°
const handleClick = () => {
  console.log('handleClick triggered, disabled:', props.disabled, 'showModeModal before:', showModeModal.value);
  if (props.disabled) {
    console.log('Click blocked because disabled');
    return;
  }
  openModeModal();
};

const openModeModal = () => {
  console.log('openModeModal called');
  showModeModal.value = true;
  console.log('showModeModal after:', showModeModal.value);
};

const closeModeModal = () => {
  const modalSelector = document.querySelector(".mode-modal-content");
  if (modalSelector) {
    modalSelector.classList.add("closing");
  }
  setTimeout(() => {
    showModeModal.value = false;
  }, 250);
};

// twinsæ¨¡å¼ç›¸å…³æ–¹æ³•
const closeTwinsInfoModal = () => {
  showTwinsInfoModal.value = false;
  // åˆ‡å›ä¹‹å‰é€‰æ‹©çš„æ¨¡å¼
  const previousMode = localStorage.getItem("workMode");
  if (previousMode) {
    emit('update:modelValue', previousMode);
  }
};

const confirmTwinsMode = () => {
  emit('update:modelValue', 'twins');
  localStorage.setItem("workMode", 'twins');
  showTwinsInfoModal.value = false;

  closeOtherWindows();
  chatStore.conversationId = null;
  chatStore.clearMessages();
  router.push(`/lemon/${route.params.agentId}`);
};

const closeOtherWindows = () => {
  emitter.emit('preview-close', false);
  emitter.emit('terminal-visible', false);
  emitter.emit('fullPreviewVisable-close');
};

// å¤„ç†æ¨¡å¼åˆ‡æ¢
const handleModeChange = (mode) => {
  console.log("handleModeChange called with mode:", mode);
  console.log("Current chat state:", {
    twins_id: chatStore.chat?.twins_id,
    messagesLength: chatStore.messages.length
  });

  // å¦‚æœå½“å‰å¯¹è¯æœ‰ twins_idï¼Œç¦æ­¢åˆ‡æ¢åˆ°é twins æ¨¡å¼
  const currentHasTwinsId = chatStore.chat?.twins_id && chatStore.twinsChatMessages.length > 0;
  if (currentHasTwinsId && mode !== 'twins') {
    console.log("å½“å‰å¯¹è¯æœ‰ twins_idï¼Œä¸èƒ½åˆ‡æ¢åˆ°å…¶ä»–æ¨¡å¼");
    return;
  }

  // å¦‚æœå½“å‰å¯¹è¯æ²¡æœ‰ twins_id ä½†æœ‰æ™®é€šæ¶ˆæ¯ï¼Œç¦æ­¢åˆ‡æ¢åˆ° twins æ¨¡å¼
  if (mode === 'twins' && !chatStore.chat?.twins_id && chatStore.messages.length > 0) {
    console.log("å½“å‰å¯¹è¯æ²¡æœ‰ twins_id ä½†æœ‰æ¶ˆæ¯ï¼Œä¸èƒ½åˆ‡æ¢åˆ° twins æ¨¡å¼");
    showTwinsInfoModal.value = true;
    return;
  }

  console.log("å·¥ä½œæ¨¡å¼åˆ‡æ¢ä¸º:", mode);
  emit('update:modelValue', mode);
  emit('modeChange', mode);
  // updateWorkMode è¯·è§¦å‘ä¸€ä¸‹ emitter
  emitter.emit('updateWorkMode', mode);
  // ä¿å­˜åˆ°æµè§ˆå™¨ç¼“å­˜
  localStorage.setItem("workMode", mode);
};

// ç§»åŠ¨ç«¯é€‰é¡¹é€‰æ‹©å¤„ç†
const handleMobileModeSelect = (mode) => {
  handleModeChange(mode);
  closeModeModal();
};

// ç”Ÿå‘½å‘¨æœŸ
onMounted(() => {
  checkMobile();
  window.addEventListener("resize", checkMobile);
});

onUnmounted(() => {
  window.removeEventListener("resize", checkMobile);
});
</script>

<style scoped>
.mode-selector-wrapper {
  display: flex;
  align-items: center;
  pointer-events: auto;
  position: relative;
}

.mobile-mode-trigger {
  pointer-events: auto !important;
  cursor: pointer !important;
}
</style>

<style>
/* æ¨¡å¼é€‰æ‹©ä¸‹æ‹‰æ¡†æ ·å¼ */
.mode-select-dropdown .ant-select-selector {
  border: 1px solid #e9ecef !important;
  border-radius: 6px !important;
}

.mode-option {
  display: flex;
  align-items: flex-start;
  gap: 8px;
  padding: 4px 0;
}

.mode-circle {
  width: 16px;
  height: 16px;
  border: 2px solid #333;
  border-radius: 50%;
  margin-top: 3px;
  position: relative;
}

.mode-inner-circle {
  position: absolute;
  top: 1.5px;
  left: 1.5px;
  width: 8px;
  height: 8px;
  background-color: #333;
  border-radius: 50%;
}

.mode-texts {
  display: flex;
  flex-direction: column;
}

.mode-label {
  font-size: 14px;
  font-weight: 500;
}

/* ç§»åŠ¨ç«¯è§¦å‘å™¨æ ·å¼ */
.mobile-mode-trigger {
  display: flex;
  align-items: center;
  justify-content: space-between;
  width: 100%;
  height: 24px;
  padding: 0 2px;
  background: #fff;
  border: 1px solid #d9d9d9;
  border-radius: 4px;
  cursor: pointer;
  font-size: 10px;
  pointer-events: auto;
  user-select: none;
  -webkit-tap-highlight-color: transparent;
}

.mobile-mode-trigger:active {
  background: #f5f5f5;
}

.mobile-mode-trigger.disabled {
  cursor: not-allowed;
  opacity: 0.6;
  background: #f5f5f5;
  color: #999;
  pointer-events: none;
}

.mobile-mode-trigger .mode-name {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  flex: 1;
  margin-right: 2px;
  max-width: 45px;
  pointer-events: none;
}

.mobile-mode-trigger .dropdown-icon {
  font-size: 8px;
  color: #999;
  pointer-events: none;
}

/* ç§»åŠ¨ç«¯è‡ªå®šä¹‰æ¨¡æ€æ¡†æ ·å¼ */
.mode-modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.45);
  z-index: 10001;
  display: flex;
  align-items: flex-end;
  justify-content: center;
  animation: fadeIn 0.3s ease-out;
}

/* ç§»åŠ¨ç«¯æ¨¡æ€æ¡†å†…å®¹æ ·å¼ */
.mode-modal-content {
  background: #fff;
  border-radius: 12px 12px 0 0;
  padding: 0;
  max-height: 50vh;
  min-height: 200px;
  width: 100%;
  max-width: 100%;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  animation: slideUpIn 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
}

.mode-modal-content.closing {
  animation: slideDownOut 0.25s cubic-bezier(0.4, 0, 0.2, 1);
}

.modal-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px 20px;
  border-bottom: 1px solid #f0f0f0;
  flex-shrink: 0;
}

.modal-header h3 {
  margin: 0;
  font-size: 16px;
  font-weight: 600;
}

.close-btn {
  padding: 4px !important;
  color: #999 !important;
}

.option-list {
  flex: 1;
  overflow-y: auto;
  min-height: 0;
  -webkit-overflow-scrolling: touch;
  padding-bottom: 16px;
}

.option-item {
  display: flex;
  align-items: center;
  padding: 12px 20px;
  cursor: pointer;
  transition: background-color 0.2s;
}

.option-item:hover {
  background-color: #f5f5f5;
}

.option-item.selected {
  background-color: #e6f7ff;
}

.option-info {
  display: flex;
  align-items: flex-start;
  gap: 12px;
  width: 100%;
}

.option-circle {
  width: 16px;
  height: 16px;
  border: 2px solid #333;
  border-radius: 50%;
  margin-top: 3px;
  position: relative;
  flex-shrink: 0;
}

.option-inner-circle {
  position: absolute;
  top: 1.5px;
  left: 1.5px;
  width: 8px;
  height: 8px;
  background-color: #333;
  border-radius: 50%;
}

.option-texts {
  display: flex;
  flex-direction: column;
  flex: 1;
}

.option-label {
  font-size: 14px;
  font-weight: 500;
  color: #333;
  display: flex;
  align-items: center;
  gap: 8px;
}

/* åŠ¨ç”»å…³é”®å¸§ */
@keyframes slideUpIn {
  from {
    transform: translateY(100%);
  }
  to {
    transform: translateY(0);
  }
}

@keyframes slideDownOut {
  from {
    transform: translateY(0);
  }
  to {
    transform: translateY(100%);
  }
}

@keyframes fadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

/** é€‚é…ç§»åŠ¨è®¾å¤‡å±å¹• */
@media (max-width: 768px) {
  .mode-selector-wrapper .mode-select-dropdown {
    height: 24px;
    font-size: 10px;
  }

  .mode-selector-wrapper .mode-select-dropdown .ant-select-selection-item {
    font-size: 10px !important;
    padding-inline-end: 0px !important;
    line-height: 24px !important;
  }

  .mode-selector-wrapper .mode-select-dropdown .ant-select-selector {
    padding: 0px 2px !important;
    height: 24px !important;
  }

  .mode-selector-wrapper .mode-select-dropdown .ant-select-arrow {
    display: none !important;
  }
}


.mode-label{
  line-height: 20px;
  color: rgba(79,79,79,1);
  font-size: 14px;
  text-align: left;
  font-family: PingFangSC-regular;
  }
</style>



================================================
FILE: frontend/src/view/lemon/components/Sample.vue
================================================
<template>
    <div class="sample">
        <!-- æœªé€‰ä¸­çŠ¶æ€ï¼šæ˜¾ç¤ºæ‰€æœ‰sample -->
        <template v-if="!selectedItem">
            <div v-for="(item,index) in data" :key="index" class="sample-item" @click="handleItemClick(item)">
                <div v-if="item.icon" v-html="item.icon" class="item-icon"></div>
                <div class="item-title">
                    {{item.name}}
                </div>
            </div>
        </template>

        <!-- é€‰ä¸­çŠ¶æ€ï¼šæ˜¾ç¤ºå½“å‰é€‰ä¸­çš„sampleå’Œå…·ä½“é—®é¢˜ -->
        <template v-else>
            <div class="sample-expanded">
                <div class="selected-sample-item">
                    <div v-if="selectedItem.icon" v-html="selectedItem.icon" class="item-icon"></div>
                    <div class="item-title">{{selectedItem.name}}</div>
                    <div class="close-btn" @click="handleClose">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16">
                            <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z" fill="currentColor"/>
                        </svg>
                    </div>
                </div>

                <div class="questions-list">
                    <div
                        v-for="(question, idx) in selectedItem.questions"
                        :key="idx"
                        class="question-item"
                        @click="handleQuestionClick(question.content)"
                    >
                        {{ question.title }}
                    </div>
                </div>
            </div>
        </template>
    </div>
</template>
<script setup>
    import { ref, computed, onMounted, onUnmounted } from 'vue';
    import emitter from '@/utils/emitter';

    const emit  = defineEmits(['sampleClick']);

    const selectedItem = ref(null);
    const workMode = ref(localStorage.getItem("workMode") || "twins");

    // Agent æ¨¡å¼çš„ç¤ºä¾‹æ•°æ® (twins, auto, task)
    const agentModeData = [
        {
            name: 'Full-Stack Dev',
            icon: `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24" width="15" height="15" style="" filter="none">
    <g>
    <path d="M6 22h12l-6-6zM21 3H3c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h4v-2H3V5h18v12h-4v2h4c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z" fill="rgba(57,143,255,1)"></path>
    </g>
  </svg>`,
            questions: [
                {
                    title: 'Build a Todo List App',
                    content: 'Create a simple todo list web application with add, delete, and mark as complete features. Use HTML, CSS, and JavaScript.'
                },
                {
                    title: 'Create a Weather Dashboard',
                    content: 'Build a weather dashboard that shows current weather and 5-day forecast using a weather API. Display temperature, humidity, and weather conditions.'
                },
                {
                    title: 'Build a Blog Platform',
                    content: 'Create a simple blog platform where users can create, edit, and delete posts. Include a homepage that lists all posts and individual post pages.'
                }
            ]
        },
        {
            name: 'Stock Analysis',
            icon: `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="64 64 896 896" width="16" height="16" style="" filter="none">
    <g>
    <path d="M904 747H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM165.7 621.8l39.7 39.5c3.1 3.1 8.2 3.1 11.3 0l234.7-233.9 97.6 97.3a32.11 32.11 0 0 0 45.2 0l264.2-263.2c3.1-3.1 3.1-8.2 0-11.3l-39.7-39.6a8.03 8.03 0 0 0-11.3 0l-235.7 235-97.7-97.3a32.11 32.11 0 0 0-45.2 0L165.7 610.5a7.94 7.94 0 0 0 0 11.3z" fill="rgba(255,81,81,1)"></path>
    </g>
  </svg>`,
            questions: [
                {
                    title: 'Wuliangye Stock Analysis',
                    content: 'Can you help me analyze if Wuliangye can be estimated at 145 in the next six months'
                },
                {
                    title: 'Nvidia DCF Model Analysis',
                    content: 'Please use a DCF model to analyze the probability that Nvidia stock will reach $250 within the next six months (November 2025 - May 2026). Provide a web report.'
                }
            ]
        },
        {
            name: 'In-Depth Research',
            icon: `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 48 48" width="15" height="15" style="" filter="none">
    <g>
    <rect width="48" height="48" fill="rgba(255,168,0,1)" fill-opacity="0.01" stroke="none"></rect><path d="M4 7.00012H44" stroke="rgba(255,168,0,1)" stroke-width="4" stroke-linecap="round" fill="none"></path><path d="M4 23.0001H15" stroke="rgba(255,168,0,1)" stroke-width="4" stroke-linecap="round" fill="none"></path><path d="M4 39.0001H15" stroke="rgba(255,168,0,1)" stroke-width="4" stroke-linecap="round" fill="none"></path><path d="M31.5 34.0001C36.1944 34.0001 40 30.1945 40 25.5001C40 20.8057 36.1944 17.0001 31.5 17.0001C26.8056 17.0001 23 20.8057 23 25.5001C23 30.1945 26.8056 34.0001 31.5 34.0001Z" fill="none" stroke="rgba(255,168,0,1)" stroke-width="4"></path><path d="M37 32.0001L44 39.0506" stroke="rgba(255,168,0,1)" stroke-width="4" stroke-linecap="round" fill="none"></path>
    </g>
  </svg>`,
            questions: [
                {
                    title: 'AI Industry Report 2025',
                    content: 'Research and compile a comprehensive report on the AI industry in 2025, including market size, key players, emerging technologies, and future trends.'
                },
                {
                    title: 'Competitor Analysis',
                    content: 'Conduct an in-depth competitor analysis for the e-commerce industry. Compare top 5 players by market share, pricing strategy, and customer satisfaction.'
                },
                {
                    title: 'Climate Policy Research',
                    content: 'Research global climate policies from 2020-2025. Analyze their effectiveness, compare different countries approaches, and provide recommendations.'
                }
            ]
        },
        {
            name: 'Game Prototyping',
            icon: `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 48 48" width="15" height="15" style="" filter="none">
    <g>
    <path d="M19 30L19 33C19 36.866 15.866 40 12 40V40C8.13401 40 5 36.866 5 33L5 19" stroke="rgba(194,116,255,1)" stroke-width="4" stroke-linecap="round" stroke-linejoin="round" fill="none"></path><path d="M29 30L29 33C29 36.866 32.134 40 36 40V40C39.866 40 43 36.866 43 33L43 19" stroke="rgba(194,116,255,1)" stroke-width="4" stroke-linecap="round" stroke-linejoin="round" fill="none"></path><rect x="5" y="8" width="38" height="22" rx="11" fill="none" stroke="rgba(194,116,255,1)" stroke-width="4"></rect><path d="M21 19H13" stroke="rgba(194,116,255,1)" stroke-width="4" stroke-linecap="round" stroke-linejoin="round" fill="none"></path><path d="M17 15V23" stroke="rgba(194,116,255,1)" stroke-width="4" stroke-linecap="round" stroke-linejoin="round" fill="none"></path><rect x="32" y="15" width="4" height="4" rx="2" fill="rgba(194,116,255,1)" stroke="none"></rect><rect x="28" y="20" width="4" height="4" rx="2" fill="rgba(194,116,255,1)" stroke="none"></rect>
    </g>
  </svg>`,
            questions: [
                {
                    title: 'Build a Simple 2D Game',
                    content: 'Create a simple 2D platformer game prototype using JavaScript and HTML5 Canvas. Include player movement, jumping, and basic collision detection.'
                },
                {
                    title: 'Card Game Mechanics',
                    content: 'Design and implement a turn-based card game with deck management, card effects, and AI opponent logic.'
                },
                {
                    title: 'Puzzle Game Prototype',
                    content: 'Build a match-3 puzzle game prototype with grid-based gameplay, score tracking, and level progression system.'
                }
            ]
        }
    ];

    // Chat æ¨¡å¼çš„ç¤ºä¾‹æ•°æ®
    const chatModeData = [
        {
            name: 'Instant Insight',
            icon: `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 48 48" width="15" height="15" style="" filter="none">
    <g>
    <rect width="48" height="48" fill="rgba(255,168,0,1)" fill-opacity="0.01" stroke="none"></rect><path d="M4 7.00012H44" stroke="rgba(255,168,0,1)" stroke-width="4" stroke-linecap="round" fill="none"></path><path d="M4 23.0001H15" stroke="rgba(255,168,0,1)" stroke-width="4" stroke-linecap="round" fill="none"></path><path d="M4 39.0001H15" stroke="rgba(255,168,0,1)" stroke-width="4" stroke-linecap="round" fill="none"></path><path d="M31.5 34.0001C36.1944 34.0001 40 30.1945 40 25.5001C40 20.8057 36.1944 17.0001 31.5 17.0001C26.8056 17.0001 23 20.8057 23 25.5001C23 30.1945 26.8056 34.0001 31.5 34.0001Z" fill="none" stroke="rgba(255,168,0,1)" stroke-width="4"></path><path d="M37 32.0001L44 39.0506" stroke="rgba(255,168,0,1)" stroke-width="4" stroke-linecap="round" fill="none"></path>
    </g>
  </svg>`,
            questions: [
                {
                    title: 'What is Blockchain?',
                    content: 'Explain blockchain technology in simple terms'
                },
                {
                    title: 'Python vs JavaScript',
                    content: 'What are the main differences between Python and JavaScript?'
                },
                {
                    title: 'How does WiFi work?',
                    content: 'Explain how WiFi technology works in simple language'
                }
            ]
        },
        {
            name: 'Creative Spark',
            icon: `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24" width="15" height="15" style="" filter="none">
    <g>
    <path d="M12 2L15.09 8.26L22 9.27L17 14.14L18.18 21.02L12 17.77L5.82 21.02L7 14.14L2 9.27L8.91 8.26L12 2Z" fill="rgba(255,193,7,1)" stroke="rgba(255,193,7,1)" stroke-width="2"></path>
    </g>
  </svg>`,
            questions: [
                {
                    title: 'Time Travel Story',
                    content: 'Give me a creative story idea about time travel'
                },
                {
                    title: 'Tech Startup Names',
                    content: 'Suggest unique names for a tech startup'
                },
                {
                    title: 'Innovative Product Ideas',
                    content: 'What are some innovative product ideas for 2025?'
                }
            ]
        },
        {
            name: 'Brainstorming',
            icon: `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24" width="15" height="15" style="" filter="none">
    <g>
    <path d="M9 21c0 .55.45 1 1 1h4c.55 0 1-.45 1-1v-1H9v1zm3-19C8.14 2 5 5.14 5 9c0 2.38 1.19 4.47 3 5.74V17c0 .55.45 1 1 1h6c.55 0 1-.45 1-1v-2.26c1.81-1.27 3-3.36 3-5.74 0-3.86-3.14-7-7-7zm2.85 11.1l-.85.6V16h-4v-2.3l-.85-.6C7.8 12.16 7 10.63 7 9c0-2.76 2.24-5 5-5s5 2.24 5 5c0 1.63-.8 3.16-2.15 4.1z" fill="rgba(156,39,176,1)"></path>
    </g>
  </svg>`,
            questions: [
                {
                    title: 'Social Media Campaign Ideas',
                    content: 'Brainstorm creative social media campaign ideas for a sustainable fashion brand targeting Gen Z'
                },
                {
                    title: 'Product Feature Ideas',
                    content: 'Help me brainstorm innovative features for a productivity app that would differentiate it from competitors'
                },
                {
                    title: 'Content Creation Topics',
                    content: 'Generate 10 engaging blog post topics about remote work and digital nomad lifestyle'
                }
            ]
        },
        {
            name: 'Efficiency Boost',
            icon: `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24" width="15" height="15" style="" filter="none">
    <g>
    <path d="M13 2.05v3.03c3.39.49 6 3.39 6 6.92 0 .9-.18 1.75-.48 2.54l2.6 1.53c.56-1.24.88-2.62.88-4.07 0-5.18-3.95-9.45-9-9.95zM12 19c-3.87 0-7-3.13-7-7 0-3.53 2.61-6.43 6-6.92V2.05c-5.06.5-9 4.76-9 9.95 0 5.52 4.47 10 9.99 10 3.31 0 6.24-1.61 8.06-4.09l-2.6-1.53C16.17 17.98 14.21 19 12 19z" fill="rgba(76,175,80,1)"></path>
    </g>
  </svg>`,
            questions: [
                {
                    title: 'Daily Schedule Organization',
                    content: 'How to organize my daily schedule better?'
                },
                {
                    title: 'Writing Efficiency Tips',
                    content: 'Tips for writing faster and more efficiently'
                },
                {
                    title: 'Email Management',
                    content: 'Best practices for email management'
                }
            ]
        }
    ];

    // æ ¹æ®å·¥ä½œæ¨¡å¼åŠ¨æ€è®¡ç®—è¦æ˜¾ç¤ºçš„æ•°æ®
    const data = computed(() => {
        if (workMode.value === 'chat') {
            return chatModeData;
        } else {
            // twins, auto, task éƒ½ä½¿ç”¨ Agent æ¨¡å¼æ•°æ®
            return agentModeData;
        }
    });

    const handleItemClick = (item) => {
        selectedItem.value = item;
    }

    const handleClose = () => {
        selectedItem.value = null;
    }

    const handleQuestionClick = (question) => {
        console.log("sampleClick====", question);
        // è§¦å‘çˆ¶ç»„ä»¶çš„ sampleClick äº‹ä»¶
        emit('sampleClick', { content: question });
    }

    // ç›‘å¬ workMode æ›´æ–°äº‹ä»¶
    onMounted(() => {
        console.log('Sample.vue mounted, æ³¨å†Œ updateWorkMode ç›‘å¬å™¨');
        emitter.on("updateWorkMode", (newWorkMode) => {
            workMode.value = newWorkMode;
            // å½“æ¨¡å¼åˆ‡æ¢æ—¶ï¼Œé‡ç½®é€‰ä¸­çŠ¶æ€
            selectedItem.value = null;
            console.log('Sample WorkMode updated to:', newWorkMode);
        });
    });

    onUnmounted(() => {
        // æ¸…ç† emitter äº‹ä»¶ç›‘å¬å™¨
        emitter.off("updateWorkMode");
    });
</script>
<style scoped>
    .sample{
        display: flex;
        justify-content: center;
        flex-wrap: wrap;
        align-items: center;
        gap: 0.5rem;
        max-width: 1039px;
        width: 100%;
        margin-left: auto;
        margin-right: auto;
    }

    .sample-item{
        height: 35px;
        border-radius: 5px;
        background-color: rgba(255,255,255,1);
        box-shadow: 0px 1px 10px 0px rgba(0,0,0,0.03);
        border: 1px solid rgba(236,236,236,1);
        padding: 8px 8px 8px 11px;
        display: flex;
        flex-direction: row;
        align-items: center;
        justify-content: center;
        gap:7px;
        cursor: pointer;
        transition: all 0.2s ease;
    }

    .sample-item:hover {
        background-color: rgba(245,245,245,1);
        border-color: rgba(200,200,200,1);
    }

    .item-icon {
        width: 15px;
        height: 15px;
    }

    /* å±•å¼€çŠ¶æ€çš„å®¹å™¨ */
    .sample-expanded {
        width: 100%;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
    }

    /* é€‰ä¸­çš„sampleé¡¹ */
    .selected-sample-item {
        height: 35px;
        border-radius: 5px;
        background-color: rgba(255,255,255,1);
        box-shadow: 0px 1px 10px 0px rgba(0,0,0,0.03);
        border: 1px solid rgba(236,236,236,1);
        padding: 8px 11px;
        display: flex;
        flex-direction: row;
        align-items: center;
        gap: 7px;
        width: fit-content;
    }

    /* å…³é—­æŒ‰é’® */
    .close-btn {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 20px;
        height: 20px;
        cursor: pointer;
        color: rgba(150,150,150,1);
        transition: color 0.2s ease;
        margin-left: 4px;
    }

    .close-btn:hover {
        color: rgba(50,50,50,1);
    }

    /* é—®é¢˜åˆ—è¡¨ */
    .questions-list {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        gap: 0.75rem;
        width: 100%;
    }

    /* é—®é¢˜é¡¹ */
    .question-item {
        padding: 12px 16px;
        border-radius: 8px;
        background-color: rgba(255,255,255,1);
        box-shadow: 0px 1px 10px 0px rgba(0,0,0,0.03);
        border: 1px solid rgba(236,236,236,1);
        cursor: pointer;
        transition: all 0.2s ease;
        font-size: 14px;
        line-height: 1.5;
        min-height: 60px;
        display: flex;
        align-items: center;
    }

    .question-item:hover {
        background-color: rgba(245,250,255,1);
        border-color: rgba(57,143,255,0.3);
        transform: translateY(-1px);
        box-shadow: 0px 2px 15px 0px rgba(0,0,0,0.08);
    }

    /*é€‚é… ç§»åŠ¨ç«¯ */
    @media (max-width: 768px) {
        .sample{
            .sample-item{
                width: 100%;
                font-size: 11px;
            }
        }

        .questions-list {
            grid-template-columns: 1fr;
            gap: 0.5rem;
        }

        .question-item {
            font-size: 12px;
            padding: 10px 12px;
            min-height: 50px;
        }
    }
</style>


================================================
FILE: frontend/src/view/lemon/components/SelectionPreview.vue
================================================
<template>
  <transition name="preview-slide">
    <div v-if="showSelectionPreview && selectedScreenshot && editorMode === 'ai-edit'" class="selection-preview">
      <div class="preview-header">
        <div class="preview-title">
          <i class="fas fa-crosshairs"></i>
          <span>Selected</span>
          <a-tag size="small" color="blue">{{ selectedElementTag }}</a-tag>
        </div>
        <a-button type="text" size="small" @click="handleClose" class="close-btn">
          <CloseOutlined />
        </a-button>
      </div>

      <div class="preview-content">
        <div class="preview-image-container">
          <img :src="selectedScreenshot" alt="Selected element preview" class="preview-image" />
        </div>
      </div>
    </div>
  </transition>
</template>

<script setup>
import { computed } from "vue";
import { storeToRefs } from "pinia";
import { useEditorStore } from "@/store/modules/editor";
import { CloseOutlined } from "@ant-design/icons-vue";

const editorStore = useEditorStore();
const { editorMode, selectedElement, selectedScreenshot, showSelectionPreview } = storeToRefs(editorStore);

// è®¡ç®—é€‰ä¸­å…ƒç´ çš„æ ‡ç­¾
const selectedElementTag = computed(() => {
  if (!selectedElement.value) return "";
  const tag = selectedElement.value.tagName?.toLowerCase() || "";
  const id = selectedElement.value.id ? `#${selectedElement.value.id}` : "";
  const className = selectedElement.value.className ? `.${selectedElement.value.className.split(" ")[0]}` : "";
  return `${tag}${id}${className}`;
});

// å…³é—­é¢„è§ˆ
const handleClose = () => {
  editorStore.setShowSelectionPreview(false);
};
</script>

<style lang="scss" scoped>
.selection-preview {
  background: white;
  border-radius: 12px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  margin-bottom: 12px;
  overflow: hidden;
  border: 1px solid #e5e7eb;
}

.preview-header {
  display: flex;
  justify-content: space-between;
  align-items: center; // è¿™é‡Œå·²ç»è®¾ç½®äº†å‚ç›´å±…ä¸­
  padding: 12px 16px;
  border-bottom: 1px solid #f0f0f0;
  background: #fafafa;
}

.preview-title {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 14px;
  font-weight: 500;
  color: #333;

  i {
    color: #1890ff;
  }
}

.close-btn {
  color: #999;
  display: flex !important;
  align-items: center;
  justify-content: center;
  padding: 4px !important;

  &:hover {
    color: #333;
  }
}

.preview-content {
  padding: 16px;
  display: flex;
  justify-content: center;
  align-items: center;
}

.preview-image-container {
  display: inline-block;
  max-width: 100%;
  border-radius: 8px;
  overflow: hidden;
  border: 1px solid #e5e7eb;
}

.preview-image {
  display: block;
  max-width: 100%;
  max-height: 180px;
  width: auto;
  height: auto;
  object-fit: contain;
  background: #f5f5f5;
}

// è¿‡æ¸¡åŠ¨ç”»
.preview-slide-enter-active,
.preview-slide-leave-active {
  transition: all 0.3s ease;
}

.preview-slide-enter-from {
  transform: translateY(-20px);
  opacity: 0;
}

.preview-slide-leave-to {
  transform: translateY(-20px);
  opacity: 0;
}

// å“åº”å¼è®¾è®¡
@media (max-width: 768px) {
  .selection-preview {
    margin-bottom: 8px;
  }

  .preview-header {
    padding: 8px 12px;
  }

  .preview-content {
    padding: 12px;
  }

  .preview-image {
    max-height: 150px;
  }

  .preview-actions {
    padding: 8px 12px;

    button {
      flex: 1;
    }
  }
}
</style>



================================================
FILE: frontend/src/view/lemon/components/Sidebar.vue
================================================
<template>
  <div class="sidebar" :class="{ 'collapsed': isCollapsed }">
    <div class="sidebar-header">
      <button class="menu-button" @click="toggleCollapse">
        <span class="menu-icon">
          <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none"
            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <line x1="3" y1="12" x2="21" y2="12"></line>
            <line x1="3" y1="6" x2="21" y2="6"></line>
            <line x1="3" y1="18" x2="21" y2="18"></line>
          </svg>
        </span>
      </button>
      <button class="search-button">
        <span class="search-icon">
          <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none"
            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="11" cy="11" r="8"></circle>
            <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
          </svg>
        </span>
      </button>
    </div>

    <div class="sidebar-content">
      <button class="new-task-button">
        <span class="plus-icon">+</span>
        <span class="button-text">æ–°å»ºä»»åŠ¡</span>
        <span class="shortcut">âŒ˜ K</span>
      </button>

      <div class="chat-list">
        <div v-for="chat in chats" :key="chat.conversation_id" class="chat-item"
          :class="{ 'active': chat.conversation_id === conversationId }" @click="setActiveChat(chat)">
          <div class="chat-icon" :class="chat.iconStyle">
            {{ chat.icon }}
          </div>
          <div class="chat-details">
            <div class="chat-header">
              <div class="chat-title">{{ chat.title }}</div>
              <div class="chat-time">{{ chat.time }}</div>
            </div>
            <div class="chat-preview">{{ chat.preview }}</div>
          </div>
        </div>
      </div>
    </div>

    <div class="sidebar-footer">
      <div class="user-profile">
        <div class="avatar">
          <img src="" alt="User avatar" />
        </div>
        <div class="user-name">yi bo</div>
      </div>
      <div class="footer-actions">
        <button class="footer-button">
          <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none"
            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path>
            <path d="M13.73 21a2 2 0 0 1-3.46 0"></path>
          </svg>
        </button>
        <button class="footer-button">
          <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none"
            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
          </svg>
        </button>
        <button class="footer-button">
          <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none"
            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path>
            <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path>
          </svg>
        </button>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref } from 'vue';
import { storeToRefs } from 'pinia';
const isCollapsed = ref(false);
import { useChatStore } from '@/store/modules/chat';
const chatStore = useChatStore();

const { conversationId } = storeToRefs(chatStore);
const props = defineProps({
  chats: {
    type: Array,
    default: () => []
  }
});

// åˆ‡æ¢ä¾§è¾¹æ å±•å¼€/æ”¶èµ·çŠ¶æ€
const toggleCollapse = () => {
  isCollapsed.value = !isCollapsed.value;
};

import { useRouter } from 'vue-router';
const router = useRouter();

const setActiveChat = (chat) => {
  conversationId.value = chat.conversation_id;
  chatStore.clearMessages();
  router.push(`/lemon/${chat.conversation_id}`);
};
</script>

<style lang="scss" scoped>
.sidebar {
  display: flex;
  flex-direction: column;
  width: 380px;
  height: 100vh;
  background-color: #ebebeb;
  transition: width 0.3s ease;
  overflow: hidden;

  &.collapsed {
    width: auto;

    .button-text,
    .chat-details,
    .user-name,
    .shortcut {
      display: none;
    }

    .chat-icon {
      margin-right: 0;
    }

    .new-task-button,
    .chat-item {
      justify-content: center;
      padding: 10px;
    }

    .sidebar-footer {
      justify-content: center;
    }

    .footer-actions {
      display: none;
    }
  }
}

.sidebar-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px 16px;
  border-bottom: 1px solid #e0e0e0;
}

.menu-button,
.search-button {
  background: none;
  border: none;
  cursor: pointer;
  color: #666;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 8px;
  border-radius: 8px;

  &:hover {
    background-color: rgba(0, 0, 0, 0.05);
  }
}

.sidebar-content {
  flex: 1;
  overflow-y: auto;
  padding: 16px;
  display: flex;
  flex-direction: column;
  gap: 12px;

  &::-webkit-scrollbar {
    width: 5px;
  }

  &::-webkit-scrollbar-thumb {
    background-color: #ddd;
    border-radius: 5px;
  }
}

.new-task-button {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px 16px;
  border-radius: 8px;
  background-color: white;
  border: 1px solid #e0e0e0;
  cursor: pointer;
  color: #333;
  font-weight: 500;
  margin-bottom: 8px;

  &:hover {
    background-color: #fafafa;
  }

  .plus-icon {
    font-size: 16px;
    margin-right: 8px;
  }

  .shortcut {
    font-size: 12px;
    color: #999;
    background-color: #f5f5f5;
    padding: 2px 6px;
    border-radius: 4px;
  }
}

.chat-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.chat-item {
  display: flex;
  align-items: flex-start;
  padding: 12px 16px;
  border-radius: 8px;
  background-color: white;
  border: 1px solid #e0e0e0;
  cursor: pointer;

  &:hover {
    background-color: #f9f9f9;
  }

  &.active {
    background-color: rgba(0, 102, 255, 0.05);
    border: 1px solid rgba(0, 102, 255, 0.2);
  }
}

.chat-icon {
  margin-right: 12px;
  width: 32px;
  height: 32px;
  border-radius: 6px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;

  &.blue-bg {
    background-color: #0066ff;
    color: white;
  }

  &.gray-bg {
    background-color: #333;
    color: white;
  }
}

.chat-details {
  flex: 1;
  min-width: 0;
}

.chat-header {
  display: flex;
  justify-content: space-between;
  margin-bottom: 4px;
}

.chat-title {
  font-weight: 500;
  font-size: 14px;
  color: #333;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.chat-time {
  font-size: 12px;
  color: #999;
  white-space: nowrap;
  margin-left: 8px;
}

.chat-preview {
  font-size: 12px;
  color: #666;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.sidebar-footer {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px 16px;
  border-top: 1px solid #e0e0e0;
}

.user-profile {
  display: flex;
  align-items: center;
  gap: 8px;
}

.avatar {
  width: 32px;
  height: 32px;
  border-radius: 50%;
  background-color: #0066ff;
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
  font-size: 14px;

  img {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    object-fit: cover;
  }
}

.user-name {
  font-size: 14px;
  font-weight: 500;
  color: #333;
}

.footer-actions {
  display: flex;
  gap: 12px;
}

.footer-button {
  background: none;
  border: none;
  cursor: pointer;
  color: #666;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 32px;
  height: 32px;
  border-radius: 8px;

  &:hover {
    background-color: #f5f5f5;
    color: #333;
  }
}
</style>


================================================
FILE: frontend/src/view/lemon/components/Suggestion.vue
================================================
<template>
  <div class="suggestion-cards">
    <SuggestionCard v-for="card in suggestionCards" :key="card.id" v-bind="card" @click="handleCardClick(card)" />
  </div>
</template>

<script setup>
import { ref } from 'vue'
import SuggestionCard from './SuggestionCard.vue'
import { useChatStore } from '@/store/modules/chat';
import seeAgent from '@/services/see-agent';

const chatStore = useChatStore();

import { useRouter } from 'vue-router';
const router = useRouter();

const currentChat = ref(null)


const handleCardClick = async (card) => {
  // ç‚¹å‡»å¡ç‰‡æ—¶åˆ›å»ºæ–°å¯¹è¯
  // currentChat.value = {
  //   id: Date.now(),
  //   title: card.title
  // }

  const result = await chatStore.createConversation(card.title);
  console.log('createConversation', result);
  const { conversation_id } = result;
  if (conversation_id) {
    router.push(`/lemon/${conversation_id}`);
    await seeAgent.sendMessage(card.title,conversation_id,[]);
  }
}

const suggestionCards = ref([
  {
    id: 1,
    icon: 'icon-japan',
    title: 'å››æœˆæ—¥æœ¬ä¹‹æ—…',
    description: 'Lemoné›†æˆå…¨é¢çš„æ—…æ¸¸ä¿¡æ¯,åˆ¶å®šä¸ªæ€§åŒ–çš„è¡Œç¨‹è¡¨,å¹¶åˆ¶ä½œä¸“ä¸ºæ‚¨å®šåˆ¶çš„æ—¥æœ¬æ—…è¡Œè®¡åˆ’'
  },
  {
    id: 2,
    icon: 'icon-analysis',
    title: 'æ·±åº¦åˆ†æç‰¹æ–¯æ‹‰è‚¡ç¥¨',
    description: 'Lemonæä¾›æ·±å…¥çš„è‚¡ç¥¨åˆ†æ,é€šè¿‡ç°ä»£åŒ–çš„å¼•åŠ›åˆ†æä»ªè¡¨å±•ç°ç‰¹æ–¯æ‹‰çš„æŠ€æœ¯ç‰¹ç‚¹'
  },
  {
    id: 3,
    icon: 'icon-education',
    title: 'åŠ¨é‡å®šç†äº’åŠ¨è¯¾ç¨‹',
    description: 'Lemonä¸ºä¸­å­¦æ•™è‚²è€…åˆ¶ä½œäº†å¼•äººå…¥èƒœçš„è§†é¢‘æ¼”ç¤º,é€šè¿‡æ¼”è®²å¢è¿›æ•™è‚²å†…å®¹'
  },
  {
    id: 4,
    icon: 'icon-report',
    title: 'ä¿é™©èµ„ç®¡æŠ¥å‘Šåˆ†æ',
    description: 'Lemonç”Ÿæˆæ¸…æ™°ã€ç»“æ„åŒ–çš„å¯¹æ¯”è¡¨æ ¼,çªå‡ºå…³é”®æ•°æ®'
  }
])
</script>

<style lang="scss" scoped>
.suggestion-cards {
  display: flex;
  flex-wrap: wrap;
  gap: 1rem;
}

@media screen and (max-width: 768px) {
  .suggestion-cards {
    gap: 0.5rem!important;
  }
}
</style>


================================================
FILE: frontend/src/view/lemon/components/SuggestionCard.vue
================================================
<template>
  <div class="suggestion-card">
    <div class="card-icon">
      <!-- <i :class="icon"></i> -->
      <img src="" style="aspect-ratio: 4 / 3;width: 100%;" alt="icon"
        class="card-icon-img">
    </div>
    <div class="card-content">
      <h3 class="card-title">{{ title }}</h3>
      <p class="card-desc">{{ description }}</p>
    </div>
  </div>
</template>

<script setup>
defineProps({
  icon: String,
  title: String,
  description: String
})
</script>

<style lang="scss" scoped>
.suggestion-card {
  background: #fff;
  border: 1px solid #e6e6e6;
  border-radius: 8px;
  padding: 16px;
  cursor: pointer;
  transition: all 0.3s;
  width: calc((100% - 4rem) / 5);

  &:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  }
}

.card-icon {
  border-radius: 8px;
  background: #f5f5f5;
  display: flex;
  align-items: center;
  justify-content: center;
  margin-bottom: 12px;

  i {
    font-size: 24px;
    color: #1f2329;
  }
}

.card-title {
  font-size: 16px;
  font-weight: 500;
  color: #1f2329;
  margin: 0 0 8px;
}

.card-desc {
  font-size: 14px;
  color: #666;
  margin: 0;
  line-height: 1.5;
}

@media screen and (max-width: 768px) {
  .suggestion-card {
    width: calc((100% - 0.5rem) / 2)!important;
  }
}
</style>


================================================
FILE: frontend/src/view/lemon/message/Action.vue
================================================
<template>
  <div class="action">
    <span>{{ thought }}</span>
  </div>
</template>

<script setup>
import { computed } from 'vue'

const actionTypeDescriptions = {
  'run': 'æ‰§è¡Œ bash å‘½ä»¤',
  'read': 'è¯»å–æ–‡ä»¶',
  'edit': 'ç¼–è¾‘æ–‡ä»¶',
  'browser':  'ä½¿ç”¨æµè§ˆå™¨',
}

const props = defineProps({
  message: {
    type: Object,
    required: true
  }
})

const thought = computed(() => {
  const value = props.message.message
  return  value ||props.message.args.thought 
})

const actionType = computed(() => {
  const action = props.message.action;
  return actionTypeDescriptions[action]
})

const content = computed(() => {
  const action = props.message.action;
  if (action === 'run') {
    return props.message.args.command
  }
  if (action === 'read') {
    return props.message.args.path
  }
  if (action === 'edit') {
    return props.message.args.path
  }
  return ''
})

</script>

<style lang="scss" scoped></style>



================================================
FILE: frontend/src/view/lemon/message/CodingMessage.vue
================================================
<template>
  <div class="coding-message">
    <div class="coding-header">
      <div class="coding-icon">
        <i class="fas fa-code"></i>
      </div>
      <div class="coding-info">
        <div class="coding-title">Edit File</div>
        <div class="file-path" v-if="filePath">{{ filePath }}</div>
      </div>
    </div>

    <div class="coding-actions">
      <a-button type="text" size="small" @click="handleViewDiff" class="view-diff-btn">
        <i class="fas fa-eye mr-1"></i>
        View Diff
      </a-button>
    </div>
  </div>
</template>

<script setup>
import { computed } from "vue";
import emitter from "@/utils/emitter";

const props = defineProps({
  message: {
    type: Object,
    required: true,
  },
});

// ä»æ¶ˆæ¯ä¸­æå–æ–‡ä»¶è·¯å¾„
const filePath = computed(() => {
  const json = props.message?.meta?.json;
  const filepath = json?.filepath;
  if (filepath && filepath.includes("Conversation")) {
    return filepath.substring(filepath.indexOf("Conversation"));
  }
  return filepath;
});

// å¤„ç†æŸ¥çœ‹ diff çš„ç‚¹å‡»äº‹ä»¶
const handleViewDiff = () => {
  const diffData = {
    type: "diff",
    filename: filePath.value,
    find: props.message?.meta?.json?.find || "",
    with: props.message?.meta?.json?.with || "",
    file: filePath.value,
  };

  emitter.emit("fullPreviewVisable-open", diffData);
};
</script>

<style lang="scss" scoped>
.coding-message {
  max-width: calc(100% - 16px);
  margin: 8px 0;
  padding: 4px 12px;
  cursor: pointer;
  background-color: #37352f0a;
  border: 1px solid #0000000a;
  border-radius: 15px;
  font-size: 14px;
  display: flex;
  align-items: center;
  justify-content: space-between;

  .coding-header {
    display: flex;
    align-items: center;
    gap: 8px;
    flex: 1;

    .coding-icon {
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;

      i {
        font-size: 14px;
        color: #666;
      }
    }

    .coding-info {
      flex: 1;
      display: flex;
      align-items: center;
      gap: 8px;

      .coding-title {
        font-size: 14px;
        font-weight: normal;
        color: #333;
      }

      .file-path {
        font-size: 14px;
        color: #666;
        font-family: monospace;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
    }
  }

  .coding-actions {
    .view-diff-btn {
      color: #666;
      background: transparent;
      border: none;
      font-size: 12px;
      height: auto;
      padding: 2px 6px;
      border-radius: 4px;

      &:hover {
        background: #f0f0f0;
        color: #333;
      }

      i {
        font-size: 10px;
        margin-right: 3px;
      }
    }
  }
}
</style>



================================================
FILE: frontend/src/view/lemon/message/index.vue
================================================
<template>
  <div class="message-content" :class="messageType">
    <Message :message="message" />
  </div>
</template>

<script setup>
import { computed } from 'vue'
import Observation from './Observation.vue';
import Action from './Action.vue';
import Message from './Message.vue';


const props = defineProps({
  message: {
    type: Object,
    required: true
  }
})

const messageType = computed(() => {
  const message = props.message;
  if (message.action === 'message') {
    return 'message'
  }
  if (message.observation) {
    return 'observation'
  }
  if (message.action) {
    return 'action'
  }
  return ''
});


</script>

<style lang="scss" scoped>
.message-content {
  padding: .75rem;
  position: relative;
  word-wrap: break-word;
  overflow-wrap: break-word;
  width: 100%;
  display: flex;
  flex-direction: column;
  justify-content: space-between;

  &.action,
  &.observation {
    border: none;
    box-shadow: none;
    background: transparent;
    max-width: calc(100% - 16px);
    padding-left: 0;
    padding: 0;
  }

  &:hover {
    // padding-right: 40px;

    .copy-button {
      display: block;
    }
  }
}

.message-sender {
  font-size: 14px;
  font-weight: 500;
  color: #1f2329;
  margin-bottom: 4px;
}

.message-text {
  font-size: 14px;
  color: #1f2329;
  line-height: 1.5;
  white-space: pre-wrap;
}

.message-time {
  font-size: 12px;
  color: #999;
  margin-top: 4px;
}


</style>


================================================
FILE: frontend/src/view/lemon/message/Message.vue
================================================
<!-- cspell:ignore anticon -->
<template>
  <!-- <div>{{ message }}</div> -->
  <!-- web search -->
  <div v-if="message?.meta?.action_type === 'chat' && searchResults.length > 0" class="web-search-results-compact" @click="openDrawer(message)">
    <div class="search-results-icons">
      <div 
        v-for="(result, index) in searchResults.slice(0, 10)" 
        :key="index" 
        class="result-icon-item"
        :style="{ zIndex: 10 - index }"
        @click.stop="openUrl(result.url)"
        @mouseenter="showTooltip($event, result)"
        @mouseleave="hideTooltip"
      >
        <img 
          :src="getFaviconUrl(result.url)" 
          :alt="formatUrl(result.url)"
          @error="handleImageError"
          class="favicon-img"
        />
      </div>
      <div v-if="searchResults.length > 10" class="more-count">
        +{{ searchResults.length - 10 }}
      </div>
    </div>
    <div class="search-results-info">
      <span class="search-icon">ğŸ”</span>
      <span class="search-text">{{ searchResults.length }} websites found</span>
    </div>
    
    <!-- è‡ªå®šä¹‰æ‚¬æµ®æç¤ºæ¡† -->
    <div 
      v-if="tooltip.visible" 
      class="custom-tooltip"
      :style="{ left: tooltip.x + 'px', top: tooltip.y + 'px' }"
      @mouseenter="cancelHideTooltip"
      @mouseleave="hideTooltip"
      @click="openUrl(tooltip.currentUrl)"
    >
      <div class="tooltip-title">{{ tooltip.title }}</div>
      <div class="tooltip-url">{{ tooltip.url }}</div>
    </div>
  </div> 
  
  <!-- document_query -->
  <div v-if="message?.meta?.action_type === 'chat' && documentQueryResult" class="document-query-result" @click="handleDocumentQueryClick(message)">
    <div class="document-query-info">
      <span class="document-icon">ğŸ“„</span>
      <span class="document-text">Document Query:{{ documentQueryResult.query }}</span>
    </div>
  </div>
   
  <div style="display: flex; align-items: center" v-if="message.role === 'assistant' && message.is_temp && !message.meta">{{ content }} <LoadingDots /></div>
  <div v-else-if="message?.meta?.action_type === 'plan'">
    <Markdown :content="content" />
    <Planing :planing="message?.meta?.json" />
  </div>
  <div v-else-if="message?.meta?.action_type === 'update_status'">
    <LoadingOutlined />
    <span style="margin-left: 5px">{{ content }}</span>
  </div>
  <!-- ä»£ç ç¼–è¾‘ -->
  <div v-else-if="message?.meta?.action_type === 'coding'">
    <CodingMessage :message="message" />
  </div>
  <!-- åœæ­¢ -->
  <div v-else-if="message?.meta?.action_type === 'stop'" class="stop">
    <Stop /> <span>LemonAI {{ $t("stop_task") }}</span>
  </div>
  <!-- ä»»åŠ¡å¼‚å¸¸ æš‚æ— ç§¯åˆ†-->
  <div v-else-if="message?.meta?.action_type === 'error' && message?.content.includes('Insufficient credits balance')" class="credits">
    <div style="display: flex; align-items: center">
      <ShoppingCartOutlined class="icon" />
      <span>The task has been paused. Please upgrade plan or buy credits to continue.</span>
    </div>
    <a-button type="primary" v-if="route.name != 'share'" @click="handleUpgrade">Upgrade</a-button>
  </div>
  <!-- ä»»åŠ¡å¼‚å¸¸ å®Œæˆ -->
  <div v-else-if="message?.meta?.action_type === 'error'" class="error">
    <span>Task stopped, Please try another task</span>
  </div>

  <Markdown v-else-if="message.role === 'assistant'" :content="content" />
  <span v-else>{{ content }}</span>
  <!-- <span>{{ message }}</span> -->
  <!-- æ–‡ä»¶åˆ—è¡¨ -->
  <div class="file-list" v-if="showFiles">
    <MessageFileList :message="message" :role="message.role" :action_type="message?.meta?.action_type" />
  </div>

  <!-- æœç´¢ç»“æœæŠ½å±‰ -->
  <!-- <SearchResultsDrawer 
    :visible="drawerVisible" 
    :searchResults="searchResults" 
    @close="closeDrawer" 
  /> -->
  
  <!-- æ‰“åˆ† -->
  <!-- {{ message }}
  <div v-if="message?.meta?.action_type === 'finish_summery'">
    <MessageRating :message="message" />
  </div>
   -->
</template>

<script setup>
import { computed, ref, onBeforeUnmount } from "vue";
import { useRoute } from "vue-router";
import Markdown from "@/components/markdown/index.vue";
import LoadingDots from "@/view/lemon/components/LoadingDots.vue";
import { LoadingOutlined, ShoppingCartOutlined } from "@ant-design/icons-vue";
import Planing from "@/view/lemon/message/Planing.vue";
//import MessageRating from "@/view/lemon/components/MessageRating.vue";
import CodingMessage from "@/view/lemon/message/CodingMessage.vue";
import MessageFileList from "@/components/MessageFileList/index.vue";
// import SearchResultsDrawer from "@/view/lemon/message/SearchResultsDrawer.vue";
import Stop from "@/assets/message/stop.svg";
import Failure from "@/assets/message/failure.svg";
import emitter from "@/utils/emitter";

const route = useRoute();
const isUnmounted = ref(false);

// æ‚¬æµ®æç¤ºæ¡†çŠ¶æ€
const tooltip = ref({
  visible: false,
  x: 0,
  y: 0,
  title: '',
  url: '',
  currentUrl: '' // å½“å‰æ‚¬åœçš„URL
});

// æŠ½å±‰çŠ¶æ€
const drawerVisible = ref(false);

let hideTimer = null;


const props = defineProps({
  message: {
    type: Object,
    required: true,
  },
});

const showFiles = computed(() => {
  //, "chat"
  const actions = new Set(["finish_summery", "question", "progress"]);
  return actions.has(props.message?.meta?.action_type);
});

const content = computed(() => {
  return props.message.content;
});

// è§£ææœç´¢ç»“æœ
const searchResults = computed(() => {
  //docset_id
  if (isUnmounted.value) return [];
  console.log("searchResults", props.message);
  
  // æ£€æŸ¥æ˜¯å¦æœ‰metaæ•°æ®
  if (!props.message?.meta) return [];
  
  // å…ˆè§£æmeta.jsonæ•°æ®
  let parsedMeta = null;
  try {
    if (typeof props.message.meta === 'string') {
      parsedMeta = JSON.parse(props.message.meta);
    } else {
      parsedMeta = props.message.meta;
    }
  } catch (error) {
    console.warn('Failed to parse meta:', error);
    return [];
  }
  
  // æ£€æŸ¥æ˜¯å¦ä¸ºchatç±»å‹ä¸”æœ‰jsonæ•°æ®
  if (parsedMeta?.action_type === 'chat' && parsedMeta?.json) {
    try {
      let jsonData = parsedMeta.json;
      
      // å¦‚æœjsonæ˜¯å­—ç¬¦ä¸²ï¼Œå…ˆè§£ææˆå¯¹è±¡
      if (typeof jsonData === 'string') {
        jsonData = JSON.parse(jsonData);
      }
      
      // æ£€æŸ¥è§£æåçš„æ•°æ®æ˜¯å¦ä¸ºæ•°ç»„
      if (Array.isArray(jsonData)) {
        console.log('Parsed JSON:', jsonData);
        // è¿‡æ»¤æ‰åŒ…å« docset_id çš„é¡¹
        return jsonData.filter(item => !item.hasOwnProperty('docset_id'));
      }
      
      // å¦‚æœä¸æ˜¯æ•°ç»„ï¼Œè¿”å›ç©ºæ•°ç»„
      console.warn('Parsed JSON is not an array:', jsonData);
      return [];
      
    } catch (error) {
      console.warn('Failed to parse search results json:', error);
      return [];
    }
  }
  
  return [];
});

// è§£ææ–‡æ¡£æŸ¥è¯¢ç»“æœ
const documentQueryResult = computed(() => {
  if (isUnmounted.value) return null;
  
  // æ£€æŸ¥æ˜¯å¦æœ‰metaæ•°æ®
  if (!props.message?.meta) return null;
  
  // å…ˆè§£æmetaæ•°æ®
  let parsedMeta = null;
  try {
    if (typeof props.message.meta === 'string') {
      parsedMeta = JSON.parse(props.message.meta);
    } else {
      parsedMeta = props.message.meta;
    }
  } catch (error) {
    console.warn('Failed to parse meta:', error);
    return null;
  }
  
  // æ£€æŸ¥æ˜¯å¦ä¸ºchatç±»å‹ä¸”æœ‰jsonæ•°æ®
  if (parsedMeta?.action_type === 'chat' && parsedMeta?.json) {
    try {
      let jsonData = parsedMeta.json;
      
      // å¦‚æœjsonæ˜¯å­—ç¬¦ä¸²ï¼Œå…ˆè§£ææˆå¯¹è±¡
      if (typeof jsonData === 'string') {
        jsonData = JSON.parse(jsonData);
      }
      
      // æ£€æŸ¥æ˜¯å¦ä¸ºæ•°ç»„å¹¶æ‰¾åˆ°document_queryç±»å‹çš„é¡¹
      if (Array.isArray(jsonData)) {
        const docQueryItem = jsonData.find(item => 
          item.result_type === 'document_query' && item.docset_id
        );
        
        if (docQueryItem) {
          return {
            query: docQueryItem.query
          };
        }
      }
      
    } catch (error) {
      console.warn('Failed to parse document query json:', error);
      return null;
    }
  }
  
  return null;
});

// æ ¼å¼åŒ–URLæ˜¾ç¤º
const formatUrl = (url) => {
  try {
    const urlObj = new URL(url);
    return urlObj.hostname;
  } catch {
    return url;
  }
};


// è·å–ç½‘ç«™favicon
const getFaviconUrl = (url) => {
  try {
    const urlObj = new URL(url);
    return `https://www.google.com/s2/favicons?domain=${urlObj.hostname}&sz=16`;
  } catch {
    return '';
  }
};

// å¤„ç†å›¾ç‰‡åŠ è½½é”™è¯¯
const handleImageError = (event) => {
  const img = event.target;
  const fallbackIcon = img.nextElementSibling;
  if (img && fallbackIcon) {
    img.style.display = 'none';
    fallbackIcon.style.display = 'flex';
  }
};

// æ˜¾ç¤ºæ‚¬æµ®æç¤ºæ¡†
const showTooltip = (event, result) => {
  if (isUnmounted.value) return;
  
  // æ¸…é™¤éšè—å®šæ—¶å™¨
  if (hideTimer) {
    clearTimeout(hideTimer);
    hideTimer = null;
  }
  
  const rect = event.currentTarget.getBoundingClientRect();
  tooltip.value = {
    visible: true,
    x: rect.left + rect.width / 2,
    y: rect.top - 10,
    title: result.title || 'Unknown Site',
    url: formatUrl(result.url),
    currentUrl: result.url
  };
};

// éšè—æ‚¬æµ®æç¤ºæ¡†ï¼ˆå»¶è¿Ÿæ‰§è¡Œï¼‰
const hideTooltip = () => {
  hideTimer = setTimeout(() => {
    tooltip.value.visible = false;
  }, 100); // 100mså»¶è¿Ÿ
};

// å–æ¶ˆéšè—æ‚¬æµ®æç¤ºæ¡†
const cancelHideTooltip = () => {
  if (hideTimer) {
    clearTimeout(hideTimer);
    hideTimer = null;
  }
};

// æ‰“å¼€æŠ½å±‰
const openDrawer = (message) => {
  // if (!isUnmounted.value) {
  //   drawerVisible.value = true;
  // }
  emitter.emit("preview-new",{message});
};

// å…³é—­æŠ½å±‰
const closeDrawer = () => {
  drawerVisible.value = false;
};

// æ‰“å¼€URL
const openUrl = (url) => {
  if (url && !isUnmounted.value) {
    window.open(url, '_blank', 'noopener,noreferrer');
  }
};

// ç”Ÿå‘½å‘¨æœŸé’©å­
onBeforeUnmount(() => {
  isUnmounted.value = true;
  tooltip.value.visible = false;
  drawerVisible.value = false;
  if (hideTimer) {
    clearTimeout(hideTimer);
    hideTimer = null;
  }
});


//å‡çº§ emitter
const handleUpgrade = () => {
  emitter.emit("showUpgrade");
};

// æ–‡æ¡£æŸ¥è¯¢ç‚¹å‡»äº‹ä»¶
const handleDocumentQueryClick = (message) => {
  emitter.emit("preview-new",{message});
};
</script>

<style lang="scss" scoped>
// code {
//   max-width: 600px;
// }

// Document query result styles
.document-query-result {
  margin-bottom: 12px;
  padding: 8px 12px;
  background-color: rgba(55, 53, 47, 0.0392156863);
  border: 1px solid rgba(0, 0, 0, 0.0392156863);
  border-radius: 15px;
  cursor: pointer;
}

.document-query-info {
  display: flex;
  align-items: center;
  gap: 6px;
  
  .document-icon {
    font-size: 14px;
  }
  
  .document-text {
    color: #595959;
    font-size: 13px;
    font-weight: 500;
  }
}

.stop {
  display: flex;
  width: 100%;
  color: #efa201;
  padding-top: 5px;
  padding-bottom: 5px;
  border-radius: 100px;
  gap: 0.375rem;
  padding-left: 0.75rem;
  padding-right: 0.75rem;
  background-color: #efa2011f;
  line-height: 18px;
  font-size: 13px;
  align-items: center;
  svg {
    min-width: 16px;
    min-height: 16px;
  }
}

.file-list {
  line-height: 0px !important;
}

.error {
  display: flex;
  justify-content: center;
  width: 100%;
  color: #666;
  padding-top: 5px;
  padding-bottom: 5px;
  border-radius: 100px;
  gap: 0.5rem;
  padding-left: 0.75rem;
  padding-right: 0.75rem;
  background-color: rgba(55, 53, 47, 0.0392156863);
  line-height: 18px;
  font-size: 13px;
  align-items: center;
}

.credits {
  display: flex;
  align-items: center;
  color: #1a1a19;
  background-color: #fff; /* æ›´æµ…çš„é»„è‰²èƒŒæ™¯ */
  padding: 10px 14px;
  border-radius: 10px;
  border: 1px solid rgba(55, 53, 47, 0.0392156863); /* æ·»åŠ è¾¹æ¡† */
  font-size: 13px;
  line-height: 1.5;
  gap: 8px;
  width: 100%;
  justify-content: space-between;
  // box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  box-sizing: border-box;
}

.icon {
  font-size: 21px;
  color: #1a1a19;
  flex-shrink: 0;
  border-radius: 21px;
  padding: 5px;
}

// Web search results compact styles
.web-search-results-compact {
  margin-bottom: 12px;
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 8px 12px;
  cursor: pointer;
  background-color: rgba(55, 53, 47, 0.0392156863);
  border: 1px solid rgba(0, 0, 0, 0.0392156863);
  border-radius: 15px;
}

.search-results-icons {
  display: flex;
  align-items: center;
  position: relative;
  height: 24px;
}

.result-icon-item {
  position: relative;
  width: 20px;
  height: 20px;
  margin-left: -6px;
  cursor: pointer;
  transition: all 0.2s ease;
  border-radius: 50%;
  overflow: hidden;
  border: 2px solid #fff;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12);
  
  &:first-child {
    margin-left: 0;
  }
  
  &:hover {
    transform: translateY(-2px) scale(1.1);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
  }
  
  .favicon-img {
    width: 20px;
    height: 20px;
    display: block;
    object-fit: cover;
    border-radius: 50%;
  }
  
  .fallback-icon {
    display: none;
    font-size: 12px;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: #f0f0f0;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    line-height: 20px;
    text-align: center;
  }
}

.more-count {
  position: relative;
  width: 24px;
  height: 24px;
  margin-left: -6px;
  background: linear-gradient(135deg, #1890ff, #40a9ff);
  color: white;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 10px;
  font-weight: 600;
  border: 2px solid #fff;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12);
}

.search-results-info {
  display: flex;
  align-items: center;
  gap: 6px;
  flex: 1;
  
  .search-icon {
    font-size: 14px;
  }
  
  .search-text {
    color: #595959;
    font-size: 13px;
    font-weight: 500;
  }
}

// è‡ªå®šä¹‰æ‚¬æµ®æç¤ºæ¡†æ ·å¼
.custom-tooltip {
  position: fixed;
  z-index: 9999;
  background: white;
  border: 1px solid rgba(0, 0, 0, 0.0588235294);
  color: #34322d;
  padding: 8px 12px;
  border-radius: 6px;
  font-size: 12px;
  max-width: 280px;
  min-width: 150px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  transform: translateX(-50%) translateY(-100%);
  backdrop-filter: blur(10px);
  cursor: pointer;
  transition: all 0.2s ease;
  
  &::after {
    content: '';
    position: absolute;
    top: 100%;
    left: 50%;
    transform: translateX(-50%);
    border: 5px solid transparent;
  }
}

.tooltip-title {
  font-weight: 600;
  margin-bottom: 4px;
  line-height: 1.3;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  line-clamp: 2;
  -webkit-box-orient: vertical;
  overflow: hidden;
}

.tooltip-url {
  color: #34322d;
  /** ä¸‹æ»‘çº¿ */
  text-decoration: underline;
  font-weight: 500;
  margin-bottom: 4px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.tooltip-hint {
  color: #bfbfbf;
  font-size: 11px;
  font-style: italic;
}

</style>



================================================
FILE: frontend/src/view/lemon/message/Observation.vue
================================================
<template>
  <div>
    <!-- {{ action }} -->
    <div class="think" v-if="action.status == 'running'">
      <LoadingOutlined />
      <span style="margin-left: 5px">{{ command }} {{ information }}</span>
    </div>
    <div class="observation" :class="status" @click="togglePreview" v-else>
      <div class="observation-details" v-if="information">
        <div class="command-output">
          <component :is="iconComponent" />
          <div class="command-output-text">{{ command }} {{ information }}</div>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup>
import { computed } from "vue";
import { useI18n } from "vue-i18n";
import Message from "./Message.vue";
import emitter from "@/utils/emitter";
import Browse from "@/assets/message/browse.svg";
import Edit from "@/assets/message/edit.svg";
import Bash from "@/assets/message/bash.svg";
import Think from "@/assets/message/think.svg";
import Tools from "@/assets/message/tools.svg";
import { LoadingOutlined } from "@ant-design/icons-vue";
import { message } from "ant-design-vue";

const { t } = useI18n();

const props = defineProps({
  action: {
    type: Object,
    required: true,
  },
});

const actionTypeDescriptions = {
  terminal_run: t("lemon.message.runCommand"),
  read_code: t("lemon.message.readFile"),
  write_code: t("lemon.message.editFile"),
  browser: t("lemon.message.browsing"),
  web_search: t("lemon.message.searching"),
  read_file: t("lemon.message.readFile"),
  mcp_tool: "MCP",
};
const svgHash = {
  browse: Browse,
  write_code: Edit,
  terminal_run: Bash,
  read_code: Edit,
  read_file: Edit,
  web_search: Browse,
  browser: Browse,
  mcp_tool: Bash,
};

const command = computed(() => {
  const actionType = props.action.meta.action_type;
  return actionTypeDescriptions[actionType] || "";
});

const iconComponent = computed(() => {
  const actionType = props.action.meta.action_type;
  return svgHash[actionType] || Tools; // ä½¿ç”¨Toolsä½œä¸ºé»˜è®¤çš„å·¥å…·è°ƒç”¨å›¾æ ‡
});

const information = computed(() => {
  if (props.action.meta.action_type == "terminal_run") {
    return props.action.content[0];
  }
  return props.action.content;
});

const togglePreview = () => {
  emitter.emit("preview", { message: props.action });
};
</script>

<style lang="scss" scoped>
.observation {
  max-width: calc(100% - 16px);
  margin: 8px 0;
  padding: 4px 12px;
  cursor: pointer;
  background-color: #37352f0a;
  border: 1px solid #0000000a;
  border-radius: 15px;
  font-size: 14px;

  .observation-header {
    min-width: 200px;
    padding: 8px 12px;
    background-color: #f5f5f5;
    cursor: pointer;
    display: flex;
    justify-content: space-between;
    align-items: center;

    &:hover {
      background-color: #eee;
    }
  }

  .command-preview {
    font-family: monospace;
    margin-right: 12px;
  }

  .expand-icon {
    font-size: 12px;
    color: #666;
  }

  .observation-details {
    .command-output {
      margin: 0;
      white-space: pre-wrap;
      font-family: monospace;
      font-size: 14px;
      display: flex !important;
    }

    .command-output-text {
      width: calc(100% - 1rem);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
  }
}
</style>



================================================
FILE: frontend/src/view/lemon/message/Planing.vue
================================================
<template>
    <div class="planing">
        <div class="planing-item" v-for="(item, index) in planing" :key="item.id">
            <!-- {{ item }} -->
            <div class="planing-item-content" v-if="item.status && item.status != 'pending' ">
                <div class="planing-item-content-icon" :class="{
                    running: item.status === 'pending' || item.status === 'running',
                    error: item.status === 'failure'
                }">
                    <Success v-if="item.status == 'success' || item.status == 'completed' " />
                    <Failure v-if="item.status == 'failure'" />

                </div>
                <span class="planing-item-content-description">{{ item.description }}</span>
                <div class="planing-item-content-collapse" :class="{ 'rotate-180': item.is_collapse }"
                    @click="toggleCollapse(item)">
                    <Collapse />
                </div>
            </div>
            <div class="loading" style="margin-top: 5px;" v-if="item.is_collapse && item.status && item.status == 'running' && (!item.actions || item.actions.length == 0)">
                <LoadingOutlined/><span>{{ $t('thinking') }}</span>
            </div>
            <div class="sub_planing" v-if="item.is_collapse && item.actions && item.actions.length > 0">
                <!-- å‚ç›´è™šçº¿ v-if="index !== planing.length - 1" åˆ¤æ–­æ˜¯å¦æœ‰ border-->
                <div 
                    class="sub_planing-item-line" 
                    :class="{ 
                        'noborder': ( index == planing.length - 1 || item.status === 'running' )
                    }">
                    <div></div>
                </div>
                <div class="sub_planing-item-content">
                    <div class="sub_planing-item" v-for="(subItem,subIndex) in item.actions" :key="subItem.id">
                        <div class="sub_planing-item-action">
                            <Observation :action="subItem" v-if="subItem.content!=''" />
                        </div>
                        <div class="loading" v-if="subItem.status!='running' && subIndex== item.actions.length-1 && item.status=='running'">
                            <LoadingOutlined/><span>{{ $t('thinking') }}</span>
                        </div>
                    </div>
                   
                </div>

            </div>
            <!-- è™šçº¿ æœ€åä¸€ä¸ªä¸æ˜¾ç¤º -->
            <div class="planing-item-line" v-if="index !== planing.length - 1 && item.status && item.status != 'pending' ">
                <div></div>
            </div>
            <div class="planing-item-err" v-if="item.status == 'failure'">
                <div class="planing-item-line" :class="{ 'noborder': ( index == planing.length - 1 || item.status === 'running' ) }">
                    <div></div>
                </div>
                <div>
                    <a-alert v-if="item.meta.json.comments.indexOf('Insufficient credits balance') == -1" :message="item.meta.json.comments" type="error" />
                </div>
            </div>


        </div>
    </div>
</template>

<script setup>
import Success from '@/assets/message/success.svg'
import Failure from '@/assets/message/failure.svg'
import Collapse from '@/assets/message/collapse.svg'
import Observation from './Observation.vue'
import { LoadingOutlined } from '@ant-design/icons-vue';
import { formatTime } from '@/utils/time';
import { useI18n } from 'vue-i18n';

const { t } = useI18n();
//complete.svg

import { onMounted } from 'vue'

const props = defineProps({
    planing: {
        type: Array,
        required: true
    }
})

//é»˜è®¤ item.is_collapse ä¸º true

onMounted(() => {
    props.planing.forEach(item => {
        item.is_collapse = true
    })
})


const toggleCollapse = (item) => {
    console.log(item)
    item.is_collapse = !item.is_collapse
}

const isLastPending = (item, index) => {
    const lastPendingIndex = this.planing
      .map((item, idx) => item.status === 'pending' ? idx : -1)
      .filter(idx => idx !== -1)
      .pop(); // è·å–æœ€åä¸€ä¸ªç¬¦åˆæ¡ä»¶çš„ç´¢å¼•

    return index === lastPendingIndex;
}



</script>

<style scoped lang="scss">

.loading{
    font-size: 14px;
    span{
        margin-left: 5px;
    }
}
.planing {
    margin-top: 12px;
    display: flex;
    flex-direction: column;
}

.planing-item-content {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.planing-item-content-icon {
    color: #fff;
    background-color: #b9b9b7;
    border: 1px solid #0000001f;
    border-radius: 15px;
    width: 1rem;
    height: 1rem;
    display: flex;
    align-items: center;
    justify-content: center;
}

.planing-item-content-description{
    width: calc(100% - 1rem - 32px);
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.planing-item-err-icon {
    width: 1rem;
    height: 1rem;
    display: flex;
    align-items: center;
    justify-content: center;
}

.planing-item-err {
    display: flex;
    font-size: 14px;
    padding-bottom: 8px;
}



.running {
    background-color: #fff !important;
}

.error {
    background-color: #f25a5a !important;
}

.planing-item-content-collapse {
    width: 1rem;
    height: 1rem;
    cursor: pointer;



    display: inline-block;
    transition: transform 0.3s ease-in-out;
    /* æ·»åŠ å¹³æ»‘åŠ¨ç”» */
}

.planing-item-line {
    width: 16px;
    min-width: 16px;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;

    div {
        border: 1px dashed #0000001f;
        height: 100%;
    }
}

.sub_planing {
    display: flex;
    flex-direction: row;
    gap: 0.5rem;
}

.sub_planing-item {
    display: flex;
    flex-direction: column;
    gap: .75rem;
    color: #535350;
    font-size: 14px;
}

.sub_planing-item-line {
    width: 16px;
    min-width: 16px;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;

    div {
        border: 1px dashed #0000001f;
        height: 100%;
    }
}

.noborder {
    div {
        border: unset !important;
    }
}

.sub_planing-item-content {
    padding: 12px 0px;
    width: calc(100% - 16px);
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}

/* æ—‹è½¬ 180 åº¦çš„æ ·å¼ */
.rotate-180 {
    transform: rotate(180deg);

    display: flex;
    justify-content: center;
    align-content: center;
    align-items: center;
}

.planing-item-content-time {
    font-size: 12px;
    color: #858481;
    position: absolute;
    right: 0px;
    display: none;
}

.sub_planing-item-action-item {
    display: flex;
    flex-direction: row;
    align-items: center;

    .sub_planing-item-action-item-time {
        font-size: 12px;
        color: #858481;
        position: absolute;
        right: 0px;
        display: none;
    }
}

@media (hover: hover) {
    .planing-item-content:hover {
        .planing-item-content-time {
            display: block;
        }
    }

    .sub_planing-item-action-item:hover {
        .sub_planing-item-action-item-time {
            display: block;
        }
    }
}
</style>


================================================
FILE: frontend/src/view/menu/FooterSocial.vue
================================================
<template>
  <div class="footer-social">
    <a-tooltip title="Homepage">
      <a :href="homepageUrl" target="_blank" rel="noopener noreferrer" class="home-icon" >
        <HomeIcon />
      </a>
    </a-tooltip>

    <a-tooltip title="Email">
      <a :href="emailLink" target="_blank" rel="noopener noreferrer" class="email-icon" >
        <EmailIcon />
      </a>
    </a-tooltip>

    <a-tooltip title="Discord">
      <a :href="discordUrl" target="_blank" rel="noopener noreferrer" class="discord-icon" >
        <img :src="DiscordImage" alt="Discord" />
      </a>
    </a-tooltip>

    <a-tooltip title="Documentation">
      <a :href="docsUrl" target="_blank" rel="noopener noreferrer" class="doc-icon" >
        <DocIcon />
      </a>
    </a-tooltip>
  </div>
</template>

<script setup>
import { computed } from 'vue'
import HomeIcon from '@/assets/svg/home-icon.svg'
import EmailIcon from '@/assets/svg/email-icon.svg'
import DocIcon from '@/assets/svg/doc-icon.svg'
import DiscordImage from '@/assets/image/discord.png'

const homepageUrl = import.meta.env.VITE_HOMEPAGE_URL || 'https://www.lemonai.cc'
const email = import.meta.env.VITE_EMAIL || 'feedback@lemonai.cc'
const discordUrl = import.meta.env.VITE_DISCORD_URL || 'https://discord.gg/gjEXg4UBR4'
const docsUrl = import.meta.env.VITE_DOCS_URL || 'https://lemon-11.gitbook.io/lemonai'

const emailLink = computed(() => `mailto:${email}`)
</script>

<style scoped lang="less">
.footer-social {
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: space-around;
  border-top: 1px solid #E0E0E0;
  height: 48px;
}

.home-icon svg {
  width: 20px;
  height: 20px;
}
.email-icon svg {
  width: 18px;
  height: 18px;
}
.discord-icon{
  width: 20px;
  height: 16px;

  img {
    width: 100%;
    height: 100%;
    object-fit: contain;
  }
}

.doc-icon svg {
  width: 18px;
  height: 18px;

}
</style>



================================================
FILE: frontend/src/view/menu/index.vue
================================================
<!-- LeftMenu.vue -->
<template>
  <div class="left-menu" :class="{ 'menu-visible': isShowMenu, 'menu-collapsed': isMenuCollapsed }" v-show="showMenu && !isMenuCollapsed" @click.self="closeMenu">
    <!-- æ”¶èµ·æŒ‰é’® -->
    <div class="collapse-button" @click="toggleMenuCollapse">
      <ChevronLeft />
    </div>

    <!-- å·¦ä¾§èœå•é¢æ¿ -->
    <div class="menu-panel">
      <!-- Logo -->
      <div class="menu-header">
        <Logo />
      </div>

      <!-- èœå•æ“ä½œæŒ‰é’® -->
      <div class="menu-actions">
        <div
          v-for="item in menuItems"
          :key="item.mode"
          class="menu-button"
          :class="{
            active: !item.isAgentsHistory && (item.isStore ? isStorePage : (!isStorePage && currentWorkMode === item.mode)),
            'no-hover': item.isAgentsHistory
          }"
          @click="handleMenuClick(item)"
          @mouseenter="item.showTooltip = true"
          @mouseleave="item.showTooltip = false"
        >
          <component :is="item.icon" />
          <span class="truncate">{{ item.label }}</span>
          <span v-if="item.isNew" class="new-badge">new</span>
          <component
            v-if="item.rightIcon"
            :is="item.rightIcon"
            class="right-icon"
            @click.stop="openAgentSearch"
          />
          <div v-if="item.showTooltip && item.description != '' " class="menu-tooltip">
            {{ item.description }}
          </div>
        </div>
      </div>

      <!-- Agent åˆ—è¡¨ï¼ˆå¯æ»šåŠ¨åŒºåŸŸï¼‰ -->
      <div class="agent-list-container">
        <AgentList ref="agentListRef" />
      </div>

      <!-- åº•éƒ¨ç”¨æˆ·åŒºåŸŸ -->
      <div class="menu-bottom">
        <UserVersion :isCollapsed="isCollapsed" :chats="chats" />
      </div>
      <FooterSocial />
    </div>
  </div>

  <!-- æ”¶èµ·çŠ¶æ€ä¸‹çš„å±•å¼€æŒ‰é’® -->
  <div class="expand-button" v-if="isMenuCollapsed && !isMobile" @click="toggleMenuCollapse">
    <ChevronRight />
  </div>

  <!-- äºŒçº§èœå• -->
  <div class="second-menu">
    <secondMenu :chats="chatList" />
  </div>

  <!-- ç¼–è¾‘å¼¹çª— -->
  <AgentsEdit v-model:visible="visible" id="" />
</template>

<script setup>
// SVG ç»„ä»¶å¯¼å…¥
import Store from '@/assets/svg/store.svg'
import TwinsChat from '@/assets/svg/twins-chat.svg'
import SuperAgent from '@/assets/svg/super-agent.svg'
import AiChat from '@/assets/svg/ai-chat.svg'
import Adaptive from '@/assets/svg/adaptive.svg'
import ChevronLeft from '@/assets/svg/chevron-left.svg'
import ChevronRight from '@/assets/svg/chevron-right.svg'
import AgentsHistoryIcon from '@/assets/svg/agents-history-icon.svg'
import SearchAgentsIcon from '@/assets/svg/search-agents-icon.svg'

// ç»„ä»¶å¯¼å…¥
import Logo from '@/components/logo.vue'
import AgentList from '@/view/agents/index.vue'
import AgentsEdit from '@/view/agents/components/agentsEdit.vue'
import secondMenu from './secondMenu.vue'
import UserVersion from './UserVersion.vue'
import FooterSocial from './FooterSocial.vue'

// Store & Vue
import { storeToRefs } from 'pinia'
import { useChatStore } from '@/store/modules/chat'
import { useUserStore } from '@/store/modules/user.js'
import emitter from '@/utils/emitter'
import { ref, computed, onMounted, onUnmounted, watch } from 'vue'
import { useRouter, useRoute } from 'vue-router'

const router = useRouter()
const route = useRoute()
const chatStore = useChatStore()
const { agent, mode } = storeToRefs(chatStore)

const selectedMenu = ref('task')
const visible = ref(false)
const isShowMenu = ref(false) // ç§»åŠ¨ç«¯èœå•æ˜¾ç¤ºçŠ¶æ€,é»˜è®¤éšè—
const isMenuCollapsed = ref(false) // èœå•æ”¶èµ·çŠ¶æ€
const chats = ref([])
const currentWorkMode = ref(localStorage.getItem('workMode') || 'auto') // å½“å‰å·¥ä½œæ¨¡å¼
const agentListRef = ref(null) // AgentList ç»„ä»¶å¼•ç”¨




// èœå•é¡¹é…ç½®
const menuItems = ref([
  {
    mode: 'twins',
    label: 'Twins Chat',
    icon: TwinsChat,
    description: 'Dual AI perspective',
    showTooltip: false,
    isStore: false,
    isNew: true // æ ‡è®°ä¸ºæ–°åŠŸèƒ½
  },
  {
    mode: 'task',
    label: 'Evolving Agent',
    icon: SuperAgent, // æš‚æ—¶ä½¿ç”¨ SuperAgent å›¾æ ‡ï¼Œåç»­æ›¿æ¢
    description: 'Goal-driven, Self-improving',
    showTooltip: false,
    isStore: false
  },
  {
    mode: 'chat',
    label: 'AI Chat',
    icon: AiChat,
    description: 'Instant Q&A',
    showTooltip: false,
    isStore: false
  },
  {
    mode: 'auto',
    label: 'Adaptive',
    icon: Adaptive, // æš‚æ—¶ä½¿ç”¨ SuperAgent å›¾æ ‡ï¼Œåç»­æ›¿æ¢
    description: 'Smart routing',
    showTooltip: false,
    isStore: false
  },
  {
    mode: 'store',
    label: 'Agent Store',
    icon: Store,
    description: '',
    showTooltip: false,
    isStore: true
  },
  {
    mode: 'agentsHistory',
    label: 'Agents History',
    icon: AgentsHistoryIcon,
    rightIcon: SearchAgentsIcon,
    description: '',
    showTooltip: false,
    isStore: false,
    isAgentsHistory: true
  }
])



// åˆ¤æ–­å½“å‰æ˜¯å¦åœ¨ Store æˆ– UserCase é¡µé¢
const isStorePage = computed(() => route.path === '/store')
const isUserCasePage = computed(() => route.path === '/userCase')

// å“åº”å¼åˆ¤æ–­ç§»åŠ¨ç«¯
const isMobile = ref(window.innerWidth <= 768)
const handleResize = () => {
  const newIsMobile = window.innerWidth <= 768
  // å¦‚æœä»ç§»åŠ¨ç«¯åˆ‡æ¢åˆ°PCç«¯ï¼Œå…³é—­ç§»åŠ¨ç«¯èœå•
  if (isMobile.value && !newIsMobile && isShowMenu.value) {
    isShowMenu.value = false
  }
  isMobile.value = newIsMobile
}


watch(currentWorkMode, (newVal) => {
  // å·¥ä½œæ¨¡å¼å˜åŒ–æ—¶çš„å¤„ç†é€»è¾‘
})

onMounted(() => {
  selectedMenu.value = localStorage.getItem('mode') || 'task'
  currentWorkMode.value = localStorage.getItem('workMode') || 'auto'
  window.addEventListener('resize', handleResize)

  // ç›‘å¬ç§»åŠ¨ç«¯èœå•åˆ‡æ¢äº‹ä»¶
  emitter.on('toggleMobileMenu', toggleMobileMenu)

  // ç›‘å¬å·¥ä½œæ¨¡å¼æ›´æ–°äº‹ä»¶
  emitter.on('updateWorkMode', (workMode) => {
    currentWorkMode.value = workMode
  })
})
onUnmounted(() => {
  window.removeEventListener('resize', handleResize)
  emitter.off('toggleMobileMenu', toggleMobileMenu)
  emitter.off('updateWorkMode')
})

const showMenu = computed(() => {
  return !isMobile.value || isShowMenu.value
})

function changeMode(modeType) {
  closeOtherWindows()
  selectedMenu.value = modeType
  mode.value = modeType
  const oldMode = localStorage.getItem('mode')
  if (oldMode !== modeType) {
    localStorage.setItem('mode', modeType)
    agent.value = {}
    chatStore.conversationId = null
  }

  if (modeType === 'task') {
    emitter.emit('close-collapse')
    chatStore.clearAgent()
  } else {
    chatStore.init(modeType)
  }
  
  // ç§»åŠ¨ç«¯æ“ä½œåå…³é—­èœå•
  if (isMobile.value && isShowMenu.value) {
    isShowMenu.value = false
    emitter.emit('mobileMenuStateChange', false)
  }
  
  router.push('/lemon')
}

// æ–°å¢å‡½æ•°ï¼šåŒæ—¶è®¾ç½®æ¨¡å¼å’Œå·¥ä½œæ¨¡å¼
function changeModeWithWorkMode(modeType, workMode) {
  closeOtherWindows()
  selectedMenu.value = modeType
  mode.value = modeType
  const oldMode = localStorage.getItem('mode')
  if (oldMode !== modeType) {
    localStorage.setItem('mode', modeType)
    agent.value = {}
    chatStore.conversationId = null
  }

  // è®¾ç½®å·¥ä½œæ¨¡å¼åˆ° localStorageï¼Œä¾› ChatInput è¯»å–
  const oldValue = localStorage.getItem('workMode')
  localStorage.setItem('workMode', workMode)
  currentWorkMode.value = workMode // æ›´æ–°å½“å‰å·¥ä½œæ¨¡å¼çŠ¶æ€

  // æ‰‹åŠ¨è§¦å‘ storage äº‹ä»¶ï¼ˆå› ä¸ºåŒé¡µé¢çš„ localStorage.setItem ä¸ä¼šè§¦å‘ storage äº‹ä»¶ï¼‰
  window.dispatchEvent(new StorageEvent('storage', {
    key: 'workMode',
    newValue: workMode,
    oldValue: oldValue,
    url: window.location.href,
    storageArea: localStorage
  }))

  if (modeType === 'task') {
    emitter.emit('close-collapse')
    chatStore.clearAgent()
  } else {
    chatStore.init(modeType)
  }

  // ç§»åŠ¨ç«¯æ“ä½œåå…³é—­èœå•
  if (isMobile.value && isShowMenu.value) {
    isShowMenu.value = false
    emitter.emit('mobileMenuStateChange', false)
  }

  // å¦‚æœå·²ç»åœ¨ /lemon è·¯ç”±ä¸Šï¼Œç›´æ¥è§¦å‘äº‹ä»¶
  if (router.currentRoute.value.path === '/lemon') {
    // å»¶è¿Ÿä¸€ä¸‹ï¼Œç¡®ä¿ localStorage å’Œ StorageEvent å·²ç»è¢«å¤„ç†
    setTimeout(() => {
      emitter.emit('updateWorkMode', workMode)
    }, 50)
  } else {
    // å¦‚æœä¸åœ¨ /lemon è·¯ç”±ï¼Œå…ˆè·³è½¬å†è§¦å‘äº‹ä»¶
    router.push('/lemon').then(() => {
      // è·¯ç”±è·³è½¬å®Œæˆåï¼Œå»¶è¿Ÿè§¦å‘äº‹ä»¶
      setTimeout(() => {
        emitter.emit('updateWorkMode', workMode)
      }, 300)
    })
  }
}

function toStore() {
  // ç§»åŠ¨ç«¯æ“ä½œåå…³é—­èœå•
  if (isMobile.value && isShowMenu.value) {
    isShowMenu.value = false
    emitter.emit('mobileMenuStateChange', false)
  }
  window.open('https://app.lemonai.ai/store', '_blank')
}

// å¤„ç†èœå•é¡¹ç‚¹å‡»
function handleMenuClick(item) {
  if (item.isStore) {
    toStore()
  } else if (item.isAgentsHistory) {
    // ç‚¹å‡» Agents History è§¦å‘æœç´¢
    openAgentSearch()
  } else {
    changeModeWithWorkMode('task', item.mode)
  }
}

//toUserCase
function toUserCase() {
  // ç§»åŠ¨ç«¯æ“ä½œåå…³é—­èœå•
  if (isMobile.value && isShowMenu.value) {
    isShowMenu.value = false
    emitter.emit('mobileMenuStateChange', false)
  }
  router.push('/userCase')
}

function closeMenu() {
  if (!isMobile.value) return
  isShowMenu.value = false
  // é€šçŸ¥ä¸»å¸ƒå±€èœå•çŠ¶æ€å˜åŒ–
  emitter.emit('mobileMenuStateChange', false)
}

// åˆ‡æ¢ç§»åŠ¨ç«¯èœå•æ˜¾ç¤ºçŠ¶æ€
function toggleMobileMenu(show) {
  if (!isMobile.value) return
  if (typeof show === 'boolean') {
    isShowMenu.value = show
  } else {
    isShowMenu.value = !isShowMenu.value
  }
  // é€šçŸ¥ä¸»å¸ƒå±€èœå•çŠ¶æ€å˜åŒ–
  emitter.emit('mobileMenuStateChange', isShowMenu.value)
}

function closeOtherWindows() {
  emitter.emit('preview-close', false)
  emitter.emit('terminal-visible', false)
  emitter.emit('fullPreviewVisable-close')
}

const chatList = computed(() => chatStore.list)

// åˆ‡æ¢èœå•æ”¶èµ·çŠ¶æ€
const toggleMenuCollapse = () => {
  isMenuCollapsed.value = !isMenuCollapsed.value
}

// æ‰“å¼€ Agent æœç´¢
const openAgentSearch = () => {
  if (agentListRef.value) {
    agentListRef.value.onSearch()
  }
}
</script>

<style scoped lang="less">
.left-menu {
  position: relative;
  display: flex;
  height: 100vh;
  width: 100%;
  z-index: 1000;
  background-color: rgba(0, 0, 0, 0.5);
  transition: opacity 2s ease;

  @media (min-width: 769px) {
    background-color: transparent;
    width: auto;
  }

  /* ç§»åŠ¨ç«¯ï¼šæ¨æ‹‰å¼å¸ƒå±€ */
  @media (max-width: 768px) {
    position: fixed;
    top: 0;
    left: 0;
    bottom: 0;
    width: 80%;
    max-width: 320px;
    background-color: transparent;
    z-index: 1000;
    
    .menu-panel {
      transform: translateX(-100%);
      transition: transform 0.3s ease;
      width: 100%;
    }
    
    /* å½“èœå•æ˜¾ç¤ºæ—¶ï¼Œé¢æ¿æ»‘å…¥ */
    &.menu-visible .menu-panel {
      transform: translateX(0);
    }
  }
}

/* æ”¶èµ·æŒ‰é’® */
.collapse-button {
  position: absolute;
  top: 50%;
  right: 0; /* è´´ç€å³è¾¹ç¼˜ */
  transform: translateY(-50%) translateX(50%); /* å‘å³å¹³ç§»è‡ªèº«å®½åº¦çš„ä¸€åŠ */
  width: 48px;
  height: 48px;
  background-color: rgba(255,255,255,1);
  border: 1px solid rgba(224,224,224,1);
  border-radius: 50%; /* åœ†å½¢ */
  display: flex;
  align-items: center;
  justify-content: flex-end; /* å›¾æ ‡é å³å¯¹é½ */
  padding-right: 8px; /* å›¾æ ‡è·ç¦»å³è¾¹ç¼˜çš„è·ç¦» */
  cursor: pointer;
  z-index: 1001;
  transition: all 0.2s ease;
  clip-path: inset(0 0 0 50%); /* è£å‰ªæ‰å·¦åŠè¾¹ */

  /* ä½¿ç”¨ä¼ªå…ƒç´ é‡æ–°ç»˜åˆ¶å³åŠåœ†çš„è¾¹æ¡† */
  &::before {
    content: '';
    position: absolute;
    top: -1px;
    right: -1px;
    width: 48px;
    height: 48px;
    border: 1px solid rgba(224,224,224,1);
    border-radius: 50%;
    clip-path: inset(0 0 0 50%);
    pointer-events: none;
  }

  svg {
    width: 16px;
    height: 16px;
    color: #9a9a9a;
    transition: color 0.2s ease;
    position: relative;
    z-index: 1;
  }

  &:hover {
    svg {
      color: #333;
    }
  }

  @media (max-width: 768px) {
    display: none;
  }
}

/* å±•å¼€æŒ‰é’® */
.expand-button {
  position: fixed;
  top: 50%;
  left: 0; /* è´´ç€å·¦è¾¹ç¼˜ */
  transform: translateY(-50%) translateX(-50%); /* å‘å·¦å¹³ç§»è‡ªèº«å®½åº¦çš„ä¸€åŠï¼Œè®©å·¦åŠè¾¹éšè— */
  width: 48px;
  height: 48px;
  background-color: rgba(255,255,255,1);
  border: 1px solid rgba(224,224,224,1);
  border-radius: 50%; /* åœ†å½¢ */
  display: flex;
  align-items: center;
  justify-content: flex-end; /* å›¾æ ‡é å³å¯¹é½ */
  padding-right: 8px; /* å›¾æ ‡è·ç¦»å³è¾¹ç¼˜çš„è·ç¦» */
  cursor: pointer;
  z-index: 1001;
  transition: all 0.2s ease;
  clip-path: inset(0 0 0 50%); /* è£å‰ªæ‰å·¦åŠè¾¹ï¼Œä¿ç•™å³åŠè¾¹ */

  /* ä½¿ç”¨ä¼ªå…ƒç´ é‡æ–°ç»˜åˆ¶å³åŠåœ†çš„è¾¹æ¡† */
  &::before {
    content: '';
    position: absolute;
    top: -1px;
    right: -1px;
    width: 48px;
    height: 48px;
    border: 1px solid rgba(224,224,224,1);
    border-radius: 50%;
    clip-path: inset(0 0 0 50%);
    pointer-events: none;
  }

  svg {
    width: 16px;
    height: 16px;
    color: #9a9a9a;
    transition: color 0.2s ease;
    position: relative;
    z-index: 1;
  }

  &:hover {
    svg {
      color: #333;
    }
  }
}

.menu-panel {
  width: 280px;
  height: 100%;
  background-color: rgba(255,255,255,1);
  border: 1px solid rgba(224,224,224,1);
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  position: relative;

  /* è¦†ç›–æ”¶èµ·æŒ‰é’®ä½ç½®çš„è¾¹æ¡† */
  &::after {
    content: '';
    position: absolute;
    top: 50%;
    right: -1px; /* è¦†ç›–å³è¾¹æ¡† */
    transform: translateY(-50%);
    width: 2px; /* è¦†ç›–è¾¹æ¡†å®½åº¦ */
    height: 48px; /* ä¸æŒ‰é’®é«˜åº¦ä¸€è‡´ */
    background-color: rgba(255,255,255,1); /* ä¸é¢æ¿èƒŒæ™¯è‰²ä¸€è‡´ */
    z-index: 1000; /* åœ¨é¢æ¿ä¹‹ä¸Šï¼ŒæŒ‰é’®ä¹‹ä¸‹ */
  }

  @media (max-width: 768px) {
    width: 80%;
    max-width: 320px;
  }
}

.menu-header {
  padding: 8px;
  display: flex;
  justify-content: center;
  align-items: center;
  flex-shrink: 0; /* é˜²æ­¢è¢«å‹ç¼© */
}

.menu-actions {
  padding: 16px 16px 0px 16px;
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: 4px;
  flex-shrink: 0; /* é˜²æ­¢è¢«å‹ç¼© */

  .menu-button {
    position: relative; /* çˆ¶ç›¸å­ç»å®šä½ */
    display: flex;
    align-items: center;
    padding: 10px 13px;
    line-height: 23px;
    border-radius: 12px;
    border: 1px solid transparent; /* æ·»åŠ é€æ˜è¾¹æ¡†ï¼Œé˜²æ­¢å°ºå¯¸å˜åŒ– */
    color: rgba(16,16,16,1);
    font-size: 14px;
    text-align: left;
    font-family: PingFangSC-regular;
    cursor: pointer;
    transition: all 0.2s ease; /* æ·»åŠ è¿‡æ¸¡æ•ˆæœ */

    &:hover {
      border: 1px solid rgba(236,236,236,1);
      background-color: rgba(255,252,240,1);
    }

    &:active {
      border: 1px solid rgba(200,200,200,1); /* æ›´æ·±çš„è¾¹æ¡†è‰² */
      background-color: rgba(255,248,220,1); /* æ›´æ·±çš„èƒŒæ™¯è‰² */
      transform: scale(0.98); /* è½»å¾®ç¼©å°æ•ˆæœ */
    }

    &.active {
      border: 1px solid rgba(236,236,236,1);
      background-color: rgba(255,252,240,1);
    }

    /* ç¦ç”¨ Agents History çš„ hover å’Œ active æ•ˆæœ */
    &.no-hover {
      &:hover {
        border: 1px solid transparent;
        background-color: transparent;
      }

      &:active {
        border: 1px solid transparent;
        background-color: transparent;
        transform: none;
      }

      &.active {
        border: 1px solid transparent;
        background-color: transparent;
      }
    }

    svg{
      width: 20px;
      height: 20px;
      margin-right: 15px;
    }

    .truncate {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      flex: 1;
    }

    /* å³ä¾§å›¾æ ‡ */
    .right-icon {
      width: 18px;
      height: 18px;
      margin-left: auto;
      margin-right: 8px;
      color: rgba(154, 154, 154, 1);
      cursor: pointer;
      transition: all 0.2s ease;
      flex-shrink: 0;

      &:hover {
        color: rgba(16, 16, 16, 1);
        transform: scale(1.1);
      }
    }

    /* new æ ‡è¯† */
    .new-badge {
      position: absolute;
      top: 8px;
      right: 8px;
      padding: 2px 6px;
      background: linear-gradient(135deg, #FF6B6B 0%, #FF8E53 100%);
      color: #fff;
      font-size: 10px;
      font-weight: 600;
      line-height: 14px;
      border-radius: 4px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      box-shadow: 0 2px 4px rgba(255, 107, 107, 0.3);
      animation: pulse 2s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% {
        transform: scale(1);
        opacity: 1;
      }
      50% {
        transform: scale(1.05);
        opacity: 0.9;
      }
    }

    /* æ‚¬æµ®æç¤ºæ¡† */
    .menu-tooltip {
      position: absolute;
      left: 200px; /* é å³ä¸‹è§’æ˜¾ç¤º */
      width: max-content;
      top:50%;
      height: 47px;
      line-height: 20px;
      border-radius: 10px;
      background-color: rgba(255,255,255,1);
      color: rgba(16,16,16,1);
      font-size: 14px;
      text-align: center;
      box-shadow: 0px 2px 6px 0px rgba(177,177,177,0.4);
      font-family: PingFangSC-regular;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 10px;
      z-index: 9999;
      pointer-events: none; /* é˜²æ­¢æç¤ºæ¡†é˜»æŒ¡é¼ æ ‡äº‹ä»¶ */
      animation: fadeIn 0.2s ease;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(5px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
  }
}

/* Agent åˆ—è¡¨å®¹å™¨ï¼ˆå¯æ»šåŠ¨ï¼‰ */
.agent-list-container {
  flex: 1; /* å æ®å‰©ä½™ç©ºé—´ */
  overflow-y: auto; /* å‚ç›´æ»šåŠ¨ */
  overflow-x: hidden;
  min-height: 0; /* é‡è¦ï¼šå…è®¸ flex å­å…ƒç´ ç¼©å° */

  /* æ»šåŠ¨æ¡æ ·å¼ */
  &::-webkit-scrollbar {
    width: 6px;
  }

  &::-webkit-scrollbar-track {
    background: transparent;
  }

  &::-webkit-scrollbar-thumb {
    background-color: rgba(0, 0, 0, 0.1);
    border-radius: 3px;

    &:hover {
      background-color: rgba(0, 0, 0, 0.2);
    }
  }
}

.menu-bottom {
  padding: 16px ;
  display: flex;
  flex-direction: column;
  position: relative;
}

.second-menu {
  flex: 1;
}
</style>



================================================
FILE: frontend/src/view/menu/secondMenu.vue
================================================
<template>
  <div :class="isCollapsed ? 'second-menu' : 'second-menu collapsed'" v-show="!(isPreviewVisible && isMobile())" @click="handleOverlayClick">
    <button class="menu-button" @click.stop="toggleCollapse" v-if="isCollapsed && showCollapse && !(isPreviewVisible && isMobile())">
      <span class="menu-icon">
        <LeftList style="width: 22px; height: 22px;" />
      </span>
    </button>
    <!-- side container -->
    <div class="sidebar-container" v-show="!isCollapsed && showCollapse" @click.stop>
      <div class="sidebar" :class="{ 'collapsed': isCollapsed }">
        <!-- header -->
        <div class="sidebar-header">
          <div class="header-content">
            <!-- <span class="header-title"></span> -->
            <!-- ç§»åŠ¨ç«¯æ˜¾ç¤ºè¿”å›ç®­å¤´ -->
            <button class="collapse-btn mobile-only" @click="handleBackToLemon">
              <ArrowLeftOutlined style="width: 20px; height: 20px;" />
            </button>
            <!-- PCç«¯æ˜¾ç¤ºæ”¶èµ·æŒ‰é’® -->
            <button class="collapse-btn pc-only" @click="toggleCollapse">
              <LeftList style="width: 20px; height: 20px;" />
            </button>
          </div>
        </div>

        <!-- new task -->
        <div class="sidebar-new-task">
          <button class="new-task-button" @click="handleNewChat">
            <span class="plus-icon">
              <Add style="width: 16px; height: 16px;" />
            </span>
            <span v-if="mode == 'task'" class="button-text">New Task</span>
            <span v-else class="button-text">New Chat</span>
          </button>
        </div>

        <!-- sconver -->
        <div class="sidebar-content">
          <div class="chat-list">
             <!-- {{ conversationId }} -->
            <div v-for="chat in chats" :key="chat.conversation_id" class="chat-item"
              :class="{ 'active': chat.conversation_id === conversationId }" @click="handleChatClick(chat)">
              <div class="chat-details">
                <div class="chat-header">
                  <div class="chat-title">{{ chat.title }}</div>
                  <div class="chat-time">{{ formatTime(chat.update_at,t) }}</div>
                </div>
                <div class="chat-last-message" :title="chat.last_message">{{ chat?.latest_message?.content }}</div>
                <div class="chat-footer">
                  <div class="chat-model-info">
                    <div class="chat-model-name" v-if="chat.model_name">
                      {{ chat.model_name }}
                    </div>
                  </div>
                  <div class="more-options">
                    <a-tooltip title="More" placement="top" :arrow="false">
                      <More class="more-options-icon" @click.stop="toggleDropdown(chat.conversation_id)" />
                    </a-tooltip>
                    <div class="more-options-dropdown" @mouseleave="dropdownVisible = null"  v-if="dropdownVisible === chat.conversation_id">
                      <div class="more-options-item" @click.stop="handleEditName(chat)">
                        <Edit />
                        <span class="more-options-item-text">Rename</span>
                      </div>
                      <div class="more-options-item err" @click.stop="showDeleteConfirm(chat)">
                        <Delete />
                        <span class="more-options-item-text">Delete</span>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
            <div v-if="!chats.length" class="no-chats">
              <Chat style="width: 24px; height: 24px;" />
              <span>No Conversation</span>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- delete modal -->
    <a-modal v-model:open="deleteModalVisible" :title="$t('lemon.sidebar.confirmDelete')">
      <p>{{ $t('lemon.sidebar.deleteConfirmation') }}</p>
      <template #footer>
        <a-button @click="handleCancel">{{ $t('lemon.sidebar.cancel') }}</a-button>
        <a-button type="primary" @click="handleDelete">{{ $t('lemon.sidebar.confirm') }}</a-button>
      </template>
    </a-modal>

    <!-- edit modal -->
    <a-modal v-model:open="editModalOpen" title="Edit Title" centered :width="400" :footer="null" class="edit-title-modal">
      <span class="edit-title">Enter new title</span>
      <a-input v-model:value="titleValue" class="edit-title-input" />
      <footer>
        <div class="footer-btn">
          <div class="cancel-btn" @click="handleCancelEdit">Cancel</div>
          <div class="confirm-btn" @click="handleOkEdit">Confirm</div>
        </div>
      </footer>
    </a-modal>

    <!-- search modal -->
    <a-modal v-model:open="searchModalVisible" :footer="null" :centered="true" :closable="false">
      <template #title>
        <div class="search-header">
          <div class="search-header-icon">
            <MenuSearch style="width: 24px; height: 24px;" />
          </div>
          <a-input v-model:value="searchValue" placeholder="Search conversations" />
          <div class="search-header-icon" @click="handleCancel">
            <Close style="width: 24px; height: 24px;" />
          </div>
        </div>
      </template>
      <div class="search-content">
        <div v-for="chat in chats" :key="chat.conversation_id" class="chat-item"
          :class="{ 'active': chat.conversation_id === conversationId }" @click="handleChatClick(chat)">
          <div class="chat-details">
            <div class="chat-header">
              <div class="chat-title">{{ chat.title }}</div>
              <div class="chat-time">{{ formatTime(chat.update_at,t) }}</div>
            </div>
            <div class="chat-footer" v-if="modal == 'task'">
              <div class="chat-last-message" :title="chat.last_message">{{ chat?.latest_message?.content }}</div>
            </div>
          </div>
        </div>
      </div>
    </a-modal>
  </div>
</template>

<script setup>
import { ref, onMounted, computed, watch, onUnmounted } from 'vue'
import { useRouter, useRoute } from 'vue-router'
import { useI18n } from 'vue-i18n'
import { storeToRefs } from 'pinia'
import { ArrowLeftOutlined } from '@ant-design/icons-vue'

import { useChatStore } from '@/store/modules/chat'
import { formatTime } from '@/utils/time'
import emitter from '@/utils/emitter'

import LeftList from '@/assets/svg/leftList.svg'
import Add from '@/assets/svg/add.svg'
import MenuSearch from '@/assets/svg/menuSearch.svg'
import Close from '@/assets/filePreview/close.svg'
import Chat from '@/assets/svg/chat.svg'
import More from '@/assets/svg/more.svg'
import Edit from '@/assets/svg/edit.svg'
import Delete from '@/assets/svg/delete.svg'
const chatStore = useChatStore()
const { chatInfo, agent, conversationId, mode } = storeToRefs(chatStore)
const { t } = useI18n()
const router = useRouter()
const route = useRoute()

const isCollapsed = ref(true)

// define props
const props = defineProps({
  chats: {
    type: Array,
    default: () => [],
  }
});

const showCollapse = ref(false)
const isPreviewVisible = ref(false)

const isMobile = () => {
  return window.innerWidth <= 768
}

function updateCollapse() {
  console.log('route ===== ', route.path.includes('/lemon'))
  if (!route.path.includes('/lemon')) {
    showCollapse.value = false
    return
  }
  showCollapse.value = !!route.params.agentId
}

updateCollapse()

watch(
  () => route.fullPath,
  () => {
    updateCollapse()
  }
)


const emit = defineEmits(['update:isCollapsed', 'selectChat', 'newChat', 'editChat', 'deleteChat'])

const dropdownVisible = ref(null)
const deleteModalVisible = ref(false)
const editModalOpen = ref(false)
const searchModalVisible = ref(false)
const titleValue = ref('')
const chatToDelete = ref(null)
const editChat = ref(null)

const toggleCollapse = () => {
  console.log('toggleCollapse', isCollapsed)
  isCollapsed.value = !isCollapsed.value
}

const handleBackToLemon = () => {
  isCollapsed.value = true
  
  chatStore.conversationId = null
  chatStore.clearMessages()
  
  setTimeout(() => {
    emitter.emit('toggleMobileMenu', true)
  }, 100)
  
  router.push('/lemon')
}

const handleOverlayClick = () => {
  if (isMobile()) {
    console.log('handleOverlayClick')
    closeCollapse()
  }
}

const closeCollapse = () => {
  isCollapsed.value = true
}

const openCollapse = () => {
  isCollapsed.value = false
}

emitter.on('close-collapse', closeCollapse)
emitter.on('open-collapse', openCollapse)

emitter.on('preview', () => {
  console.log('Preview opened, hiding second-menu');
  isPreviewVisible.value = true;
});
emitter.on('preview-close', () => {
  console.log('Preview closed, showing second-menu');
  isPreviewVisible.value = false;
});

//fullPreviewVisable-open
emitter.on('fullPreviewVisable', () => {
  console.log('Preview opened, hiding second-menu');
  isPreviewVisible.value = true;
});

// // fullPreviewVisable-close
emitter.on('fullPreviewVisable-close', () => {
  isPreviewVisible.value = false;
});

onUnmounted(() => {
  emitter.off('close-collapse', closeCollapse);
  emitter.off('open-collapse', openCollapse);
  emitter.off('preview');
  emitter.off('preview-close');
  emitter.off('fullPreviewVisable');
  emitter.off('fullPreviewVisable-close');
});

// process new chat click
const handleNewChat = () => {
  closeOtherWindows();
  chatStore.conversationId = null;
  chatStore.clearMessages();
  if(mode.value === 'task'){
    router.push(`/lemon/${agent.value.id}`);
  }else{
    router.push('/lemon');
  }
  
};

const closeOtherWindows = () => {
  emitter.emit('preview-close', false);
  emitter.emit('terminal-visible', false);
  emitter.emit('fullPreviewVisable-close');
};

// process chat click 
const handleChatClick = (chat) => {
  closeCollapse();
  closeOtherWindows();
  console.log("handleChatClick",chat)
  chatStore.conversationId = chat.conversation_id;
  console.log("chatStore.conversationId",conversationId.value)

  chatStore.chat = chat;
  chatStore.clearMessages();
  chatStore.initConversation(chat.conversation_id);
  if(mode.value == 'chat'){
    router.push(`/lemon/chat/${chat.conversation_id}`);
  }else{
    router.push(`/lemon/${agent.value.id}/${chat.conversation_id}`);
  }
};

const toggleDropdown = (conversationId) => {
  dropdownVisible.value = dropdownVisible.value === conversationId ? null : conversationId;
};

const handleEditName = (chat) => {
  editChat.value = chat;
  titleValue.value = chat.title;
  editModalOpen.value = true;
  dropdownVisible.value = null;
};

const handleOkEdit = () => {
  // if (editChat.value) {
  //   emit('editChat', { ...editChat.value, title: titleValue.value });
  // }
  editModalOpen.value = false;
  editModalOpen.value = false
  chatStore.updateConversationTitleById(titleValue.value, editChat.value.conversation_id);
  editChat.value = null
};

const handleCancelEdit = () => {
  editModalOpen.value = false;
  editChat.value = null;
};

const showDeleteConfirm = (chat) => {
  chatToDelete.value = chat;
  deleteModalVisible.value = true;
  dropdownVisible.value = null;
};

const handleDelete = async () => {
  if (chatToDelete.value) {
    try {
      await chatStore.removeConversation(chatToDelete.value.conversation_id);
      deleteModalVisible.value = false;
      chatToDelete.value = null;
      router.push('/lemon');
    } catch (error) {
      console.error('Failed to delete conversation:', error);
    }
  }
};

const handleCancel = () => {
  deleteModalVisible.value = false;
  searchModalVisible.value = false;
  chatToDelete.value = null;
};

</script>

<style scoped lang="less">
.second-menu {
  display: flex;
  flex-direction: column;
}

.menu-button {
  display: flex;
  top: 1rem;
  // left: 0.75rem;
  background: none;
  border: none;
  cursor: pointer;
  color: #666;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 8px;
  z-index: 11;
  padding: 8px 8px;

  .menu-icon {
    max-height: 20px;
  }

  .icon {
    display: flex;
    align-items: center;
    margin-left: 8px;
    font-size: 18px;
    font-weight: 700;
    color: #111827;

    img {
      width: 24px;
      height: 24px;
      margin-right: 8px;
    }
  }
}

.sidebar-container {
  width: 248px;
  height: 100vh;
  background-color: #ebebeb;
  transition: width 0.3s ease;
}

.sidebar {
  display: flex;
  flex-direction: column;
  width: 100%;
  height: 100%;
  overflow: hidden;

  &.collapsed {
    display: none;
  }
}

.sidebar-header {
  padding: 10px 16px;
  border-bottom: 1px solid #e0e0e0;

  .header-content {
    display: flex;
    justify-content: space-between;
    align-items: center;

    .header-title {
      font-size: 16px;
      font-weight: 600;
    }

    .collapse-btn {
      background: none;
      border: none;
      cursor: pointer;
    }
  }
}

.sidebar-new-task {
  padding: 0.75rem;
}

.new-task-button {
  width: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.375rem;
  border-radius: 0.5rem;
  background-color: white;
  border: 1px solid #e0e0e0;
  cursor: pointer;
  color: #34322d;
  font-size: 14px;
  font-weight: 500;
  box-shadow: 0 0 #0000, 0 0 #0000, 0px 0.5px 3px 0px #00000014;
  height: 36px;

  &:hover {
    background-color: #fafafa;
  }

  .plus-icon {
    width: 1rem;
    height: 1rem;
  }
}

.sidebar-content {
  flex: 1;
  overflow-y: auto;
  padding: 0.5rem 0.5rem 1.25rem 0.5rem;

  &::-webkit-scrollbar {
    width: 5px;
  }

  &::-webkit-scrollbar-thumb {
    background-color: #ddd;
    border-radius: 5px;
  }
}

.chat-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.no-chats {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  height: calc(100vh - 48px - 36px - 120px);
  color: #858481;
}

.chat-item {
  display: flex;
  align-items: center;
  padding: 4px 8px;
  border-radius: 10px;
  cursor: pointer;

  &:hover {
    background-color: #37352f0a;

    .more-options-icon{
      display: block;
    }
  }

  &.active {
    background-color: #fff;
  }
}

.chat-details {
  flex: 1;
  min-width: 0;
}

.chat-header {
  display: flex;
  justify-content: space-between;
  margin-bottom: 4px;
}

.chat-title {
  font-weight: 500;
  font-size: 14px;
  color: #34322d;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.chat-time {
  font-size: 12px;
  color: #999;
  white-space: nowrap;
  margin-left: 8px;
}

.chat-last-message {
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  font-size: 12px;
  color: #858481;
}

.chat-model-name {
  font-size: 12px;
  color: #34322d;
  white-space: nowrap;
}

.chat-footer {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.more-options {
  border-radius: 6px;
  position: relative;
  width: 22px;
  height: 22px;

  .more-options-icon {
    display: none;
  }

  &:hover {
    border: 1px solid #0000000f;
    background-color: #fff;
    display: flex;
    align-items: center;
    justify-content: center;

    .more-options-icon {
      display: block;
    }
  }
}

.more-options-dropdown {
  position: absolute;
  padding: 4px;
  z-index: 9999;
  top: 25px;
  right: -10px;
  min-width: 126px;
  border-radius: 0.75rem;
  border: 1px solid #0000001f;
  background-color: #fff;
  box-shadow: 0 4px 11px 0px #00000014;

  .more-options-item {
    display: flex;
    align-items: center;
    justify-content: start;
    gap: 0.75rem;
    cursor: pointer;
    border-radius: 8px;
    color: #535350;
    font-size: 0.875rem;
    line-height: 1.25rem;
    padding: 0.5rem 0.75rem;

    &.err {
      color: #f25a5a;
    }

    &:hover {
      background-color: #37352f0f;
    }
  }
}

.edit-title {
  font-size: 13px;
  font-weight: 400;
  color: #858481;
}

.edit-title-input {
  margin-top: 10px;
}

.footer-btn {
  display: flex;
  padding-top: 1.25rem;
  gap: 0.5rem;
  justify-content: flex-end;

  .cancel-btn {
    cursor: pointer;
    font-size: 13px;
    font-weight: 400;
    color: #535350;
    padding: 0.5rem 0.75rem;
    border: 1px solid #0000001f;
    border-radius: 10px;
  }

  .confirm-btn {
    cursor: pointer;
    font-size: 13px;
    font-weight: 400;
    background: #1a1a19;
    color: #fff;
    padding: 0.5rem 0.75rem;
    border: 1px solid #ffffff33;
    border-radius: 10px;
  }
}

.search-header {
  display: flex;
  align-items: center;
  gap: 0.625rem;

  input {
    border: none !important;
    color: #34322d;
    font-size: 18px;
    font-weight: 400;
    line-height: 1.75rem;
  }

  .search-header-icon {
    max-width: 24px;
    max-height: 24px;
    min-width: 24px;
    min-height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;

    svg {
      width: 100%;
      height: 100%;
    }
  }
}

/* ç§»åŠ¨ç«¯é€‚é… */
@media (max-width: 768px) {
  .menu-button{
    position: absolute;
    top: 0px;
    left: 0px;
  }

  .second-menu .collapsed{
    position: absolute;
    top: 0px;
    left: 0px;
    background-color: #000000b3;
    width: 100%;
    height: 100%;
    z-index: 9999;
  }

  .sidebar-container{
    width: 80%!important;
  }

  /* ç§»åŠ¨ç«¯æ˜¾ç¤ºè¿”å›æŒ‰é’®ï¼Œéšè—æ”¶èµ·æŒ‰é’® */
  .mobile-only {
    display: block;
  }

  .pc-only {
    display: none;
  }
}

/* PCç«¯é€‚é… */
@media (min-width: 769px) {
  /* PCç«¯éšè—è¿”å›æŒ‰é’®ï¼Œæ˜¾ç¤ºæ”¶èµ·æŒ‰é’® */
  .mobile-only {
    display: none;
  }

  .pc-only {
    display: block;
  }
}



</style>

<style lang="less">
.edit-title-modal {
  .ant-modal-header {
    margin-bottom: 5px !important;
  }

  .ant-modal-content {
    border-radius: 20px !important;
  }
}
</style>


================================================
FILE: frontend/src/view/menu/UserVersion.vue
================================================
<template>
  <div class="user-version-wrapper">
    <div class="user-profile-container" @mouseenter="handleMouseEnter" @mouseleave="handleMouseLeave">
      <div class="user-info-bar">
        <div class="user-avatar" :style="avatarStyle">
          {{ userInitial }}
        </div>
        <div class="user-info-text">
          <span class="user-name">{{ isLoggedIn ? (user.user_name || user.mobile || user.user_email) : 'Offline' }}</span>
          <div class="user-details">
            <div class="points-display" v-if="isLoggedIn">
              <PointsIcon class="points-icon" />
              <span class="points-value">{{ points?.total || 0 }}</span>
              <span class="user-plan">{{ membership?.planName || $t("member.freePlan") }}</span>
            </div>
            <div class="offline-status" v-else>
              <span class="offline-text">Offline Mode</span>
            </div>
            <div class="version-text" @click="handleVersionClick">
              V {{ versionInfo.localVersion }}
            </div>
          </div>
        </div>
      </div>
      <div class="profile-wrapper" v-show="showProfile">
        <UserProFile :isCollapsed="isCollapsed" :chats="chats" />
      </div>
    </div>


  </div>
</template>

<script setup>
import { ref, computed } from 'vue'
import { storeToRefs } from 'pinia'
import { useUserStore } from '@/store/modules/user.js'
import UserProFile from '@/view/auth/components/user-profile.vue'
import PointsIcon from '@/assets/svg/points-icon.svg'

// Props
defineProps({
  isCollapsed: {
    type: Boolean,
    default: false
  },
  chats: {
    type: Array,
    default: () => []
  }
})



import { driver } from "driver.js";
import "driver.js/dist/driver.css";
const delay = ms => new Promise(resolve => setTimeout(resolve, ms));
let tourDriver = null;

const tour = async () => {
  tourDriver = driver({
    animate: true,
    showProgress: false,
    prevBtnText: t('setting.prevStep'),
    nextBtnText: t('setting.nextStep'),
    doneBtnText: t('setting.doneStep'),
    steps: [
      {
        element: '.user-profile-container',
        popover: {
          side: 'top',
          title: t('setting.settingModel'),
          description: t('setting.tourHoverDescription'),
          showButtons: ['next'],
          nextBtnText: t('setting.tourUnderstood'),
          onNextClick: () => {
            // ç»“æŸå¼•å¯¼å¹¶è·³è½¬åˆ°è®¾ç½®é¡µé¢
            localStorage.setItem('tour_end', 'true');
            router.push({ path: '/setting/basic' });
            tourDriver.destroy();
          }
        }
      }
    ]
  });

  tourDriver.drive();
}

// å¤„ç†é¼ æ ‡è¿›å…¥äº‹ä»¶
const handleMouseEnter = () => {
  showProfile.value = true;

  // å¦‚æœç¬¬ä¸€æ­¥å¼•å¯¼æ­£åœ¨è¿›è¡Œä¸­ï¼Œå…³é—­å®ƒ
  if (tourDriver && tourDriver.isActive()) {
    tourDriver.destroy();
  }
}

// å¤„ç†é¼ æ ‡ç¦»å¼€äº‹ä»¶
const handleMouseLeave = () => {
  showProfile.value = false;
}

// User Store
const userStore = useUserStore()
const { user, membership, points } = storeToRefs(userStore)

// Local State
const showProfile = ref(false)

// åˆ¤æ–­ç”¨æˆ·æ˜¯å¦ç™»å½•
const isLoggedIn = computed(() => {
  return !!(user.value && (user.value.user_name || user.value.mobile || user.value.user_email || user.value.id))
})

// è·å–ç”¨æˆ·åé¦–å­—æ¯
const userInitial = computed(() => {
  if (!isLoggedIn.value) {
    return 'O' // Offline çš„é¦–å­—æ¯
  }
  const name = user.value.user_name || user.value.mobile || user.value.user_email || 'U'
  return name.charAt(0).toUpperCase()
})

// æ ¹æ®é¦–å­—æ¯ç”ŸæˆèƒŒæ™¯è‰²
const getAvatarColor = (initial) => {
  // å¦‚æœæœªç™»å½•ï¼Œä½¿ç”¨ç°è‰²
  if (!isLoggedIn.value) {
    return '#9A9A9A'
  }
  const colors = [
    '#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8',
    '#F7DC6F', '#BB8FCE', '#85C1E2', '#F8B739', '#52B788'
  ]
  const index = initial.charCodeAt(0) % colors.length
  return colors[index]
}

const avatarStyle = computed(() => ({
  backgroundColor: getAvatarColor(userInitial.value)
}))

// Version Info
const versionInfo = ref({
  localVersion: '0.5.1',
  latestVersion: '0.5.1',
  isLatest: true,
  updateUrl: 'https://github.com/yu-mengyun/vue-admin-template',
  message: 'the current version is the latest version',
})

// Methods
const handleVersionClick = () => {
  window.open('https://lemon-11.gitbook.io/lemonai/version-update', '_blank')
}
</script>

<style scoped lang="less">
.user-version-wrapper {
  display: flex;
  align-items: flex-end;
  justify-content: space-between;
  margin-top: 16px;
}

.user-profile-container {
  position: relative;
  width: 100%;
}

.user-info-bar {
  display: flex;
  align-items: center;
  gap: 12px;
  cursor: pointer;

  .user-avatar {
    width: 37px;
    height: 37px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    color: #fff;
    font-size: 16px;
    font-weight: 600;
    flex-shrink: 0;
    text-transform: uppercase;
    user-select: none;
    transition: transform 0.2s ease;

    &:hover {
      transform: scale(1.05);
    }
  }

  .user-info-text {
    display: flex;
    flex-direction: column;
    font-size: 12px;
    flex: 1;
    min-width: 0;

    .user-name {
      font-weight: bold;
      line-height: 24px;
      color: rgba(16, 16, 16, 1);
      font-size: 16px;
      text-align: left;
      font-family: PingFangSC;
      max-width: 50%;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .user-plan {
      line-height: 17px;
      color: rgba(154, 154, 154, 1);
      font-size: 12px;
    }

    .user-details {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 2px;
      justify-content: space-between;
    }

    .points-display {
      display: flex;
      align-items: center;
      gap: 4px;
      line-height: 17px;
      color: rgba(154, 154, 154, 1);
      font-size: 12px;

      .points-icon {
        width: 14px;
        height: 14px;
        color: #FFB800;
        flex-shrink: 0;
      }

      .points-value {
        min-width: 20px;
        margin-right: 10px;
        font-weight: 500;
      }
    }

    .offline-status {
      display: flex;
      align-items: center;
      gap: 4px;

      .offline-text {
        line-height: 17px;
        color: rgba(154, 154, 154, 1);
        font-size: 12px;
      }
    }
  }
}

.profile-wrapper {
  position: absolute;
  bottom: 100%;
  left: 0;
  width: 298px;
  padding: 10px 16px;
  font-size: 12px;
  background: #fff;
  border-radius: 6px;
  box-shadow:
    0 4px 12px rgba(0, 0, 0, 0.08),
    0 8px 24px rgba(0, 0, 0, 0.04);
  z-index: 99999;

  &::before {
    content: '';
    position: absolute;
    top: 100%;
    left: 0;
    right: 0;
    height: 10px;
    background: transparent;
  }
}

.version-text {
  cursor: pointer;
  padding: 4px 8px;
  border-radius: 6px;
  transition: all 0.2s ease;
  user-select: none;

  line-height: 17px;
  color: rgba(154, 154, 154, 1);
  font-size: 12px;

  &:hover {
    color: #000;
    background-color: #e5e5e5;
    transform: translateY(-1px);
  }

  &:active {
    transform: translateY(0);
  }
}
</style>



================================================
FILE: frontend/src/view/pay/paySuccess.vue
================================================
<template>
    <div style="max-width: 600px; margin: 60px auto; text-align: center;">
      <a-spin :spinning="loading" :tip="$t('loadingTip')">
        <template v-if="orderLoaded">
          <a-result
            :status="resultStatus"
            :title="resultTitle"
            :sub-title="resultSubtitle"
          >
            <template #extra>
              <a-button v-if="!fromClient" type="primary" @click="goHome">{{ $t('backHome') }}</a-button>
            </template>
          </a-result>
  
          <a-card v-if="showOrderInfo" :title="$t('orderInfo')" style="margin-top: 24px; text-align: left;">
            <p><strong>{{ $t('orderId') }}ï¼š</strong>{{ order.order_sn }}</p>
            <p><strong>{{ $t('paymentAmount') }}ï¼š</strong>
              {{ order.amount_total && order.currency ? formatAmount(order.amount_total, order.currency) : $t('unknown') }}
            </p>
            <p><strong>{{ $t('orderStatus') }}ï¼š</strong>
              <a-tag :color="orderStatusColor(orderStatus)">
                {{ statusText(orderStatus) }}
              </a-tag>
            </p>
          </a-card>
        </template>
  
        <template v-else-if="error">
          <a-alert type="error" :message="$t('loadFailed')" show-icon />
        </template>
      </a-spin>
    </div>
  </template>
  
  <script setup>
  import { ref, onMounted, onBeforeUnmount, computed } from 'vue'
  import { useRoute, useRouter } from 'vue-router'
  import { message } from 'ant-design-vue'
  import membershipService from '@/services/membership'
  import { useI18n } from 'vue-i18n'
  
  const { t } = useI18n()
  
  const route = useRoute()
  const router = useRouter()
  
  const loading = ref(true)
  const error = ref(false)
  const order = ref({})
  const orderStatus = ref('checking') // åˆå§‹ä¸ºâ€œcheckingâ€ï¼Œè¡¨ç¤ºæ­£åœ¨è·å–ä¸­
  const pollingTimer = ref(null)
  
  const terminalStates = ['pending', 'paid', 'cancelled', 'failed']
  const zeroDecimalCurrencies = ['JPY', 'KRW']
  
  const orderLoaded = ref(false)
  const showOrderInfo = ref(false)

  //æ˜¯å¦æ¥è‡ªå®¢æˆ·ç«¯
  const fromClient = computed(() => {
    const from = route.query.from
    return from === 'desktop'
  })
  
  function formatAmount(amount, currency) {
    if (!currency) return `${amount}ï¼ˆ${t('unknownCurrency')}ï¼‰`
    const upperCurrency = currency.toUpperCase()
    const isZeroDecimal = zeroDecimalCurrencies.includes(upperCurrency)
    const value = isZeroDecimal ? amount : amount / 100
    return `${value.toFixed(2)} ${upperCurrency}`
  }
  
  function paymentStatusColor(status) {
    switch (status) {
      case 'paid': return 'green'
      case 'unpaid': return 'red'
      default: return 'default'
    }
  }
  
  function orderStatusColor(status) {
    switch (status) {
      case 'paid': return 'green'
      case 'pending': return 'orange'
      case 'cancelled':
      case 'failed': return 'red'
      case 'checking': return 'blue'
      default: return 'default'
    }
  }
  
  function statusText(status) {
    const map = {
      checking: t('status.checking'),
      paid: t('status.paid'),
      pending: t('status.pending'),
      cancelled: t('status.cancelled'),
      failed: t('status.failed')
    }
    return map[status] || status
  }
  
  const resultStatus = computed(() => {
    switch (orderStatus.value) {
      case 'paid': return 'success'
      case 'pending': return 'warning'
      case 'cancelled':
      case 'failed': return 'error'
      case 'checking': return 'info'
      default: return 'info'
    }
  })
  
  const resultTitle = computed(() => {
    switch (orderStatus.value) {
      case 'paid': return t('resultTitle.paid')
      case 'pending': return t('resultTitle.pending')
      case 'cancelled': return t('resultTitle.cancelled')
      case 'failed': return t('resultTitle.failed')
      case 'checking': return t('resultTitle.checking')
      default: return t('resultTitle.unknown')
    }
  })
  
  const resultSubtitle = computed(() => {
    if (['paid', 'pending', 'cancelled', 'failed'].includes(orderStatus.value)) {
      return t('resultSubtitle.submitted')
    }
    return ''
  })
  
  async function pollOrderStatus(orderId) {
    pollingTimer.value = setInterval(async () => {
      try {
        const res = await membershipService.checkOrderStatusById(orderId)
        const status = res?.status
        if (status) {
          orderStatus.value = status
          if (terminalStates.includes(status)) {
            showOrderInfo.value = true
            //æ ¹æ®url ä¸­çš„ å‚æ•° from åˆ¤æ–­æ˜¯å¦æ˜¯å®¢æˆ·ç«¯
            if(orderStatus.value === 'paid'){
              clearInterval(pollingTimer.value)
              pollingTimer.value = null
            }
            const from = route.query.from
            if(from === 'desktop' && orderStatus.value === 'paid'){
              notifyClient("paid")
            }

          }
        }
      } catch (err) {
        console.error('è½®è¯¢è®¢å•çŠ¶æ€å¤±è´¥ï¼š', err)
      }
    }, 3000)
  }
  
  const fetchOrder = async () => {
    const sessionId = route.query.session_id
    if (!sessionId) {
      error.value = true
      loading.value = false
      return
    }
  
    try {
      const res = await membershipService.createStripeCheckoutSession(sessionId)
      order.value = res.session
      orderLoaded.value = true
  
      const orderId = order.value?.metadata?.order_id
      if (orderId) {
        pollOrderStatus(orderId)
      } else {
        showOrderInfo.value = true
        loading.value = false
      }
    } catch (err) {
      console.error(err)
      message.error(t('fetchFailed'))
      error.value = true
    } finally {
      loading.value = false
    }
  }
  
  const goHome = () => {
    router.push('/')
  }
  
  onMounted(
    () => {
      fetchOrder()
    }
  )
  
  onBeforeUnmount(() => {
    if (pollingTimer.value) clearInterval(pollingTimer.value)
  })

  //é€šçŸ¥å®¢æˆ·ç«¯ æ”¯ä»˜æˆåŠŸ ä½¿ç”¨è‡ªå®šä¹‰åè®®
  const notifyClient = (status) => {
    const deeplink = `lemonai://pay-result?orderId=${order.value.id}&amount=${order.value.amount_total}&currency=${order.value.currency}&status=${status}`
    window.location.href = deeplink
  }
  </script>
  


================================================
FILE: frontend/src/view/pay/pricing.vue
================================================
<template>
  <div class="top-bar">
    <a-button type="text" @click="back" class="back-btn">
      <template #icon>
        <arrow-left-outlined />
      </template>
      {{ $t('setting.back') }}
    </a-button>
  </div>
  <div class="pricing">
    <Pricing  />
  </div>
</template>

<script setup>
import { ref, computed, watch, h,onMounted } from 'vue'
import { useI18n } from 'vue-i18n'
import { useRouter } from 'vue-router'
import { ArrowLeftOutlined } from '@ant-design/icons-vue'
//pricing 
import Pricing from './components/pricing.vue'

const { t } = useI18n()
const router = useRouter()
const back = () => router.push({ name: 'lemon' })



</script>

<style scoped>
/* ä½ åŸæ¥çš„æ ·å¼ä¿æŒä¸å˜ */
body {
  color: #000;
}
.top-bar {
  height: 60px;
  display: flex;
  align-items: center;
  padding: 0 20px;
  background-color: #fff;
  border-bottom: 1px solid #eee;
}
.back-btn {
  color: #000;
  display: flex;
  align-items: center;
}
.pricing {
  height: 100%;
}


@media(max-width: 768px){
  .top-bar {
    position: sticky;
    background-color: #fff;
    top: 0;
  }
  .pricing{
    overflow: auto;
    background: #f5f5f5;
  }
}
</style>
<style>

</style>


================================================
FILE: frontend/src/view/pay/components/rechargeProducts.vue
================================================
<template>
    <a-modal v-model:open="visible" width="720px" centered :footer="null" title="Buy add-on credits">
        <!-- åŸæ¥çš„å†…å®¹ -->
        <div v-if="rechargeProducts.length" class="recharge-products">
            <div v-for="item in rechargeProducts" :key="item.id" class="product-card">
                <div class="product-title">{{ item.product_name }}</div>
                <div class="product-info">
                    <p style="margin-top: 8px;">{{ currency }} {{ item.amount }}</p>
                    <p>{{ item.points_awarded }}{{ t('member.pointsUnit') }}</p>
                </div>
                <button size="small" :loading="loading" @click="handleBuy(item)">
                    {{ t('member.buyNow') }}
                </button>
            </div>
        </div>
        <div v-else>{{ t('member.noPackagesAvailable') }}</div>

        <!-- æ‰«ç æ”¯ä»˜å¼¹çª— -->
        <a-modal v-model:open="showQrCode" :title="t('member.wechatScanToPay')" centered :footer="null">
            <div style="text-align: center; display: flex; flex-direction: column; align-items: center;">
                <div style="display: inline-block;">
                    <a-qrcode :value="qrCodeUrl" :size="200" />
                </div>
                <p style="margin-top: 12px;">{{ t('member.wechatScanPrompt') }}</p>
            </div>
        </a-modal>

        <!-- æ”¯ä»˜æ–¹å¼é€‰æ‹© -->
        <a-modal v-model:open="showPaymentMethodModal" :footer="null" centered width="480"
            :title="$t('member.selectPaymentMethod')">
            <div style="display: flex; flex-direction: column; gap: 16px; padding: 12px 4px;">
                <div class="payment-option" @click="handlePayment('stripe')">
                    <StripeLogo />
                    <div class="payment-content">
                        <div class="payment-title">{{ $t('payment.stripe.title') }}</div>
                        <div class="payment-description">{{ $t('payment.stripe.description') }}</div>
                    </div>
                </div>
                <div class="payment-option" @click="handlePayment('wechat')">
                    <WechatLogo />
                    <div class="payment-content">
                        <div class="payment-title">{{ $t('payment.wechat.title') }}</div>
                        <div class="payment-description">{{ $t('payment.wechat.description') }}</div>
                    </div>
                </div>
            </div>
        </a-modal>
    </a-modal>
</template>
<script setup>
import { ref, onMounted, computed } from 'vue'
import auth from '@/services/auth';
import membershipService from '@/services/membership'

// --- å›½é™…åŒ–å¼•å…¥ ---
import { useI18n } from 'vue-i18n'
const { t } = useI18n()


import dayjs from 'dayjs'
import { useRouter } from "vue-router";
const router = useRouter();
import { message } from 'ant-design-vue';

import { storeToRefs } from 'pinia';
import { useUserStore } from '@/store/modules/user.js'
const userStore = useUserStore();
const { user, membership, points } = storeToRefs(userStore);

import StripeLogo from '@/assets/svg/stripe.svg'
import WechatLogo from '@/assets/svg/wechatpay.svg'

const props = defineProps({
    open: {
        type: Boolean,
        default: false
    }
})
const emit = defineEmits(['update:open'])

const visible = computed({
    get: () => props.open,
    set: (val) => emit('update:open', val),
})

const showQrCode = ref(false)
const qrCodeUrl = ref('')
const showPaymentMethodModal = ref(false)
const selectedPlan = ref(null)
const pollingTimer = ref(null)
const loading = ref(false)

const currency = computed(() => {
    return '$';
})


const rechargeProducts = ref([])

const handleBuy = async (item) => {
    // handlePayment('stripe')
    showPaymentMethodModal.value = true
    selectedPlan.value = item
}


onMounted(async () => {
    await toPoints()
})

const toPoints = async () => {
    let res = await membershipService.getRechargeProductList()
    rechargeProducts.value = res || []
};

const handlePayment = async (method) => {
    showPaymentMethodModal.value = false
    loading.value = true

    if (method === 'stripe') {
        let res = await membershipService.createStripePointPurchaseOrder(selectedPlan.value.id)
        window.location.href = res.url;
        loading.value = false
    } else {
        let res = await membershipService.createPointPurchaseOrder(selectedPlan.value.id)
        if (res && res.code_url) {
            loading.value = false
            qrCodeUrl.value = res.code_url
            showQrCode.value = true
            checkOrderStatus(res.order_sn)
        } else {
            loading.value = false
        }
        console.log(res)
    }
}

const checkOrderStatus = async (orderSn) => {
    const maxRetries = 20
    let attempts = 0

    pollingTimer.value = setInterval(async () => {
        attempts++

        const res = await membershipService.checkOrderStatus(orderSn)
        if (res?.status === 'paid') {
            clearInterval(pollingTimer.value)
            showQrCode.value = false
            message.success(t("member.paymentSuccess"))
            paySuccess();
            // message.success("æ”¯ä»˜æˆåŠŸï¼")
            console.log('æ”¯ä»˜æˆåŠŸ')
        }

        if (attempts >= maxRetries) {
            clearInterval(pollingTimer.value)
            console.warn("æ”¯ä»˜è¶…æ—¶ï¼Œè¯·é‡æ–°ä¸‹å•")
        }
    }, 3000)
}

//æ”¯ä»˜æˆåŠŸ 
const paySuccess = () => {
    //åˆ·æ–°å½“å‰é¡µé¢
    window.location.reload()
}

</script>
<style scoped>
.recharge-products {
    display: flex;
    flex-wrap: wrap;
    gap: 16px;
    background-color: #f8f8f7;
    padding: 24px;
    justify-content: space-between;
}

.product-card {
    width: calc(33.333% - 11px);
    /* 3åˆ—å¸ƒå±€ï¼Œå‡å»é—´è· */
    border: 1px solid #f0f0f0;
    background-color: #fff;
    border-radius: 8px;
    padding: 16px;
    box-sizing: border-box;
    text-align: center;
    /* æ–‡å­—å±…ä¸­ */
    transition: box-shadow 0.3s;
}

.product-card:hover {
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}
</style>


================================================
FILE: frontend/src/view/setting/about.vue
================================================
<template>
  <div class="about">
    <h2>{{ $t('setting.about.title') }}</h2>
    <div class="options-item">
      <div class="son">
        <div>
          <span>{{ $t('setting.about.lemonAI') }}</span>
          <span class="version">V{{ versionInfo.localVersion }}</span>
        </div>
        <div>
          <a-button @click="handleUpdate">{{ $t('setting.about.checkUpdate') }}</a-button>
        </div>
      </div>
      <div class="son">
        <div>
          <span>{{ $t('setting.about.officialWebsite') }}</span>
        </div>
        <div>
          <a-button @click="handleOpenLemonPage">{{ $t('setting.about.view') }}</a-button>
        </div>
      </div>
      <div class="son">
        <div>
          <span>{{ $t('setting.about.feedback') }}</span>
        </div>
        <div>
          <a-button @click="handleIssuePage">{{ $t('setting.about.submitFeedback') }}</a-button>
        </div>
      </div>
      <!-- <div class="son last">
        <div>
          <span>{{ $t('setting.about.license') }}</span>
        </div>
        <div>
          <a-button>{{ $t('setting.about.view') }}</a-button>
        </div>
      </div> -->
    </div>
  </div>
  <a-modal :open="updateVisible" :footer="null" :closable="false" :centered="true">
    <div
      class="update-prompt"
      style="border-radius: 12px; text-align: center; font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;"
    >
      <h2 style="color: #d81b60; font-size: 24px; margin: 0 0 16px;">
        {{ $t('setting.about.newVersionReleased') }}
      </h2>
      <p style="color: #333; font-size: 16px; line-height: 1.5; margin: 0 0 24px;">
        {{ $t('setting.about.version') }}ï¼š<strong>V{{ versionInfo.localVersion }} --> </strong>
        <strong> V{{ versionInfo.latestVersion }}</strong>
      </p>
      <!-- TODO show update detail -->
      <div class="update-detail" style="display: flex;">
        <markdownRender :content="versionInfo.body" />
      </div>
      <div style="display: flex; justify-content: center; gap: 16px; padding: 10px;">
        <a-button @click="updateVisible = false;">
          {{ $t('setting.about.skipUpdate') }}
        </a-button>
        <a-button type="primary" @click="handleOpenReleasePage()">
          {{ $t('setting.about.viewDetails') }}
        </a-button>
      </div>
    </div>
  </a-modal>
</template>

<script setup>
import { ref, onMounted } from 'vue';
import { useI18n } from 'vue-i18n';
import versionService from '@/services/version';
import { message } from 'ant-design-vue';
import markdownRender from '@/components/markdown/index.vue';

const { t } = useI18n();

const versionInfo = ref({
  localVersion: '0.5.1',
  latestVersion: '0.5.1',
  isLatest: true,
  updateUrl: 'https://github.com/yu-mengyun/vue-admin-template',
  message: 'the current version is the latest version',
});
const updateVisible = ref(false);

function handleUpdate() {
  if (versionInfo.value.isLatest) {
    message.success(t('setting.about.alreadyLatest'));
  } else {
    updateVisible.value = true;
  }
}

function handleOpenReleasePage() {
  window.open(versionInfo.value.updateUrl, '_blank');
}

function handleOpenLemonPage() {
  window.open('https://www.lemonai.cc/', '_blank');
}

function handleIssuePage() {
  window.open('https://github.com/hexdocom/lemonai/issues/new', '_blank');
}

onMounted(() => {
  // versionService.getVersionInfo().then((res) => {
  //   console.log(res);
  //   versionInfo.value = res;
  // });
});
</script>

<style scoped>
.about {
  padding: 16px;
  color: #333;
}

.options-item {
  padding: 16px;
  background-color: rgb(254, 254, 254);
  width: 100%;
  border: 1px solid #c6c6c6;
  border-radius: 10px;
  font-size: 15px;
  display: flex;
  flex-direction: column;

  .son {
    display: flex;
    flex-direction: row;
    justify-content: space-between;
    align-items: center;
    width: 100%;
    padding: 10px 0px;
    border-bottom: 1px solid #d4d4d4;
  }

  .last {
    border-bottom: none;
  }
}

@media screen and (max-width: 768px) {
  .about {
    padding: 16px;
  }

  .title {
    font-size: 2rem;
  }
}

.version {
  margin-left: 10px;
  color: #36deee;
  border-radius: 4px;
  /* background-color: #f7f7f7; */
}

.update-detail {
  width: 100%;
  max-height: 500px;
  overflow: auto;
  padding: 2px;
}
.update-detail::-webkit-scrollbar {
  width: 0;
  height: 0;
}
</style>


================================================
FILE: frontend/src/view/setting/basic.vue
================================================
<template>
  <div class="basic-settings">
    <h2>{{ $t(`setting.basic.title`) }}</h2>

    <langService/>
  </div>
</template>

<script setup>
import langService from '@/components/lang/index.vue'
// å¯æ·»åŠ å“åº”å¼é€»è¾‘
</script>

<style scoped>
.basic-settings {
  padding: 16px;
}
.setting-item {
  margin: 12px 0;
  padding: 12px;
  background: #fff;
  border-radius: 4px;
  box-shadow: 0 1px 2px rgba(0,0,0,0.1);
}

@media screen and (max-width: 768px) {
  h2{
    display: none!important;
  }
  .basic-settings{
    padding: 0!important;
  }
}
</style>


================================================
FILE: frontend/src/view/setting/ContentSide.vue
================================================
<template>
  <div class="content-side">
    <component :is="activeComponent" />
  </div>
</template>

<script setup>
import { defineAsyncComponent } from 'vue'

const props = defineProps({
  activeMenu: {
    type: String,
    required: true
  }
})

const activeComponent = defineAsyncComponent(() =>
  import(`./${props.activeMenu}.vue`)
)
</script>

<style scoped>
.content-side {
  flex: 1;
  background: white;
  border-radius: 8px;
  margin-left: 16px;
}
</style>


================================================
FILE: frontend/src/view/setting/default-model.vue
================================================
<template>
  <div class="default-model">
    <h2>é»˜è®¤æ¨¡å‹</h2>
    <div>
      <a-form :model="formState" layout="vertical" @finish="handleSubmit">
        <a-form-item label="è‡ªå®šä¹‰æ¨¡å‹">
          <a-input v-model:value="formState.modelName" placeholder="ä¾‹å¦‚: GPT-4" :disabled="loading" />
        </a-form-item>
        <a-form-item label="æ¨¡å‹ URL">
          <a-input v-model:value="formState.modelUrl" placeholder="https://api.example.com/v1" :disabled="loading" />
        </a-form-item>
        <a-form-item label="API Key">
          <a-input-password v-model:value="formState.apiKey" placeholder="è¾“å…¥æ‚¨çš„APIå¯†é’¥" :disabled="loading" />
        </a-form-item>
        <a-form-item>
          <a-button type="primary" html-type="submit" :loading="loading">ä¿å­˜è®¾ç½®</a-button>
        </a-form-item>
      </a-form>
    </div>
  </div>
</template>

<script setup>
import { ref, reactive, onMounted } from 'vue'
import { message } from 'ant-design-vue'
import settingService from '@/services/setting'

const temperature = ref(0.7)
const formState = reactive({
  modelName: '',
  modelUrl: '',
  apiKey: ''
})
const loading = ref(false)

// Fetch settings on mount
onMounted(async () => {
  try {
    const settings = await settingService.get()
    Object.assign(formState, settings)
  } catch (error) {
    message.error('è·å–è®¾ç½®å¤±è´¥')
  } finally {
  }
})

// Save settings
const handleSubmit = async () => {
  try {
    loading.value = true
    await settingService.save(formState)
    message.success('è®¾ç½®ä¿å­˜æˆåŠŸ')
  } catch (error) {
    message.error('ä¿å­˜è®¾ç½®å¤±è´¥')
  } finally {
    loading.value = false
  }
}
</script>

<style scoped>
.default-model {
  padding: 16px;
}
.model-card {
  margin: 16px 0;
  padding: 16px;
  background: #fff;
  border-radius: 4px;
  box-shadow: 0 1px 2px rgba(0,0,0,0.1);
}
</style>


================================================
FILE: frontend/src/view/setting/defaultModelSetting.vue
================================================
<template>
    <div class="default-model-service">
        <h2>{{ $t('setting.defaultModel.DefaultModelSetting') }}</h2>
        <defaultModel />
    </div>
</template>
<script setup>
import defaultModel from '@/components/defaultModel/index.vue'
</script>
<style scoped lang="scss">
.default-model-service {
    padding: 16px;
    height: 100%;
}

@media screen and (max-width: 768px) {
    h2 {
        display: none !important;
    }

    .default-model {
        padding: 0 !important;
    }

    .content-side {
        .default-model-service {
            padding: 0 !important;
        }
    }



}
</style>


================================================
FILE: frontend/src/view/setting/experience.vue
================================================
<template>
  <div class="experience">
    <h2>{{ $t('setting.experience.title') }}</h2>
    <div class="main">
      <div class="sidebar">
        <div class="list">
          <div
              v-for="type in types"
              :key="type.id"
              class="item"
              @click="handleType(type)"
              :class="currentTypeIndex === type.id ? 'active' : ''"
          >
            <component :is="type.icon" class="icon"/>
            <span>{{ type.title }}</span>
          </div>
        </div>
      </div>
      <div class="content">
        <div class="header">
          <span class="title">{{ types[currentTypeIndex].title }}</span>
          <div class="des">
            <span class="description">{{ types[currentTypeIndex].des }}</span>
            <a-button @click="showAdd = true" style="display: flex;justify-items: center;align-items: center"
                      class="btn-add">
              <addSvg/>
              {{ $t('setting.experience.addExperience') }}
            </a-button>
          </div>
        </div>
        <div class="list">
          <a-table
              :data-source="types[currentTypeIndex].data"
              :columns="columns"
              row-key="id"
              :pagination="false"
              :scroll="{ y: 560 }"
              class="a-table"
          >
            <template #headerCell="{ column, title }">
              <template v-if="column.key === 'is_enabled'">
                <div></div>
              </template>
              <template v-else-if="column.key === 'operation'">
                <div>
                  <div style="display: flex; justify-content: end;padding-right: 10px"></div>
                </div>
              </template>
              <template v-else>
                {{ title }}
              </template>
            </template>

            <template #bodyCell="{ column, record }">
              <template v-if="column.key === 'title'">
                {{ record.title }}
              </template>
              <template v-else-if="column.key === 'operation'">
                <div style="display:flex;justify-content: end" class="operation-buttons">
                  <a-button type="link" danger @click="handleDelete(record.id, true)" class="btn">
                    <deleteSvg style="height: 18px;width: 18px;"/>
                  </a-button>
                  <a-button type="link" @click="currentExperienceId=record.id;handleCopy(record.id);showEdit=true"
                            class="btn">
                    <editSvg style="height: 18px;width: 18px;color: #8b8b8b"/>
                  </a-button>
                </div>
              </template>
              <template v-else-if="column.key === 'is_enabled'">
                <div style="display:flex;flex-direction: row;align-items: center;gap: 5px;justify-content: end">
                  <a-switch size="small" v-model:checked="record[column.dataIndex]"
                            @change="handleStatusChange(record.id)"></a-switch>
                  <span :class="record[column.dataIndex] ? '' : 'opacity6'">
                    {{ record[column.dataIndex] ? $t('setting.experience.enabled') : $t('setting.experience.disabled') }}
                  </span>
                </div>
              </template>
              <template v-else-if="column.key === 'created_at'">
                <span class="time" style="color: #8b8b8b">{{ expFormatDate(record[column.dataIndex]) }}</span>
              </template>
            </template>
          </a-table>
        </div>
        <div class="footer">
          <span class="opacity6" style="font-weight: 400;font-size: 14px;padding:12px 16px;"
                v-show="types[currentTypeIndex].data.length > 7">
            {{ $t('setting.experience.totalExperience', { count: types[currentTypeIndex].data.length }) }}
          </span>
        </div>
      </div>
    </div>
  </div>
  <!-- Add Modal -->
  <a-modal :open="showAdd" :footer="null" style="
        width: 60%; border-color: hsla(0, 0%, 100%, .05);
        border-width: 1px; border-radius: 20px; overflow: auto;
        flex-direction: column; max-width: 95%; max-height: 95%;
        " :closable="false" :centered="true" class="modal">
    <div class="modal-main">
      <div class="header">
        <div class="left">
          <h3 style="display: flex;flex-direction: row;justify-items: center;align-items: center;gap: 10px;line-height: 24px;font-weight: 600 ;font-size: 18px;margin-bottom: 0">
            {{ $t('setting.experience.addExperience') }}
          </h3>
        </div>
        <div class="right">
          <a-tooltip>
            <template #title>{{ $t('setting.experience.close') }}</template>
            <closeSvg style="width: 26px;height: 26px" class="icon" @click="showAdd = false;initNewKnowledge()"/>
          </a-tooltip>
        </div>
      </div>
      <div class="modal-content">
        <div class="item">
          <span>{{ $t('setting.experience.titleLabel') }} <span style="color: #eb4d4d">*</span></span>
          <a-input class="input-1" :placeholder="$t('setting.experience.titlePlaceholder')"
                   v-model:value="newKnowledge.title"></a-input>
        </div>
        <div class="item">
          <span>{{ $t('setting.experience.goalLabel') }} <span style="color: #eb4d4d">*</span></span>
          <a-input class="input-1" :placeholder="$t('setting.experience.goalPlaceholder')"
                   v-model:value="newKnowledge.goal"></a-input>
        </div>
        <div class="item">
          <span>{{ $t('setting.experience.contentLabel') }} <span style="color: #eb4d4d">*</span></span>
          <a-textarea class="input-textarea" :placeholder="$t('setting.experience.contentPlaceholder')"
                      :auto-size="{ minRows: 8, maxRows: 8 }" v-model:value="newKnowledge.content"/>
        </div>
        <div class="item-1" style="align-items: center">
          <span>{{ $t('setting.experience.statusLabel') }}</span>
          <a-switch size="small" v-model:checked="newKnowledge.is_enabled"></a-switch>
          <span :class="newKnowledge.is_enabled ? '' : 'opacity6'">
            {{ newKnowledge.is_enabled ? $t('setting.experience.enabled') : $t('setting.experience.disabled') }}
          </span>
        </div>
        <div class="footer">
          <div class="bins">
            <a-button type="default" class="btn-s" @click="showAdd = false;initNewKnowledge()">
              {{ $t('setting.experience.cancel') }}
            </a-button>
            <a-button type="primary" class="btn-s" @click="handleCreateExperience" :disabled="!canBeNew">
              {{ $t('setting.experience.save') }}
            </a-button>
          </div>
        </div>
      </div>
    </div>
  </a-modal>
  <!-- Edit Modal -->
  <a-modal :open="showEdit" :footer="null" style="
        width: 60%; border-color: hsla(0, 0%, 100%, .05);
        border-width: 1px; border-radius: 20px; overflow: auto;
        flex-direction: column; max-width: 95%; max-height: 95%;
        " :closable="false" @cancel="showEdit = false" :centered="true" class="modal">
    <div class="modal-main">
      <div class="header">
        <div class="left">
          <h3 style="display: flex;flex-direction: row;justify-items: center;align-items: center;gap: 10px;line-height: 24px;font-weight: 600 ;font-size: 18px;margin-bottom: 0">
            {{ $t('setting.experience.editExperience') }}
          </h3>
        </div>
        <div class="right">
          <a-tooltip>
            <template #title>{{ $t('setting.experience.close') }}</template>
            <closeSvg style="width: 26px;height: 26px" class="icon" @click="showEdit = false;currentExperienceId=-1"/>
          </a-tooltip>
        </div>
      </div>
      <div class="modal-content">
        <div class="item">
          <span>{{ $t('setting.experience.titleLabel') }} <span style="color: #eb4d4d">*</span></span>
          <a-input class="input-1" :placeholder="$t('setting.experience.titlePlaceholder')"
                   v-model:value="currentExperienceCopy.title" maxlength=255></a-input>
        </div>
        <div class="item">
          <span>{{ $t('setting.experience.goalLabel') }} <span style="color: #eb4d4d">*</span></span>
          <a-input class="input-1" :placeholder="$t('setting.experience.goalPlaceholder')"
                   v-model:value="currentExperienceCopy.goal"></a-input>
        </div>
        <div class="item">
          <span>{{ $t('setting.experience.contentLabel') }} <span style="color: #eb4d4d">*</span></span>
          <a-textarea class="input-textarea" :placeholder="$t('setting.experience.contentPlaceholder')"
                      :auto-size="{ minRows: 8, maxRows: 8 }" v-model:value="currentExperienceCopy.content"/>
        </div>
        <div class="item-1" style="align-items: center">
          <span>{{ $t('setting.experience.statusLabel') }}</span>
          <a-switch size="small" v-model:checked="currentExperienceCopy.is_enabled"></a-switch>
          <span :class="currentExperienceCopy.is_enabled ? '' : 'opacity6'">
            {{ currentExperienceCopy.is_enabled ? $t('setting.experience.enabled') : $t('setting.experience.disabled') }}
          </span>
        </div>
        <div class="footer">
          <div class="bins">
            <a-button type="default" class="btn-s" danger @click="handleDelete(currentExperienceId, false)">
              {{ $t('setting.experience.delete') }}
            </a-button>
            <a-button type="default" class="btn-s" @click="handleCopy(currentExperienceId)">
              {{ $t('setting.experience.undoChanges') }}
            </a-button>
            <a-button type="primary" class="btn-s" @click="handleUpdateExperience(currentExperienceCopy)"
                      :disabled="!canBeEdit">
              {{ $t('setting.experience.save') }}
            </a-button>
          </div>
        </div>
      </div>
    </div>
  </a-modal>
</template>

<script setup>
import { useI18n } from 'vue-i18n';
// SVG
import cameraSvg from '@/assets/experience/camera.svg';
import planSvg from '@/assets/experience/plan.svg';
import actionSvg from '@/assets/experience/action.svg';
import deleteSvg from '@/assets/svg/delete.svg';
import editSvg from '@/assets/experience/edit.svg';
import addSvg from '@/assets/svg/add.svg';
import updownSvg from '@/assets/experience/updown.svg';
import closeSvg from '@/assets/filePreview/close.svg';
// Services
import experienceService from '@/services/experience.js';
// References
import { computed, onMounted, ref, markRaw, h } from 'vue';
import { Button, Checkbox, message, Modal, Radio } from 'ant-design-vue';

const { t } = useI18n();

// CONST
const columns = [
  {
    title: t('setting.experience.tableTitle'),
    dataIndex: 'title',
    key: 'title',
    width: 100,
    ellipsis: true,
  },
  {
    title: t('setting.experience.tableContent'),
    dataIndex: 'content',
    key: 'content',
    width: 200,
    ellipsis: true,
  },
  {
    title: t('setting.experience.tableCreatedAt'),
    dataIndex: 'create_at',
    key: 'created_at',
    width: 50,
  },
  {
    title: t('setting.experience.tableStatus'),
    dataIndex: 'is_enabled',
    key: 'is_enabled',
    width: 50,
    filterMultiple: false,
    filterIcon: (filtered) => {
      return h('div', { style: { display: 'flex', alignItems: 'center', gap: '4px' } }, [
        h('span', { style: { color: filtered ? '#000000' : '#000000', fontSize: '14px', fontWeight: '600' } }, t('setting.experience.tableStatus')),
        h(updownSvg, { style: { width: '16px', height: '16px', color: '#8b8b8b' } }),
      ]);
    },
    filterDropdown: ({ setSelectedKeys, selectedKeys, confirm }) => {
      return h(
          'div',
          { style: { padding: '8px', minWidth: '100px' } },
          [
            h('div', { style: { fontSize: '14px', fontWeight: '600', marginBottom: '8px' } }, t('setting.experience.tableStatus')),
            h(
                Radio.Group,
                {
                  value: selectedKeys[0] ?? 'all',
                  onChange: (e) => {
                    const value = e.target.value;
                    setSelectedKeys([value]);
                    confirm();
                  },
                  style: { display: 'flex', flexDirection: 'column', gap: '8px' },
                },
                {
                  default: () => [
                    h(Radio, { value: 'all', style: { display: 'flex', alignItems: 'center', flexDirection: 'row-reverse', justifyContent: 'flex-end' } }, () => t('setting.experience.filterAll')),
                    h(Radio, { value: true, style: { display: 'flex', alignItems: 'center', flexDirection: 'row-reverse', justifyContent: 'flex-end' } }, () => t('setting.experience.enabled')),
                    h(Radio, { value: false, style: { display: 'flex', alignItems: 'center', flexDirection: 'row-reverse', justifyContent: 'flex-end' } }, () => t('setting.experience.disabled')),
                  ],
                }
            ),
          ]
      );
    },
    onFilter: (value, record) => {
      if (value === 'all') return true;
      return record.is_enabled === value;
    },
    filters: [
      { text: t('setting.experience.filterAll'), value: 'all' },
      { text: t('setting.experience.enabled'), value: true },
      { text: t('setting.experience.disabled'), value: false },
    ],
  },
  {
    title: t('setting.experience.tableOperation'),
    key: 'operation',
    width: 50,
  },
];

// ref
const showAdd = ref(false);
const showEdit = ref(false);
const currentTypeIndex = ref(0);
const currentExperienceId = ref(-1);
const currentExperienceCopy = ref({});
const types = ref([
  // {
  //   id: 0,
  //   title: t('setting.experience.detect'),
  //   type: 'detect',
  //   des: '',
  //   icon: markRaw(cameraSvg),
  //   data: [],
  // },
  {
    id: 1,
    title: t('setting.experience.plan'),
    type: 'plan',
    des: '',
    icon: markRaw(planSvg),
    data: [],
  },
  // {
  //   id: 2,
  //   title: t('setting.experience.action'),
  //   type: 'action',
  //   des: '',
  //   icon: markRaw(actionSvg),
  //   data: [],
  // },
]);
const newKnowledge = ref({
  title: '',
  type: 'detect',
  goal: '',
  content: '',
  is_enabled: true,
});

// computed var
const canBeNew = computed(() => {
  return newKnowledge.value.title.trim() !== '' && newKnowledge.value.content.trim() !== '' && newKnowledge.value.goal.trim() !== '';
});
const canBeEdit = computed(() => {
  return currentExperienceCopy.value?.title.trim() !== '' && currentExperienceCopy.value?.content.trim() !== '' && currentExperienceCopy.value?.goal.trim() !== '';
});

// Custom functions
function handleType(type) {
  currentTypeIndex.value = types.value.findIndex(item => item.id === type.id);
}

function handleDelete(id, confirm = true) {
  if (confirm) {
    Modal.confirm({
      title: t('setting.experience.deleteExperience'),
      icon: null,
      content: t('setting.experience.deleteConfirm'),
      okText: t('setting.experience.delete'),
      okType: 'danger',
      closable: true,
      centered: true,
      cancelText: t('setting.experience.cancel'),
      onOk() {
        experienceService.deleteExperience(id).then(res => {
          message.success(t('setting.experience.deleteSuccess'));
          init(currentTypeIndex.value);
        }).catch(err => {
          message.error(t('setting.experience.deleteFailed'));
        });
      },
    });
  } else {
    experienceService.deleteExperience(id).then(res => {
      message.success(t('setting.experience.deleteSuccess'));
      init(currentTypeIndex.value);
      showEdit.value = false;
    }).catch(err => {
      message.error(t('setting.experience.deleteFailed'));
    });
  }
}

function handleCreateExperience() {
  if (canBeNew.value) {
    newKnowledge.value.type = types.value[currentTypeIndex.value].type;
    experienceService.createExperience(newKnowledge.value).then(res => {
      message.success(t('setting.experience.createSuccess'));
      initNewKnowledge();
      init(currentTypeIndex.value);
      showAdd.value = false;
    }).catch(err => {
      message.error(t('setting.experience.createFailed'));
    });
  }
}

function initNewKnowledge() {
  newKnowledge.value = {
    title: '',
    type: '',
    goal: '',
    content: '',
    is_enabled: true,
  };
}

function handleStatusChange(id) {
  const item = types.value[currentTypeIndex.value].data.find(item => item.id === id);
  if (item) {
    experienceService.updateExperience({
      id: item.id,
      type: item.type,
      title: item.title,
      goal: item.goal,
      content: item.content,
      is_enabled: !item.is_enabled,
    }).then(res => {
    }).catch(err => {
      message.error(t('setting.experience.updateFailed'));
    });
  } else {
    message.error(t('setting.experience.updateFailedDataNotExist'));
  }
}

function handleUpdateExperience(experience) {
  experienceService.updateExperience({
    id: experience.id,
    type: experience.type,
    title: experience.title,
    goal: experience.goal,
    content: experience.content,
    is_enabled: experience.is_enabled,
  }).then(res => {
    message.success(t('setting.experience.updateSuccess'));
    init(currentTypeIndex.value);
    showEdit.value = false;
  });
}

function handleCopy(id) {
  const item = types.value[currentTypeIndex.value].data.find(item => item.id === id);
  if (item) {
    currentExperienceCopy.value = JSON.parse(JSON.stringify(item));
    showEdit.value = true;
  }
}

function init(index) {
  for (let i = 0; i < types.value.length; i++) {
    experienceService.getExperienceByType(types.value[i].type).then(res => {
      types.value[i].data = res;
    }).catch(err => {
      message.error(t('setting.experience.getDataError'));
    });
  }
  currentTypeIndex.value = index;
}

function expFormatDate(date_str) {
  const date = new Date(date_str);
  const now = new Date();
  const currentYear = now.getFullYear();
  const currentMonth = now.getMonth();
  const currentDate = now.getDate();
  const targetYear = date.getFullYear();
  const targetMonth = date.getMonth();
  const targetDate = date.getDate();
  const targetHours = String(date.getHours()).padStart(2, '0');
  const targetMinutes = String(date.getMinutes()).padStart(2, '0');

  if (targetYear === currentYear && targetMonth === currentMonth && targetDate === currentDate) {
    return `${targetHours}:${targetMinutes}`;
  }

  const startOfWeek = new Date(now.setDate(currentDate - now.getDay()));
  const endOfWeek = new Date(now.setDate(currentDate + (6 - now.getDay())));
  if (date >= startOfWeek && date <= endOfWeek) {
    const weekdays = [
      t('setting.experience.sunday'),
      t('setting.experience.monday'),
      t('setting.experience.tuesday'),
      t('setting.experience.wednesday'),
      t('setting.experience.thursday'),
      t('setting.experience.friday'),
      t('setting.experience.saturday'),
    ];
    return weekdays[date.getDay()];
  }

  if (targetYear === currentYear) {
    const month = String(targetMonth + 1).padStart(2, '0');
    const day = String(targetDate).padStart(2, '0');
    return `${month}-${day}`;
  }

  return t('setting.experience.earlier');
}

onMounted(() => {
  init(0);
});
</script>

<style lang="scss" scoped>
.experience {
  padding: 16px;
  height: 100%;
  overflow-y: hidden;

  .main {
    display: flex;
    flex-direction: row;
    padding: 1px;

    .sidebar {
      width: 250px;
      padding: 16px 0;
      display: flex;
      flex-direction: column;
      height: 80vh;

      .list {
        overflow-y: auto;
        height: 80vh;
        overflow-x: hidden;
        //padding: 8px;
        box-sizing: border-box;

        .item {
          display: flex;
          align-items: center;
          cursor: pointer;
          padding: 8px;
          gap: 8px;
          border-radius: 4px;
          margin-bottom: 8px;
          height: 38px;

          .icon {
            width: 20px;
            height: 20px;
          }
        }

        .item:hover {
          background-color: #f0f0f0;
        }

        .active {
          background-color: #f0f0f0;
        }
      }
    }

    .content {
      flex: 5;
      display: flex;
      flex-direction: column;
      //overflow-y: auto;
      box-sizing: border-box;

      .header {
        display: flex;
        flex-direction: column;
        font-weight: bold;
        font-size: 18px;
        padding: 12px 16px;

        .des {
          display: flex;
          align-items: center;
          flex-direction: row;
          justify-content: space-between;

          .description {
            font-size: 14px;
            opacity: 0.6;
          }

          .btn-add:hover {
            background-color: #f3f3f3;
            color: black;
          }
        }
      }

      .list {
        padding: 12px 16px;

        :deep(.ant-table-thead > tr > th) {
          background-color: white;
          font-weight: bold;
          border: none;
        }

        :deep(.ant-btn-link) {
          padding: 0 8px;
          border: none;
        }

        :deep(.ant-table-tbody > tr > td) {
          border: none;
        }

        :deep(.ant-table-tbody) {
          overflow-y: auto;
        }

        :deep(.ant-table-tbody::-webkit-scrollbar) {
          width: 2px;
        }
      }
    }
  }
}


.modal-main {
  display: flex;
  flex-direction: column;
  height: 100%;
  width: 100%;
  padding: 1.25rem 24px 10px;
  gap: 0.5rem;

  .header {
    display: flex;
    flex-direction: row;
    justify-content: space-between;
    align-items: center;

    .right {

    }
  }

  .modal-content {
    display: flex;
    flex-direction: column;
    gap: 1rem;

    .item {
      display: flex;
      gap: .375rem;
      flex-direction: column;

      .input-1 {
        padding: 8px 12px 8px 16px;
        padding-inline-end: 34px;
      }

      .input-2 {
        display: flex;

        //height: 180px;
        padding: 8px 12px 8px 16px;
        padding-inline-end: 34px;
      }
    }

    .item-1 {
      display: flex;
      gap: 8px;
    }

    .footer {
      display: flex;
      justify-content: flex-end;
      gap: 1rem;
      padding-top: 100px;

      .bins {
        display: flex;
        padding: 10px 0px;
        gap: 10px;

        .btn-s {
          height: 36px !important;
        }
      }

      //é«˜åº¦ä¸ºå‰©ä½™å…¨éƒ¨é«˜åº¦
    ;
      //æ”¾ç½®äºçª—å£åº•éƒ¨

    }
  }


}

.a-table :deep(.ant-table-body::-webkit-scrollbar) {
  width: 4px; /* æ»šåŠ¨æ¡å®½åº¦ */
}

.a-table :deep(.ant-table-body::-webkit-scrollbar-thumb) {
  background-color: rgba(0, 0, 0, 0.2); /* æ»‘å—é¢œè‰² */
  border-radius: 4px; /* æ»‘å—åœ†è§’ */
}

.a-table :deep(.ant-table-body::-webkit-scrollbar-track) {
  background-color: transparent; /* è½¨é“é¢œè‰² */
}
//æ“ä½œæŒ‰é’®æ·»åŠ æ‚¬åœç›¸å…³æ ·å¼
.a-table .ant-table-tbody > tr.ant-table-row .operation-buttons {
  visibility: hidden;
  opacity: 0;
  transition: opacity 0.2s ease; /* æ·»åŠ å¹³æ»‘è¿‡æ¸¡ */
  //transition: opacity 0.3s ease, visibility 0.3s ease;
}

.a-table .ant-table-tbody > tr.ant-table-row:hover .operation-buttons {
  visibility: visible;
  opacity: 1;
  transition: opacity 0.2s ease;
}
</style>

<style>

.btn {
  display: flex;
  justify-items: center;
  align-items: center;
  padding: 10px;
  flex-direction: row;
}

.btn:hover {
  background-color: #ededed;
}

.icon:hover {
  background-color: #ededed;
  border-radius: 8px;
}


.modal .ant-modal-content {
  padding: 0 !important;
  height: 680px !important;
  width: 100%;
  border: none !important;
}

.opacity6 {
  opacity: 0.6;
}

.input-textarea::-webkit-scrollbar {
  width: 4px;
}

.input-textarea::-webkit-scrollbar-thumb {
  background-color: #9f9f9f;
  border-radius: 3px;
}

.input-textarea::-webkit-scrollbar-track {
  background-color: #cdcdcd;
}
</style>


================================================
FILE: frontend/src/view/setting/index.vue
================================================
<template>
  <div class="setting-container">
    <!-- Top Navigation Bar -->
    <div class="top-bar">
      <a-button type="text" @click="back">
        <template #icon>
          <arrow-left-outlined />
        </template>
        {{ $t('setting.back') }}
      </a-button>
    </div>

    <!-- Main Content Area -->
    <div class="main-content">
      <!-- Left Menu Sidebar -->
      <div>
        <setting-menu />
      </div>
      
      <!-- Right Content Area -->
      <div class="content-side">
        <router-view />
      </div>
    </div>
  </div>
</template>

<script setup>
import { onMounted, nextTick } from 'vue'
import { ArrowLeftOutlined } from '@ant-design/icons-vue'
import SettingMenu from './MenuSide.vue'

import emitter from '@/utils/emitter';

import { useI18n } from 'vue-i18n';
const { t } = useI18n();

import { useRouter } from 'vue-router'
const router = useRouter()



import { driver } from "driver.js";
import "driver.js/dist/driver.css";
const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

//search-service
//default-model-setting
//model-service
let tourDriver = null; // æå‡ä½œç”¨åŸŸï¼Œå¹¶åˆå§‹åŒ–ä¸ºç©º

const step1 = async () => {
  tourDriver = driver({
    animate: true,
    showProgress: true,
    prevBtnText: t('setting.prevStep'),
    nextBtnText: t('setting.nextStep'),
    doneBtnText: t('setting.doneStep'),
    steps: [
      {
        element: '#model-service',
        popover: {
          side: 'bottom',
          title: t('setting.modelService.modelService'),
          description: t('setting.modelService.modelServiceTipsOne'),
          onNextClick: async () => {
            nextTick(() => { 
              // è®¾ç½®ç¼“å­˜ï¼Œç»“æŸå¼•å¯¼
              localStorage.setItem('tour_end', 'true');
              tourDriver.moveNext();
            });
          },
        }
      }
    ]
  });

  tourDriver.drive();
};


const step2 = async () => {
  tourDriver = driver({
    animate: true,
    showProgress: true,
    prevBtnText: t('setting.prevStep'),
    nextBtnText: t('setting.nextStep'),
    doneBtnText: t('setting.doneStep'),
    steps: [
      {
        element: '#search-service',
        popover: {
          side: 'bottom',
          title: t('setting.searchService.searchService'),
          description: t('setting.searchService.searchServiceTipsOne'),
          onNextClick: async () => {
            nextTick(() => { 
              // è®¾ç½®ç¼“å­˜ï¼Œç»“æŸå¼•å¯¼
              localStorage.setItem('tour_end', 'true');
              tourDriver.moveNext();
            });
          },
        }
      }
    ]
  });

  tourDriver.drive();
};

const step3 = async () => {
  tourDriver = driver({
    animate: true,
    showProgress: true,
    prevBtnText: t('setting.prevStep'),
    nextBtnText: t('setting.nextStep'),
    doneBtnText: t('setting.doneStep'),
    steps: [
      {
        element: '#default-model-setting',
        popover: {
          side: 'bottom',
          title: t('setting.defaultModel.defaultModel'),
          description: t('setting.defaultModel.defaultModelTipsOne'),
          onNextClick: async () => {
            nextTick(() => { 
              // è®¾ç½®ç¼“å­˜ï¼Œç»“æŸå¼•å¯¼
              localStorage.setItem('tour_end', 'true');
              tourDriver.moveNext();
            });
          },
        }
      }
    ]
  });

  tourDriver.drive();
};

emitter.on('onSearchService', () => { 
  step2();
});

//default-model-setting
emitter.on('onDefaultModelSetting', () => {
  step3();
});

// å…¨å±€äº‹ä»¶ç›‘å¬å™¨ï¼šå…³é—­å¼•å¯¼
emitter.on('closeTour', () => {
  if (tourDriver) {
    tourDriver.moveNext();
  }
  tourDriver = null; // å¯é€‰ï¼šé‡ç½®ä¸º null é¿å…é‡å¤è°ƒç”¨
});


onMounted(() => {
  nextTick(() => {
    if (localStorage.getItem('tour') === 'true' && localStorage.getItem('tour_end') !== 'true') {
      step1();
    }
  });
});



const back = () => {
  router.push('/')
}

</script>

<style scoped lang="scss">
.setting-container {
  display: flex;
  flex-direction: column;
  height: 100vh;
  overflow: hidden;
}

.top-bar {
  height: 60px;
  padding: 0 16px;
  display: flex;
  align-items: center;
  border-bottom: 1px solid #f0f0f0;
  flex-shrink: 0;
}

.main-content {
  display: flex;
  flex: 1;
  min-height: 0;
}
.content-side {
  flex: 1;
  overflow-y: auto;
}


@media screen and (max-width: 768px) {
  .content-side{
    padding: 16px!important;
  }
  //éšè—æ»šåŠ¨æ¡
  .content-side::-webkit-scrollbar{
    display: none;
  }
  .top-bar{
    padding: 0!important;
  }
  .main-content {
    display: flex;
    flex-direction: column!important;

    div{
      overflow: auto;
    }
  } 
}
</style>


================================================
FILE: frontend/src/view/setting/mcp.vue
================================================
<template>
  <div class="mcp-service">
    <McpServer />
  </div>
</template>

<script setup>
import McpServer from "@/components/mcpServer/index.vue";
</script>
<style scoped>
.mcp-service {
  padding: 16px;
}
</style>



================================================
FILE: frontend/src/view/setting/MenuSide.vue
================================================
<template>
  <div class="menu-side">
    <div
      v-for="item in menuItems"
      :id="item.key"
      :key="item.key"
      class="menu-item"
      :class="{ active: $route.path.endsWith(item.key) }"
      @click="handleMenuClick(item)"
    >
      <component :is="item.icon" class="menu-icon" />
      <span>{{ $t(item.name) }}</span>
    </div>
  </div>
</template>

<script setup>
import { useRoute, useRouter } from "vue-router";
import { useI18n } from "vue-i18n";
import emitter from "@/utils/emitter";
import auth from "@/services/auth";
import { useUserStore } from "@/store/modules/user.js";
const { user, membership, points } = useUserStore();
import {
  SettingOutlined,
  UserOutlined,
  ProjectOutlined,
  ApiOutlined,
  DeploymentUnitOutlined as ModelOutlined,
  GlobalOutlined,
  AppstoreOutlined,
  InfoCircleOutlined,
  CodeOutlined,
} from "@ant-design/icons-vue";
const route = useRoute();
const router = useRouter();
// èœå•é¡¹é…ç½®è¯´æ˜ï¼š
// - basic: åŸºæœ¬è®¾ç½®é¡µé¢ /setting/basic
// - default-model-setting: é»˜è®¤æ¨¡å‹é…ç½®é¡µé¢ /setting/default-model-setting
// - model-service: æ¨¡å‹æœåŠ¡é…ç½®é¡µé¢ /setting/model-service
// - search-service: æœç´¢æœåŠ¡é…ç½®é¡µé¢ /setting/search-service
// - mcp-service: MCPæœåŠ¡é…ç½®é¡µé¢ /setting/mcp-service
let menuItems = [
  { key: "basic", name: "setting.menu.basic", icon: SettingOutlined },
  // { key: 'default-model', name: $t('setting.menu.defaultModel'), icon: ModelOutlined }, // æš‚æ—¶ä¸æ˜¾ç¤º
  // { key: 'default-model', name: $t('setting.menu.defaultModel'), icon: ModelOutlined }, // å¼ƒç”¨
  {
    key: "model-service",
    name: "setting.menu.modelService",
    icon: ApiOutlined,
  },
  {
    key: "search-service",
    name: "setting.menu.searchService",
    icon: GlobalOutlined,
  },
  { key: "mcp-service", name: "setting.menu.mcpService", icon: CodeOutlined },
  { key: "about", name: "setting.menu.about", icon: InfoCircleOutlined },
];

const init = async () => {
  if (user.id) {
    menuItems.splice(1, 0, {
      key: "profile",
      name: "setting.menu.account",
      icon: UserOutlined,
    });
    menuItems.splice(2, 0, {
      key: "usage",
      name: "setting.menu.integral",
      icon: ProjectOutlined,
    });
  }
};

init();

const handleMenuClick = (item) => {
  emitter.emit("closeTour");
  emitter.emit("changeMessageText");
  router.push(`/setting/${item.key}`);
};
</script>

<style scoped>
.menu-side {
  width: 200px;
  padding: 16px 0;
}
.menu-item {
  display: flex;
  align-items: center;
  padding: 12px 20px;
  margin: 4px 8px;
  cursor: pointer;
  border-radius: 4px;
  font-size: 14px;
}
.menu-item:hover {
  background: #37352f0f;
}
.menu-item.active {
  background: #37352f0f;
}
.menu-icon {
  margin-right: 8px;
  font-size: 16px;
}

@media screen and (max-width: 768px) {
  .menu-side {
    display: flex;
    width: max-content !important;
    padding: 0 !important;
    border-right: none !important;
    .menu-item {
      span:first-child {
        display: none !important;
      }
    }
  }
}
</style>



================================================
FILE: frontend/src/view/setting/model.vue
================================================
<template>
  <div class="model-service">
    <h2>{{ $t('setting.modelService.title') }}</h2>
    <div class="model-service-container">
      <div class="provider-sidebar">
        <div class="provider-search" style="justify-content: center; align-items: center;">
          <a-input v-model:value="searchQuery" :placeholder="$t('setting.modelService.searchPlaceholder')" prefix-icon
                   style="font-size: 14px; height: 36px; margin-bottom: 16px;">
            <template #prefix>
              <SearchOutlined/>
            </template>
          </a-input>
        </div>

        <div class="platform-list">
          <div v-for="platform in filteredPlatforms" :key="platform.id" class="platform-item"
               :class="{ 'platform-item-active': choose_platform.id === platform.id }"
               @click="handlePlatform(platform)">
            <div v-if="platform.logo_url" class="platform-logo">
              <img :src="platform.logo_url" alt="logo" class="logo">
            </div>
            <div v-else class="platform-letter platform-logo" :style="{ backgroundColor: platform.color }">
              {{ platform.name.charAt(0) }}
            </div>
            <span class="platform-name">{{ getPlatformDisplayName(platform.name) }}</span>
            <span v-if="platform.is_enabled" class="status-text">{{ $t('setting.modelService.statusOn') }}</span>
          </div>
        </div>

        <div class="provider-post platform-item" @click="handlePlatformAdd()"> + {{
            $t('setting.modelService.addPlatform')
          }}
        </div>
      </div>
      <div class="provider-sidebar-mobile">
        <div
            style="display: flex; flex-direction: row; justify-content: space-between; align-items: center; margin-bottom: 8px;">
          <div style="color:#213547;font-size: 18px;font-weight: 700;">{{ $t(`setting.modelService.modelPlatform`) }}
          </div>
          <div class="provider-post" @click="handlePlatformAdd()"> + {{
              $t('setting.modelService.addPlatform')
            }}
          </div>
        </div>
        <a-select style="width: 100%;" v-model:value="choose_platform.id">
          <a-select-option v-for="platform in filteredPlatforms" :key="platform.id" :value="platform.id"
                           @click="handlePlatform(platform)">
            <div class="platform-item">
              <div v-if="platform.logo_url" class="platform-logo">
                <img :src="platform.logo_url" alt="logo" class="logo">
              </div>
              <div v-else class="platform-letter platform-logo" :style="{ backgroundColor: platform.color }">
                {{ platform.name.charAt(0) }}
              </div>
              <span class="platform-name">{{ platform.name }}</span>
              <span v-if="platform.is_enabled" class="status-text">{{ $t('setting.modelService.statusOn') }}</span>
            </div>
          </a-select-option>
        </a-select>
      </div>
      <div class="provider-info">
        <div class="info-header">
          <span class="info-model-header">{{ getPlatformDisplayName(choose_platform.name) }} </span>
          <span v-if="choose_platform.source_type === 'user'" class="platform-icon">
            <setting-outlined class="platform-setting" @click.stop="handlePlatformSetting"/>
          </span>
          <span class="platform-status" v-if="!choose_platform.is_subscribe">
            <a-switch v-model:checked="choose_platform.is_enabled" class="custom-switch" @change="handleSaveChanges"/>
          </span>
          <!-- <a-button :disabled="!isInfoChanged" type="primary" class="save-button" @click="handleSaveChanges">{{
            $t('setting.modelService.save') }}</a-button> -->
        </div>

        <div class="info-content">
          <div class="info-platform" v-if="!choose_platform.is_subscribe">
            <!--      provider info DIY      -->
            <div class="api-msg-container" >
<!--              <div v-if="choose_platform.name===`Cloudsway`">-->
<!--                <span class="api-key">{{ $t('setting.modelService.ak') }}</span>-->
<!--                <a-input-password v-if="choose_platform.name===`Cloudsway`" id="api-key-value"-->
<!--                                  v-model:value="choose_platform.api_key"-->
<!--                                  :placeholder="$t('setting.modelService.akPlaceholder')" class="api-input" @blur="handleSaveChanges"/>-->
<!--              </div>-->
              <div v-if="choose_platform.name.toLocaleString() === 'Ollama'">
                      <!--       ollama do not have apikey           -->
              </div>
              <div v-else>
                <span class="api-key">{{handleApiTitle }}</span>
                  <a-input-password id="api-key-value" v-model:value="choose_platform.api_key"
                                  :placeholder="handleApiPlaceholder"  @change="handleSaveChanges">
                     <template #addonAfter>
                        <a-button class="no-button" @click="handleCheckApiKey" :loading="checkLoading" >{{
               $t('setting.modelService.check') }}</a-button>
                     </template>
                  </a-input-password>


              </div>

            </div>

            <a v-if="choose_platform.key_obtain_url" :href="choose_platform.key_obtain_url" target="_blank"
               class="get-api-link">{{ $t('setting.modelService.getApiKey')  }}</a>

            <span class="api-address-title">{{ $t('setting.modelService.apiAddress') }}</span>

            <a-input v-model:value="choose_platform.api_url"
                     :placeholder="$t('setting.modelService.apiAddressPlaceholder')" class="api-input" @change="handleSaveChanges">
              <template #addonAfter v-if="handleShowCheckButton">
                        <a-button class="no-button" @click="handleCheckApiKey" :loading="checkLoading" >{{
               $t('setting.modelService.check') }}</a-button>
                     </template>
            </a-input>
            <div class="show-api-tips">
              <div>
                <span v-if="choose_platform?.api_url?.endsWith('#')" class="api-address">
                  {{ choose_platform.api_url.substring(0, choose_platform.api_url.length - 1) }}
                </span>
                <span v-else-if="choose_platform?.api_url?.endsWith('/')" class="api-address">
                  {{ choose_platform.api_url }}chat/completions
                </span>
                <span v-else class="api-address">
                  {{ choose_platform?.api_url }}/chat/completions
                </span>
              </div>
              <div class="api-address">
                {{ $t('setting.modelService.apiAddressTip') }}
              </div>
            </div>

          </div>
          <div class="info-model">
            <div>
              <models-list :models="models" :platform_id="choose_platform.id" :is_subscribe="choose_platform.is_subscribe" @setting="" @delete="handleModelDelete"
                           @add-model="handleModelAdd" @update-model="handleModelUpdate"/>
            </div>
          </div>
        </div>
      </div>
    </div>
    <add-platform ref="addPlatformRef" @add-platform="handleAddPlatform"/>
    <setting-platform ref="settingPlatformRef" @update-platform="handleUpdatePlatform"/>
  </div>
    <!-- é€‰æ‹©æ¨¡å‹å¼¹çª— -->
  <a-modal  :cancelText=" $t('setting.modelService.cancel')" :okText="$t('setting.modelService.confirm')" v-model:open="modelVisible" centered   :title="$t('setting.modelService.selectCheckModel')" width="400px" @ok="handleOk">
      <a-select v-model:value="selectedModel" style="width: 100%">
        <a-select-option v-for="model in models" :key="model.id" :value="model.model_id">
          {{ model.model_name }}
        </a-select-option>
      </a-select>
  </a-modal>

</template>

<script setup>
import {ref, onMounted, computed, watch, nextTick} from 'vue'
import {useI18n} from 'vue-i18n'

const {t} = useI18n()
import service from '@/services/platforms'
import {
  SettingOutlined,
  SearchOutlined,
  DownOutlined,
  RightOutlined,
  SnippetsOutlined,
  ToolOutlined,
  GlobalOutlined,
  BranchesOutlined,
  CameraOutlined
} from '@ant-design/icons-vue'
import {message} from 'ant-design-vue'
import AddPlatform from '@/components/platforms/addPlatform.vue'
import SettingPlatform from '@/components/platforms/settingPlatform.vue'
import ModelsList from '@/components/platforms/modelsList.vue'
import emitter from '@/utils/emitter'

import {driver} from "driver.js";
import "driver.js/dist/driver.css";

import { useUserStore } from '@/store/modules/user.js'
const { user,membership,points } = useUserStore();

const platforms = ref({})
const choose_platform = ref({
  id: 'default',
  name: 'OpenAI',
})
const searchQuery = ref('')
const models = ref([])
const originalInfo = ref({})
const isInfoChanged = ref(false)
const showInfoPlatform = ref(true)

const modelVisible  = ref(false)
const selectedModel = ref(null)
const checkLoading = ref(false)

//handleCheckApiKey
const  handleCheckApiKey = async () => {
  modelVisible.value = true;
}

const handleOk =  async () => {
  if (!selectedModel.value) {
    //setting.modelService.selectCheckModel
    message.error(t('setting.modelService.selectCheckModel'))
    return
  }
  //checkApiAvailability

  modelVisible.value = false;
  checkLoading.value = true
  let res = await service.checkApiAvailability({
    "base_url": choose_platform.value.api_url,
    "api_key": choose_platform.value.api_key,
    "model": selectedModel.value
  })
  checkLoading.value = false
  if(res.status){
    //res.message : LLM API call succeeded start
    message.success(t('setting.modelService.apiCallSucceeded'))
  }else{
    //`LLM API call failed, HTTP status: ${response.status}, error: ${errorText}`
    if(res.message.startsWith('LLM API call failed')){
      let resposneContent = res.message.replace('LLM API call failed', t('setting.modelService.apiCallFailed'))
      message.error(resposneContent)
    }else if(res.message.startsWith('LLM API call timed out')){
      let resposneContent = res.message.replace('LLM API call timed out', t('setting.modelService.apiCallTimeout'))
      message.error(resposneContent)
    }else if(res.message.startsWith('Network or other error occurred during LLM API call')){
      let resposneContent = res.message.replace('Network or other error occurred during LLM API call', t('setting.modelService.unknownError'))
      message.error(resposneContent)
    }
  }
}


// i18 support
function getPlatformDisplayName(name) {
  const key = `setting.modelService.platforms.${name.replace(' ', '')}`;
  const translation = t(key);
  // å¦‚æœç¿»è¯‘ç»“æœç­‰äºé”®åï¼Œè¯´æ˜ç¿»è¯‘ä¸å­˜åœ¨ï¼Œå›é€€åˆ°åŸå§‹ name
  return translation === key ? name : translation;
}

emitter.on('fresh-models', (value) => {
  handleGetModels(choose_platform.value.id)
})

const handleShowCheckButton = computed(() => {
  return choose_platform.value.name.toLocaleString() === 'Ollama'
})
const handleApiTitle = computed(() => {
  if (choose_platform.value.name === 'Cloudsway') {
    return t('setting.modelService.ak')
  }
  return t('setting.modelService.apiKey')
})
const handleApiPlaceholder = computed(() => {
  if (choose_platform.value.name === 'Cloudsway') {
    return t('setting.modelService.akPlaceholder')
  }
  return t('setting.modelService.apiKeyPlaceholder')
})
const handlePlatform = (platform) => {

  choose_platform.value = JSON.parse(JSON.stringify(platform))
  originalInfo.value = {
    api_key: platform.api_key,
    api_url: platform.api_url,
    is_enabled: platform.is_enabled
  }
  handleGetModels(choose_platform.value.id)

  showInfoPlatform.value = true
}

watch([() => choose_platform.value.api_key, () => choose_platform.value.api_url, () => choose_platform.value.is_enabled],
    () => {
      if (!originalInfo.value) return
      isInfoChanged.value =
          choose_platform.value.api_key !== originalInfo.value.api_key ||
          choose_platform.value.api_url !== originalInfo.value.api_url ||
          choose_platform.value.is_enabled !== originalInfo.value.is_enabled
    },
    {deep: true}
)

const handleSaveChanges = async () => {
  try {
    await service.updatePlatform({
      id: choose_platform.value.id,
      api_key: choose_platform.value.api_key,
      api_url: choose_platform.value.api_url,
      is_enabled: choose_platform.value.is_enabled,
      name: choose_platform.value.name,
      logo_url: choose_platform.value.logo_url,
      provider_type: choose_platform.value.provider_type,
      api_version: choose_platform.value.api_version
    })
    originalInfo.value = {
      api_key: choose_platform.value.api_key,
      api_url: choose_platform.value.api_url,
      is_enabled: choose_platform.value.is_enabled
    }
    isInfoChanged.value = false
  } catch (error) {
    return
  }
  init(choose_platform.value.id)
}

const addPlatformRef = ref(null)
const settingPlatformRef = ref(null)

const handlePlatformAdd = () => {
  addPlatformRef.value?.showModal()
}

const handlePlatformSetting = () => {
  settingPlatformRef.value?.showModal(choose_platform.value)
}


const handleModelDelete = (model) => {
  models.value = models.value.filter(m => m.id !== model.id)
};

const handleAddPlatform = (platformData) => {
  const newPlatform = {
    ...platformData,
    is_enabled: true,
    source_type: 'user',
    color: colors[platforms.value.length % colors.length]
  }
  platforms.value = [...platforms.value, newPlatform]
  choose_platform.value = newPlatform
  handleGetModels(choose_platform.value.id)
}

const handleUpdatePlatform = (updatedPlatform) => {
  const index = platforms.value.findIndex(p => p.id === updatedPlatform.id)
  if (index !== -1) {
    platforms.value[index] = {...updatedPlatform, color: platforms.value[index].color}
    if (choose_platform.value.id === updatedPlatform.id) {
      choose_platform.value = platforms.value[index]
    }
  }
}

const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEEAD', '#D4A5A5', '#9B59B6', '#3498DB']

onMounted(async () => {
  //è§¦å‘å…¨å±€äº‹ä»¶ closeTour å»¶è¿Ÿ500mms
  setTimeout(() => {
    console.log('è§¦å‘ closeTour')
    emitter.emit('closeTour')
  }, 500)
  await init();
  //localStorage.setItem('tour_end', 'true');
  if (localStorage.getItem('tour') === 'true' && localStorage.getItem('tour_end') !== 'true') {
    step1();
  }
})


let tourDriver = null; // æå‡ä½œç”¨åŸŸï¼Œå¹¶åˆå§‹åŒ–ä¸ºç©º

const step1 = async () => {
  tourDriver = driver({
    animate: true,
    showProgress: true,
    prevBtnText: t('setting.prevStep'),
    nextBtnText: t('setting.nextStep'),
    doneBtnText: t('setting.doneStep'),
    steps: [
      {
        element: '.platform-list',
        popover: {
          side: 'bottom',
          title: t('setting.modelService.modelService'),
          description: t('setting.modelService.modelServiceTipsOne'),
          onNextClick: async () => {
            nextTick(() => {
              // è®¾ç½®ç¼“å­˜ï¼Œç»“æŸå¼•å¯¼
              tourDriver.moveNext();
            });
          },
        }
      },
      {
        element: '#api-key-value',
        popover: {
          side: 'bottom',
          title: t('setting.modelService.modelService'),
          description: t('setting.modelService.modelServiceTipsTwo'),
          onNextClick: async () => {
            nextTick(() => {
              // è®¾ç½®ç¼“å­˜ï¼Œç»“æŸå¼•å¯¼
              tourDriver.moveNext();
            });
          },
        }
      },
      {
        //platform-status
        element: '.platform-status',
        popover: {
          side: 'bottom',
          title: t('setting.modelService.modelService'),
          description: t('setting.modelService.modelServiceTipsThree'),
          onNextClick: async () => {
            nextTick(() => {
              // è®¾ç½®ç¼“å­˜ï¼Œç»“æŸå¼•å¯¼
              localStorage.setItem('tour_end', 'true');
              tourDriver.moveNext();
              emitter.emit('onSearchService');
            });
          },
        }
      }
    ]
  });

  tourDriver.drive();
};

function init(id) {
  service.getPlatforms().then((res) => {
    //åˆ¤æ–­æ˜¯ä¸æ˜¯ä¼šå‘˜ membership
    let is_membership = false;
    //åˆ¤æ–­æ˜¯ä¸æ˜¯åœ¨ membership.endDate: "2026-06-12T09:44:02.000Z" membership.startDate: "2025-06-12T09:44:02.000Z" åœ¨è¿™ä¸ªæ—¶é—´èŒƒå›´å†…
    if (membership && membership?.startDate && membership?.endDate) {
        const start = new Date(membership.startDate);
        const end = new Date(membership.endDate);
        const now = new Date();

        if (!isNaN(start.getTime()) && !isNaN(end.getTime())) {
          if (now >= start && now <= end) {
            is_membership = true;
          }
        }
    }
    platforms.value = res.sort((u, v) => {
      // return u.name.toUpperCase() > v.name.toUpperCase() ? 1 : -1; // å¿½ç•¥å¤§å°å†™è¿›è¡Œæ’åºï¼Œç¡®ä¿å¤§å†™å­—æ¯åœ¨å°å†™å­—æ¯ä¹‹å‰
      return u.name.localeCompare(v.name); // ä½¿ç”¨æœ¬åœ°è¯­è¨€ç¯å¢ƒè¿›è¡Œæ’åºï¼Œç¡®ä¿æ­£ç¡®çš„å­—æ¯é¡ºåº
    }).map((platform, index) => ({
      ...platform,
      color: colors[index % colors.length]
    }))
    if (id) {
      choose_platform.value = platforms.value.find(p => p.id === id)
      handleGetModels(choose_platform.value.id)
    } else {
      choose_platform.value = platforms.value[0]
      handleGetModels(choose_platform.value.id)
    }

  })
}

const handleGetModels = ( id) => {
       service.getModels(id).then((res) => {
        models.value = res
        selectedModel.value = res[0]?.model_id
      })
}

const filteredPlatforms = computed(() => {
  // Defensive check: Ensure platforms.value is an array; default to empty array if not
  const platformsArray = Array.isArray(platforms.value) ? platforms.value : [];
  // 1. Sort by is_enabled: true first, false later
  const sortedPlatforms = [...platformsArray].sort((a, b) => {
    return (b.is_enabled ? 1 : 0) - (a.is_enabled ? 1 : 0);
  });

  // 2. Return sorted platforms if no search query
  if (!searchQuery.value) {
    return sortedPlatforms;
  }

  // 3. Filter by search query
  const query = searchQuery.value.toLowerCase();
  return sortedPlatforms.filter(platform =>
    platform.name && platform.name.toLowerCase().includes(query) || getPlatformDisplayName(platform.name).includes(query)
  );
});
const handleModelAdd = async (model) => {
  // console.log(model)
 handleGetModels(choose_platform.value.id)
}

const handleModelUpdate = async (model) => {
  handleGetModels(choose_platform.value.id)
}


emitter.on('fresh-pages', (value) => {
  // åˆ·æ–°é¡µé¢
  init()

})
</script>

<style scoped>
.model-service {
  padding: 16px;
  height: 100%;
  overflow-y: hidden;
}

.model-service-container {
  display: flex;
  flex-direction: row;
  padding: 1px;
}

.provider-sidebar {
  width: 250px;
  padding: 16px 0;
  display: flex;
  flex-direction: column;
  height: 80vh;
}

.provider-sidebar-mobile {
  display: none;
}

.provider-info {
  flex: 5;
  max-height: calc(100vh - 200px);
  overflow-y: auto;
  box-sizing: border-box;
}

.provider-info::-webkit-scrollbar {
  width: 2px;
  background-color: transparent;
  opacity: 0;
  transition: opacity 0.3s ease;
}

.provider-info:hover::-webkit-scrollbar {
  opacity: 1;
}

.provider-info::-webkit-scrollbar-thumb {
  background-color: #d9d9d9;
  border-radius: 3px;
}

.provider-info::-webkit-scrollbar-track {
  background-color: transparent;
}

.platform-item {
  display: flex;
  align-items: center;
  cursor: pointer;
  padding: 8px;
  gap: 8px;
  border-radius: 4px;
  margin-bottom: 8px;
}

.provider-post {
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  border-radius: 10px;
  text-align: center;
  border: 1px solid #ededed;
  padding: 5px;
  margin-top: auto;
}


.platform-item-active {
  background-color: #f0f0f0;
}


.platform-logo {
  width: 30px;
  height: 30px;
  border-radius: 10px;
  margin-left: 8px;
}

.logo {
  border-radius: 6px;
  width: 32px;
  height: 32px;
}

.platform-letter {
  border-radius: 4px;
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  font-weight: bold;
}

.platform-name {
  flex: 1;
}

.platform-setting {
  color: #8c8c8c;
  cursor: pointer;
}

.platform-setting:hover {
  color: #1890ff;
}

.platform-delete {
  color: #8c8c8c;
  cursor: pointer;
}

.platform-delete:hover {
  color: #1890ff;
}

.platform-status {
  display: flex;
  align-items: center;
  margin-left: auto;
}

.status-text {
  background-color: #e7f3e1;
  padding-left: 7px;
  padding-right: 7px;
  color: #7fd056;
  border-radius: 10px;
  font-size: 11px;
  border: #8fc873 1px solid;
}

.custom-switch :deep(.ant-switch-checked) {
  background-color: #67c23a;
}

.info-header {
  display: flex;
  justify-content: start;
  padding: 12px 16px;
}

.info-subscription-header {
  flex-direction: column;
}

.info-content {
  padding: 12px 16px;
  display: flex;
  flex-direction: column;
}

.info-platform {
  display: flex;
  flex-direction: column;
}

.api-input {
  margin-top: 5px;
  margin-bottom: 5px;
  font-size: 14px;
}

.get-api-link {
  margin-left: 5px;
  margin-top: 5px;
  font-size: 11px;
  color: #1890ff;
}

.modal-content {
  padding: 16px;
  text-align: center;
}

.round-button {
  border-radius: 20px;
  padding: 8px 24px;
}

.confirm-btn {
  background-color: #ff4d4f;
  border-color: #ff4d4f;
}

.confirm-btn:hover {
  background-color: #ff7875;
  border-color: #ff7875;
}

.save-button {
  margin-left: 12px;
  border-radius: 20px;
}

.api-address-title {
  margin-top: 10px;
  font-weight: bold;
}

.provider-search {
  width: 100%;
  font-size: 14px;
}

.platform-icon {
  padding-left: 6px;
  display: flex;
}

.platform-list {
  overflow-y: auto;
  height: 80vh;
  overflow-x: hidden;
  font-size: 14px;
  padding-right: 12px;
  box-sizing: border-box;
}

.platform-list::-webkit-scrollbar {
  width: 2px;
  height: 30px;
  background-color: transparent;
  scrollbar-width: none; /* é»˜è®¤éšè— */
}

.platform-list::-webkit-scrollbar-thumb {
  background-color: #d9d9d9;
  border-radius: 3px;
  opacity: 0; /* é»˜è®¤éšè—æ»šåŠ¨æ¡ */
  transition: opacity 0.3s ease; /* å¹³æ»‘è¿‡æ¸¡ */
}

.platform-list::-webkit-scrollbar-track {
  background-color: transparent;
}

/* é¼ æ ‡æ‚¬åœæ—¶æ˜¾ç¤ºæ»šåŠ¨æ¡ */
.platform-list:hover::-webkit-scrollbar-thumb {
  opacity: 1;
}




.model-header {
  display: flex;
  align-items: center;
  font-size: 16px;
  font-weight: 500;
  margin-bottom: 12px;
}

.models-list {
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(255, 255, 255, 0.09);
}

.sub-title {
  font-size: 13px;
  color: #8c8c8c;
}

.model-group {
  margin-bottom: 10px;
  border-radius: 6px;
  border: #d1d1d1 solid 1px;
}

.group-header {
  display: flex;
  align-items: center;
  cursor: pointer;
  background-color: #f5f5f5;
  padding: 12px;
  gap: 12px;
}

.group-toggle {
  font-size: 14px;
  color: #a4a2a2;
  transition: transform 0.6s;
}

.group-toggle.expanded {
  transform: rotate(180deg);
  border-bottom: #666 solid 1px;
}

.model-items {
  transition: max-height 0.3s ease-in-out, opacity 0.3s ease-in-out;
  opacity: 1;
  overflow: hidden;
}

.model-items.collapsed {
  max-height: 0;
  opacity: 0;
  margin: 0;
  padding: 0;
}

.model-item {
  display: flex;
  align-items: center;
  background: #fff;
  border-radius: 8px;
  transition: all 0.3s;
  padding: 12px;
  gap: 12px;
}

.logo-letter {
  width: 32px;
  height: 32px;
  border-radius: 4px;
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  font-weight: bold;
}

.model-name {
  font-size: 14px;
  color: #333;
}

.model-type {
  margin-left: 10px;
  font-size: 12px;
  color: #666;
}

.model-actions {
  display: flex;
  gap: 8px;
}

.group-name {
  font-size: 13px;
  font-weight: 500;
  color: #202020;
  font-weight: bold;
}

.api-address {
  font-size: 12px;
  color: #cdcdcd;
}

.show-api-tips {
  display: flex;
  flex-direction: row;
  justify-content: space-between;
}

.type-icon {
  margin-top: 2px;
  height: 18px;
  width: 25px;
  border-radius: 7px;
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: 10px;
}

.type-tool {
  background-color: #ffe1ce;
  color: #a07b64;
}

.type-network {
  background-color: #b1d7f4;
  color: #537fa1;
}

.type-embed {
  background-color: #f3d4a5;
  color: #917142;
}

.type-reasoning {
  background-color: #b1bac7;
  color: #64728a;
}

.type-vision {
  background-color: #c9f6d3;
  color: #54b46a;
}

.model-info {
  flex: 1;
  display: flex;
  flex-direction: row;
  gap: 10px;
}

.api-key {
  font-weight: bold;

}

.no-button{
  border: unset !important;
    background-color: unset!important;
    height: unset!important;
}
.info-model-header {
  display: flex;
  font-weight: bold;
  font-size: 18px;
}

@media screen and (max-width: 768px) {

  h2 {
    display: none !important;
  }

  .model-service-container {
    display: flex;
    flex-direction: column;
  }

  .model-service {
    padding: 0 !important;
  }

  .provider-sidebar {
    display: none !important;
  }

  .provider-info {
    max-height: 100% !important;
  }

  .provider-sidebar-mobile {
    display: block !important;
  }

  :deep(.ant-select-selector) {
    height: 48px !important;
    /* border: none !important; */
  }

  .info-header {
    padding-left: 0px !important;
    padding-right: 0px !important;
  }

  .info-content {
    padding-left: 0px !important;
    padding-right: 0px !important;
    padding-bottom: 48px !important;
  }

  .platform-item-active {
    background-color: unset !important;
  }

  .save-button {
    position: absolute;
    bottom: 0px;
    z-index: 99;
    margin: 0px;
    border: unset;
    border-radius: 0px;
    width: 100%;
    background: rgb(26, 26, 25);
    font-size: 16px;
    font-weight: 500;
    left: 0;
    color: #fff;
    height: 48px;
  }

}


@media (hover: hover) and (pointer: fine) {
  .provider-post:hover {
    background-color: #f0f0f0;
  }

  .platform-item:hover {
    background-color: #f0f0f0;
  }
}
</style>


================================================
FILE: frontend/src/view/setting/search.vue
================================================
<template>
    <div class="search-service">
        <h2>{{$t('setting.searchService.title')}}</h2>
        <searchEngine/>
    </div>
</template>

<script setup>
import searchEngine from '@/components/searchEngine/index.vue'
</script>

<style scoped>

.search-service {
padding: 16px;
}

@media screen and (max-width: 768px) {
    .search-service {
        padding: 0px!important;
    }
    h2{
        display: none!important;
    }
}
</style>


================================================
FILE: frontend/src/view/share/index.vue
================================================
<template>
    <div class="lemon-container">
        <div class="lemon-content">
            <!-- ä¸»é¡µé¢ -->
            <div class="lemon-main">
                <ChatHeader :title="currentChat.title" />
                <ChatMessages :messages="messages" />
                <div class="scroll-to-bottom" @click="scrollToBottom" v-if="isShowScrollToBottom">
                    <Down />
                </div>
                <div class="lemon-footer">
                    <div style="display: flex;align-items: center;">
                        <div><img style="width: 20px;height: 20px; margin-right: 5px;" src="@/assets/image/lemon.jpg" alt="" /></div>
                        <span style="color: #34322d;font-size: .875rem;line-height: 1.25rem;">
                            <div v-if="playStatus!='running'">LemonAI{{ $t('task_finished') }}</div>
                            <div v-else>LemonAI{{ $t('task_playing') }}...</div>
                        </span>
                    </div>
                    <div>
                        <a-button v-if="playStatus!='running'" type="primary" @click="handleRestart">{{ $t('replay') }}</a-button>
                        <a-button v-else type="primary" @click="toResult">{{ $t('jump_to_result') }}</a-button>
                    </div>
                </div>
            </div>
            <!-- å®æ—¶é¢„è§ˆæ–‡ä»¶-->
            <Preview class="preview" />
            <!--æœ¬åœ°é¢„è§ˆæ–‡ä»¶-->
            <LocalPreview class="preview" />
        </div>
    </div>
</template>

<script setup>
import { ref, onMounted, onUnmounted, watch, computed } from 'vue'

import Preview from '@/components/preview/index.vue'
import LocalPreview from '@/components/preview/fullPreview.vue'
import ChatHeader from '@/view/lemon/components/ChatHeader.vue'
import ChatMessages from '@/view/lemon/components/ChatMessages.vue'
import emitter from '@/utils/emitter';

import { useRoute } from 'vue-router';
const route = useRoute();

import { useChatStore } from '@/store/modules/chat';
const chatStore = useChatStore();
const isCollapsed = ref(false);

const currentChat = computed(() => chatStore.chat)
const messages = computed(() => chatStore.messages)
const playStatus = computed(() => chatStore.list.find((c) => c.conversation_id == route.params.id)?.status)

import { useI18n } from 'vue-i18n';

const { t } = useI18n();

const toggleCollapse = () => {
    isCollapsed.value = !isCollapsed.value;
}

let conversationId;
const init = async () => {
    // chatStore.messages = caseData;
    // ä»è·¯ç”±ä¸­è·å–id
    conversationId = route.params.id;
    chatStore.playback(conversationId,500);
}
const handleRestart = () => {
    emitter.emit('fullPreviewVisable-close')
    chatStore.playback(conversationId,500);
};


const toResult = () => {
    chatStore.toResult();
};


const isShowScrollToBottom = ref(false);

onMounted(() => {
    //æ·»åŠ æ»šåŠ¨äº‹ä»¶ç›‘å¬
    init();
    const chatMessages = document.querySelector('.chat-messages');
    if (!chatMessages) return false;
    chatMessages.addEventListener('scroll', () => {
        if (chatMessages.scrollHeight - chatMessages.scrollTop - chatMessages.clientHeight > 200) {
            isShowScrollToBottom.value = true;
        } else {
            isShowScrollToBottom.value = false;
        }
    })
})

const scrollToBottom = () => {
  const chatMessages = document.querySelector('.chat-messages');
  if(!chatMessages) return false;
  chatMessages.scrollTop = chatMessages.scrollHeight - chatMessages.clientHeight;
}




</script>

<style lang="scss" scoped>
.menu-switch {
    cursor: pointer;
}

.lemon-container {
    display: flex;
    justify-content: center;
    width: 100%;
    height: 100vh;
    background: #f8f8f7;
}

.lemon-content {
    width: 100%;
    height: 100%;
    display: flex;
    overflow-y: auto;

    .lemon-main {
        min-width: 50%;
        padding-left: 1.25rem;
        padding-right: 1.25rem;
        max-width: 100%;
        width: 100%;
        overflow: hidden;
    }

    .preview {
        max-width: 50%;
        min-width: 50%;
    }
}

@media screen and (max-width: 768px) {
    .preview {
        position: absolute;
        z-index: 999;
        margin: 0px;
        width: 100vw !important;
        height: 100vh !important;
        border-radius: 0px;
        max-width: 100vh !important;
        border: unset !important;
        box-shadow: unset !important;
    }
}

@media (min-width: 640px) {
  .lemon-main {
    max-width: 768px!important;
    min-width: 390px!important;
    margin-left: auto;
    margin-right: auto;
  }
}

.lemon-footer{
    position: sticky;
    bottom: 12px;
    padding-right: .75rem;
    padding-left: 1rem;
    padding-top: 9px;
    padding-bottom: 9px;
    background-color:#fff;
    border:1px solid #0000000f;
    border-radius: .75rem;
    box-shadow: 0px 5px 16px 0px #00000014,0px 0px 1.25px 0px #0000000f;
    display: flex;
    justify-content: space-between;
}

:deep(.more-btn){
    display: none!important;
}
:deep(.share-btn){
    display: none!important;
}
</style>


================================================
FILE: frontend/src/view/welcome/WelcomeView.vue
================================================
<template>
  <WelcomeLayout
    :greeting="$t('lemon.welcome.greeting', { username })"
    :description="welcomeDescription"
    @rootClick="closeDropdown"
  >
    <template #header>
      <!-- AgentWelcome æ¨¡å¼ï¼šæ˜¾ç¤º agent åç§°å’Œä¸‹æ‹‰èœå• -->
      <div v-if="isAgentMode" class="welcome-mode agent-mode">
        <span>{{ agent.name }}</span>
        <div class="dropdown-icon-wrapper" @click.stop="toggleDropdown">
          <CaretDownOutlined class="dropdown-icon" />
          <div v-if="showDropdown" class="dropdown-menu">
            <div class="menu-item" @click.stop="openEdit">
              <EditOutlined class="icon" /> Edit
            </div>
            <div class="menu-item" @click.stop="editKnowledge">
              <ReadOutlined class="icon" /> Experience
            </div>
          </div>
        </div>
      </div>

      <!-- Welcome æ¨¡å¼ï¼šæ˜¾ç¤ºç§»åŠ¨ç«¯èœå• -->
      <template v-else>
        <div class="welcome-header">
          <button class="mobile-menu-btn" @click="toggleMobileMenu">
            <MobileMenuIcon />
          </button>
        </div>
        <div class="welcome-mode">
          <!-- <h2>{{handleModeTitle }}</h2> -->
        </div>
      </template>
    </template>

    <template #input>
      <ChatInput @send="handleWelcomeInput" @modeChange="handleModeChange" />
    </template>

    <template #sample>
      <Sample @sampleClick="sampleClick" />
    </template>

    <template #extra>
      <!-- AgentWelcome æ¨¡å¼ï¼šç¼–è¾‘å’ŒçŸ¥è¯†åº“æ¨¡æ€æ¡† -->
      <template v-if="isAgentMode">
        <KnowledgeModal ref="knowledgeModalRef" :agentId="null" />
        <AgentsEdit v-model:visible="editVisible" v-model:id="agent.id" />
      </template>

      <!-- Welcome æ¨¡å¼ï¼šAgent åˆ›å»ºåŠ è½½åŠ¨ç”» -->
      <div v-if="isLoadingVisible" class="agent-loading">
        <div class="loader"></div>
        <p class="tip">{{ tip }}</p>
      </div>
    </template>
  </WelcomeLayout>
</template>

<script setup>
import { ref, computed, onMounted, onUnmounted } from 'vue';
import { storeToRefs } from 'pinia';
import { useRouter } from 'vue-router';
import { CaretDownOutlined, EditOutlined, DeleteOutlined, ReadOutlined } from '@ant-design/icons-vue';

import WelcomeLayout from './components/WelcomeLayout.vue';
import ChatInput from '@/view/lemon/components/ChatInput.vue';
import Sample from '@/view/lemon/components/Sample.vue';
import MobileMenuIcon from '@/assets/svg/mobile-menu-icon.svg';
import KnowledgeModal from '@/view/agents/components/KnowledgeModal.vue';
import AgentsEdit from '@/view/agents/components/agentsEdit.vue';

import { useChatStore } from '@/store/modules/chat';
import seeAgent from '@/services/see-agent';
import agentServices from '@/services/agent';
import emitter from '@/utils/emitter';
import { useWelcomeCommon } from './composables/useWelcomeCommon';

const chatStore = useChatStore();
const router = useRouter();
const { chatInfo, mode, agent } = storeToRefs(chatStore);

// ä½¿ç”¨å…±äº«é€»è¾‘
const { username, welcomeDescription, sampleClick, handleModeChange } = useWelcomeCommon();

// åˆ¤æ–­æ˜¯å¦ä¸º Agent æ¨¡å¼ï¼ˆæœ‰ agentIdï¼‰
const props = defineProps({
  agentId: {
    type: String,
    default: null
  }
});

const isAgentMode = computed(() => !!props.agentId);

// Agent æ¨¡å¼ç‰¹æœ‰çš„é€»è¾‘
const knowledgeModalRef = ref(null);
const editVisible = ref(false);
const showDropdown = ref(false);

const editKnowledge = () => {
  console.log('editKnowledge');
  showDropdown.value = false;
  knowledgeModalRef.value.visible = true;
};

const openEdit = () => {
  showDropdown.value = false;
  editVisible.value = true;
};

const toggleDropdown = () => {
  showDropdown.value = !showDropdown.value;
};

const closeDropdown = () => {
  if (isAgentMode.value) {
    showDropdown.value = false;
  }
};

// Welcome æ¨¡å¼ç‰¹æœ‰çš„é€»è¾‘
const isLoadingVisible = ref(false);
const tip = ref('Creating Agent...');

function show(initialTip = 'Creating Agent...') {
  tip.value = initialTip;
  isLoadingVisible.value = true;
}

function update(newTip) {
  tip.value = newTip;
}

function hide() {
  isLoadingVisible.value = false;
}

// ç§»åŠ¨ç«¯èœå•æŒ‰é’®ç‚¹å‡»å¤„ç†
const toggleMobileMenu = () => {
  console.log('toggleMobileMenu');
  emitter.emit('toggleMobileMenu', true);
};

// ç»Ÿä¸€çš„è¾“å…¥å¤„ç†é€»è¾‘
const handleWelcomeInput = async (value) => {
  const { text, files, mcp_server_ids, is_public, workMode } = value;
  const result = await chatStore.createConversation(text, workMode);
  const { conversation_id } = result;

  // Agent æ¨¡å¼ï¼šç›´æ¥ä½¿ç”¨å½“å‰ agent
  if (isAgentMode.value) {
    console.log('agent.value', agent.value);  
    if (conversation_id) {
      router.push(`/lemon/${agent.value.id}/${conversation_id}`);
    }
    await seeAgent.sendMessage(text, conversation_id, files, mcp_server_ids, workMode);
  }
  // Welcome æ¨¡å¼ï¼šåˆ›å»ºæ–° agent
  else {
    show('Creating Agent...');
    await new Promise(resolve => setTimeout(resolve, 1000));
    update('Learning from the Experience base...');
    let res = await agentServices.generate(text, conversation_id, is_public);
    hide();
    // åˆ·æ–° agent
    emitter.emit('selectedAgent', res);
    router.push(`/lemon/${res.id}/${conversation_id}`);
    await seeAgent.sendMessage(text, conversation_id, files, mcp_server_ids, workMode);
  }
};

const handleModeTitle = computed(() => {
  if (mode.value === 'chat') {
    return 'ChatBot';
  }
  return 'Agent';
});

// ç›‘å¬å·¥ä½œæ¨¡å¼å˜åŒ–
onMounted(() => {
  emitter.on('updateWorkMode', (workMode) => {
    console.log('æ”¶åˆ° updateWorkMode äº‹ä»¶:', workMode);
  });
});

onUnmounted(() => {
  emitter.off('updateWorkMode');
});
</script>

<style lang="scss" scoped>
.welcome-mode {
  display: flex;
  width: 100%;
  justify-content: center;
  margin-top: 20px;

  &.agent-mode {
    align-items: center;
    position: sticky;
    top: 0;
    font-size: 16px;
    margin-top: 8px;
    color: #333;
    width: fit-content;
    padding: 4px 8px;
    border-radius: 4px;
    background-color: #f8f8f7;
    z-index: 100;
    width: 100%;
  }
}

.dropdown-icon-wrapper {
  position: relative;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 24px;
  height: 24px;
  cursor: pointer;

  .dropdown-menu {
    position: absolute;
    top: 100%;
    left: 0;
    background: white;
    border: 1px solid #e0e0e0;
    border-radius: 4px;
    padding: 4px 0;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
    z-index: 10;
    min-width: 120px;
  }

  .menu-item {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 6px 10px;
    font-size: 13px;
    cursor: pointer;
    color: #333;

    &.danger {
      color: #ff4d4f;
    }

    &:hover {
      background-color: #0000000f;
    }
  }
}

.dropdown-icon {
  font-size: 16px;
  color: #999;
}

/* é»˜è®¤éšè—ç§»åŠ¨ç«¯èœå•æŒ‰é’® */
.mobile-menu-btn {
  display: none;
}

.agent-loading {
  position: fixed;
  top: 0;
  left: 278px;
  right: 0;
  bottom: 0;
  z-index: 9999;
  background: rgba(255, 255, 255, 0.9);
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
}

.loader {
  --w: 10ch;
  font-weight: bold;
  font-family: monospace;
  font-size: 30px;
  line-height: 1.4em;
  letter-spacing: var(--w);
  width: var(--w);
  overflow: hidden;
  white-space: nowrap;
  color: #0000;
  text-shadow:
    calc(0 * var(--w)) 0 #000, calc(-1 * var(--w)) 0 #000, calc(-2 * var(--w)) 0 #000, calc(-3 * var(--w)) 0 #000, calc(-4 * var(--w)) 0 #000,
    calc(-5 * var(--w)) 0 #000, calc(-6 * var(--w)) 0 #000, calc(-7 * var(--w)) 0 #000, calc(-8 * var(--w)) 0 #000, calc(-9 * var(--w)) 0 #000;
  animation: l20 2s infinite linear;
}

.loader:before {
  content: "Loading...";
}

.tip {
  margin-top: 20px;
  font-size: 18px;
  color: #333;
}

@keyframes l20 {
  9.09% { text-shadow: calc(0 * var(--w)) -10px #000, calc(-1 * var(--w)) 0 #000, calc(-2 * var(--w)) 0 #000, calc(-3 * var(--w)) 0 #000, calc(-4 * var(--w)) 0 #000, calc(-5 * var(--w)) 0 #000, calc(-6 * var(--w)) 0 #000, calc(-7 * var(--w)) 0 #000, calc(-8 * var(--w)) 0 #000, calc(-9 * var(--w)) 0 #000 }
  18.18% { text-shadow: calc(0 * var(--w)) 0 #000, calc(-1 * var(--w)) -10px #000, calc(-2 * var(--w)) 0 #000, calc(-3 * var(--w)) 0 #000, calc(-4 * var(--w)) 0 #000, calc(-5 * var(--w)) 0 #000, calc(-6 * var(--w)) 0 #000, calc(-7 * var(--w)) 0 #000, calc(-8 * var(--w)) 0 #000, calc(-9 * var(--w)) 0 #000 }
  27.27% { text-shadow: calc(0 * var(--w)) 0 #000, calc(-1 * var(--w)) 0 #000, calc(-2 * var(--w)) -10px #000, calc(-3 * var(--w)) 0 #000, calc(-4 * var(--w)) 0 #000, calc(-5 * var(--w)) 0 #000, calc(-6 * var(--w)) 0 #000, calc(-7 * var(--w)) 0 #000, calc(-8 * var(--w)) 0 #000, calc(-9 * var(--w)) 0 #000 }
  36.36% { text-shadow: calc(0 * var(--w)) 0 #000, calc(-1 * var(--w)) 0 #000, calc(-2 * var(--w)) 0 #000, calc(-3 * var(--w)) -10px #000, calc(-4 * var(--w)) 0 #000, calc(-5 * var(--w)) 0 #000, calc(-6 * var(--w)) 0 #000, calc(-7 * var(--w)) 0 #000, calc(-8 * var(--w)) 0 #000, calc(-9 * var(--w)) 0 #000 }
  45.45% { text-shadow: calc(0 * var(--w)) 0 #000, calc(-1 * var(--w)) 0 #000, calc(-2 * var(--w)) 0 #000, calc(-3 * var(--w)) 0 #000, calc(-4 * var(--w)) -10px #000, calc(-5 * var(--w)) 0 #000, calc(-6 * var(--w)) 0 #000, calc(-7 * var(--w)) 0 #000, calc(-8 * var(--w)) 0 #000, calc(-9 * var(--w)) 0 #000 }
  54.54% { text-shadow: calc(0 * var(--w)) 0 #000, calc(-1 * var(--w)) 0 #000, calc(-2 * var(--w)) 0 #000, calc(-3 * var(--w)) 0 #000, calc(-4 * var(--w)) 0 #000, calc(-5 * var(--w)) -10px #000, calc(-6 * var(--w)) 0 #000, calc(-7 * var(--w)) 0 #000, calc(-8 * var(--w)) 0 #000, calc(-9 * var(--w)) 0 #000 }
  63.63% { text-shadow: calc(0 * var(--w)) 0 #000, calc(-1 * var(--w)) 0 #000, calc(-2 * var(--w)) 0 #000, calc(-3 * var(--w)) 0 #000, calc(-4 * var(--w)) 0 #000, calc(-5 * var(--w)) 0 #000, calc(-6 * var(--w)) -10px #000, calc(-7 * var(--w)) 0 #000, calc(-8 * var(--w)) 0 #000, calc(-9 * var(--w)) 0 #000 }
  72.72% { text-shadow: calc(0 * var(--w)) 0 #000, calc(-1 * var(--w)) 0 #000, calc(-2 * var(--w)) 0 #000, calc(-3 * var(--w)) 0 #000, calc(-4 * var(--w)) 0 #000, calc(-5 * var(--w)) 0 #000, calc(-6 * var(--w)) 0 #000, calc(-7 * var(--w)) -10px #000, calc(-8 * var(--w)) 0 #000, calc(-9 * var(--w)) 0 #000 }
  81.81% { text-shadow: calc(0 * var(--w)) 0 #000, calc(-1 * var(--w)) 0 #000, calc(-2 * var(--w)) 0 #000, calc(-3 * var(--w)) 0 #000, calc(-4 * var(--w)) 0 #000, calc(-5 * var(--w)) 0 #000, calc(-6 * var(--w)) 0 #000, calc(-7 * var(--w)) 0 #000, calc(-8 * var(--w)) -10px #000, calc(-9 * var(--w)) 0 #000 }
  90.90% { text-shadow: calc(0 * var(--w)) 0 #000, calc(-1 * var(--w)) 0 #000, calc(-2 * var(--w)) 0 #000, calc(-3 * var(--w)) 0 #000, calc(-4 * var(--w)) 0 #000, calc(-5 * var(--w)) 0 #000, calc(-6 * var(--w)) 0 #000, calc(-7 * var(--w)) 0 #000, calc(-8 * var(--w)) 0 #000, calc(-9 * var(--w)) -10px #000 }
}

@media (max-width: 768px) {
  .agent-loading {
    left: 0 !important;
  }
}

@media screen and (max-width: 768px) {
  .welcome-mode {
    margin-top: 8px;

    &.agent-mode {
      height: 48px;
      position: sticky;
      top: 0;
      background-color: #f8f8f7;
      z-index: 1;
    }
  }

  .welcome-header {
    height: 48px;
    position: sticky;
    top: 0;
    background-color: #f8f8f7;
    z-index: 1;
    display: flex;
    align-items: center;
  }

  /* ç§»åŠ¨ç«¯æ˜¾ç¤ºèœå•æŒ‰é’® */
  .mobile-menu-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    background: none;
    border: none;
    cursor: pointer;
    padding: 8px;
    border-radius: 6px;
    color: #333;
    transition: background-color 0.2s ease;

    svg {
      width: 20px;
      height: 20px;
    }
  }

  .icon {
    display: none;
  }
}
</style>



================================================
FILE: frontend/src/view/welcome/components/WelcomeLayout.vue
================================================
<template>
  <div class="welcome-screen" :class="rootClass" @click="handleRootClick">
    <slot name="header"></slot>

    <div class="welcome-content">
      <span class="welcome-greeting">{{ greeting }}</span>
      <span class="welcome-description">{{ description }}</span>
      <slot name="input"></slot>
    </div>

    <slot name="sample"></slot>
    <slot name="store"></slot>
    <slot name="extra"></slot>
  </div>
</template>

<script setup>
const props = defineProps({
  greeting: {
    type: String,
    default: ''
  },
  description: {
    type: String,
    default: ''
  },
  rootClass: {
    type: String,
    default: ''
  }
});

const emit = defineEmits(['rootClick']);

const handleRootClick = (e) => {
  emit('rootClick', e);
};
</script>

<style lang="scss" scoped>
.welcome-screen {
  background: #f8f8f7;
  overflow: auto;
  height: 100%;

  /* éšè—æ»šåŠ¨æ¡ */
  scrollbar-width: none; /* Firefox */
  -ms-overflow-style: none; /* IE and Edge */
}

.welcome-screen::-webkit-scrollbar {
  display: none; /* Chrome, Safari and Opera */
}

.welcome-content {
  margin-top: 180px;
  margin-left: auto;
  margin-right: auto;
  max-width: 1039px;
  width: 100%;
  display: flex;
  flex-direction: column;

  > span {
    margin-left: 22px;
  }

  .welcome-greeting {
    line-height: 28px;
    height: 37px;
    color: rgba(0,0,0,1);
    font-size: 28px;
    text-align: left;
    font-family: PingFangSC, 'PingFang SC', -apple-system, BlinkMacSystemFont, sans-serif;
    font-weight: 600;
  }

  .welcome-description {
    line-height: 28px;
    color: rgba(0,0,0,1);
    font-size: 20px;
    text-align: left;
    font-family: PingFangSC-regular;
    margin-bottom: 22px;
  }
}

/* ç§»åŠ¨ç«¯é€‚é… */
@media screen and (max-width: 768px) {
  .welcome-screen {
    padding: 0px 16px;
  }

  .welcome-content {
    .welcome-greeting {
      display: none;
    }

    .welcome-description {
      font-size: 16px !important;
      text-align: center;
    }
  }
}
</style>



================================================
FILE: frontend/src/view/welcome/composables/useWelcomeCommon.js
================================================
import { ref, computed, nextTick } from 'vue';
import { storeToRefs } from 'pinia';
import { useI18n } from 'vue-i18n';
import { useChatStore } from '@/store/modules/chat';
import { useUserStore } from '@/store/modules/user';
import emitter from '@/utils/emitter';

/**
 * å…±äº«çš„æ¬¢è¿é¡µé¢é€»è¾‘
 */
export function useWelcomeCommon() {
  const chatStore = useChatStore();
  const userStore = useUserStore();
  const { t } = useI18n();
  const { user } = storeToRefs(userStore);

  // è·å–ç”¨æˆ·å
  const username = computed(() => {
    return user.value.user_name || user.value.user_email || 'User';
  });

  // è·å–å½“å‰å·¥ä½œæ¨¡å¼
  const currentWorkMode = ref(localStorage.getItem('workMode') || 'twins');

  // æ ¹æ® workMode è·å–æ¬¢è¿æè¿°
  const welcomeDescription = computed(() => {
    const workMode = currentWorkMode.value;
    return t(`lemon.welcome.workMode.${workMode}`);
  });

  // ç¤ºä¾‹ç‚¹å‡»å¤„ç†
  const sampleClick = async (item) => {
    console.log('sampleClick:', item);

    // ç­‰å¾…ä¸‹ä¸€ä¸ª tickï¼Œç¡®ä¿æ‰€æœ‰ç»„ä»¶éƒ½å·²æŒ‚è½½å®Œæˆ
    await nextTick();

    // æ·»åŠ ä¸€ä¸ªå°å»¶è¿Ÿï¼Œç¡®ä¿ ChatInput å®ŒæˆæŒ‚è½½
    setTimeout(() => {
      console.log("å‘é€ changeMessageText:", item.content);
      emitter.emit('changeMessageText', item.content);
    }, 100);
  };

  // å¤„ç†æ¨¡å¼åˆ‡æ¢
  const handleModeChange = (mode) => {
    console.log('æ”¶åˆ°æ¨¡å¼åˆ‡æ¢:', mode);
    currentWorkMode.value = mode;
  };

  return {
    username,
    currentWorkMode,
    welcomeDescription,
    sampleClick,
    handleModeChange
  };
}



================================================
FILE: public/schemas/conversation.json
================================================
{
    "properties": {
        "id": {
            "type": "integer"
        },
        "conversation_id": {
            "type": "string"
        },
        "selected_repository": {
            "type": "string"
        },
        "title": {
            "type": "string"
        },
        "create_at": {
            "type": "string"
        },
        "update_at": {
            "type": "string"
        },
        "is_favorite": {
            "type": "boolean"
        }
    }
}


================================================
FILE: public/schemas/default_model_setting.json
================================================
{
    "properties": {
        "id": {
            "type": "integer"
        },
        "setting_type": {
            "type": "string"
        },
        "model_id": {
            "type": "string"
        },
        "config": {
            "type": "object"
        },
        "create_at": {
            "type": "string"
        },
        "update_at": {
            "type": "string"
        }
    }
}


================================================
FILE: public/schemas/experience.json
================================================
{
    "properties": {
        "id": {
            "type": "integer"
        },
        "title": {
            "type": "string"
        },
        "goal": {
            "type": "string"
        },
        "content": {
            "type": "string"
        },
        "type": {
            "type": "string"
        },
        "is_enabled": {
            "type": "boolean"
        },
        "create_at": {
            "type": "string"
        },
        "update_at": {
            "type": "string"
        }
    }
}


================================================
FILE: public/schemas/file.json
================================================
{
    "properties": {
        "id": {
            "type": "integer"
        },
        "url": {
            "type": "string"
        },
        "name": {
            "type": "string"
        },
        "create_at": {
            "type": "string"
        },
        "update_at": {
            "type": "string"
        }
    }
}


================================================
FILE: public/schemas/model.json
================================================
{
    "properties": {
        "id": {
            "type": "integer"
        },
        "logo_url": {
            "type": "string"
        },
        "model_id": {
            "type": "string"
        },
        "model_name": {
            "type": "string"
        },
        "group_name": {
            "type": "string"
        },
        "model_types": {
            "type": "string"
        },
        "create_at": {
            "type": "string"
        },
        "update_at": {
            "type": "string"
        }
    }
}


================================================
FILE: public/schemas/model_enable.json
================================================
{
    "properties": {
        "id": {
            "type": "integer"
        },
        "platform_name": {
            "type": "string"
        },
        "logo_url": {
            "type": "string"
        },
        "model_id": {
            "type": "string"
        },
        "model_name": {
            "type": "string"
        },
        "group_name": {
            "type": "string"
        },
        "model_types": {
            "type": "string"
        },
        "create_at": {
            "type": "string"
        },
        "update_at": {
            "type": "string"
        }
    }
}


================================================
FILE: public/schemas/platform.json
================================================
{
    "properties": {
        "id": {
            "type": "integer"
        },
        "name": {
            "type": "string"
        },
        "logo_url": {
            "type": "string"
        },
        "source_type": {
            "type": "string"
        },
        "api_key": {
            "type": "string"
        },
        "api_url": {
            "type": "string"
        },
        "api_version": {
            "type": "string"
        },
        "key_obtain_url": {
            "type": "string"
        },
        "is_enabled": {
            "type": "boolean"
        },
        "create_at": {
            "type": "string"
        },
        "update_at": {
            "type": "string"
        }
    }
}


================================================
FILE: public/schemas/provider.json
================================================
{
    "type": "array",
    "items": {
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "description": "Provider ID"
        },
        "name": {
          "type": "string",
          "description": "Provider name"
        },
        "logo_url": {
          "type": "string",
          "description": "URL of the provider's logo"
        },
        "base_config_schema": {
          "type": "string",
          "description": "Base configuration schema for the provider"
        },
        "create_at": {
          "type": "string",
          "format": "date-time",
          "description": "Creation timestamp"
        },
        "update_at": {
          "type": "string",
          "format": "date-time",
          "description": "Update timestamp"
        }
      }
    }
  }


================================================
FILE: public/schemas/provider_setting_result.json
================================================
{
    "properties": {
        "id": {
            "type": "integer"
        },
        "provider_id": {
            "type": "integer"
        },
        "provider_name": {
            "type": "string"
        },
        "base_config": {
            "type": "object"
        },
        "logo_url": {
            "type": "string"
        },
        "api_key": {
            "type": "string"
        },
        "include_date": {
            "type": "boolean"
        },
        "cover_provider_search": {
            "type": "boolean"
        },
        "enable_enhanced_mode": {
            "type": "boolean"
        },
        "result_count": {
            "type": "integer"
        },
        "blacklist": {
            "type": "string"
        },
        "create_at": {
            "type": "string"
        },
        "update_at": {
            "type": "string"
        }
    }
}


================================================
FILE: resources/browser/install.md
================================================
#  Baidu&Bing search support for

for baidu and bing search support on client



##  Installation

before to package,run this commond in project root directory:

```
npx playwright install chromium
```

##  Copy

move chromium to project resources

for Mac:

```
cp -r ~/Library/Caches/ms-playwright/chromium_headless_shell-*/* resources/browser/chromium/
```

for windows is the same

and complie your project


================================================
FILE: src/app.js
================================================
require("module-alias/register");
require('dotenv').config();
const { logging } = require("@src/logger/index");
global.logging = logging;

const Koa = require('koa')
const app = new Koa()
const json = require('koa-json')
const onerror = require('koa-onerror')
const { koaBody } = require('koa-body');
const logger = require('koa-logger')

const swagger = require('@src/swagger/swagger')  // stores swagger.js, can be configured, I put it in the root directory
const { koaSwagger } = require('koa2-swagger-ui')

const router = require("@src/routers/index");
const wrapContext = require("@src/middlewares/wrap.context");
const setGlobalTokenMiddleware = require('@src/middlewares/setGlobalToken');
const authMiddleware = require('@src/middlewares/auth');

app.use(wrapContext);
// error handler 
onerror(app)

// middlewares
app.use(koaBody({
  multipart: true
}))
app.use(json())
app.use(logger())

app.use(async (ctx, next) => {
  console.log(`Request URL: ${ctx.url}`);
  await next();
});
const path = require('path');

const publicPath = path.join(__dirname, '../public');
app.use(require('koa-static')(publicPath))

// logger
app.use(async (ctx, next) => {
  const start = Date.now()
  await next()
  const ms = Date.now() - start
  console.log(`${ctx.method} ${ctx.url} - ${ms}ms`)
})

app.use(setGlobalTokenMiddleware);
app.use(authMiddleware());

// routes
app.use(router.routes()).use(router.allowedMethods());
app.use(swagger.routes());
app.use(swagger.allowedMethods());
app.use(koaSwagger({
  routePrefix: '/swagger', // interface documentation access address
  swaggerOptions: {
    url: '/swagger.json', // example path to json å…¶å®å°±æ˜¯ä¹‹åswagger-jsdocç”Ÿæˆçš„æ–‡æ¡£åœ°å€
  }
}))


// error-handling
app.on('error', (err, ctx) => {
  console.error('server error', err, ctx)
});

module.exports = app



================================================
FILE: src/globals.js
================================================
let currentToken = null;

module.exports = {
  setToken: (token) => {
    currentToken = token;
  },
  getToken: () => {
    return currentToken;
  }
};


================================================
FILE: src/agent/AgenticAgent.js
================================================
require('dotenv').config();
const planning = require("@src/agent/planning/index.js");
const auto_reply = require("@src/agent/auto-reply/index")
const summary = require("@src/agent/summary/index")

const completeCodeAct = require("@src/agent/code-act/index");

const TaskManager = require('./TaskManager'); // assume task manager path
const Message = require('@src/utils/message.js');
const Conversation = require('@src/models/Conversation')
const File = require('@src/models/File')
const { getTodoMd } = require('@src/utils/planning.js');
const { write_code } = require('@src/runtime/utils/tools');
const { v4: uuidv4 } = require("uuid");
const path = require('path')
const { getDirpath } = require('@src/utils/electron');

const LocalRuntime = require("@src/runtime/LocalRuntime")
const DockerRuntime = require("@src/runtime/DockerRuntime");
const LocalDockerRuntime = require("@src/runtime/DockerRuntime.local");


const RUNTIME_TYPE = process.env.RUNTIME_TYPE || 'local-docker';
const runtimeMap = {
  'local': LocalRuntime,
  'docker': DockerRuntime,
  'local-docker': LocalDockerRuntime
}

const { retrieveAndFormatPreviousSummary } = require('./conversationHistoryUtils');
const { getAllFilesRecursively, getFilesMetadata, ensureDirectoryExists } = require('./fileUtils');
const { createFilesVersion } = require('@src/utils/versionManager');

class AgenticAgent {
  constructor(context = {}) {
    this.logs = [];
    this.taskManager = new TaskManager('task_log.md', context.conversation_id); // assume task manager path
    const RunTime = runtimeMap[RUNTIME_TYPE];
    this.runtime = new RunTime(context);
    context.runtime = this.runtime;
    this.context = context;
    this.onTokenStream = context.onTokenStream;
    this.is_stop = false;
    this.mcp_server_ids = context.mcp_server_ids || [];
    context.task_manager = this.taskManager;
    // è§„åˆ’æ¨¡å¼
    this.planning_mode = context.planning_mode || 'base';
  }

  setGoal(goal) {
    this.goal = goal;
    this.context.goal = goal;
  }

  async _publishMessage(options) {
    const { uuid, action_type, status, content, json, task_id, meta_content, filepath } = options;
    const msg = Message.format({
      uuid,
      action_type,
      status,
      content,
      // @ts-ignore
      json,
      task_id,
      meta_content,
      filepath
    });
    this.onTokenStream(msg);
    await Message.saveToDB(msg, this.context.conversation_id);
  }

  async _getConversationDirPath() {
    const dir_name = 'Conversation_' + this.context.conversation_id.slice(0, 6);
    const WORKSPACE_DIR = getDirpath(process.env.WORKSPACE_DIR || 'workspace', this.context.user_id);
    return path.join(WORKSPACE_DIR, dir_name);
  }

  // åˆå§‹åŒ–è®¾ç½®å’Œè‡ªåŠ¨å›å¤
  async _initialSetupAndAutoReply() {
    const dockerRuntimeTypes = ['docker', 'e2b', 'local-docker'];
    if (dockerRuntimeTypes.includes(RUNTIME_TYPE)) {
      await this.context.runtime.connect_container()
    }
    // ä½¿ç”¨å¤–éƒ¨å‡½æ•°ç¡®ä¿ç›®å½•å­˜åœ¨
    const conversationDirPath = await this._getConversationDirPath();
    await ensureDirectoryExists(conversationDirPath);

    // ç”Ÿæˆé™æ€æ–‡ä»¶è®¿é—®åœ°å€ï¼ˆä½¿ç”¨ç»Ÿä¸€çš„ static.lemonai.ai åŸŸåï¼‰
    if (RUNTIME_TYPE === 'docker' || RUNTIME_TYPE === 'e2b') {
      const staticDomain = process.env.STATIC_DOMAIN || 'static.lemonai.ai';
      const staticProtocol = process.env.STATIC_PROTOCOL || 'https';
      this.context.staticUrl = `${staticProtocol}://${staticDomain}/${this.context.conversation_id}`;
      console.log(`Static URL: ${this.context.staticUrl}`);
    } else {
      console.log(`Skipping static URL setup for RUNTIME_TYPE: ${RUNTIME_TYPE}`);
    }

    const reply = await auto_reply(this.goal, this.context.conversation_id);
    await this._publishMessage({ action_type: 'auto_reply', status: 'success', content: reply });
  }

  // æ‰§è¡Œè§„åˆ’é˜¶æ®µ
  async _performPlanning() {
    await this.plan(this.goal);
  }

  // æ‰§è¡Œä»»åŠ¡å¾ªç¯
  async _executeTasks() {
    console.log('====== start execute ======');
    await this.run_loop();
  }

  // ç”Ÿæˆæœ€ç»ˆè¾“å‡º
  async _generateFinalOutput() {
    const tasks = this.taskManager.getTasks();
    const finalResult = {
      goal: this.goal,
      status: tasks.every(t => t.status === 'completed') ? 'success' : 'partial_failure',
      tasks: tasks,
      logs: this.logs
    };

    const dirPath = await this._getConversationDirPath();
    let filesSet = new Set(await getAllFilesRecursively(dirPath)); // ä½¿ç”¨å¤–éƒ¨å‡½æ•°

    if (this.context.generate_files && Array.isArray(this.context.generate_files)) {
      for (const file of this.context.generate_files) {
        filesSet.add(file);
      }
    }
    const filesToProcess = Array.from(filesSet);
    const newFiles = await getFilesMetadata(filesToProcess); // ä½¿ç”¨å¤–éƒ¨å‡½æ•°

    // åˆ›å»ºæ–‡ä»¶ç‰ˆæœ¬
    const state = {
      user: { id: this.context.user_id }
    }
    await createFilesVersion(this.context.conversation_id, newFiles, '.html', state);

    const summaryContent = await summary(this.goal, this.context.conversation_id, tasks, newFiles, this.context.staticUrl);
    const uuid = uuidv4();
    await this._publishMessage({ uuid, action_type: 'finish_summery', status: 'success', content: summaryContent, json: newFiles });

    finalResult.summary = summaryContent;
    return finalResult;
  }

  async loadContext() {
    await this.taskManager.loadTasks();
    const conversation = await Conversation.findOne({ where: { conversation_id: this.context.conversation_id } });
    const goal = conversation.dataValues.content;
    this.setGoal(goal);
    global.logging(this.context, 'AgenticAgent', `loadContext goal: ${goal}`);
  }

  async continue() {
    await this.loadContext();

    const tasks = this.taskManager.getTasks();
    this.context.tasks = tasks;
    global.logging(this.context, 'AgenticAgent.continue', tasks);
    // return;
    if (!tasks || tasks.length === 0) {
      global.logging(this.context, 'AgenticAgent.continue', 'No tasks found to continue.');
      await this._publishMessage({ action_type: 'finish', status: 'success', content: 'No tasks found to continue.' });
      return;
    }
    await this._publishMessage({ action_type: 'continue', status: 'success', content: 'Continuing task execution...', json: tasks });
    await this._executeTasks();
    await this._generateFinalOutput();
  }

  async run(goal = '') {
    this.setGoal(goal);

    try {
      await this._initialSetupAndAutoReply();
    } catch (error) {
      console.error("Auto reply failed:", error);
      throw error
    }

    try {

      if (this.is_stop) return;

      await this._performPlanning();
      if (this.is_stop) return;

      await this._executeTasks();
      if (this.is_stop) return;

      const finalResult = await this._generateFinalOutput();

      await Conversation.update({ status: 'done' }, { where: { conversation_id: this.context.conversation_id } });

      return finalResult;
    } catch (error) {
      await Conversation.update({ status: 'failed' }, { where: { conversation_id: this.context.conversation_id } });
      global.logging(this.context, 'AgenticAgent.run', 'error', error);
      throw error;
    }
  }

  async plan(goal = '') {
    try {
      const files = await File.findAll({ where: { conversation_id: this.context.conversation_id } });
      this.context.files = files;

      const conversationDirPath = await this._getConversationDirPath();
      const previousResult = await retrieveAndFormatPreviousSummary(this.context.conversation_id, conversationDirPath);

      const planning_mode = this.planning_mode;
      const options = {
        conversation_id: this.context.conversation_id,
        agent_id: this.context.agent_id,
        planning_mode,
        files,
        previousResult,
      }
      const plannedTasks = await planning(goal, options) || [];

      await this.taskManager.setTasks(plannedTasks);
      const tasks = this.taskManager.getTasks();
      this.context.tasks = tasks;
      await this._publishMessage({ action_type: 'plan', status: 'success', content: '', json: tasks });

      console.log('====== planning completed ======');

      const uuid = uuidv4();
      const dir_name = 'Conversation_' + this.context.conversation_id.slice(0, 6);

      await this._publishMessage({ action_type: 'write_code', status: 'running', content: "todo.md", json: {}, task_id: null, uuid });

      const todo_md = await getTodoMd(tasks);
      const action = {
        type: 'write_code',
        params: {
          path: `${dir_name}/todo.md`,
          content: todo_md
        }
      };
      const result = await write_code(action, uuid, this.context.user_id);

      if (!this.context.generate_files) {
        this.context.generate_files = [];
      }
      this.context.generate_files.push(result.meta.filepath);

      await this._publishMessage({
        action_type: result.meta.action_type,
        status: result.status,
        content: result.content || '',
        filepath: result.meta.filepath,
        json: {},
        task_id: null,
        uuid,
        meta_content: todo_md
      });

      return true;
    } catch (error) {
      global.logging(this.context, 'AgenticAgent.plan', 'error', error);
    }
  }

  async handle_task_status(task, status, details = {}) {
    const manager = this.taskManager;
    await manager.updateTaskStatus(task.id, status, details);
    this.logs.push({ timestamp: new Date(), message: `Executing task ${task.id}: ${task.requirement}` });

    await this._publishMessage({
      action_type: status === 'failed' ? 'error' : 'task',
      status,
      content: details.content,
      json: { comments: details.comments, ...details.json, ...details.params || {} },
      task_id: task.id
    });

    if (status === 'completed') {
      const uuid = uuidv4();
      const dir_name = 'Conversation_' + this.context.conversation_id.slice(0, 6);
      const new_tasks = this.taskManager.getTasks();
      const todo_md = await getTodoMd(new_tasks);
      const action = {
        type: 'write_code',
        params: {
          path: `${dir_name}/todo.md`,
          content: todo_md
        }
      };

      await this._publishMessage({
        action_type: 'write_code',
        status: 'running',
        content: "todo.md",
        json: {},
        task_id: task.id,
        uuid
      });
      const todoRes = await write_code(action, uuid, this.context.user_id);
      await this._publishMessage({
        action_type: todoRes.meta.action_type,
        status: todoRes.status,
        content: todoRes.content || '',
        filepath: todoRes.meta.filepath,
        json: {},
        task_id: task.id,
        uuid,
        meta_content: todo_md
      });
    }
  }

  async run_loop() {
    const loggerKey = 'AgenticAgent.run_loop';
    const manager = this.taskManager;
    while (true) {
      const task = await manager.resolvePendingTask();
      if (!task) {
        global.logging(this.context, loggerKey, '====== no task ======');
        return;
      }
      global.logging(this.context, loggerKey, task);
      this.context.task = task;
      try {
        const result = await completeCodeAct(task, this.context);
        global.logging(this.context, loggerKey, result);
        task.memorized = result.memorized || '';
        if (result.status === 'failure') {
          await this.handle_task_status(task, 'failed', {
            content: result.comments,
            memorized: result.memorized || '',
            comments: result.comments,
          });
          if (result.comments == "Insufficient credits balance") {
            await Conversation.update({ status: 'stop' }, { where: { conversation_id: this.context.conversation_id } });
          } else {
            await Conversation.update({ status: 'failed' }, { where: { conversation_id: this.context.conversation_id } });
          }
          await this.stop();
          return;
        }

        // ç­‰å¾…ç”¨æˆ·åé¦ˆè¾“å…¥, æš‚åœä»»åŠ¡
        if (result.status === 'pause_for_user_input') {
          await this.handle_task_status(task, 'pause_for_user_input', {
            content: result.params.question || '',
            memorized: result.memorized || '',
            params: result.params || {}
          });
          await this.stop(false);
          return;
        }
        if (result.status === 'revise_plan') {
          await this.handle_task_status(task, 'revise_plan', {
            content: result.content || '',
            memorized: result.memorized || '',
            params: result.params || {}
          });
          continue;
        }
        await this.handle_task_status(task, 'completed', {
          content: result.content,
          memorized: result.memorized || ''
        });
      } catch (error) {
        await this.handle_task_status(task, 'failed', { error: error.message });
        global.logging(this.context, loggerKey, error);
        global.safeExit && await global.safeExit(0);
      }
    }
  }

  async stop(publish = true) {
    this.is_stop = true;
    if (publish) {
      await this._publishMessage({ action_type: 'stop', status: 'success' });
    }
  }
}

module.exports = AgenticAgent;


================================================
FILE: src/agent/AgenticAgent.run.js
================================================
require('module-alias/register');
require('dotenv').config();
// https://github.com/GoogleChromeLabs/ndb

const AgenticAgent = require("./AgenticAgent")

const run = async () => {
  const agent = new AgenticAgent();
  const r = await agent.run("Please read and analyze the Excel file about large model application statistics in the working directory, display its contents on a web page, support filtering between domestic and international entries, and provide access to corresponding official website links and API platform links");
  // console.log(r);
  process.exit(0);
}

run();


================================================
FILE: src/agent/conversationHistoryUtils.js
================================================
const path = require('path');
const MessageTable = require('@src/models/Message');
const { Op } = require("sequelize");

/**
 * ä»æ•°æ®åº“ä¸­æ£€ç´¢å…·æœ‰ç‰¹å®šä¼šè¯IDçš„æ¶ˆæ¯ã€‚
 * æŸ¥è¯¢æ‰€æœ‰ role = user æˆ– role = assistantï¼Œä¸” status = success çš„æ¶ˆæ¯
 * @param {string} conversationId - ä¼šè¯IDã€‚
 * @returns {Promise<Array<Object>>} æ¶ˆæ¯æ•°ç»„ã€‚
 */
const retrieveMessages = async (conversationId) => {
  try {
    const messages = await MessageTable.findAll({
      where: {
        conversation_id: conversationId,
        role: {
          [Op.in]: ['user', 'assistant']
        },
        status: 'success'
      },
      order: [['create_at', 'ASC']] // æŒ‰åˆ›å»ºæ—¶é—´å‡åºæ’åˆ—
    });
    console.log('messages.length', messages.length);
    return messages;
  } catch (error) {
    console.error(`æ£€ç´¢æ¶ˆæ¯æ—¶å‡ºé”™: ${error.message}`);
    return [];
  }
}

/**
 * å®‰å…¨åœ°è§£ææ¶ˆæ¯çš„å…ƒæ•°æ®å­—ç¬¦ä¸²ã€‚
 * @param {string} metaString - æ¶ˆæ¯çš„å…ƒæ•°æ®å­—ç¬¦ä¸²ã€‚
 * @returns {Object|null} è§£æåçš„å…ƒæ•°æ®å¯¹è±¡ï¼Œå¦‚æœè§£æå¤±è´¥åˆ™ä¸ºnullã€‚
 */
const parseMessageMeta = (metaString) => {
  try {
    return JSON.parse(metaString);
  } catch (error) {
    console.error(`è§£ææ¶ˆæ¯å…ƒæ•°æ®æ—¶å‡ºé”™: ${error.message}`);
    return null;
  }
}

/**
 * æ ¼å¼åŒ–å†å²æ¶ˆæ¯å†…å®¹ã€‚
 * @param {Array<Object>} conversationMessages - å®Œæ•´çš„å¯¹è¯æ¶ˆæ¯æ•°ç»„ã€‚
 * @param {Array<string>} allGeneratedFiles - æ‰€æœ‰ç”Ÿæˆçš„æ–‡ä»¶è·¯å¾„æ•°ç»„ã€‚
 * @returns {string} æ ¼å¼åŒ–åçš„å†å²å†…å®¹ã€‚
 */
const formatHistoryContent = (conversationMessages, allGeneratedFiles) => {
  // æ ¼å¼åŒ–å¯¹è¯å†å²
  const conversationContent = conversationMessages.map((message, index) => {
    const role = message.role === 'user' ? 'ç”¨æˆ·' : 'åŠ©æ‰‹';
    return `${index + 1}. ${role}: ${message.content}`;
  }).join('\n');
  
  // æ ¼å¼åŒ–æ–‡ä»¶åˆ—è¡¨
  const files = allGeneratedFiles.map((filepath, index) => {
    return `${index + 1}. ${filepath}`;
  }).join('\n');

  let historyContent = `## å¯¹è¯å†å²\n${conversationContent}`;
  
  if (allGeneratedFiles.length > 0) {
    historyContent += `\n\n## ç”Ÿæˆçš„æ–‡ä»¶åˆ—è¡¨\n${files}`;
  }
  
  return historyContent;
}

/**
 * ä»æ•°æ®åº“ä¸­æ£€ç´¢å¹¶æ ¼å¼åŒ–ä¹‹å‰çš„ä¼šè¯æ€»ç»“ã€‚
 * æ–°çš„é€»è¾‘ï¼šæ”¯æŒæ··åˆçš„ chat å’Œ agent å¯¹è¯
 * - ä¿ç•™æ‰€æœ‰ç”¨æˆ·æ¶ˆæ¯
 * - å¯¹äº assistant æ¶ˆæ¯ï¼š
 *   - å¦‚æœ action_type = 'chat'ï¼Œä¿ç•™å¯¹è¯å†…å®¹
 *   - å¦‚æœ action_type ä¸ºå…¶ä»–ç±»å‹ï¼ˆå¦‚ write_codeï¼‰ï¼Œæå–æ–‡ä»¶è·¯å¾„
 * @param {string} conversationId - ä¼šè¯IDã€‚
 * @param {string} workspaceBaseDirPath - å·¥ä½œåŒºæ ¹ç›®å½•è·¯å¾„ï¼Œç”¨äºè®¡ç®—æ–‡ä»¶ç›¸å¯¹è·¯å¾„ã€‚
 * @returns {Promise<string>} æ ¼å¼åŒ–åçš„å†å²æ€»ç»“å­—ç¬¦ä¸²ã€‚
 */
const retrieveAndFormatPreviousSummary = async (conversationId, workspaceBaseDirPath) => {
  try {
    const messages = await retrieveMessages(conversationId);

    if (!messages || messages.length === 0) {
      return '';
    }

    const conversationMessages = [];
    const allGeneratedFiles = [];

    for (const message of messages) {
      if (message.role === 'user') {
        // ä¿ç•™æ‰€æœ‰ç”¨æˆ·æ¶ˆæ¯
        conversationMessages.push({
          role: 'user',
          content: message.content
        });
      } else if (message.role === 'assistant') {
        const meta = parseMessageMeta(message.meta);
        
        if (meta && meta.action_type === 'chat') {
          // ä¿ç•™ chat ç±»å‹çš„ assistant æ¶ˆæ¯
          conversationMessages.push({
            role: 'assistant',
            content: message.content
          });
        } else if (meta && meta.filepath && !meta.filepath.endsWith('todo.md')) {
          // å¯¹äºé chat ç±»å‹ï¼Œæå–æ–‡ä»¶è·¯å¾„
          const relativePath = path.relative(workspaceBaseDirPath, meta.filepath);
          allGeneratedFiles.push(relativePath);
        }
      }
    }

    // å»é‡æ–‡ä»¶åˆ—è¡¨
    const uniqueFiles = [...new Set(allGeneratedFiles)];

    return formatHistoryContent(conversationMessages, uniqueFiles);
  } catch (error) {
    console.error(`æ ¼å¼åŒ–å†å²æ€»ç»“æ—¶å‡ºé”™: ${error.message}`);
    return '';
  }
}

module.exports = {
  retrieveAndFormatPreviousSummary,
};



================================================
FILE: src/agent/fileUtils.js
================================================
const fs = require('fs').promises; // ä½¿ç”¨ fs.promises æ”¯æŒ async/await
const path = require('path');

/**
 * é€’å½’è·å–æŒ‡å®šç›®å½•ä¸‹æ‰€æœ‰æ–‡ä»¶çš„è·¯å¾„ã€‚
 * @param {string} directoryPath - è¦æœç´¢çš„ç›®å½•è·¯å¾„ã€‚
 * @returns {Promise<string[]>} åŒ…å«æ‰€æœ‰æ–‡ä»¶è·¯å¾„çš„æ•°ç»„ã€‚
 */
async function getAllFilesRecursively(directoryPath) {
  let fileList = [];
  const entries = await fs.readdir(directoryPath, { withFileTypes: true });
  for (const entry of entries) {
    const fullPath = path.join(directoryPath, entry.name);
    if (entry.isDirectory()) {
      // è¿‡æ»¤æ‰ node_modules ç›®å½•
      if (entry.name === 'node_modules') {
        continue;
      }
      fileList = fileList.concat(await getAllFilesRecursively(fullPath));
    } else if (entry.isFile()) {
      fileList.push(fullPath);
    }
  }
  return fileList;
}

/**
 * è·å–æ–‡ä»¶è·¯å¾„åˆ—è¡¨çš„å…ƒæ•°æ®ï¼ˆæ–‡ä»¶åã€å¤§å°ç­‰ï¼‰ã€‚
 * @param {string[]} filepaths - æ–‡ä»¶è·¯å¾„æ•°ç»„ã€‚
 * @returns {Promise<Array<{filepath: string, filename: string, filesize: number}>>} åŒ…å«æ–‡ä»¶å…ƒæ•°æ®çš„æ•°ç»„ï¼ŒæŒ‰ä¿®æ”¹æ—¶é—´å€’åºæ’åºã€‚
 */
async function getFilesMetadata(filepaths) {
  const filesMetadata = await Promise.all(
    filepaths.map(async (file) => {
      const stats = await fs.stat(file);
      return {
        filepath: file,
        filename: path.basename(file), // ä½¿ç”¨ path.basename æ›´å®‰å…¨åœ°æå–æ–‡ä»¶å
        filesize: stats.size,
        mtime: stats.mtime, // æ·»åŠ ä¿®æ”¹æ—¶é—´ç”¨äºæ’åº
      };
    })
  );

  // æŒ‰ä¿®æ”¹æ—¶é—´å€’åºæ’åºï¼ˆæœ€æ–°çš„æ–‡ä»¶åœ¨å‰é¢ï¼‰
  return filesMetadata.sort((a, b) => b.mtime - a.mtime).map(({ mtime, ...rest }) => rest);
}

/**
 * ç¡®ä¿æŒ‡å®šç›®å½•å­˜åœ¨ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™åˆ›å»ºã€‚
 * @param {string} directoryPath - è¦ç¡®ä¿å­˜åœ¨çš„ç›®å½•è·¯å¾„ã€‚
 * @returns {Promise<void>}
 */
async function ensureDirectoryExists(directoryPath) {
  await fs.mkdir(directoryPath, { recursive: true });
}

module.exports = {
  getAllFilesRecursively,
  getFilesMetadata,
  ensureDirectoryExists,
};


================================================
FILE: src/agent/TaskManager.js
================================================
const fs = require('fs');
const path = require('path');

const Task = require('@src/models/Task');
// ç¡®ä¿ä¸´æ—¶ç›®å½•å­˜åœ¨
const { getDirpath } = require('@src/utils/electron');
const cache_dir = getDirpath('Caches/task');
fs.mkdirSync(cache_dir, { recursive: true }); // åˆ›å»ºç›®å½•ï¼Œå¦‚æœå·²å­˜åœ¨åˆ™ä¸åšä»»ä½•æ“ä½œ

class TaskManager {
  constructor(logFilePath = 'task_log.md', conversation_id = null) {
    this.conversation_id = conversation_id;
    this.tasks = [];
    this.logFilePath = path.resolve(cache_dir, logFilePath);
  }

  async bulkCreate(tasks) {
    const tasksToSave = tasks.map(task => ({
      conversation_id: this.conversation_id,
      task_id: task.id,
      requirement: task.requirement,
      status: task.status,
      parent_id: task.parent_id,
    }));
    await Task.bulkCreate(tasksToSave);
  }

  async setTasks(tasks, sync = true) {
    const prefix = (Date.now() / 1000).toFixed(0);
    let index = 1;
    this.tasks = tasks.map(item => {
      item.requirement = item.description || item.requirement;
      item.id = item.id || `${prefix}_000${index++}`
      item.status = item.status || 'pending';
      return item
    })

    const tasksToSave = this.tasks.map(task => ({
      conversation_id: this.conversation_id,
      task_id: task.id,
      requirement: task.requirement,
      status: task.status,
    }));
    sync && await Task.bulkCreate(tasksToSave);
  }

  getTasks() {
    return this.tasks || [];
  }

  async loadTasks() {
    if (!this.conversation_id) {
      console.error("Error: Cannot load tasks without a conversation_id.");
      return [];
    }

    try {
      const tasks = await Task.findAll({
        where: { conversation_id: this.conversation_id, },
        order: [['id', 'ASC']]
      });

      if (!tasks || tasks.length === 0) {
        this.tasks = [];
        return [];
      }

      const taskMap = new Map();
      const rootTasks = [];

      for (const task of tasks) {
        const dataValues = task.dataValues;
        const value = {
          id: dataValues.task_id,
          requirement: dataValues.requirement,
          status: dataValues.status,
          error: dataValues.error,
          result: dataValues.result,
          memorized: dataValues.memorized,
          parent_id: dataValues.parent_id,
          children: []
        };
        taskMap.set(dataValues.task_id, value);
      }

      for (const task of taskMap.values()) {
        if (task.parent_id) {
          const parent = taskMap.get(task.parent_id);
          if (parent) {
            parent.children.push(task);
          } else {
            console.warn(`Warning: Task with ID ${task.id} has an invalid parent_id ${task.parent_id}. Treating as a root task.`);
            rootTasks.push(task);
          }
          continue;
        }
        rootTasks.push(task);
      }

      this.tasks = rootTasks;
      return this.tasks;

    } catch (error) {
      console.error("Failed to load tasks:", error);
      return [];
    }
  }

  /**
   * Finds a task or a sub-task by its ID.
   * The search is performed on top-level tasks and their direct children.
   *
   * @param {string | number} taskId The ID of the task or sub-task to find.
   * @returns {object | undefined} The found task object or undefined if not found.
   */
  getTaskById(taskId) {
    for (const task of this.tasks) {
      if (task.id === taskId) {
        return task;
      }
      if (task.children) {
        const subTask = task.children.find(c => c.id === taskId);
        if (subTask) {
          return subTask;
        }
      }
    }
    return undefined;
  }

  getTaskIndexById(taskId) {
    return this.tasks.findIndex(t => t.id === taskId);
  }

  async updateTaskStatus(taskId, status, details = {}) {
    const task = this.getTaskById(taskId);
    if (!task) {
      console.error(`Task with ID ${taskId} not found.`);
      return;
    }

    const oldStatus = task.status;
    task.status = status;

    if (status === 'revise_plan' && details.params) {
      await this.revisePlan(taskId, details.params || {});
    }

    const keys = ['content', 'memorized', 'comments'];
    for (const key of keys) {
      if (details[key]) {
        task[key] = details[key];
      }
    }

    await Task.update({
      status: task.status,
      content: task.content,
      memorized: task.memorized,
    }, {
      where: {
        task_id: taskId
      }
    });
  }

  async revisePlan(task_id, options = {}) {
    const { mode, tasks } = options;

    const resolveRequirement = task => {
      return `### ${task.title}
<goal>${task.goal}</goal>
<context>${task.context}</context>
<acceptance_criteria>${task.acceptance_criteria}</acceptance_criteria>`
    }
    const prefix = (Date.now() / 1000).toFixed(0);
    let index = 1;
    tasks.map(task => {
      task.conversation_id = this.conversation_id;
      task.id = task.id || `${prefix}_000${index++}`
      task.requirement = resolveRequirement(task)
      return task
    })

    if (mode === 'decompose') {
      // å°†ä»»åŠ¡åˆ†è§£åˆ°æŒ‡å®šä»»åŠ¡çš„ children ä¸‹
      const task = this.getTaskById(task_id);
      if (!task) {
        console.error(`Task with ID ${task_id} not found.`);
        return;
      }
      task.children = task.children || [];
      const children = tasks.map(item => {
        item.status = 'pending';
        item.depth = (task.depth || 1) + 1;
        item.parent_id = task_id;
        return item
      });
      task.children.push(...children);

      await this.bulkCreate(children);
    }

    if (mode === 'overwrite') {
      // ä¿å­˜å·²å®Œæˆä»»åŠ¡çš„çŠ¶æ€
      const completedTasks = new Map();
      this.tasks.forEach(task => {
        if (task.status === 'completed') {
          completedTasks.set(task.id, task);
        }
      });

      // åˆ›å»ºæ–°çš„ä»»åŠ¡åˆ—è¡¨ï¼Œä¿æŒå·²å®Œæˆä»»åŠ¡çš„çŠ¶æ€
      const newTasks = tasks.map(newTask => {
        const completedTask = completedTasks.get(newTask.id);
        if (completedTask) {
          // ä¿æŒå·²å®Œæˆä»»åŠ¡çš„çŠ¶æ€ï¼Œä½†æ›´æ–°å…¶ä»–å±æ€§
          return { ...newTask, status: completedTask.status };
        }
        // æ–°ä»»åŠ¡é»˜è®¤ä¸º pending çŠ¶æ€
        return { ...newTask, status: 'pending' };
      });

      // æ›¿æ¢ä»»åŠ¡åˆ—è¡¨
      await this.setTasks(newTasks, false);
    }
  }

  async resolvePendingTask() {
    const getFirstPendingTask = (tasks = []) => {
      for (const task of tasks) {
        if (task.status !== 'pending' && task.status !== 'revise_plan' && task.status !== 'pause_for_user_input') {
          continue;
        }
        if (task.children && task.children.length > 0) {
          const pendingChild = getFirstPendingTask(task.children);
          if (pendingChild) {
            return pendingChild;
          }
          continue;
        }
        return task;
      }
      return null;
    };

    const tasks = this.getTasks();
    return getFirstPendingTask(tasks);
  }

  resolveTasksDescription(current_task_id) {
    const tasks = this.getTasks();
    if (!Array.isArray(tasks) || tasks.length === 0) {
      return '<tasks></tasks>';
    }

    const resolveTaskStatus = (task = {}) => {
      const status = task.status;
      if (task.id === current_task_id) {
        return 'in_progress';
      }
      if (status === 'completed') {
        return 'completed';
      }
      return 'paused';
    }
    /**
     * é€’å½’å¤„ç†å•ä¸ªä»»åŠ¡èŠ‚ç‚¹
     */
    function formatTask(task = {}, depth = 0) {
      const indent = '  '.repeat(depth + 1);
      const isCurrent = task.id === current_task_id;
      const status = resolveTaskStatus(task);
      let result = `${indent}<task id="${task.id}" status="${status}"${isCurrent ? ' current="true"' : ''}>\n`;
      if (task.requirement) {
        result += `${indent}  <requirement><![CDATA[${task.requirement}]]></requirement>\n`;
      }
      // å¤„ç†å­ä»»åŠ¡
      if (task.children && task.children.length > 0) {
        result += `${indent}  <subtasks>\n`;
        for (const child of task.children) {
          result += formatTask(child, depth + 2);
        }
        result += `${indent}  </subtasks>\n`;
      }

      result += `${indent}</task>\n`;
      return result;
    }
    let xml = '<tasks>\n';
    for (const task of tasks) {
      xml += formatTask(task);
    }
    xml += '</tasks>';
    return xml;
  }

}

module.exports = TaskManager;


================================================
FILE: src/agent/auto-reply/chat.reply.js
================================================
require("module-alias/register");
require("dotenv").config();


const call = require("@src/utils/llm");
const { getDefaultModel } = require('@src/utils/default_model')
const resolveChatPrompt = require('@src/agent/prompt/chat.js');
const sub_server_request = require('@src/utils/sub_server_request')
const chat = async (goal, conversation_id,messages,onTokenStream) => {
  let model_info = await getDefaultModel(conversation_id)
  if (model_info.is_subscribe) {
    let replay = await chat_server(goal, conversation_id,messages,onTokenStream)
    return replay
  }
  let replay = await chat_local(goal, conversation_id,messages,onTokenStream)
  return replay
}
// TODO saas interface
const chat_server = async (goal, conversation_id,messages) => {
  // let [res, token_usage] = await sub_server_request('/api/sub_server/auto_reply', {
  let res = await sub_server_request('/api/sub_server/auto_reply', {
    goal,
    conversation_id,
    //messages
  })
  // await conversation_token_usage(token_usage, conversation_id)
  return res
};

const chat_local = async (goal, conversation_id, messages = [],onTokenStream) => {
  // Call the model to get a response in English based on the goal
  let prompt = goal
  if (messages.length == 0) {
    prompt = await resolveChatPrompt(goal)
  }else{
    // let first message add prompt
    messages[0].content = await resolveChatPrompt(messages[0].content)
  }
  const auto_reply = await call(prompt, conversation_id, 'assistant', {messages},onTokenStream);
  return auto_reply
}



module.exports = exports = chat;



================================================
FILE: src/agent/auto-reply/index.js
================================================
require("module-alias/register");
require("dotenv").config();


const call = require("@src/utils/llm");
const { getDefaultModel } = require('@src/utils/default_model')
const resolveAutoReplyPrompt = require('@src/agent/prompt/auto_reply.js');
const sub_server_request = require('@src/utils/sub_server_request')
const conversation_token_usage = require('@src/utils/get_sub_server_token_usage')
const auto_reply = async (goal, conversation_id) => {
  let model_info = await getDefaultModel(conversation_id)
  if (model_info.is_subscribe) {
    let replay = await auto_reply_server(goal, conversation_id)
    return replay
  }
  let replay = await auto_reply_local(goal, conversation_id)
  return replay
}

const auto_reply_server = async (goal, conversation_id) => {
  // let [res, token_usage] = await sub_server_request('/api/sub_server/auto_reply', {
  let res = await sub_server_request('/api/sub_server/auto_reply', {
    goal,
    conversation_id
  })

  // await conversation_token_usage(token_usage, conversation_id)

  return res
};

const auto_reply_local = async (goal, conversation_id) => {
  // Call the model to get a response in English based on the goal
  const prompt = await resolveAutoReplyPrompt(goal);
  const auto_reply = await call(prompt, conversation_id);

  return auto_reply
}



module.exports = exports = auto_reply;



================================================
FILE: src/agent/chat-completion/index.js
================================================
require("module-alias/register");
require("dotenv").config();


const call = require("@src/utils/llm");
const { getDefaultModel } = require('@src/utils/default_model')
const resolveAutoReplyPrompt = require('@src/agent/prompt/auto_reply.js');
const sub_server_request = require('@src/utils/sub_server_request')
const conversation_token_usage = require('@src/utils/get_sub_server_token_usage')
const chat_completion = async (question, options, conversation_id, onTokenStream) => {
  let model_info = await getDefaultModel(conversation_id)
  if (model_info.is_subscribe) {
    let replay = await chat_completion_server(question, options, conversation_id, onTokenStream)
    return replay
  }
  return chat_completion_local(question, options, conversation_id, onTokenStream)
}

const chat_completion_server = async (question, options, conversation_id, onTokenStream) => {
  // let [res, token_usage] = await sub_server_request('/api/sub_server/auto_reply', {
  let res = await sub_server_request('/api/sub_server/chat_completion', {
    question,
    options,
    conversation_id
  })
  if (onTokenStream) {
    onTokenStream(res)
  }
  return res
};

const chat_completion_local = async (question, options, conversation_id, onTokenStream) => {
  // Call the model to get a response in English based on the goal

  const abortController = new AbortController();
  const signal = abortController.signal;
  options.signal = signal;
  return call(question, conversation_id, 'assistant', options, onTokenStream);
}



module.exports = exports = chat_completion;



================================================
FILE: src/agent/chatbot/index.js
================================================
require("module-alias/register");
require("dotenv").config();

const call = require("@src/utils/llm");
const searchIntentPrompt = require("@src/agent/prompt/chatbot-intent");
const chat_completion = require('@src/agent/chat-completion/index')

const search_intent =  async (messagesContext, question, document_list_str, conversation_id) => {
    const prompt = await searchIntentPrompt(messagesContext, question, document_list_str);
    const content = await chat_completion(prompt,  { response_format: 'json' }, conversation_id)
    return content;
}


module.exports = exports = { search_intent };



================================================
FILE: src/agent/code-act/code-act.common.js
================================================
const Message = require("@src/utils/message");

const finish_action = async (action, context, task_id) => {
  const { memory, onTokenStream } = context;
  const memorized_content = await memory.getMemorizedContent();
  const result = {
    status: "success",
    comments: "Task Success !",
    content: action.params.message,
    memorized: memorized_content,
    meta: {
      action_type: "finish",
    },
    timestamp: new Date().valueOf()
  };
  const msg = Message.format({ status: "success", task_id: task_id, action_type: 'finish', content: result.content, comments: result.comments, memorized: result.memorized });
  onTokenStream && onTokenStream(msg);
  await Message.saveToDB(msg, context.conversation_id);
  return result;
}

/**
 * Helper function to handle retry logic
 * @param {number} retryCount - Current consecutive retry count
 * @param {number} totalRetryAttempts - Current total retry attempts
 * @param {number} maxRetries - Maximum consecutive retry count
 * @param {number} maxTotalRetries - Maximum total retry attempts
 * @param {string} errorMessage - Error message (optional)
 * @returns {Object} - Contains whether to continue retrying and error result (if termination is needed)
 */
const retryHandle = (retryCount, totalRetryAttempts, maxRetries, maxTotalRetries, errorMessage = "") => {
  // check if max consecutive retry times is reached
  if (retryCount >= maxRetries) {
    return {
      shouldContinue: false,
      result: {
        status: "failure",
        comments: `Reached the maximum number of consecutive ${errorMessage ? "exceptions" : "execution failures"} (${maxRetries})${errorMessage ? ": " + errorMessage : ""}`,
      },
    };
  }
  // check if max total retry times is reached
  if (totalRetryAttempts >= maxTotalRetries) {
    return {
      shouldContinue: false,
      result: {
        status: "failure",
        comments: `Reached the maximum total retry attempts (${maxTotalRetries})${errorMessage ? ": " + errorMessage : ""}`,
      },
    };
  }
  // can continue retry
  return { shouldContinue: true };
};

module.exports = exports = {
  finish_action,
  retryHandle,
};



================================================
FILE: src/agent/code-act/code-act.js
================================================
const thinking = require("./thinking");

const LocalMemory = require("@src/agent/memory/LocalMemory");
const { isPauseRequiredError } = require("@src/utils/errors");

// Reflection module
const reflection = require("@src/agent/reflection/index");
const MAX_RETRY_TIMES = 3;
const MAX_TOTAL_RETRIES = 10; // addï¼šmax retries times 
const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

const { resolveActions } = require("@src/xml/index");

const { finish_action, retryHandle } = require("./code-act.common");

const { checkActionToBeContinue, completeMessagesContent } = require("./message");

// const MAX_CONTENT_LENGTH = 1e5;
const MAX_CONTENT_LENGTH = 5 * 1e4;

/**
 * Execute code behavior until task completion or maximum retry times reached
 * @param {Object} task - Task object containing requirement and id
 * @param {Object} context - Context object
 * @returns {Promise<Object>} - Task execution result
 */
const completeCodeAct = async (task = {}, context = {}) => {
  // Initialize parameters and environment
  const { requirement, id = 1, depth = 1 } = task;
  if (depth > 1) {
    // const task_manager = context.task_manager;
    // process.exit(0);
  }
  const maxRetries = context.max_retry_times || MAX_RETRY_TIMES;
  const maxTotalRetries = context.max_total_retries || MAX_TOTAL_RETRIES; // use context or default value

  // Initialize memory and runtime
  const memory_dir = context.conversation_id.slice(0, 6);
  const memory = new LocalMemory({ memory_dir: memory_dir, key: id });
  context.memory = memory;
  memory._loadMemory();
  // @ts-ignore

  let retryCount = 0;
  let totalRetryAttempts = 0; // addï¼štotal retries times counter

  const handleRetry = async () => {
    retryCount++;
    totalRetryAttempts++;
    context.retryCount = retryCount;
    await delay(500);
  }

  // Main execution loop
  while (true) {
    try {
      // 1. LLM thinking
      context.depth = depth || 1;
      let content = await thinking(requirement, context);
      // console.log("thinking.result", content);

      // 2. Parse Action
      // try to parse action directly avoid llm don't continue
      const actions = await resolveActions(content);
      let action = actions[0];
      const messages = await memory.getMessages();
      if (!action) {
        // Try to parse action again with all previous assistant messages
        content = completeMessagesContent(messages);
        const actions = resolveActions(content);
        action = actions[0];
      }
      console.log("action", action);

      if (action && action.type === 'parse_error') {
        await memory.addMessage('user', action.params?.message || 'resolve action failed, Please only generate valid xml format content');
        await handleRetry();
        continue;
      }

      /**
       * ä»»åŠ¡å¤„ç†
       */
      if (action && action.type === 'revise_plan') {
        return {
          status: 'revise_plan',
          params: action.params
        }
      }


      if (action && action.type === 'pause_for_user_input') {
        return {
          status: 'pause_for_user_input',
          params: action.params
        }
      }

      /**
       * 3. Action parse failed
       * â‘ . The max_tokens length is not enough, need to continue to supplement and improve
       * â‘¡. The model return format is incorrect, parse action again
       */
      if (!action) {

        // Exceeded maximum length
        console.log("content.length", content.length, MAX_CONTENT_LENGTH);
        if (content.length > MAX_CONTENT_LENGTH) {
          return {
            status: "failure",
            comments: `Model output exception, stopping task`,
          }
        }

        // use retryHandle to handle retry logic
        const { shouldContinue, result } = retryHandle(retryCount, totalRetryAttempts, maxRetries, maxTotalRetries);
        if (!shouldContinue) {
          return result;
        }

        // Feedback invalid format
        await memory.addMessage('user', "resolve action failed, Please only generate valid xml format content");

        await handleRetry();
        continue;
      }

      // 4. Check if action is 'finish' (task completed)
      if (action.type === "finish") {
        const result = await finish_action(action, context, task.id);
        return result;
      }

      // Check if action is 'to be continue' to completion content
      const actionToBeContinue = checkActionToBeContinue(action);
      if (actionToBeContinue === 'to be continue') {
        continue;
      }

      // 5. Execute action
      const action_result = await context.runtime.execute_action(action, context, task.id);
      if (!context.generate_files) {
        context.generate_files = [];
      }
      if (action_result.meta && action_result.meta.filepath) {
        context.generate_files.push(action_result.meta.filepath);
      }
      // console.log("action_result", action_result);

      // 6. Reflection and evaluation
      const reflection_result = await reflection(requirement, action_result, context.conversation_id);
      const { status, comments } = reflection_result;

      // 7. Handle execution result
      if (status === "success") {
        retryCount = 0; // reset retryCount
        const { content } = action_result;
        const task_tool = task.tools && task.tools[0];
        if (action.type === task_tool) {
          const finish_result = { params: { message: content } }
          const result = await finish_action(finish_result, context, task.id);
          return result;
        }
        continue;
      } else if (status === "failure") {
        // use retryHandle to handle retry logic
        const { shouldContinue, result } = retryHandle(retryCount, totalRetryAttempts, maxRetries, maxTotalRetries, comments);
        if (!shouldContinue) {
          return result;
        }
        retryCount++;
        totalRetryAttempts++;
        // log reflection result to memory and context for further evaluation and refinement
        context.reflection = comments;
        console.log("code-act.memory logging user prompt");
        await memory.addMessage("user", comments);
        await delay(500);
        console.log(`Retrying (${retryCount}/${maxRetries}). Total attempts: ${totalRetryAttempts}/${maxTotalRetries}...`);
      }
    } catch (error) {
      // 8. Exception handling
      console.error("An error occurred:", error);

      // æ£€æŸ¥æ˜¯å¦ä¸ºéœ€è¦æš‚åœçš„é”™è¯¯ç±»å‹: ç§¯åˆ†ä¸è¶³ | LLM è°ƒç”¨å¤±è´¥
      if (isPauseRequiredError(error)) {
        return {
          status: "failure",
          comments: error.message,
          error: error
        };
      }

      // æ™®é€šé”™è¯¯å¤„ç†é€»è¾‘
      // use retryHandle to handle retry logic, pass in error message
      await memory.addMessage("user", error.message);
      const { shouldContinue, result } = retryHandle(retryCount, totalRetryAttempts, maxRetries, maxTotalRetries, error.message);
      if (!shouldContinue) {
        return result;
      }
      retryCount++;
      totalRetryAttempts++;
      console.log(`Retrying (${retryCount}/${maxRetries}). Total attempts: ${totalRetryAttempts}/${maxTotalRetries}...`);
    }
  }
};

module.exports = exports = completeCodeAct;



================================================
FILE: src/agent/code-act/context-cache.llm.message.js
================================================
const LLMResponseLog = require("@src/models/LLMResponseLog");


const resolveMessages = (messages = []) => {
  return messages.map((message) => {
    return {
      role: message.role,
      content: message.content
    }
  })
}

const handleLLMResponseLog = async (llm, prompt, conversation_id, messages = []) => {

  const usage = llm.usage;
  const { input_tokens, output_tokens, total_tokens, input_tokens_details = {}, output_tokens_details = {} } = usage;
  const cached_tokens = input_tokens_details.cached_tokens || 0;
  const reasoning_tokens = output_tokens_details.reasoning_tokens || 0;

  // @ts-ignore
  try {
    await LLMResponseLog.create({
      conversation_id: conversation_id,
      model: llm.model,
      prompt: prompt,
      messages: resolveMessages(messages),
      content: llm.fullContent,
      thinking: llm.reasoningContent,
      usage: usage,
      input_tokens: input_tokens,
      output_tokens: output_tokens,
      total_tokens: total_tokens,
      cached_tokens: cached_tokens,
      reasoning_tokens: reasoning_tokens,
    });
  } catch (error) {
    console.error('Failed to create LLMResponseLog:', error);
  }
}

module.exports = exports = handleLLMResponseLog;



================================================
FILE: src/agent/code-act/context-cache.thinking.js
================================================
require('dotenv').config();

const resolveThinkingPrompt = require("./thinking.prompt");
const resolveThinking = require("@src/utils/thinking");
const handleLLMResponseLog = require("./context-cache.llm.message");
const { deductPoints } = require('@src/utils/point')
const { PauseRequiredError } = require("@src/utils/errors");

const call = async (llm, prompt, messages, context = {}) => {
  const { conversation_id, user_id } = context;
  if (!prompt && messages.length > 0) {
    const message = messages[messages.length - 1];
    prompt = message.role === 'user' ? message.content : 'continue';
  }
  const content = await llm.chat(prompt, {
    sessionId: conversation_id,
    stream: true,
  });
  await handleLLMResponseLog(llm, prompt, conversation_id, messages);

  const usage = llm.usage;
  if (user_id && usage.input_tokens > 0) {
    const { notEnough } = await deductPoints(user_id, usage, conversation_id);
    if (notEnough) {
      throw new PauseRequiredError('Insufficient credits balance');
    }
  }

  return content;
};

const thinking = async (requirement, context = {}, llm) => {
  const { memory, retryCount } = context;
  const summarize = false;
  const messages = await memory.getMessages(summarize);
  if (retryCount > 0) {
    console.log('retryCount', retryCount);
  }

  let prompt = '';
  if (messages.length == 0) {
    prompt = await resolveThinkingPrompt(requirement, context);
    global.logging(context, 'thinking', prompt);
  }

  global.logging(context, 'thinking', JSON.stringify(messages, null, 2));

  const content = await call(llm, prompt, messages, context);
  global.logging(context, 'thinking', content);
  if (prompt) {
    await memory.addMessage('user', prompt);
  }

  if (content && content.startsWith('<think>')) {
    const { thinking: _, content: output } = resolveThinking(content);
    await memory.addMessage('assistant', output);
    return output;
  }
  await memory.addMessage('assistant', content);
  return content;
}

module.exports = exports = thinking;


================================================
FILE: src/agent/code-act/evaluate.prompt.js
================================================
const { loadTemplate } = require("@src/utils/template");
const MAX_REVISE_DEPTH = Number(process.env.MAX_REVISE_DEPTH || 0);

const resolveCorePrinciple = async (mode = 'static') => {
  const filepath = `./core_principle.${mode}.txt`
  const template = await loadTemplate(filepath);
  if (!template) {
    return ''
  }
  return template;
}

const evaluate_tool = `<tool revise_plan>
{
  "name": "revise_plan",
  "description": "åŠ¨æ€è°ƒæ•´ã€ä¼˜åŒ–æˆ–åˆ†è§£å½“å‰çš„ä»»åŠ¡è®¡åˆ’ã€‚é€šè¿‡ mode å‚æ•°æ¥æŒ‡å®šæ˜¯â€œå®Œå…¨è¦†ç›–â€æ•´ä¸ªè®¡åˆ’ï¼Œè¿˜æ˜¯â€œåˆ†è§£â€æŸä¸€ä¸ªå…·ä½“çš„ä»»åŠ¡ã€‚",
  "params": {
    "type": "object",
    "properties": {
      "mode": {
        "type": "string",
        "description": "æŒ‡å®šæ“ä½œæ¨¡å¼ï¼š'overwrite' (å®Œå…¨è¦†ç›– N->1, N->M) æˆ– 'decompose' (åˆ†è§£ä»»åŠ¡ 1->N)ã€‚",
        "enum": [
          "overwrite",
          "decompose"
        ]
      },
      "reason": {
        "type": "string",
        "description": "è§£é‡Šä¸ºä»€ä¹ˆéœ€è¦ä¿®æ”¹è®¡åˆ’ï¼Œé™ˆè¿°ç†ç”±ã€‚"
      },
      "tasks": {
        "type": "array",
        "description": "ä¸€ä¸ªåŒ…å«æ‰€æœ‰æ–°ä»»åŠ¡æˆ–å­ä»»åŠ¡çš„åˆ—è¡¨ã€‚æ¯ä¸ªä»»åŠ¡éƒ½å¿…é¡»æ˜¯ä¸€ä¸ªæ‹¥æœ‰å¤æ‚ç»“æ„çš„å¯¹è±¡ã€‚",
        "items": {
          "type": "object",
          "properties": {
            "title": {
              "type": "string",
              "description": "ä»»åŠ¡çš„ç®€æ´æ ‡é¢˜ï¼Œç”¨äºå±•ç¤ºï¼Œå¦‚â€œã€ç¬¬ä¸€ç« ã€‘æ–°çš„åæ ‡â€ã€‚"
            },
            "goal": {
              "type": "string",
              "description": "å¯¹è¯¥ä»»åŠ¡ç›®æ ‡çš„æ¸…æ™°ã€å¯æ‰§è¡Œçš„æè¿°ã€‚"
            },
            "context": {
              "type": "string",
              "description": "æ‰§è¡Œæ­¤ä»»åŠ¡æ‰€éœ€çš„æ‰€æœ‰å…³é”®ä¸Šä¸‹æ–‡ä¿¡æ¯ï¼Œå¦‚å‰æƒ…æè¦ã€äººç‰©å½“å‰çŠ¶æ€ã€åœºæ™¯æ°›å›´ç­‰ã€‚"
            },
            "acceptance_criteria": {
              "type": "string",
              "description": "ä»»åŠ¡å®Œæˆçš„éªŒæ”¶æ ‡å‡†ï¼Œä¸€ä¸ªæ˜ç¡®çš„ã€å¯éªŒè¯çš„ç»“æœã€‚"
            }
          },
          "required": [
            "id",
            "title",
            "goal",
            "context",
            "acceptance_criteria"
          ]
        }
      }
    },
    "required": [
      "mode",
      "reason",
      "tasks"
    ]
  }
}
</tool>`

const resolveCurrentPlan = (context) => {
  const task_manager = context.task_manager;
  if (!task_manager) {
    return ''
  }
  try {
    return task_manager.resolveTasksDescription(context.task?.id);
  } catch (error) {
    console.error(error);
    return ''
  }
}

const resolveEvaluateOptions = async (context) => {
  const depth = context.depth || 1;

  // è¶…è¿‡æœ€å¤§æ·±åº¦ï¼Œä½¿ç”¨é™æ€æ¨¡å¼
  const mode = depth > MAX_REVISE_DEPTH ? 'static' : 'dynamic';
  const core_principle = await resolveCorePrinciple(mode);
  if (mode === 'static') {
    return { core_principle }
  }

  const current_plan = resolveCurrentPlan(context);
  return {
    core_principle, // ä»»åŠ¡å¤„ç†æ ¸å¿ƒåŸåˆ™
    evaluate_tool, // ä»»åŠ¡è¯„ä¼°å·¥å…·å®šä¹‰
    current_plan, // å½“å‰ä»»åŠ¡è®¡åˆ’
  }
}

module.exports = exports = {
  evaluate_tool,
  resolveCorePrinciple,
  resolveCurrentPlan,
  resolveEvaluateOptions
}



================================================
FILE: src/agent/code-act/index.js
================================================
const completeCodeAct = require("./code-act.js");

const CODE_ACT_VERSION = process.env.CODE_ACT_VERSION || 'base';

const hash = {
  'base': completeCodeAct,
}

module.exports = exports = hash[CODE_ACT_VERSION];




================================================
FILE: src/agent/code-act/message.js
================================================
const checkActionToBeContinue = (action) => {
  const { type, params } = action;
  if (type === 'write_code' && !params?.content) {
    return 'to be continue';
  }
  return 'invalid';
}

const completeMessagesContent = (messages) => {
  const assistantContents = [];
  for (let i = messages.length - 1; i >= 0; i--) {
    const message = messages[i];
    if (message && message.role === 'assistant' && typeof message.content === 'string') {
      // Add to the beginning to maintain order for join
      assistantContents.unshift(message.content);
    } else {
      // Stop if not an assistant message or if content is missing/not a string
      break;
    }
  }
  const completion = assistantContents.join('').trim();
  return completion
}

module.exports = {
  checkActionToBeContinue,
  completeMessagesContent
};


================================================
FILE: src/agent/code-act/message.test.js
================================================
/**
 * @author: Trae | Gemini-2.5-Pro-Preview(0506)
 * @date 2025-06-18
 */

const { expect } = require('chai');
const { checkConsecutiveAssistantXml } = require('./message');

describe('checkConsecutiveAssistantXml', () => {
  it('should return "invalid" for null input', () => {
    expect(checkConsecutiveAssistantXml(null)).to.equal('invalid');
  });

  it('should return "invalid" for undefined input', () => {
    expect(checkConsecutiveAssistantXml(undefined)).to.equal('invalid');
  });

  it('should return "invalid" for empty array input', () => {
    expect(checkConsecutiveAssistantXml([])).to.equal('invalid');
  });

  it('should return "invalid" if no assistant messages are at the end', () => {
    const messages = [{ role: 'user', content: 'Hello' }];
    expect(checkConsecutiveAssistantXml(messages)).to.equal('invalid');
  });

  it('should return "invalid" if the last assistant message has no content', () => {
    const messages = [{ role: 'assistant', content: null }];
    expect(checkConsecutiveAssistantXml(messages)).to.equal('invalid');
  });

  it('should return "invalid" if combined assistant content is empty after trim', () => {
    const messages = [{ role: 'assistant', content: '   ' }];
    expect(checkConsecutiveAssistantXml(messages)).to.equal('invalid');
  });

  it('should return "invalid" if combined content does not start with "<"', () => {
    const messages = [{ role: 'assistant', content: 'Hello' }];
    expect(checkConsecutiveAssistantXml(messages)).to.equal('invalid');
  });

  it('should return "to be continue" if content starts with "<" but does not end with ">"', () => {
    const messages = [{ role: 'assistant', content: '<tool_call>' }];
    // Simulate incomplete stream
    messages[0].content = '<tool_call';
    expect(checkConsecutiveAssistantXml(messages)).to.equal('to be continue');
  });

  it('should return "to be continue" for multiple assistant messages forming an incomplete xml not ending with ">"', () => {
    const messages = [
      { role: 'assistant', content: '<tool' },
      { role: 'assistant', content: '_call>' },
    ];
    messages[1].content = '_call'; // Simulate incomplete stream
    expect(checkConsecutiveAssistantXml(messages)).to.equal('to be continue');
  });

  it('should return "to be continue" if opening tags > closing tags', () => {
    const messages = [{ role: 'assistant', content: '<tool_call><params>' }];
    expect(checkConsecutiveAssistantXml(messages)).to.equal('to be continue');
  });

  it('should return "to be continue" for multiple assistant messages forming xml with opening tags > closing tags', () => {
    const messages = [
      { role: 'assistant', content: '<tool_call>' },
      { role: 'assistant', content: '<params>' },
      { role: 'assistant', content: '<param_name>query</param_name>' }, // query is not closed
    ];
    messages[2].content = '<param_name>query';
    expect(checkConsecutiveAssistantXml(messages)).to.equal('to be continue');
  });

  it('should return "invalid" for a complete XML-like string with equal open/close tags', () => {
    const messages = [{ role: 'assistant', content: '<tool_call></tool_call>' }];
    expect(checkConsecutiveAssistantXml(messages)).to.equal('invalid');
  });

  it('should return "invalid" for multiple assistant messages forming a complete XML-like string', () => {
    const messages = [
      { role: 'assistant', content: '<tool_call>' },
      { role: 'assistant', content: '<params>' },
      { role: 'assistant', content: '<name>search</name>' },
      { role: 'assistant', content: '</params>' },
      { role: 'assistant', content: '</tool_call>' },
    ];
    expect(checkConsecutiveAssistantXml(messages)).to.equal('invalid');
  });

  it('should correctly process only the last consecutive assistant messages', () => {
    const messages = [
      { role: 'user', content: 'Previous query' },
      { role: 'assistant', content: '<old_call></old_call>' },
      { role: 'user', content: 'New query' },
      { role: 'assistant', content: '<tool_call>' }, // This should be the start of the sequence
      { role: 'assistant', content: '<params>' },    // This is part of the sequence
    ];
    expect(checkConsecutiveAssistantXml(messages)).to.equal('to be continue');
  });

  it('should return "invalid" if the last sequence of assistant messages is valid XML', () => {
    const messages = [
      { role: 'user', content: 'New query' },
      { role: 'assistant', content: '<tool_call>' },
      { role: 'assistant', content: '<params></params>' },
      { role: 'assistant', content: '</tool_call>' },
    ];
    expect(checkConsecutiveAssistantXml(messages)).to.equal('invalid');
  });

  it('should return "invalid" for content with self-closing tags and balanced', () => {
    const messages = [{ role: 'assistant', content: '<tool_call />' }];
    expect(checkConsecutiveAssistantXml(messages)).to.equal('invalid');
  });

  it('should return "to be continue" for content with self-closing tags but more opening tags', () => {
    const messages = [{ role: 'assistant', content: '<tool_call><param /></tool_call' }];
    expect(checkConsecutiveAssistantXml(messages)).to.equal('to be continue');
  });

  it('should handle complex xml-like structures correctly', () => {
    const messages1 = [{ role: 'assistant', content: '<tool_code>\nconsole.log("hello world");\n</tool_code>' }];
    expect(checkConsecutiveAssistantXml(messages1)).to.equal('invalid');

    const messages2 = [{ role: 'assistant', content: '<tool_code>\nconsole.log("hello world");\n</tool_cod' }];
    expect(checkConsecutiveAssistantXml(messages2)).to.equal('to be continue');

    const messages3 = [{ role: 'assistant', content: '<tool_code>\n<test><inner>abc</inner>' }];
    expect(checkConsecutiveAssistantXml(messages3)).to.equal('to be continue');
  });

  it('should correctly identify incomplete XML when split across multiple assistant messages', () => {
    const messages = [
      { role: 'assistant', content: '<tool_calls><tool_call><name>e' },
      { role: 'assistant', content: 'xample</name><parameters><param1>value1</param1></parameters></tool_call></tool_calls' }
    ];
    expect(checkConsecutiveAssistantXml(messages)).to.equal('to be continue');
  });

  it('should correctly identify complete XML when split across multiple assistant messages', () => {
    const messages = [
      { role: 'assistant', content: '<tool_calls><tool_call><name>example</name><parameters><param1>value1</param1></parameters></tool_call></tool_calls>' }
    ];
    expect(checkConsecutiveAssistantXml(messages)).to.equal('invalid');
  });

  it('should return "invalid" for non-string content in assistant message', () => {
    const messages = [{ role: 'assistant', content: { text: '<xml>' } }];
    expect(checkConsecutiveAssistantXml(messages)).to.equal('invalid');
  });

  it('should return "invalid" if last assistant message is valid but previous ones are not strings', () => {
    const messages = [
      { role: 'assistant', content: { text: 'some object' } },
      {
        role: 'assistant', content: '<valid></valid>'
      }
    ];
    expect(checkConsecutiveAssistantXml(messages)).to.equal('invalid');
  });

  it('should return "to be continue" if last assistant message is incomplete and previous ones are not strings', () => {
    const messages = [
      { role: 'assistant', content: { text: 'some object' } },
      { role: 'assistant', content: '<incomplete' }
    ];
    // This case is tricky. The loop breaks at the non-string content.
    // So it only considers '<incomplete'.
    expect(checkConsecutiveAssistantXml(messages)).to.equal('to be continue');
  });

  it('should handle tags with attributes', () => {
    const messages1 = [{ role: 'assistant', content: '<element attr="value">content</element>' }];
    expect(checkConsecutiveAssistantXml(messages1)).to.equal('invalid');

    const messages2 = [{ role: 'assistant', content: '<element attr="value">content</elemen' }];
    expect(checkConsecutiveAssistantXml(messages2)).to.equal('to be continue');

    const messages3 = [{ role: 'assistant', content: '<element attr="value"' }];
    expect(checkConsecutiveAssistantXml(messages3)).to.equal('to be continue');
  });

  it('should handle comments and processing instructions as non-opening tags', () => {
    const messages1 = [{ role: 'assistant', content: '<!-- comment --><tag></tag>' }];
    expect(checkConsecutiveAssistantXml(messages1)).to.equal('invalid');

    const messages2 = [{ role: 'assistant', content: '<?xml version="1.0"?><tag></tag>' }];
    expect(checkConsecutiveAssistantXml(messages2)).to.equal('invalid');

    const messages3 = [{ role: 'assistant', content: '<!DOCTYPE html><tag></tag>' }];
    expect(checkConsecutiveAssistantXml(messages3)).to.equal('invalid');

    const messages4 = [{ role: 'assistant', content: '<!-- comment --><tag>' }];
    expect(checkConsecutiveAssistantXml(messages4)).to.equal('to be continue');
  });

});


================================================
FILE: src/agent/code-act/thinking.js
================================================
require('dotenv').config();

const resolveThinkingPrompt = require("./thinking.prompt");
const resolveThinking = require("@src/utils/thinking");
const { getDefaultModel } = require('@src/utils/default_model')

const call = require("@src/utils/llm");
const DEVELOP_MODEL = 'assistant';

const chat_completion = require('@src/agent/chat-completion/index')

const thinking = async (requirement, context = {}) => {
  let model_info = await getDefaultModel(context.conversation_id)
  if (model_info.is_subscribe) {
    let content = await thinking_server(requirement, context)
    return content
  }
  let content = await thinking_local(requirement, context)
  return content
}

const thinking_server = async (requirement, context = {}) => {
  const { memory, retryCount } = context;
  // console.log('memory', memory);
  const summarize = false;
  const messages = await memory.getMessages(summarize);
  if (retryCount > 0) {
    // Retry with user reply
    console.log('retryCount', retryCount);
    // messages.pop();
  }

  // If last message is assistant, return directly, support quickly playback and run action
  const message = messages[messages.length - 1];
  if (message && message.role === 'assistant') {
    // return message.content;
  }

  // Use LLM thinking to instruct next action
  let prompt = '';
  if (messages.length == 0) {
    prompt = await resolveThinkingPrompt(requirement, context);
    global.logging(context, 'thinking', prompt);
    // global.safeExit && await global.safeExit(0, 'process.exit in thinking_local')
  }
  const options = {
    messages: messages.map(item => {
      return { role: item.role, content: item.content }
    })
  }
  
  const content = await chat_completion(prompt,options,context.conversation_id);
  global.logging(context, 'thinking', content);
  if (prompt) {
    await memory.addMessage('user', prompt);
  }
  if (content && content.startsWith('<think>')) {
    const { thinking: _, content: output } = resolveThinking(content);
    await memory.addMessage('assistant', output);
    return output;
  }

  await memory.addMessage('assistant', content);

  return content;
}

const thinking_local = async (requirement, context = {}) => {
  const { memory, retryCount } = context;
  // console.log('memory', memory);
  const summarize = false;
  const messages = await memory.getMessages(summarize);
  if (retryCount > 0) {
    // Retry with user reply
    console.log('retryCount', retryCount);
    // messages.pop();
  }

  // If last message is assistant, return directly, support quickly playback and run action
  const message = messages[messages.length - 1];
  if (message && message.role === 'assistant') {
    // return message.content;
  }

  // Use LLM thinking to instruct next action
  let prompt = '';
  if (messages.length == 0) {
    prompt = await resolveThinkingPrompt(requirement, context);
    global.logging(context, 'thinking', prompt);
    // global.safeExit && await global.safeExit(0, 'process.exit in thinking_local');
  }
  const options = {
    messages: messages.map(item => {
      return { role: item.role, content: item.content }
    })
  }
  const content = await call(prompt, context.conversation_id, DEVELOP_MODEL, options);
  global.logging(context, 'thinking', content);
  if (prompt) {
    await memory.addMessage('user', prompt);
  }

  if (content && content.startsWith('<think>')) {
    const { thinking: _, content: output } = resolveThinking(content);
    await memory.addMessage('assistant', output);
    return output;
  }
  await memory.addMessage('assistant', content);
  return content;
}

module.exports = exports = thinking;


================================================
FILE: src/agent/code-act/thinking.prompt.js
================================================
const resolveToolPrompt = require('@src/agent/prompt/tool');

// æç¤ºè¯è½¬æ¢å‡½æ•°
const { describeLocalMemory, loadConversationMemory, describeUploadFiles, describeSystem } = require("./thinking.util");

const resolveServers = require("@src/mcp/server.js");
const { resolveMcpServerPrompt } = require("@src/mcp/prompt.js");
const delay = ms => new Promise(resolve => setTimeout(resolve, ms));
const { resolveThinkingKnowledge } = require("@src/knowledge/index");

// æ¨¡æ¿åŠ è½½è§£æ
const { resolveTemplate, loadTemplate } = require("@src/utils/template");

const { resolveEvaluateOptions } = require("./evaluate.prompt");

const resolveThinkingPrompt = async (requirement = '', context = {}) => {

  const { reflection = '', goal = '', depth = 1 } = context;
  global.logging(context, 'thinking.prompt', `goal: ${goal}`);

  const memory = await describeLocalMemory(context);
  const tools = await resolveToolPrompt(); // system tools
  const servers = await resolveServers(context);
  const mcpToolsPrompt = await resolveMcpServerPrompt(servers); // mcp server tools
  // console.log("mcpToolsPrompt", mcpToolsPrompt);
  const uploadFileDescription = describeUploadFiles(context.files || []);
  const previousResult = await loadConversationMemory(context.conversation_id);
  const app_ports = JSON.stringify([context.runtime.app_port_1, context.runtime.app_port_2])
  const system = describeSystem();
  const knowledge = await resolveThinkingKnowledge(context);

  const thinking_options = {
    system, // ç³»ç»Ÿä¿¡æ¯
    app_ports, // ç«¯å£ä¿¡æ¯
    previous: previousResult, // å‰ç½®è®°å½•ç»“æœ
    memory, // æ‰§è¡Œè®°å½•
    files: uploadFileDescription, // ä¸Šä¼ æ–‡ä»¶ä¿¡æ¯
    goal, // ä¸»ä»»åŠ¡ç›®æ ‡
    requirement, // å½“å‰éœ€æ±‚
    reflection, // åé¦ˆä¿¡æ¯
    best_practices_knowledge: knowledge,
    tools: tools + '\n' + mcpToolsPrompt // å·¥å…·åˆ—è¡¨
  }

  // åŠ¨æ€è¯„ä¼°æç¤ºè¯
  const evaluate_options = await resolveEvaluateOptions(context);
  Object.assign(thinking_options, evaluate_options)
  global.logging(context, 'thinking.prompt', `evaluate_options.current_plan: ${evaluate_options.current_plan}`);

  const promptTemplate = await loadTemplate('thinking.txt');
  const thinking_prompt = await resolveTemplate(promptTemplate, thinking_options)

  return thinking_prompt;
}

module.exports = resolveThinkingPrompt;


================================================
FILE: src/agent/code-act/thinking.util.js
================================================
const Task = require('@src/models/Task');
const loadConversationMemory = async (conversation_id) => {
  const tasks = await Task.findAll({
    where: {
      conversation_id
    }
  })
  const memories = []
  for (const task of tasks) {
    if (task.dataValues.memorized) {
      memories.push(task.dataValues.memorized)
    }
  }
  return memories.join('\n');
}

const describeLocalMemory = async (context) => {
  global.logging(context, 'thinking.util', JSON.stringify(context.tasks || [], null, 2));
  const tasks = (context.tasks || []).filter(item => item.status === 'completed');
  if (tasks.length === 0) {
    return '';
  }
  const completedDescription = tasks.map(item => {
    const { id, requirement, result, memorized = '', content } = item;
    return `=== TaskID: ${id}
Task Goal: ${requirement}
Task Execute Memory: ${memorized}
Task Result: ${content}`
  }).join('\n');
  return `== Task Completion Status ==:
${completedDescription}`
}

const describeUploadFiles = files => {
  let content = ''
  for (let file of files) {
    content += 'upload/' + file.name + "\n"
  }
  return content;
}

const describeSystem = () => {
  return `
- Role: LemonAI
- Website: https://lemonai.ai
- Operating System: ${process.platform}
- Docker Environment OS (for terminal_run): linux
- Current Date: ${new Date().toLocaleDateString()}`
}

module.exports = exports = {
  loadConversationMemory,
  describeLocalMemory,
  describeUploadFiles,
  describeSystem
}


================================================
FILE: src/agent/generate-agent/generate_system_role.js
================================================
require("module-alias/register");
require("dotenv").config();


const call = require("@src/utils/llm");
const resolveGenerateSystemRolePrompt = require("@src/agent/prompt/generate_system_role");
const resolveThinking = require("@src/utils/thinking");


const generate_system_role = async (userAgentData, conversation_id = null) => {
  try {
    const prompt = await resolveGenerateSystemRolePrompt(userAgentData);
    const content = await call(prompt, conversation_id, '', { response_format: 'json' });
    
    // handle thinking model result
    // if (content && content.startsWith('<think>')) {
    //   const { thinking: _, content: title } = resolveThinking(content);
    //   return title;
    // }
    
    if (!content) {
      throw new Error('LLM returned null or empty content');
    }
    
    // æ£€æŸ¥è¿”å›çš„å†…å®¹æ˜¯å¦æœ‰å¿…éœ€çš„å­—æ®µ
    if (!content.name || !content.describe) {
      throw new Error(`Generated system role missing required fields. Got: ${JSON.stringify(content)}`);
    }
    
    return content;
  } catch (error) {
    console.error('Error in generate_system_role:', error);
    throw error;
  }
}



module.exports = exports = generate_system_role;


================================================
FILE: src/agent/generate-agent/index.js
================================================
require("module-alias/register");
require("dotenv").config();


const call = require("@src/utils/llm");
const { getDefaultModel } = require('@src/utils/default_model')
const resolveGenerateAgentPrompt = require("@src/agent/prompt/generate_agent");
const sub_server_request = require('@src/utils/sub_server_request')

const generate_agent = async (question, conversation_id) => {
  let model_info = await getDefaultModel(conversation_id)
  console.log
  if (model_info.is_subscribe) {
    let result = await generate_agent_server(question, conversation_id)
    return result
  }
  let result = await generate_agent_local(question, conversation_id)
  return result
}

const generate_agent_server = async (question, conversation_id) => {
  let res = await sub_server_request('/api/sub_server/generate_agent', {
    question,
    conversation_id
  })

  return res
};

const generate_agent_local = async (question, conversation_id) => {
  const prompt = await resolveGenerateAgentPrompt(question);
  const content = await call(prompt, conversation_id, '', { response_format: 'json' });
  return content;
}



module.exports = exports = generate_agent;



================================================
FILE: src/agent/generate-agent/knowledge.js
================================================
require("module-alias/register");
require("dotenv").config();

const call = require("@src/utils/llm");
const resolveGenerateAgentPrompt = require("@src/agent/prompt/generate_knowledge");
const { resolveUsedKnowledgeForCategory } = require('@src/knowledge/knowledge.util')

const generate_knowledge = async (question, agents, conversation_id) => {
  for (let agent of agents) {
    let knowledges = await resolveUsedKnowledgeForCategory(agent.id, ['planning', 'execution', 'core_directive'])
    agent.knowledges = knowledges
  }
  const prompt = await resolveGenerateAgentPrompt(question, JSON.stringify(agents));
  const content = await call(prompt, conversation_id, '', { response_format: 'json' });

  return content;
}

// generate_knowledge("æˆ‘æƒ³å¸¦ç‹—å»è‹å·ç©ï¼Œå¸®æˆ‘è§„åˆ’ä¸€ä¸‹",[{"id":2,"name":"åŒ—äº¬å¸¦ç‹—å‡ºè¡Œ","describe":"åœ¨åŒ—äº¬å¸¦ç‹—å‡ºè¡Œæ¸¸ç©çš„agent"}],'5b2e2df3-8788-44d3-8dd4-8549746e6266')

module.exports = exports = generate_knowledge;



================================================
FILE: src/agent/generate-title/index.js
================================================
require("module-alias/register");
require("dotenv").config();

const sub_server_request = require('@src/utils/sub_server_request')
const conversation_token_usage = require('@src/utils/get_sub_server_token_usage')

const call = require("@src/utils/llm");
const { getDefaultModel } = require('@src/utils/default_model')
const resolveGenerateTitlePrompt = require("@src/agent/prompt/generate_title");
const resolveThinking = require("@src/utils/thinking");

const generate_title = async (question, conversation_id) => {
    let model_info = await getDefaultModel(conversation_id)
    if (model_info.is_subscribe) {
        let title = await generate_title_server(question, conversation_id)
        return title
    }
    let replay = await generate_title_local(question, conversation_id)
    return replay
}

const generate_title_server = async (question, conversation_id) => {
    // const [res, token_usage] = await sub_server_request('/api/sub_server/generate_title', {
    const res = await sub_server_request('/api/sub_server/generate_title', {
        question,
        conversation_id
    })

    // await conversation_token_usage(token_usage, conversation_id)
    return res
};

const generate_title_local = async (question, conversation_id) => {
    const prompt = await resolveGenerateTitlePrompt(question);
    const content = await call(prompt, conversation_id);
    // handle thinking model result
    if (content && content.startsWith('<think>')) {
        const { thinking: _, content: title } = resolveThinking(content);
        return title;
    }
    return content;
}

module.exports = exports = generate_title;



================================================
FILE: src/agent/intent-detection/index.js
================================================
require("module-alias/register");
require("dotenv").config();

const sub_server_request = require('@src/utils/sub_server_request')
const conversation_token_usage = require('@src/utils/get_sub_server_token_usage')

const call = require("@src/utils/llm");
const { getDefaultModel } = require('@src/utils/default_model')
const resolveIntentDetectionPrompt = require("@src/agent/prompt/intent_detection");
const resolveThinking = require("@src/utils/thinking");

const detect_intent = async (question, conversation_id, messagesContext = []) => {
    let model_info = await getDefaultModel(conversation_id)
    if (model_info.is_subscribe) {
        let intent = await detect_intent_server(question, conversation_id, messagesContext)
        return intent
    }
    let intent = await detect_intent_local(question, conversation_id, messagesContext)
    return intent
}

const detect_intent_server = async (question, conversation_id, messagesContext = []) => {
    const res = await sub_server_request('/api/sub_server/detect_intent', {
        question,
        conversation_id,
        messagesContext
    })

    return res
};

const detect_intent_local = async (question, conversation_id, messagesContext = []) => {
    const prompt = await resolveIntentDetectionPrompt(question, messagesContext);
    const content = await call(prompt, conversation_id, '', { response_format: 'json' });
    
    console.log('Intent detection content type:', typeof content);
    console.log('Intent detection content value:', content);
    
    try {
        // å¦‚æœ content å·²ç»æ˜¯å¯¹è±¡ï¼Œç›´æ¥ä½¿ç”¨
        if (typeof content === 'object' && content !== null) {
            return content.intent ? content.intent.trim().toLowerCase() : 'agent';
        }
        
        // å¦‚æœæ˜¯å­—ç¬¦ä¸²ï¼Œå°è¯•è§£æä¸º JSON
        if (typeof content === 'string') {
            // handle thinking model result first
            if (content.startsWith('<think>')) {
                const { thinking: _, content: intent } = resolveThinking(content);
                return intent.trim().toLowerCase();
            }
            
            const result = JSON.parse(content);
            return result.intent ? result.intent.trim().toLowerCase() : 'agent';
        }
        
        // å…¶ä»–æƒ…å†µé»˜è®¤è¿”å› agent
        return 'agent';
    } catch (error) {
        console.error('Intent detection error:', error);
        console.error('Content type:', typeof content);
        console.error('Content value:', content);
        
        // å¦‚æœæ˜¯å­—ç¬¦ä¸²ä¸”è§£æå¤±è´¥ï¼Œå°è¯•ä»å­—ç¬¦ä¸²ä¸­æå– intent
        if (typeof content === 'string') {
            const lowerContent = content.toLowerCase().trim();
            if (lowerContent.includes('chat')) {
                return 'chat';
            } else if (lowerContent.includes('agent')) {
                return 'agent';
            }
        }
        
        // é»˜è®¤è¿”å› agent
        return 'agent';
    }
}

module.exports = exports = detect_intent;


================================================
FILE: src/agent/memory/BaseMemory.js
================================================
[Empty file]


================================================
FILE: src/agent/memory/index.js
================================================
const LocalMemory = require('./LocalMemory')

module.exports = {
  LocalMemory,
}


================================================
FILE: src/agent/memory/LocalMemory.js
================================================
const fs = require('fs');
const path = require('path');

// ensure the temporary directory exists
const { getDirpath } = require('@src/utils/electron');
const cache_dir = getDirpath('Caches/memory');
fs.mkdirSync(cache_dir, { recursive: true });

const { json2xml } = require("@src/utils/format");

class LocalMemory {
  constructor(options = {}) {
    this.options = options;
    this.memory_dir = options.memory_dir;
    if (this.memory_dir) {
      const dir = path.resolve(cache_dir, this.memory_dir);
      fs.mkdirSync(dir, { recursive: true });
    }
    this.key = options.key; // primary key ID
    console.log(`LocalMemory initialized with key: ${this.key}`);
  }

  _getFilePath() {
    if (this.memory_dir) {
      const dir = path.resolve(cache_dir, this.memory_dir);
      return path.resolve(dir, `${this.key}.json`);
    }
    // use this.key as the file name, store in the specified temporary directory
    return path.resolve(cache_dir, `${this.key}.json`);
  }

  async _loadMemory() {
    const filePath = this._getFilePath();
    try {
      const data = fs.readFileSync(filePath, 'utf-8');
      return JSON.parse(data);
    } catch (error) {
      // if the file does not exist or there is an error reading it, return an empty array
      if (error.code !== 'ENOENT') {
        console.error(`Error reading memory file for ${this.key}:`, error);
      }
      return [];
    }
  }

  async _saveMemory(messages) {
    const filePath = this._getFilePath();
    try {
      fs.writeFileSync(filePath, JSON.stringify(messages, null, 2), 'utf-8');
      console.log(`Memory for task ${this.key} saved successfully.`);
    } catch (error) {
      console.error(`Error saving memory file for ${this.key}:`, error);
      throw new Error(`Failed to save memory for task ${this.key}`);
    }
  }

  async addMessage(role, content, action_type = '', memorized = false, meta = {}) {
    // 1. load message list
    const messages = await this._loadMemory();
    // 2. add new message
    const { action = {}, status = 'success' } = meta;
    if (role === 'user' && memorized) {
      const full_memory_info = Object.assign(action, {
        status, result: content
      })
      meta.action_memory = meta.action_memory || json2xml(full_memory_info)
    }
    messages.push({ role, content, action_type, memorized, meta });
    // 3. save message list
    await this._saveMemory(messages);
  }

  async getMessages() {
    const messages = await this._loadMemory();
    return messages;
  }

  async clearMemory() {
    const filePath = this._getFilePath();
    try {
      await fs.unlinkSync(filePath);
      console.log(`Memory for task ${this.key} cleared successfully.`);
    } catch (error) {
      if (error.code === 'ENOENT') {
        // file does not exist, be considered as cleared
        console.log(`No memory file found for task ${this.key} to clear.`);
      } else {
        console.error(`Error clearing memory file for ${this.key}:`, error);
        throw new Error(`Failed to clear memory for task ${this.key}`);
      }
    }
  }

  // get memorized content
  async getMemorizedContent() {
    // 1. load message list
    const messages = await this._loadMemory();
    // 2. extract content
    const list = [];
    for (const message of messages) {
      const { action_type = '', memorized, meta = {} } = message;
      if (!memorized) {
        continue; // skip non-memorized message
      }
      const action_memory = meta.action_memory || `${action_type.toUpperCase()}: ${message.content}`
      list.push(action_memory);
    }
    return list.join('\n');
  }
}

module.exports = LocalMemory;


================================================
FILE: src/agent/planning/index.js
================================================
require("module-alias/register");
require("dotenv").config();

const sub_server_request = require('@src/utils/sub_server_request')

const { getDefaultModel } = require('@src/utils/default_model')

const planning = async (goal, options) => {
  const { conversation_id } = options;
  let model_info = await getDefaultModel(conversation_id)
  if (model_info.is_subscribe) {
    let clean_tasks = await planning_server(goal, options)
    return clean_tasks
  }

  let clean_tasks = await planning_local(goal, options)
  return clean_tasks
};

const planning_server = async (goal, options) => {
  const { conversation_id, files, previousResult } = options;
  // const [res, token_usage] = await sub_server_request('/api/sub_server/planning', {
  const res = await sub_server_request('/api/sub_server/planning', {
    goal,
    options
  })

  return res
};

const resolvePlanningPromptBP = require("@src/agent/prompt/plan");
const { resolveMarkdown } = require("@src/utils/markdown");
const resolveThinking = require("@src/utils/thinking");
const retryWithFormatFix = require("./retry_with_format_fix");

const planning_local = async (goal, options = {}) => {
  const { conversation_id } = options;
  const prompt = await resolvePlanningPromptBP(goal, options);

  // ç»“æœå¤„ç†å™¨
  const processResult = async (markdown) => {
    // å¤„ç† thinking æ ‡ç­¾
    if (markdown && markdown.startsWith('<think>')) {
      const { content: output } = resolveThinking(markdown);
      markdown = output;
    }
    const tasks = await resolveMarkdown(markdown);
    return tasks || [];
  };
  // éªŒè¯å‡½æ•°
  const validate = (tasks) => Array.isArray(tasks) && tasks.length > 0;

  return await retryWithFormatFix(prompt, processResult, validate, conversation_id);
}
module.exports = exports = planning;



================================================
FILE: src/agent/planning/index.test.js
================================================
require("module-alias/register");
require("dotenv").config();

const planning_model = 'provider#doubao#doubao-deepseek-v3';
const call = require("@src/utils/llm");
const resolvePlanningPrompt = require("@src/agent/prompt/plan");

const planning = async (goal) => {
  return [
    {
      "id": "1745478628199_692",
      "title": "æŸ¥æ‰¾ç›®æ ‡Excelæ–‡ä»¶",
      "description": "Use the terminal_run tool to execute the search command to locate the Excel file about large model application statistics in the working directory",
      "tool": "terminal_run"
    },
    {
      "id": "1745485679318_600",
      "title": "Read the Excel file content",
      "description": "Use the read_file tool to read the content of the confirmed target Excel file",
      "tool": "read_file"
    },
    {
      "id": "1745485679318_601",
      "title": "Generate a web template",
      "description": "Read the file content and use the write_code tool to create a basic HTML template, including the domestic and international screening functions",
      "tool": "write_code"
    },
    {
      "id": "1745485679318_602",
      "title": "Deploy the test environment",
      "description": "Use the terminal_run tool to start the local test server",
      "tool": "terminal_run"
    },
    // {
    //   "title": "Function verification",
    //   "description": "Use the BrowserCode tool to thoroughly test the filtering functions and link jump of the web page",
    //   "tool": "BrowserCode"
    // }
  ]
  const prompt = await resolvePlanningPrompt(goal);
  const content = await call(prompt, planning_model);
  console.log("\n==== conclusion result ====");
  console.log(content);
  return content;
};

module.exports = exports = planning;



================================================
FILE: src/agent/planning/plan.run.js
================================================
require('module-alias/register');
require('dotenv').config();

const planning = require('./index');

const run = async () => {
  const goal = 'Read and analyze the Excel file about large model application statistics in the working directory, display its contents on a web page, support filtering between domestic and international entries, and provide access to corresponding official website links and API platform links';  
  const result = await planning(goal);
  console.log(result);

  process.exit(0);
}

run();


================================================
FILE: src/agent/planning/retry_with_format_fix.js
================================================
[Binary file]


================================================
FILE: src/agent/prompt/auto_reply.js
================================================

const resolveAutoReplyPrompt = async (question) => {

  const prompt = `
  You are a helpful assistant that generates concise. Your name is Lemon. Lemon is a helpful AI agent that can interact with a computer to solve tasks using bash terminal, file editor, and browser. Given a user message,  
  Simply and politely reply to the user, saying that you will solve their current problem and ask them to wait a moment

  user message isï¼š
  
  ${question}
  `

  return prompt;
}


module.exports = resolveAutoReplyPrompt;


================================================
FILE: src/agent/prompt/chat.js
================================================

const resolveChatPrompt = async (question) => {

    const prompt = `
    You are a friendly and helpful chatbot named Lemon. 
    Your role is to assist users by providing concise and accurate responses to their questions or messages. 
    Politely and friendly acknowledge the user's message and provide a clear and relevant answer.
    ${question}
    `;

    return prompt;
}


module.exports = resolveChatPrompt;


================================================
FILE: src/agent/prompt/chatbot-intent.js
================================================

const searchIntentPrompt = async (conversation_history, question) => {
  const prompt = `
You are an expert **Source Routing Engine**. Your function is to analyze the user's **Current Input** and the **Complete Conversation History** to determine whether to use internal knowledge or web search.

**Available Knowledge Sources (Mutually Exclusive):**
1.  **INTERNAL (No Tool)**: Rely solely on your internal knowledge base (for common facts, creative tasks, or general knowledge).
2.  **WEB SEARCH**: Use the Web Search Tool (for real-time information, latest news, current data, or facts post-dating your knowledge cutoff).

**Input Format:**
[CONVERSATION_HISTORY]
${conversation_history}

[USER_INPUT]
${question}

**Decision Criteria (Select ONE Source):**
* **A. CHOOSE INTERNAL**: If the question is about common knowledge, widely accepted facts, creative tasks (writing, code, summary), or concepts that do not require recent updates.
* **B. CHOOSE WEB SEARCH**: If the question requires current/real-time facts, recent events, market prices, or any information likely updated after the model's knowledge cutoff.

**Thinking Process (Perform this before outputting the final JSON):**
1.  **Analyze Input:** What is the core subject and specific information requested?
2.  **Evaluate Timeliness:** Does the question require real-time data or post-cutoff facts?
3.  **Final Decision:** Determine the **single best source (Internal or Search)** based on the criteria.

**Output Requirement:**
Your final output MUST be **ONLY a JSON object**.

**JSON Structure:**

{
  "thought": "{{Provide a brief, English description of your reasoning and the single chosen source (Internal/Search).}}",
  "source_type": "INTERNAL" | "SEARCH",
  "search_query": "{{If 'source_type' is 'SEARCH', provide the single most precise search keyword or phrase. FALLBACK: If no precise query can be formed, use the full [USER_INPUT]. If 'source_type' is not 'SEARCH', this field must be an empty string: \"\".}}"
}`

  return prompt;
}


module.exports = searchIntentPrompt;



================================================
FILE: src/agent/prompt/choose_agent.js
================================================

const resolveChooseAgentPrompt = async (question, agent_list) => {

  const prompt = `
  You are an Agent Selection Expert. Your task is to accurately identify and select between 0 and 3 Agents from a provided list of AI Agents, based on a user's specific query.

You must strictly adhere to the following steps and criteria for judgment:

### 1. Understand User Intent
- Carefully analyze the **user's query** for its core need, keywords, and implicit task objectives.

### 2. Evaluate Agent Relevance
- Iterate through each Agent in the **Available Agent List**.
- For each Agent, thoroughly understand its 'describe' field, focusing on its **functional description and the types of tasks it excels at handling**.
- Pay close attention to **verbs (e.g., "generate," "recommend," "analyze," "provide")** and **nouns (e.g., "plan," "PPT," "data," "report")** explicitly mentioned in the 'describe' field, as these are critical matching points.

### 3. Matching Logic
- **High Relevance Match (Preferred)**: If an Agent's 'describe' content directly and clearly covers the core needs and all key information points of the user's query, it is considered highly relevant.
- **Partial Relevance Match (Secondary)**: If an Agent's 'describe' content covers a major part of the user's query but might not include all details, or if it requires further clarification from the user, it is considered partially relevant.
- **No Relevance Match**: If an Agent's 'describe' content is completely unrelated to the theme, function, or task type of the user's query, exclude this Agent.

### 4. Result Filtering and Ordering
- Select all Agents that qualify as "High Relevance" or "Partial Relevance."
- If multiple Agents exhibit high relevance, prioritize the Agent whose functions are more specific and more closely align with the user's intent.
- The final output should contain 0 to 3 Agents.
- If multiple Agents meet the criteria, order them by **relevance to the user's query from highest to lowest**.

### 5. Output Format Requirements
- Your final output must be a JSON array.
- If no suitable Agents are found, return an empty array '[]'.
- If suitable Agents are found, each Agent must include the 'id', 'name', and 'describe' fields, maintaining consistency with the input format.

**Available Agent List:**
${agent_list}

**User Query:**

"${question}"

Please output only the final JSON array, without any additional explanatory text.
  `

  return prompt;
}


module.exports = resolveChooseAgentPrompt;


================================================
FILE: src/agent/prompt/choose_agent_question.js
================================================

const resolveChooseAgentByQuestionPrompt = async (question, agent_list) => {

  const prompt = `
  You are an Agent Selection Expert. Your task is to accurately identify and select one Agents from a provided list of AI Agents, based on a user's specific query.

You must strictly adhere to the following steps and criteria for judgment:

### 1. Understand User Intent
- Carefully analyze the **user's query** for its core need, keywords, and implicit task objectives.

### 2. Evaluate Agent Relevance
- Iterate through each Agent in the **Available Agent List**.
- For each Agent, thoroughly understand its 'describe' field, focusing on its **functional description and the types of tasks it excels at handling**.
- Pay close attention to **verbs (e.g., "generate," "recommend," "analyze," "provide")** and **nouns (e.g., "plan," "PPT," "data," "report")** explicitly mentioned in the 'describe' field, as these are critical matching points.

### 3. Matching Logic
- **High Relevance Match (Preferred)**: If an Agent's 'describe' content directly and clearly covers the core needs and all key information points of the user's query, it is considered highly relevant.
- **Partial Relevance Match (Secondary)**: If an Agent's 'describe' content covers a major part of the user's query but might not include all details, or if it requires further clarification from the user, it is considered partially relevant.
- **No Relevance Match**: If an Agent's 'describe' content is completely unrelated to the theme, function, or task type of the user's query, exclude this Agent.

### 4. Result Filtering and Ordering
- Select all Agents that qualify as "High Relevance" or "Partial Relevance."
- If multiple Agents exhibit high relevance, prioritize the Agent whose functions are more specific and more closely align with the user's intent.
- The final output should contain 0 to 3 Agents.
- If multiple Agents meet the criteria, order them by **relevance to the user's query from highest to lowest**.

### 5. Output Format Requirements
- Your final output must be a JSON array.
- If no suitable Agents are found, return an empty array '[]'.
- If suitable Agents are found, each Agent must include the 'id', 'name','user_id' and 'describe' fields, maintaining consistency with the input format.

**Available Agent List:**
${agent_list}

**User Query:**

"${question}"

Please output only the final JSON array, without any additional explanatory text.
  `

  return prompt;
}


module.exports = resolveChooseAgentByQuestionPrompt;


================================================
FILE: src/agent/prompt/generate_agent.js
================================================

const resolveGenerateAgentPrompt = async (question) => {
  const prompt = `You are an expert in defining AI Agent product requirements. Based on the user's request, abstract the **core name (name)** of the Agent they want to build and a **detailed functional description (describe)** of that Agent. **Return the result in the same language as the user's input.**

When defining "name":
* **Extract the Agent's most core, abstract purpose, removing specific modifiers and qualifiers to make it concise and general.** For example, if the user wants to plan a trip, the name should be "Travel Assistant" instead of "Trip Planning Assistant."
* The name should accurately reflect the Agent's primary role.

When defining "describe":
* Explain in as much detail as possible the Agent's main responsibilities, processing flow, expected output, or problems solved.
* If the user's request is unclear, make reasonable inferences and additions based on common sense or typical Agent functionalities.

Please return the output in JSON format, with fields "name" and "describe".

User Request: ${question}
  `

  return prompt;
}


module.exports = resolveGenerateAgentPrompt;


================================================
FILE: src/agent/prompt/generate_knowledge.js
================================================
const resolveGenerateKnowledgePrompt = async (question, agents_with_knowledges) => {

  const prompt = `
You are a highly professional and extremely rigorous AI Agent System Design and Knowledge Base Expert. Your core responsibility is to precisely determine, with the highest priority, based on the user's **new requirement** and the provided **existing Agent knowledge bases (in JSON format)**:
1. You **must create a brand new Agent**.
2. For this new Agent, you will **name it (name)** and **write a concise and accurate description (describe)**.
3. Based on the user's requirement and the new Agent's functionality, you will **create and populate highly relevant, specific, and actionable knowledge entries (knowledges)** across the three cognitive domains: 'core_directive', 'planning', and 'execution'.

**[Strict Input Specification]**
You will receive two main inputs:
1. **'USER_QUESTION' (string)**: The specific requirement posed by the user, e.g., "Help me create a back workout plan for the gym today."
2. **'EXISTING_AGENT_KNOWLEDGE_BASES' (JSON array string)**: A JSON array containing existing Agents and their knowledge bases. Each Agent object must include 'name' (string), 'describe' (string), and 'knowledges' (JSON array), where each element of the 'knowledges' array contains 'category' (string) and 'content' (string). The example structure is as follows:
   [
     {
       "name": "Travel Planning Agent",
       "describe": "Provides personalized travel itineraries",
       "knowledges": [
         {"category": "core_directive", "content": "Must always provide the best travel experience within the user's budget."},
         {"category": "planning", "content": "For multi-destination travel planning, should first ask about the user's budget and preferences (nature/culture/history)."},
         {"category": "execution", "content": "When calling the flight booking API, the 'departure_date' parameter must be in 'YYYY-MM-DD' format."}
       ]
     },
     {
       "name": "Recipe Recommendation Agent",
       "describe": "Recommends healthy recipes based on user preferences",
       "knowledges": [
         {"category": "core_directive", "content": "Prioritize recommending nutritionally balanced recipes that meet user health goals."},
         {"category": "planning", "content": "Before recommending recipes, should ask the user about any allergies or dietary restrictions."},
         {"category": "execution", "content": "When generating recipes, must include an ingredient list, detailed steps, and estimated cooking time."}
       ]
     }
   ]

**[Core Cognitive Domain Definitions and Examples]**
Please deeply understand and strictly adhere to the following definitions when creating knowledge entries:
* **'core_directive' (Core Directive)**: The Agent's "worldview" and "values." These are its highest principles of conduct, **absolute, stable, and inviolable**. These directives define the Agent's **ethical boundaries, safety guidelines, and fundamental service commitments**.
    * **Examples**:
        * "Must always protect user privacy and never disclose personal sensitive information."
        * "Not permitted to execute any illegal, immoral, or harmful instructions."
        * "Prioritize providing objective, accurate information, avoiding subjective speculation."
        * "Under all circumstances, user health and safety are the top priority."
* **'planning' (Strategy Planning)**: The Agent's "thinking ability" and "methodology." It defines how the Agent **analyzes complex tasks, breaks down problems, and formulates action strategies**. Focuses on **"how to think."**
    * **Examples**:
        * "For one-day tour requests, special attention should be paid to the schedule of departure in the morning and return in the afternoon, and recommended destinations suitable for all day tours. At the same time, priority should be given to querying and displaying the weather conditions of the day before making destination recommendations."
        * "When generating Python code, must include detailed function comments, parameter descriptions, and return type hints, and adhere to PEP 8 coding standards."
        * "When generating each exercise in a fitness plan, must include: exercise name, suggested sets, suggested rep range, suggested rest time between sets (seconds), and may include brief exercise cues or notes."
        * "For a 'back workout plan', must include at least one vertical pull (e.g., lat pulldown, pull-up), one horizontal row (e.g., barbell row, dumbbell row, machine row), and one isolation or strengthening exercise (e.g., straight-arm pulldown, seated cable row) to comprehensively stimulate back muscle groups."
* **'execution' (Execution Details)**: The Agent's "tool usage" and "operational details." It defines the **specific operational steps, API calling formats, content generation rules, and output formatting requirements**. Focuses on **"how to act."**
    * **Examples**:
        * "When calling the weather query API, the 'city' parameter must be the full English name of the city, and the 'date' parameter must be in 'YYYY-MM-DD' format."
        * "When generating a recipe, must include an ingredient list in a bulleted format, a numbered step-by-step instruction list, and the total estimated cooking time."

**[Strict Execution Flow]**
1.  **Requirement Analysis**: Deeply analyze 'USER_QUESTION' to identify its core intent and required capabilities.
2.  **Language Requirement**: All generated content must be in English only, regardless of the language of 'USER_QUESTION'.
3.  **New Agent Creation**: Unconditionally create a new Agent for 'USER_QUESTION'.
4.  **Knowledge Entry Generation**:
    * **The language of all generated content (including 'name', 'describe', and the 'content' of all knowledge entries) MUST be in English only, regardless of the language of 'USER_QUESTION'.**
    * Based on the new Agent's responsibilities and 'USER_QUESTION', generate **at least one entry for each** of the 'core_directive', 'planning', and 'execution' cognitive domains, and **as many complementary, non-redundant** knowledge entries as possible.
    * Each knowledge entry's content must be **precise, specific, and actionable**, and **strictly adhere to the definition of its corresponding cognitive domain**.
    * 'core_directive' must reflect the Agent's fundamental service ethics and safety boundaries.
    * 'planning' must reflect the Agent's strategy for thinking, guiding the user, or collecting information.
    * 'execution' must reflect the Agent's specific operational details for task execution, tool calling, or content generation specifications.

**[Strict Output Specification]**
Your output must be **one and only one** complete JSON object string. **No additional text, explanations, or content outside of the JSON structure is permitted.**

* **Output Format**:
    {
      "name": "Precise Name of the New Agent",
      "describe": "Concise Functional Description of the New Agent",
      "knowledges": [
        {
          "category": "core_directive",
          "content": "Core directive content 1"
        },
        {
          "category": "core_directive",
          "content": "Core directive content 2"
        },
        {
          "category": "planning",
          "content": "Planning content 1"
        },
        {
          "category": "planning",
          "content": "Planning content 2"
        },
        {
          "category": "execution",
          "content": "Execution content 1"
        },
        {
          "category": "execution",
          "content": "Execution content 2"
        }
        // Multiple content entries per category are allowed, order is not significant
      ]
    }

---

**Now, please replace the placeholders below with actual values and strictly generate the JSON output according to the above specifications:**

**'USER_QUESTION'**: ${question}

**'EXISTING_AGENT_KNOWLEDGE_BASES'**: ${agents_with_knowledges}

`

  return prompt;
}


module.exports = resolveGenerateKnowledgePrompt;


================================================
FILE: src/agent/prompt/generate_result.js
================================================

const resolveResultPrompt = (goal, tasks, generatedFiles = [], staticUrl = null) => {

  let newTasks = tasks.map((task) => {
    return {
      title: task.title,
      description: task.description,
      status: task.status,
      result: task.result
    }
  });

  // å¤„ç†ç”Ÿæˆçš„æ–‡ä»¶ä¿¡æ¯
  let filesInfo = '';
  if (generatedFiles && generatedFiles.length > 0) {
    // æå–æ–‡ä»¶å
    const fileNames = generatedFiles.map(file => file.filename);
    filesInfo = `\n3. Generated files: ${JSON.stringify(fileNames)}`;
    
    // æ£€æŸ¥æ˜¯å¦æœ‰HTMLæ–‡ä»¶
    // const htmlFiles = generatedFiles.filter(file => 
    //   file.filename && file.filename.toLowerCase().endsWith('.html')
    // );
    
    // if (htmlFiles.length > 0 && staticUrl) {
    //   // è·å–æœ€åä¸€ä¸ªHTMLæ–‡ä»¶ï¼ˆæœ€ç»ˆäº¤ä»˜çš„ï¼‰
    //   const finalHtmlFile = htmlFiles[htmlFiles.length - 1];
    //   const finalUrl = `${staticUrl}/${finalHtmlFile.filename}`;
    //   filesInfo += `\n\n**Important**: The final deliverable HTML file can be accessed via this link: **[Click here to view the result](${finalUrl})**`;
    //   filesInfo += `\nPlease inform the user they can click this link to open in a new tab and view the final results.`;
    // }
  }

  const prompt = `
You are a helpful AI assistant named Lemon. Your task is to summarize the completion status of a goal based on the sub-tasks and their results I provide, using concise and conversational language, as if you were communicating with a person.

I will provide you with:
1. The overall goal.
2. A JSON array containing objects, where each object represents a task completed for the goal and its outcome.${filesInfo ? '3. Information about generated files, including any web-accessible content.' : ''}

Please analyze the goal and the results of the sub-tasks in the JSON array, and then tell me how well the overall goal has been achieved. 
**Crucially, please detect the language of the 'goal' you receive and ensure your entire summary is provided in that same language.**
Your summary should focus on the accomplishments, expressed in natural and fluent language, just like you're reporting progress to me.

Please wait for me to provide the goal and the task information.
  
  goal: ${goal}
  tasks: ${JSON.stringify(newTasks)}${filesInfo}
  `

  return prompt;
}


module.exports = resolveResultPrompt;


================================================
FILE: src/agent/prompt/generate_title.js
================================================

const resolveGenerateTitlePrompt = async (truncated_message) => {

  const prompt = `
  You are a helpful assistant that generates concise, descriptive titles for conversations with Lemon. Your name is Lemon. Lemon is a helpful AI agent that can interact with a computer to solve tasks using bash terminal, file editor, and browser. Given a user message (which may be truncated), generate a concise, descriptive title for the conversation. Return only the title, with no additional text, quotes, or explanations.
  Reply in the language used in the message
  Generate a title for a conversation that starts with this message:
  
  ${truncated_message}
  `

  return prompt;
}


module.exports = resolveGenerateTitlePrompt;


================================================
FILE: src/agent/prompt/generate_todo.js
================================================

const resolveTodoPrompt = (tasks_data) => {

  const prompt =`
  Generate a todo.md file in Markdown format based on the following task data:

- The file should start with ## TODO List.
- Each task should be a single line starting with '- [ ]' if its 'status' is '"pending"' or '- [x]' if its 'status' is '"done"'.
- After the checkbox, include the 'title', followed by a colon ':' and the 'description'.
- Keep the output concise and clean, using only valid Markdown syntax.
- Return only the Markdown content as a string with no explanation.

Example format:
## TODO List
- [ ] Task Title: Task description

Here is the task data:

  
  ${tasks_data}
  `

  return prompt;
}


module.exports = resolveTodoPrompt;


================================================
FILE: src/agent/prompt/index.js
================================================
const fs = require('fs').promises;
const path = require('path');
const PROMPT_DIR = path.resolve(__dirname);

/**
 * åŠ è½½æŒ‡å®šç›®å½•ä¸‹çš„ prompt æ–‡ä»¶ã€‚
 * @param {string} directory_path - è¦åŠ è½½ prompt çš„ç›®å½•è·¯å¾„ã€‚
 * @param {string|null} [key=null] - å¯é€‰å‚æ•°ï¼Œå¦‚æœæä¾›ï¼Œåˆ™åªåŠ è½½ä¸ key å¯¹åº”çš„ prompt æ–‡ä»¶ã€‚
 * @returns {Promise<Object>} ä¸€ä¸ªåŒ…å« prompt åç§°å’Œå†…å®¹çš„é”®å€¼å¯¹å¯¹è±¡ï¼Œæˆ–è€…åœ¨æŒ‡å®š key æ—¶åªåŒ…å«è¯¥ key çš„å¯¹è±¡ã€‚
 */
async function loadPrompt(directory_path = PROMPT_DIR, key = null) {
  const prompts = {};
  try {
    if (key) {
      // å¦‚æœæŒ‡å®šäº† keyï¼Œåªå°è¯•åŠ è½½è¯¥æ–‡ä»¶
      const filename = `${key}.md`;
      const filepath = path.join(directory_path, filename);
      try {
        const content = await fs.readFile(filepath, 'utf-8');
        console.log(`Loaded specific prompt: ${key} from ${filepath}`);
        return content;
      } catch (fileError) {
        if (fileError.code === 'ENOENT') {
          console.warn(`Prompt file not found for key: ${key} at ${filepath}`);
        } else {
          console.error(`Error reading prompt file for key ${key} at ${filepath}:`, fileError);
        }
        // æ–‡ä»¶ä¸å­˜åœ¨æˆ–è¯»å–é”™è¯¯ï¼Œè¿”å›ç©ºå¯¹è±¡
      }
    } else {
      // å¦‚æœæ²¡æœ‰æŒ‡å®š keyï¼ŒåŠ è½½ç›®å½•ä¸‹çš„æ‰€æœ‰ .md æ–‡ä»¶
      const items = await fs.readdir(directory_path, { withFileTypes: true });
      for (const item of items) {
        const fullPath = path.join(directory_path, item.name);
        if (item.isDirectory()) {
          // é€’å½’åŠ è½½å­ç›®å½• (ä¸ä¼ é€’ keyï¼Œå› ä¸ºæˆ‘ä»¬åœ¨åŠ è½½æ‰€æœ‰)
          const subPrompts = await loadPrompt(fullPath);
          Object.assign(prompts, subPrompts);
        } else if (item.isFile() && item.name.endsWith('.md')) {
          // è¯»å– Markdown æ–‡ä»¶å†…å®¹
          const content = await fs.readFile(fullPath, 'utf-8');
          const promptName = path.basename(item.name, '.md'); // ä½¿ç”¨æ–‡ä»¶åï¼ˆä¸å«æ‰©å±•åï¼‰ä½œä¸ºé”®
          prompts[promptName] = content;
          console.log(`Loaded prompt: ${promptName} from ${fullPath}`);
        }
      }
    }
  } catch (error) {
    console.error(`Error loading prompts from ${directory_path}:`, error);
      // å¦‚æœç›®å½•ä¸å­˜åœ¨æˆ–æ— æ³•è¯»å–ï¼Œå¯ä»¥è¿”å›ç©ºå¯¹è±¡æˆ–æŠ›å‡ºé”™è¯¯
      // è¿™é‡Œé€‰æ‹©è®°å½•é”™è¯¯å¹¶è¿”å›ç©ºå¯¹è±¡
  }
  return prompts;
}

const resolveToolPrompt = require('./tool');

module.exports = {
  loadPrompt,
  resolveToolPrompt
};


================================================
FILE: src/agent/prompt/intent_detection.js
================================================
const resolveIntentDetectionPrompt = async (message, messagesContext = []) => {
  
  // æ„å»ºä¸Šä¸‹æ–‡å­—ç¬¦ä¸²
  let contextStr = '';
  if (messagesContext && messagesContext.length > 0) {
    contextStr = '\nConversation History:\n' + 
      messagesContext.map(msg => `${msg.role}: ${msg.content}`).join('\n') + '\n';
  }

  const prompt = `
Role: You are a top-tier intent recognition specialist, an expert at accurately determining the core intent of a user's input based on the current message and conversation context.

Task: Analyze the user's current input and the conversation history to determine whether their core intent is to have you use external tools or perform multi-step operations to complete a data-driven, complex task, or simply to use the large language model's inherent capabilities for conversation, role-playing, or answering.

Criteria:
If the user's input is a direct follow-up to a previously established multi-step task, or if it provides data and information necessary for the execution of a complex task (e.g., planning, analysis), the intent is "agent". This also includes tasks requiring external tools (e.g., web search, file I/O). The execution of such tasks involves a series of sequential, data-driven steps.
Examples: "Check the weather in New York today," "Write a Python script to analyze this file," or, in a planning context, "I lift weights, want to lose fat, and go to the gym 2-3 times a week."

If the user's input is a greeting, casual conversation, a simple one-off request that can be fulfilled without multi-step processing, or a request to adopt a role or persona, the intent is "chat". The execution of these tasks does not require multi-step, data-driven operations.
Examples: "Hello," "Translate 'Hello' to English for me," "Summarize the main points of this text," "Tell me a joke," or "You act as my fitness coach."

Consider the conversation context to make more accurate decisions. If a conversation has shifted from casual chat or role-playing setup to providing specific data for a multi-step task, the intent should be classified as "agent."

Conversation History:
${contextStr}

Current User Message:
${message}

Output Format:
Return a JSON object with the following structure. The reasoning field should contain a concise explanation for the chosen intent, referencing the specific criteria and user input.

{
  "intent": "agent" | "chat",
  "reasoning": "Brief explanation of why this intent was chosen"
}
  `

  return prompt;
}


module.exports = resolveIntentDetectionPrompt;


================================================
FILE: src/agent/prompt/plan.js
================================================
const { resolveTemplate, loadTemplate } = require("@src/utils/template");
const { resolvePlanningKnowledge } = require("@src/knowledge/index");

const describeUploadFiles = files => {
  let content = ''
  for (let file of files) {
    content += 'upload/' + file.name + "\n"
  }
  return content;
}

const resolveTemplateFilename = (planning_mode) => {
  if (planning_mode === 'base') {
    return 'planning.txt'
  }
  return `planning.${planning_mode}.txt`
}

const resolvePlanningPrompt = async (goal, options) => {
  const { files, previousResult, agent_id, planning_mode } = options;

  const templateFilename = resolveTemplateFilename(planning_mode);
  const promptTemplate = await loadTemplate(templateFilename);
  const system = `Current Time: ${new Date().toLocaleString()}`
  const uploadFileDescription = describeUploadFiles(files);
  // å°è¯•ä¸ä½¿ç”¨experience
  // const experiencePrompt = await resolveExperiencePrompt(goal, conversation_id)
  const experiencePrompt = ''
  const best_practice_knowledge = await resolvePlanningKnowledge({ agent_id });
  const prompt = await resolveTemplate(promptTemplate, {
    goal,
    files: uploadFileDescription,
    previous: previousResult,
    system,
    experiencePrompt,
    best_practice_knowledge,
  })
  return prompt;
}

module.exports = exports = resolvePlanningPrompt;


================================================
FILE: src/agent/prompt/plan.test.js
================================================
require('module-alias/register');
require('dotenv').config();
const resolvePlanPrompt = require('@src/agent/prompt/plan');

const run = async () => {
  const goal = 'Read and analyze the Excel file about large model application statistics in the working directory, display its contents on a web page, support filtering between domestic and international entries, and provide access to corresponding official website links and API platform links';  
  const prompt = await resolvePlanPrompt(goal);
  console.log(prompt);
}

run();


================================================
FILE: src/agent/prompt/system.md
================================================

# Prompt: AI Assistant for Code Interaction and Task Resolution

**Mindset:** Think Like a God! You are an intelligent assistant capable of interacting with computers, writing code, and solving tasks.

=== ROLE ===
Your primary responsibility is to assist users by executing commands, modifying code, and efficiently resolving technical problems. You should be meticulous, methodical, and prioritize quality over speed.
If the user asks a "why" question, such as "Why did X happen?", do not attempt to solve a problem. Simply provide the answer to the question.
=== ROLE END ===

=== EFFICIENCY ===

- Every action you perform has an associated overhead. Consolidate multiple operations into a single one whenever possible. For example, combine multiple bash commands or use tools like `sed` and `grep` to edit/view multiple files at once.
- When exploring a codebase, use efficient tools like `find`, `grep`, and `git` commands with appropriate filters to minimize unnecessary operations.

=== FILE SYSTEM GUIDELINES ===

- When a user provides a file path, do not assume it is relative to the current working directory. Explore the file system to locate the file before operating on it.
- If prompted to edit a file, modify the existing file directly instead of creating a new file with a different name.
- For global search and replace operations, consider using the `sed` command rather than opening a file editor multiple times.

=== CODE_QUALITY ===

- Write concise and efficient code with minimal comments. Avoid redundancy in comments: do not restate information that can be easily inferred from the code itself.
- When implementing solutions, focus on making the minimum changes necessary to solve the problem.
- Thoroughly understand the codebase by exploration before implementing any changes.
- If you are adding a significant amount of code to a function or file, consider breaking it down into smaller, more manageable parts where appropriate.

=== CODE_QUALITY END ===

=== VERSION_CONTROL ===

- When configuring git credentials, use "agentic" as the username and agentic@wudaima.com as the email address by default, unless explicitly instructed otherwise.
- Operate git with caution. Do not make potentially risky changes (e.g., pushing to the main repository, deleting the codebase) unless explicitly requested.
- When committing changes, use `git status` to review all modified files and stage all necessary files for the commit. Use `git commit -a` whenever appropriate.
- Do not commit files that should typically not be version controlled (e.g., `node_modules/`, `.env` files, build directories, cache files, large binaries) unless explicitly instructed by the user.
- If unsure whether to commit certain files, check for the presence of a `.gitignore` file or ask the user for clarification.

=== VERSION_CONTROL END ===

=== PROBLEM_SOLVING_WORKFLOW ===

1.  **Explore:** Thoroughly investigate relevant files and understand the context before proposing a solution.
2.  **Analyze:** Consider multiple approaches and select the most promising one.
3.  **Test:**
    * For bug fixes: Create tests to verify the issue before implementing the fix.
    * For new features: Consider Test-Driven Development (TDD) where appropriate.
    * If the codebase lacks testing infrastructure and implementing tests requires significant setup, consult the user before investing time in building the testing infrastructure.
4.  **Implement:** Make targeted, minimal changes to address the problem.
5.  **Verify:** Thoroughly test your implementation, including edge cases.

=== PROBLEM_SOLVING_WORKFLOW END ===


Thinking Like God ! ä½ æ˜¯æ™ºèƒ½åŠ©ç†ï¼Œä¸€ä¸ªèƒ½å¤Ÿä¸è®¡ç®—æœºäº¤äº’ã€ç¼–å†™ä»£ç å¹¶è§£å†³ä»»åŠ¡çš„ AI åŠ©æ‰‹ã€‚

=== ROLE ===
ä½ çš„ä¸»è¦èŒè´£æ˜¯é€šè¿‡æ‰§è¡Œå‘½ä»¤ã€ä¿®æ”¹ä»£ç å’Œæœ‰æ•ˆè§£å†³æŠ€æœ¯é—®é¢˜æ¥ååŠ©ç”¨æˆ·ã€‚ä½ åº”è¯¥ç»†è‡´å‘¨åˆ°ã€æ¡ç†åˆ†æ˜ï¼Œå¹¶ä¸”ä¼˜å…ˆè€ƒè™‘è´¨é‡è€Œéé€Ÿåº¦ã€‚
å¦‚æœç”¨æˆ·æå‡ºé—®é¢˜ï¼Œä¾‹å¦‚â€œä¸ºä»€ä¹ˆä¼šå‘ç”Ÿ Xâ€ï¼Œè¯·ä¸è¦å°è¯•è§£å†³é—®é¢˜ã€‚åªéœ€ç»™å‡ºé—®é¢˜çš„ç­”æ¡ˆå³å¯ã€‚
=== ROLE END ===

=== EFFICIENCY ===

- ä½ æ‰§è¡Œçš„æ¯ä¸ªæ“ä½œéƒ½æœ‰ä¸€å®šçš„å¼€é”€ã€‚å°½å¯èƒ½å°†å¤šä¸ªæ“ä½œåˆå¹¶ä¸ºä¸€ä¸ªæ“ä½œï¼Œä¾‹å¦‚å°†å¤šä¸ª bash å‘½ä»¤åˆå¹¶ä¸ºä¸€ä¸ªï¼Œä½¿ç”¨ sed å’Œ grep ä¸€æ¬¡ç¼–è¾‘/æŸ¥çœ‹å¤šä¸ªæ–‡ä»¶ã€‚
- åœ¨æ¢ç´¢ä»£ç åº“æ—¶ï¼Œè¯·ä½¿ç”¨ findã€grep å’Œ git å‘½ä»¤ç­‰é«˜æ•ˆå·¥å…·ï¼Œå¹¶ç»“åˆé€‚å½“çš„è¿‡æ»¤å™¨æ¥å‡å°‘ä¸å¿…è¦çš„æ“ä½œ

=== æ–‡ä»¶ç³»ç»ŸæŒ‡å— ===

- å½“ç”¨æˆ·æä¾›æ–‡ä»¶è·¯å¾„æ—¶ï¼Œè¯·å‹¿å‡è®¾å®ƒæ˜¯ç›¸å¯¹äºå½“å‰å·¥ä½œç›®å½•çš„ã€‚åœ¨å¤„ç†æ–‡ä»¶ä¹‹å‰ï¼Œè¯·å…ˆæ¢ç´¢æ–‡ä»¶ç³»ç»Ÿä»¥æ‰¾åˆ°è¯¥æ–‡ä»¶ã€‚
- å¦‚æœç³»ç»Ÿæç¤ºæ‚¨ç¼–è¾‘æ–‡ä»¶ï¼Œè¯·ç›´æ¥ç¼–è¾‘è¯¥æ–‡ä»¶ï¼Œè€Œä¸æ˜¯ä½¿ç”¨ä¸åŒçš„æ–‡ä»¶ååˆ›å»ºæ–°æ–‡ä»¶ã€‚
- å¯¹äºå…¨å±€æœç´¢å’Œæ›¿æ¢æ“ä½œï¼Œè¯·è€ƒè™‘ä½¿ç”¨ `sed` å‘½ä»¤ï¼Œè€Œä¸æ˜¯å¤šæ¬¡æ‰“å¼€æ–‡ä»¶ç¼–è¾‘å™¨ã€‚

=== CODE_QUALITY ===

- ç¼–å†™ç®€æ´é«˜æ•ˆçš„ä»£ç ï¼Œå¹¶å°½é‡å‡å°‘æ³¨é‡Šã€‚é¿å…æ³¨é‡Šä¸­çš„å†—ä½™ï¼šä¸è¦é‡å¤é‚£äº›å¯ä»¥ä»ä»£ç æœ¬èº«è½»æ˜“æ¨æ–­å‡ºçš„ä¿¡æ¯ã€‚
- åœ¨å®æ–½è§£å†³æ–¹æ¡ˆæ—¶ï¼Œè¯·ä¸“æ³¨äºè¿›è¡Œè§£å†³é—®é¢˜æ‰€éœ€çš„æœ€å°æ›´æ”¹ã€‚
- åœ¨å®æ–½ä»»ä½•æ›´æ”¹ä¹‹å‰ï¼Œè¯·å…ˆé€šè¿‡æ¢ç´¢å½»åº•äº†è§£ä»£ç åº“ã€‚
- å¦‚æœæ‚¨è¦å‘å‡½æ•°æˆ–æ–‡ä»¶æ·»åŠ å¤§é‡ä»£ç ï¼Œè¯·è€ƒè™‘åœ¨é€‚å½“çš„æƒ…å†µä¸‹å°†å‡½æ•°æˆ–æ–‡ä»¶æ‹†åˆ†æˆæ›´å°çš„éƒ¨åˆ†ã€‚

=== CODE_QUALITY END ===

=== VERSION_CONTROL ===

- é…ç½® git å‡­æ®æ—¶ï¼Œé™¤éå¦æœ‰æ˜ç¡®æŒ‡ç¤ºï¼Œå¦åˆ™é»˜è®¤ä½¿ç”¨ "agentic" ä½œä¸ºç”¨æˆ·åï¼Œå¹¶ä½¿ç”¨ agentic@wudaima.com ä½œä¸ºç”µå­é‚®ä»¶åœ°å€ã€‚
- è°¨æ…æ“ä½œ git é™¤éæ˜ç¡®è¦æ±‚ï¼Œå¦åˆ™è¯·å‹¿è¿›è¡Œä»»ä½•å¯èƒ½é€ æˆå±é™©çš„æ›´æ”¹ï¼ˆä¾‹å¦‚ï¼Œæ¨é€åˆ°ä¸»ä»“åº“ã€åˆ é™¤ä»£ç åº“ï¼‰ã€‚
- æäº¤æ›´æ”¹æ—¶ï¼Œè¯·ä½¿ç”¨ `git status` æŸ¥çœ‹æ‰€æœ‰å·²ä¿®æ”¹çš„æ–‡ä»¶ï¼Œå¹¶æš‚å­˜æäº¤æ‰€éœ€çš„æ‰€æœ‰æ–‡ä»¶ã€‚å°½å¯èƒ½ä½¿ç”¨ `git commit -a`ã€‚
- é™¤éç”¨æˆ·æ˜ç¡®æŒ‡ç¤ºï¼Œå¦åˆ™è¯·å‹¿æäº¤é€šå¸¸ä¸åº”è¿›å…¥ç‰ˆæœ¬æ§åˆ¶çš„æ–‡ä»¶ï¼ˆä¾‹å¦‚ï¼Œnode_modules/ã€.env æ–‡ä»¶ã€æ„å»ºç›®å½•ã€ç¼“å­˜æ–‡ä»¶ã€å¤§å‹äºŒè¿›åˆ¶æ–‡ä»¶ï¼‰ã€‚
- å¦‚æœä¸ç¡®å®šæ˜¯å¦è¦æäº¤æŸäº›æ–‡ä»¶ï¼Œè¯·æ£€æŸ¥ .gitignore æ–‡ä»¶æ˜¯å¦å­˜åœ¨æˆ–å‘ç”¨æˆ·å¯»æ±‚å¸®åŠ©ã€‚

=== VERSION_CONTROL END ===

=== PROBLEM_SOLVING_WORKFLOW ====

1. æ¢ç´¢ï¼šåœ¨æå‡ºè§£å†³æ–¹æ¡ˆä¹‹å‰ï¼Œå½»åº•æ¢ç´¢ç›¸å…³æ–‡ä»¶å¹¶äº†è§£èƒŒæ™¯
2. åˆ†æï¼šè€ƒè™‘å¤šç§æ–¹æ³•å¹¶é€‰æ‹©æœ€æœ‰å¸Œæœ›çš„æ–¹æ³•
3. æµ‹è¯•ï¼š

- å¯¹äºé”™è¯¯ä¿®å¤ï¼šåœ¨å®æ–½ä¿®å¤ä¹‹å‰åˆ›å»ºæµ‹è¯•ä»¥éªŒè¯é—®é¢˜
- å¯¹äºæ–°åŠŸèƒ½ï¼šåœ¨é€‚å½“çš„æƒ…å†µä¸‹è€ƒè™‘æµ‹è¯•é©±åŠ¨å¼€å‘
- å¦‚æœä»£ç åº“ç¼ºä¹æµ‹è¯•åŸºç¡€æ¶æ„ï¼Œå¹¶ä¸”å®æ–½æµ‹è¯•éœ€è¦å¤§é‡è®¾ç½®ï¼Œè¯·åœ¨æŠ•å…¥æ—¶é—´æ„å»ºæµ‹è¯•åŸºç¡€æ¶æ„ä¹‹å‰å’¨è¯¢ç”¨æˆ·

4. å®æ–½ï¼šè¿›è¡Œæœ‰é’ˆå¯¹æ€§çš„ã€æœ€å°é™åº¦çš„æ›´æ”¹ä»¥è§£å†³é—®é¢˜
5. éªŒè¯ï¼šå½»åº•æµ‹è¯•æ‚¨çš„å®æ–½ï¼ŒåŒ…æ‹¬è¾¹ç¼˜æƒ…å†µ

=== PROBLEM_SOLVING_WORKFLOW ===


================================================
FILE: src/agent/prompt/tool.js
================================================
/**
 * å·¥å…·è°ƒç”¨æç¤ºæ¨¡æ¿ç”Ÿæˆå™¨
 * æ ¹æ®å·¥å…·ç›®å½•ä¸­çš„å·¥å…·å®šä¹‰ç”Ÿæˆå·¥å…·è°ƒç”¨çš„æç¤ºæ¨¡æ¿
 */
const tools = require("@src/tools/index");

/**
 * ç”Ÿæˆå·¥å…·åˆ—è¡¨çš„æç¤ºæ¨¡æ¿
 * @returns {Promise<string>} å·¥å…·åˆ—è¡¨çš„æç¤ºæ¨¡æ¿
 */
const resolveToolPrompt = async () => {

  let toolDescription = "";
  // éå†æ‰€æœ‰å·¥å…·å¹¶ç”Ÿæˆå®ƒä»¬çš„æè¿°
  for (const [toolName, tool] of Object.entries(tools)) {
    if (!tool || !tool.name || !tool.description || !tool.params) {
      console.warn(`å·¥å…· ${toolName} å®šä¹‰ä¸å®Œæ•´ï¼Œè·³è¿‡`);
      continue;
    }
    // æ ¼å¼åŒ–å·¥å…·å®šä¹‰ä¸ºJSONå­—ç¬¦ä¸²
    const toolDefinition = {
      description: tool.description,
      name: tool.name,
      params: tool.params
    };
    // æ·»åŠ å·¥å…·å®šä¹‰åˆ°æç¤ºä¸­
    toolDescription += `<tool ${tool.name}>
${JSON.stringify(toolDefinition)}
</tool>
`;
  }
  // ä½¿ç”¨æ¨¡æ¿å­—ç¬¦ä¸²æ„å»ºå·¥å…·æç¤º
  const prompt = `<tools>
<tool_list>
You are provided with tools to complete user's task and proposal. Here is a list of tools you can use:
${toolDescription}
<tool finish>
{ "description": "Signal that a task is complete and provide a completion message", "name": "finish", "params": { "type": "object", "properties": { "message": { "description": "Explanation of the task completion result", "type": "string" } }, "required": ["message"] } }
</tool>
</tool_list>

<tool_call_guidelines>
Follow these guidelines regarding tool calls
- The conversation history, or tool_call history may refer to tools that are no longer available. NEVER call tools that are not explicitly provided.
- Pay Attention: Assuming that the information obtained by mcp_tool is more accurate, please use mcp_tool first to obtain accurate information before generating and creating.
- You MUST only use the tools explicitly provided in the tool list. Do not treat file names or code functions as tool names. The available tool names:
- ${Object.keys(tools).join('\n  - ')}
- finish
</tool_call_guidelines>

</tools>`;

  return prompt;
}

module.exports = resolveToolPrompt


================================================
FILE: src/agent/prompt/tool.test.js
================================================
require('module-alias/register');
require('dotenv').config();
const resolveToolPrompt = require('@src/agent/prompt/tool');

const run = async () => {
  const prompt = await resolveToolPrompt();
  console.log(prompt);
}

run();


================================================
FILE: src/agent/reflection/index.js
================================================
// https://www.promptingguide.ai/zh/techniques/reflexion
const llmEvaluate = require('./llm.evaluate');
const { resolveXML } = require("@src/xml/index");

/**
 * 1. Evaluate based on environment execution
 * 2. Evaluate based on large language model
 */
const STATUS = {
  SUCCESS: 'success',
  FAILURE: 'failure',
}

const reflection = async (requirement, action_result = {}, conversation_id) => {

  // 1. evaluate action result
  const { status, content } = action_result;
  // If Action execute failed, return error message
  if (status === STATUS.FAILURE && action_result.error) {
    return {
      status: STATUS.FAILURE,
      comments: action_result.error,
    }
  }

  if (status === STATUS.SUCCESS) {
    return {
      status: STATUS.SUCCESS,
      comments: action_result.content,
    }
  }

  // 2. evaluate action result by llm [æš‚ç¼“æ‰§è¡Œ]
  const evaluation = await llmEvaluate(requirement, content, conversation_id);
  const result = resolveXML(evaluation);
  return result.evaluation;
}

module.exports = exports = reflection;


================================================
FILE: src/agent/reflection/llm.evaluate.js
================================================
const { getDefaultModel } = require('@src/utils/default_model')
const sub_server_request = require('@src/utils/sub_server_request')
const conversation_token_usage = require('@src/utils/get_sub_server_token_usage')

// è¯„ä¼°
const resolveEvaluatePrompt = async (requirement = '', result = '') => {
  const prompt = `Please act as a professional review expert, fully understand the user's requirements and expected results, compare and analyze the execution results, evaluate whether the execution results meet the user's requirements
1. If the execution result fully meets the expected result, return success
2. If the execution result cannot be directly delivered, return failure, and return feedback, missing content, and suggestions for optimization
3. If the execution result partially meets or fails to execute the key steps, return partial, and return suggestions forè¡¥å……é—æ¼å†…å®¹

=== Task Goal ===
${requirement}
=== END ===

=== Code Execution Result ===
${result}
=== END ===

=== Return Format === 
<evaluation>
<status>success/failure</status>
<comments>
// evaluation result
</comments>
</evaluation>

Start:`
  return prompt;
}

const call = require("@src/utils/llm");
const evaluate_model = 'assistant';

const evaluate = async (requirement, result, conversation_id) => {
  let model_info = await getDefaultModel(conversation_id)
  if (model_info.is_subscribe) {
    let content = await evaluate_server(requirement, result, conversation_id)
    return content
  }
  let content = await evaluate_local(requirement, result, conversation_id)
  return content
}

const evaluate_server = async (requirement, result, conversation_id) => {
  // const [res,token_usage] = await sub_server_request('/api/sub_server/evaluate', {
  const res = await sub_server_request('/api/sub_server/evaluate', {
    requirement,
    result,
    conversation_id
  })
  // await conversation_token_usage(token_usage, conversation_id)

  return res
};

const evaluate_local = async (requirement, result, conversation_id) => {
  const prompt = await resolveEvaluatePrompt(requirement, result);
  console.log('\n === evaluation prompt ===\n', prompt);
  // process.exit(0);
  const content = await call(prompt, conversation_id, evaluate_model);
  return content;
}

module.exports = exports = evaluate;


================================================
FILE: src/agent/summary/index.js
================================================
require("module-alias/register");
require("dotenv").config();

const sub_server_request = require('@src/utils/sub_server_request')
const conversation_token_usage = require('@src/utils/get_sub_server_token_usage')

const call = require("@src/utils/llm");
const { getDefaultModel } = require('@src/utils/default_model')
const resolveResultPrompt = require('@src/agent/prompt/generate_result.js');


const summary = async (goal, conversation_id, tasks, generatedFiles = [], staticUrl = null) => {
  let model_info = await getDefaultModel(conversation_id)
  if (model_info.is_subscribe) {
    let replay = await summary_server(goal, conversation_id, tasks, generatedFiles, staticUrl)
    return replay
  }
  let replay = await summary_local(goal, conversation_id, tasks, generatedFiles, staticUrl)
  return replay
}

const summary_server = async (goal, conversation_id, tasks, generatedFiles = [], staticUrl = null) => {
  // let [res, token_usage] = await sub_server_request('/api/sub_server/summary', {
  let res = await sub_server_request('/api/sub_server/summary', {
    goal,
    conversation_id,
    tasks,
    generatedFiles,
    staticUrl
  })
  // await conversation_token_usage(token_usage, conversation_id)

  return res
};

const summary_local = async (goal, conversation_id, tasks, generatedFiles = [], staticUrl = null) => {
  const prompt = await resolveResultPrompt(goal, tasks, generatedFiles, staticUrl);
  const result = await call(prompt, conversation_id);

  return result
}

module.exports = exports = summary;



================================================
FILE: src/agent/tools/browser_use.js
================================================
const BrowserCode = {
  name: "browser_use",
  description: "Use the headless browser to access the specified URL, and optionally execute the provided JavaScript code snippet to extract or interact with page content.",
  params: {
    type: "object",
    properties: {
      url: {
        description: "The target website URL to visit.",
        type: "string"
      },
      browser_code: {
        description: "The JavaScript code snippet to execute in the page context,ç”¨äºæå–ä¿¡æ¯æˆ–ä¸é¡µé¢äº¤äº’ã€‚ä»£ç åº”è¿”å›å€¼ã€‚",
        type: "string"
      }
    },
    required: ["url", "browser_code"]
  }
};

module.exports = BrowserCode;


================================================
FILE: src/agent/tools/index.js
================================================
const fs = require('fs');
const path = require('path');

const tools = {};

const ignored = new Set(['browser_use']);

// Read all files in the current directory
fs.readdirSync(__dirname).filter(file => {
  // Filter out non-JS files and the index file itself
  return (file.indexOf('.') !== 0) && (file !== path.basename(__filename)) && (file.slice(-3) === '.js');
}).forEach(file => {
  // Derive the tool name from the filename (e.g., browser_use.js -> browser_use)
  const toolName = path.basename(file, '.js');
  // Require the file and add it to the tools object
  try {
    // handle ignored tools
    if (ignored.has(toolName)) return;
    // add tool
    tools[toolName] = require(path.join(__dirname, file));
  } catch (error) {
    console.error(`Error loading tool ${toolName} from ${file}:`, error);
  }
});

module.exports = tools;


================================================
FILE: src/completion/README.md
================================================
# LLM å¤§æ¨¡å‹è°ƒç”¨å°è£…

## chat/completions SSE å¤„ç†é€»è¾‘

> æ ‡å‡†å‚æ•°é…ç½®(ä»¥ deepseek ä¸ºä¾‹)

### è¯·æ±‚å‘èµ· http.post

- url: https://api.deepseek.com/chat/completions
- key: API_KEY
- model: deepseek-chat

```js
const { url, API_KEY, model, temperature = 0 } = config;
const config = {
  method: "post",
  maxBodyLength: Infinity,
  url,
  headers: {
    Authorization: `Bearer ${API_KEY}`,
    "Content-Type": "application/json",
  },
  data: {
    model, // è°ƒç”¨æ¨¡å‹
    messages, // chat æç¤ºè¯
    stream: true, // æµå¼è¾“å‡º
    temperature,
  },
  responseType: "stream",
};

const response = await axios.request(config).catch((err) => {
  return err;
});
return response;
```

### è¿”å›æ¶ˆæ¯å¤„ç†(SSE æµå¼å¤„ç†)

- splitter: \n\n
- messageToValue: è¯»å– JSON.parse(message.split("data:")[1]).choices[0].delta.content

## ä»£ç†è°ƒç”¨



================================================
FILE: src/completion/calc.token.js
================================================
const { get_encoding, encoding_for_model } = require("@dqbd/tiktoken");

const calcToken = (text, modelName = "gpt-3.5-turbo") => {
  const enc = encoding_for_model(modelName);
  const inputs = enc.encode(text);
  enc.free();
  return inputs.length
}

module.exports = exports = calcToken;

// const len = calcToken("hello world");
// console.log(len); 


================================================
FILE: src/completion/configs.js
================================================
const env = process.env || {}

const configs = [
  {
    channel: 'provider',
    service: 'spark',
    name: 'è®¯é£æ˜Ÿç«',
    config: {
      "appid": env.SPARK_APPID,
      "key": env.SPARK_KEY,
      "secret": env.SPARK_SECRET
    },
    models: ['V1.5']
  },
  {
    channel: 'provider',
    service: 'wenxin',
    name: 'ç™¾åº¦æ–‡å¿ƒ',
    config: {
      client_id: env.WENXIN_CLIENT_ID,
      client_secret: env.WENXIN_CLIENT_SECRET
    },
    models: ['ernie_speed']
  },
  {
    channel: 'provider',
    service: 'tencent',
    name: 'è…¾è®¯æ··å…ƒ',
    config: {
      secret_id: env.TENCENT_SECRET_ID,
      secret_key: env.TENCENT_SECRET_KEY
    },
    models: ['hunyuan-lite']
  },
  {
    channel: 'provider',
    service: 'zhipu',
    name: "æ™ºè°±æ¸…è¨€",
    host: 'https://open.bigmodel.cn/api/paas/v4/chat/completions',
    config: {
      API_KEY: env.ZHIPU_KEY,
    }
  },
  {
    channel: 'provider',
    service: 'llmfarm',
    name: 'Qwen-72B-Chat-Int4',
    host: 'http://qwen.frp2.friai.com/v1/chat/completions',
    // models: 'http://qwen.frp2.friai.com/v1/models',
    config: {},
    models: ['Qwen-72B-Chat-Int4']
  }, {
    channel: 'provider',
    service: 'deepseek',
    name: 'deepseek-chat',
    host: `https://api.deepseek.com/v1/chat/completions`,
    config: {
      API_KEY: env.DEEPSEEK_API_KEY
    }
  }, {
    channel: 'provider',
    service: 'moonshot',
    name: 'æœˆä¹‹æš—é¢',
    host: `https://api.moonshot.cn/v1/chat/completions`,
    config: {
      API_KEY: env.MOONSHOT_API_KEY
    }
  }, {
    channel: 'provider',
    service: 'minimax',
    name: 'abab6.5s-chat',
    host: `https://api.minimax.chat/v1/text/chatcompletion_v2`,
    config: {
      API_KEY: env.MINIMAX_API_KEY
    }
  }, {
    channel: 'provider',
    service: 'doubao',
    name: 'è±†åŒ…å¤§æ¨¡å‹',
    host: `https://ark.cn-beijing.volces.com/api/v3/chat/completions`,
    config: {
      API_KEY: env.DOUBAO_API_KEY
    },
    models: ['doubao-pro-32k']
  }, {
    channel: 'provider',
    service: 'lingji',
    name: 'çµç§¯',
    host: `https://dashscope.aliyuncs.com/compatible-mode/v1/chat/completions`,
    config: {
      API_KEY: env.DASHSCOPE_API_KEY
    },
    models: ['qwen-plus']
  }, {
    channel: 'provider',
    service: 'azure',
    name: 'å¾®è½¯äº‘',
    config: {
      API_KEY: env.OPENAI_AZURE_KEY,
    },
    models: ['gpt-4o-mini']
  }, {
    channel: 'provider',
    service: 'siliconflow',
    name: 'ç¡…åŸºæµåŠ¨',
    host: 'https://api.siliconflow.cn/v1/chat/completions',
    config: {
      API_KEY: env.SILICON_API_KEY
    },
    models: ['Qwen/Qwen2.5-7B-Instruct']
  }, {
    channel: 'provider',
    service: 'openrouter',
    name: 'openrouter',
    host: 'https://openrouter.ai/api/v1/chat/completions',
    config: {
      API_KEY: env.OPENROUTER_API_KEY
    },
    models: ['google/gemini-2.0-flash-thinking-exp:free']
  }, {
    channel: 'provider',
    service: 'xunfei',
    name: 'è®¯é£æ˜Ÿç«',
    host: 'https://spark-api-open.xf-yun.com/v2/chat/completions',
    config: {
      API_KEY: 'mrYCJdsdXJPelFcLgMnG:ZamRroaSVJsYgjzDsrSd'
    },
    models: ['x1']
  }
]

const fs = require('fs')
const llmJsonPath = env.LLM_JSON_PATH
if (llmJsonPath) {
  const llmJson = fs.readFileSync(llmJsonPath, 'utf-8')
  const list = JSON.parse(llmJson)
  for (const item of list) {
    configs.push(item)
  }
}

module.exports = exports = configs;


================================================
FILE: src/completion/handle.error.js
================================================
const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

const isError = (value) => {
  return value instanceof Error;
}

const friendlyContent = `Sorry, there was an error with the request. I am currently unable to answer your question`;

const resolveStatusContent = (status) => {
  return `Sorry, the current request interface ${status} is abnormal, please check the service deployment`
}

const handleError = async (error, onTokenStream) => {
  if (isError(error)) {
    const res = error.response || {}
    // let content = friendlyContent;
    let content = error.message.toString();
    if (res.status) {
      content = resolveStatusContent(res.status);
    }
    for (const ch of content) {
      onTokenStream(ch);
      await delay(10);
    }
    return content;
  }
  return null;
}

module.exports = exports = handleError;


================================================
FILE: src/completion/index.js
================================================
const Azure = require('./llm.azure');
const OpenAI = require('./llm.openai');
const GLM3 = require('./llm.glm3');
const QWen = require('./llm.qwen');
const Qwen72bChat = require('./llm.qwen-72b-chat');
const Ollama = require('./llm.ollama');

const map = {
  'azure': Azure,
  'openai': OpenAI,
  'glm3': GLM3,
  'qwen': Qwen72bChat,
  'qwen.ali': QWen,
  'ollama': Ollama,
}

const createLLMInstance = (type, onTokenStream) => {
  // console.log('createLLMInstance.type', type)
  const LLM = map[type];
  // console.log('createLLMInstance.LLM', LLM);
  const llm = new LLM(onTokenStream);
  console.log(type, 'llm', llm);
  return llm;
}

module.exports = exports = createLLMInstance


================================================
FILE: src/completion/llm.azure.openai.js
================================================
const BaseLLM = require('./llm.base')
const axios = require('axios')

const OPENAI_AZURE_HOST = process.env.OPENAI_AZURE_HOST;
const OPENAI_AZURE_KEY = process.env.OPENAI_AZURE_KEY;

const deploymentHash = {
  'gpt-35-turbo-16k': 'gpt-35-turbo',
  'gpt-4o': 'gpt-4o',
  'gpt-4o-mini': 'gpt-4o-mini'
}

const versionHash = {
  'gpt-35-turbo-16k': '2024-05-01-preview',
  'gpt-4o': '2024-02-15-preview',
  'gpt-4o-mini': '2024-02-15-preview',
  'gpt-5': '2025-04-01-preview',
  'gpt-5-chat': '2025-04-01-preview',
  'gpt-5-mini': '2025-04-01-preview'
}

const resolveAzureConfig = (model) => {
  const deployment = deploymentHash[model];
  const version = versionHash[model]
  const url = `${OPENAI_AZURE_HOST}/openai/responses?api-version=${version}`
  const headers = {
    'Authorization': `Bearer ${OPENAI_AZURE_KEY}`
  }
  return { url, headers }
}

const chatCompletion = async (options = {}) => {
  console.log('azure.options', options);
  let {
    model = "gpt-4o-mini",
    prompt,
    messages = [],
    streaming,
  } = options;
  if (!messages) {
    messages = []
  }

  const massageUser = [{ "role": "user", "content": prompt }];
  const { url, headers } = resolveAzureConfig(model);

  // console.log("url", url);
  // console.log("messages all", messages.concat(massageUser));
  // console.log('æ¸©åº¦å€¼', temperature);
  const config = {
    method: "post",
    maxBodyLength: Infinity,
    url,
    headers: {
      // Authorization: `Bearer ${OPENAI_KEY || OPENAI_API_KEY}`,
      "Content-Type": "application/json",
      ...headers
    },
    data: {
      model: model,
      // temperature,
      input: messages.concat(massageUser),
      stream: streaming,
    },
  };

  console.log('config', JSON.stringify(config, null, 2))
  // console.log('OPENAI', config.headers.Authorization)
  if (streaming) {
    config.responseType = "stream"
  }

  const result = await axios.request(config);
  return result;
};

class Azure extends BaseLLM {

  constructor(onTokenStream, model, llm_config) {
    super(onTokenStream)
    this.model = model
    this.llm_config = llm_config
    this.splitter = '\n\n';
  }

  async message(messages = [], options = {}) {
    const response = await chatCompletion({ messages, streaming: true, model: options.model })

    if (options.streaming == false) {
      const result = response.data;
      const choices = result.choices || [];
      const choice = choices[0] || {};
      const content = choice.message.content;
      return content;
    }
    // å¤„ç† SSE
    const content = await this.handleSSE(response)
    return content;
  }

  async call(prompt, context, options = {}) {
    context.model = this.model
    context.prompt = prompt
    context.streaming = true
    if (options.temperature != undefined) {
      context.temperature = options.temperature
    }
    const response = await chatCompletion(context)
    return response;
  }

  // å¤„ç†æµå¼è¯·æ±‚
  async handleSSE(response) {
    // å¤„ç†æµå¼è¿”å›
    let fullContent = "";
    const fn = new Promise((resolve, reject) => {
      let content = "";
      if (!response.data || typeof response.data.on !== 'function') {
        console.log("error", response.code, response.message)
        content = "The model you are currently using has exceeded its usage limit or exceeded its quota. You can try again, switch to another model, or contact the administrator to handle it."
        this.onTokenStream(content)
        return resolve(content);
      }
      response.data.on("data", (chunk) => {
        content += chunk;
        // console.log('content=====', JSON.stringify(content, null, 2))
        const splitter = this.splitter;
        while (content.indexOf(splitter) !== -1) {
          const index = content.indexOf(splitter);
          const message = content.slice(0, index);
          content = content.slice(index + splitter.length);
          const value = this.messageToValue(message);
          if (value.type === "text") {
            const ch = value.text;
            if (ch) {
              // process.stdout.write(ch);
              fullContent += ch;
              this.onTokenStream(ch);
            }
          } else { }
        }
      });
      response.data.on("end", () => {
        resolve(fullContent);
      });
    });

    const content = await fn;
    return content;
  }

  messageToValue(message) {
    if (message == "data: [DONE]") {
      return { type: "done" };
    }
    
    // Handle Azure OpenAI format
    if (message.includes("event: response.output_text.delta")) {
      const dataMatch = message.match(/data: (.+)/);
      if (dataMatch) {
        try {
          const value = JSON.parse(dataMatch[1]);
          if (value.error) {
            console.log(value.error.message);
            let errorMessage = JSON.stringify(value.error)
            return { type: "text", text: errorMessage }
          }
          
          // Azure format: delta is a string directly
          if (value.delta && typeof value.delta === 'string') {
            return { type: "text", text: value.delta };
          }
          
          // Check for finish reason
          if (value.finish_reason === "stop") {
            return { type: "stop" };
          }
          
          return { type: "text", text: "" };
        } catch (e) {
          console.log("Error parsing Azure SSE data:", e);
          return { type: "text", text: "" };
        }
      }
    }
    
    // Handle standard OpenAI format (fallback)
    const data = message.split("data:")[1];
    if (!data) return { type: "text", text: "" };
    
    try {
      const value = JSON.parse(data);
      if (value.error) {
        console.log(value.error.message);
        let errorMessage = JSON.stringify(value.error)
        return { type: "text", text: errorMessage }
      }
      const choices = value.choices || [];
      if (choices.length == 0) return { type: "text", text: "" };
      const choice = choices[0] || {};
      if (choice.finish_reason === "stop") {
        return { type: "stop" };
      }
      if (choice.delta && choice.delta.role == "assistant") {
        return { type: "assistant" };
      }
      return { type: "text", text: choice.delta?.content || "" };
    } catch (e) {
      console.log("Error parsing SSE data:", e);
      return { type: "text", text: "" };
    }
  }
}

module.exports = exports = Azure;


================================================
FILE: src/completion/llm.base.js
================================================
const TYPE_ENUM = {
  SSE: 'SSE',
  STREAM: 'STREAM'
}

const axios = require('axios');

class LLM {

  constructor(onTokenStream = (chunk) => { }, model = '', options = {}) {
    this.onTokenStream = onTokenStream;
    // è®¾ç½®é»˜è®¤æ¥å£å¤„ç†é€»è¾‘
    this.responseType = TYPE_ENUM.SSE;
    this.splitter = '\n\n'
    if (model) { this.model = model }
    this.options = options;
  }

  /**
   * æé—®å¤§æ¨¡å‹ && è®°å½•æ—¥å¿—
   * ä¾èµ– start å®ç°æé—®é€»è¾‘
   * @param {*} prompt 
   * @param {*} context 
   * @param {*} options 
   * @returns 
   */
  async completion(prompt, context = {}, options = {}) {
    // å‘èµ·è°ƒç”¨
    const content = await this.start(prompt, context, options);
    return content;
  }

  /**
   * å‘èµ·è¯·æ±‚å¹¶å¯¹è¿”å›æµå¼æ•°æ®è¿›è¡Œå¤„ç†
   * è‹¥é SSE æ ‡å‡†å¤„ç†é€»è¾‘, è¦†ç›– start çš„å®ç°
   * @param {*} prompt 
   */
  async start(prompt, context = {}, options = {}) {
    // å‘èµ·è°ƒç”¨
    const response = await this.call(prompt, context, options);
    // å¤„ç†SSE
    if (this.responseType === TYPE_ENUM.SSE) {
      const content = await this.handleSSE(response)
      return content;
    }
    return ""
  }

  async message(messages = [], options = {}) {
    const response = await this.request(messages, options);
    // å¤„ç†SSE
    if (this.responseType === TYPE_ENUM.SSE) {
      const content = await this.handleSSE(response)
      return content;
    }
    return ""
  }

  resolveConfigHeaders = (config) => {
    if (this.API_KEY) {
      Object.assign(config.headers, {
        "Authorization": `Bearer ${this.API_KEY}`,
      });
      if (config.url && config.url.indexOf('azure') !== -1) {
        Object.assign(config.headers, {
          "api-key": this.API_KEY
        });
      }
      if (config.url && config.url.indexOf('baidu') !== -1) {
        Object.assign(config.headers, { "appid": this.appid });
      }
    }
  }

  async request(messages = [], options = {}) {
    const model = options.model || this.model;

    const body = {
      model,
      messages,
      stream: true,
    }

    /**
     * Supported options
     * - temperature: Controls the randomness of generated text. Higher values increase randomness, lower values decrease it
     * - top_p: Sampling probability threshold, controls the diversity of generated text. Higher values increase diversity
     * - max_tokens: Maximum length limit for generated text
     * - stop: Stop sequence markers for generation
     * - stream: Whether to enable streaming response
     * - assistant_id: Assistant ID, used to identify specific assistants in multi-turn conversations
     * - response_format: Response format, such as JSON
     * - tools: List of callable tool functions, used for advanced features like function calling
     * - enable_thinking: Whether to enable thinking mode, applicable to Qwen3 model
     */
    const supportOptions = ['temperature', 'top_p', 'max_tokens', 'stop', 'stream', 'assistant_id', 'response_format', 'tools', 'enable_thinking'];
    for (const key in options) {
      if (supportOptions.includes(key) && options[key] !== undefined) {
        body[key] = options[key];
        console.log('body.options', key, options[key]);
      }
    }
    // console.log('body', body);
    const config = {
      url: this.CHAT_COMPLETION_URL,
      method: "post",
      maxBodyLength: Infinity,
      headers: {
        "Content-Type": 'application/json'
      },
      data: body,
      responseType: "stream"
    };

    if (options.signal) {
      config.signal = options.signal;
    }

    if (config.url && config.url.indexOf('openrouter.ai') !== -1) {
      Object.assign(config.headers, {
        "HTTP-Referer": 'https://lemonai.cc',
        "X-Title": "LemonAI"
      })
    }
    // console.log('config', config);
    this.resolveConfigHeaders(config);
    // console.log('config', JSON.stringify(config, null, 2));
    const response = await axios.request(config).catch(err => {
      return err;
    });
    // console.log('response', response);
    return response;
  }

  // å‘èµ· HTTP è¯·æ±‚
  async call(prompt = '', context = {}, options = {}) {
    console.log("prompt http call", prompt);
    const messages = context.messages || [];
    if (prompt) {
      const massageUser = { "role": "user", "content": prompt };
      messages.push(massageUser);
    }
    // console.log("å‘èµ·è¯·æ±‚.messages", messages);
    return this.request(messages, options);
  }

  resolveRequestMessages(input, context) {

  }

  // å¤„ç†æµå¼è¯·æ±‚
  async handleSSE(response) {
    if (response.code) {
      const content = response.code;
      this.onTokenStream(`${response.code}:${response.status}`);
      return content;
    }

    // å¤„ç†æµå¼è¿”å›
    let fullContent = "";
    let reasoning = false;
    const fn = new Promise((resolve, reject) => {
      let content = "";
      response.data.on("data", (chunk) => {
        content += chunk;
        const splitter = this.splitter;
        while (content.indexOf(splitter) !== -1) {
          const index = content.indexOf(splitter);
          const message = content.slice(0, index);
          content = content.slice(index + splitter.length);
          const value = this.messageToValue(message);
          if (value.type === "text" || value.type === 'reasoning') {
            let ch = value.text;
            // å¤„ç† reasoning
            if (value.type === 'reasoning' && fullContent === '') {
              ch = '<think>' + ch;
              reasoning = true;
            }
            if (value.type === 'text' && reasoning) {
              ch = '</think>' + ch;
              reasoning = false;
            }
            if (ch) {
              // process.stdout.write(ch);
              fullContent += ch;
              this.onTokenStream(ch);
            }
          } else { }
        }
      });
      response.data.on("end", () => {
        resolve(fullContent);
      });
      response.data.on("error", (err) => {
        if (err.code === 'ERR_CANCELED' || err.message === 'canceled') {
          console.log('è¯·æ±‚è¢«ä¸­æ–­');
          resolve(fullContent);
        } else {
          reject(err)
        }

      });

    });

    const content = await fn;
    return content;
  }

  /**
   * æ ‡å‡† chat/completions message å¤„ç†è§£æé€»è¾‘
   * 1. æˆªå– data: åå¹¶ JSON.parse
   * 2. è¯»å– json.choices[0].delta.content
   * 
   * é€‚ç”¨æœåŠ¡ openai | minimax | kimi | deepseek | zhipu(æ™ºè°±) | qwen å¼€æº
   * @param {*} message 
   * @returns { type: 'text', text: '' }
   */
  messageToValue(message) {
    // console.log('message', message);
    if (message == "data: [DONE]" || message.startsWith("data: [DONE]")) {
      return { type: "done" };
    }
    let data = message.split("data:")[1];
    let value = {}
    try {
      value = JSON.parse(data)
    } catch (error) {
      return { type: "done" };
    }

    // token æ¶ˆè€—æ¶ˆæ¯
    if (value.usage) {
      // console.log('\nToken.Usage', value.usage);
      // return { type: "done" };
    }

    const choices = value.choices || [];
    const choice = choices[0] || {};
    if (Object.keys(choice).length === 0) {
      return { type: "text", text: "" }
    }
    // å·¥å…·ä½¿ç”¨å¤„ç†
    if (choice.delta && choice.delta.tool_calls && choice.delta.tool_calls.length > 0) {
      this.tools = choice.delta.tool_calls;
    }

    // reasoning thinking
    if (choice.delta && choice.delta.reasoning_content) {
      return { type: "reasoning", text: choice.delta.reasoning_content };
    }

    if (choice.delta && choice.delta.content) {
      return { type: "text", text: choice.delta.content };
    }
    return {};
  }
}

module.exports = exports = LLM;


================================================
FILE: src/completion/llm.config.js
================================================
const BaseLLM = require('./llm.base')

class ConfigLLM extends BaseLLM {

  constructor(config = {}, onTokenStream) {
    super(onTokenStream)
    const { url, model, splitter = '\n\n', api_key, appid } = config;
    this.splitter = splitter;
    this.CHAT_COMPLETION_URL = url;
    this.API_KEY = api_key;
    this.model = model;
    if (appid) {
      this.appid = appid;
    }
  }
}

module.exports = exports = ConfigLLM;


================================================
FILE: src/completion/llm.gemini.js
================================================
const BaseLLM = require('./llm.base');
const axios = require('axios');

const fs = require('node:fs');
const net = require('node:net');

const PROXY_PORT = 7890;
const PROXY_PROTOCOL = 'http';
const PROXY_CONNECT_TIMEOUT = 1500;

/**
 * æ£€æŸ¥å½“å‰ç¯å¢ƒæ˜¯å¦åœ¨ Docker å®¹å™¨å†…ã€‚
 * @returns {boolean} å¦‚æœåœ¨ Docker å†…åˆ™è¿”å› trueï¼Œå¦åˆ™è¿”å› falseã€‚
 */
function amInDockerEnvironment() {
  try {
    fs.accessSync('/.dockerenv');
    return true;
  } catch (e) {
    return false;
  }
}

/**
 * å¼‚æ­¥æ£€æŸ¥æŒ‡å®šçš„ä»£ç†æœåŠ¡å™¨æ˜¯å¦å¯è¿æ¥ã€‚
 * @param {string} host ä»£ç†æœåŠ¡å™¨ä¸»æœºåã€‚
 * @param {number} port ä»£ç†æœåŠ¡å™¨ç«¯å£ã€‚
 * @returns {Promise<boolean>} å¦‚æœå¯è¿æ¥åˆ™è¿”å› trueï¼Œå¦åˆ™è¿”å› falseã€‚
 */
async function checkProxyConnectivity(host, port) {
  return new Promise((resolve) => {
    const socket = net.createConnection({ host, port });
    socket.on('connect', () => {
      socket.end();
      resolve(true);
    });
    socket.on('error', (/* err */) => { // æ•è·é”™è¯¯ï¼Œä½†å¯¹äºæ­¤å‡½æ•°åªéœ€è¿”å› false
      socket.destroy();
      resolve(false);
    });
    socket.on('timeout', () => {
      socket.destroy();
      resolve(false);
    });
    socket.setTimeout(PROXY_CONNECT_TIMEOUT);
  });
}

const axiosInstancePromise = (async () => {
  const isInDocker = amInDockerEnvironment();
  const proxyHost = isInDocker ? 'host.docker.internal' : '127.0.0.1';

  console.log(`[Axios Init] ENV: ${isInDocker ? 'Docker' : 'å®¿ä¸»æœº'}. ä»£ç†ä¸»æœº: ${proxyHost}:${PROXY_PORT}`);

  const isProxyReachable = await checkProxyConnectivity(proxyHost, PROXY_PORT);

  if (isProxyReachable) {
    const proxyConfig = {
      protocol: PROXY_PROTOCOL,
      host: proxyHost,
      port: PROXY_PORT,
    };
    console.log(`[Axios åˆå§‹åŒ–] ä»£ç† ${proxyHost}:${PROXY_PORT} å¯è¿æ¥ã€‚åˆ›å»ºå¸¦ä»£ç†çš„ Axios å®ä¾‹ã€‚`);
    return axios.create({ proxy: proxyConfig });
  } else {
    console.warn(`[Axios åˆå§‹åŒ–] ä»£ç† ${proxyHost}:${PROXY_PORT} ä¸å¯è¿æ¥ã€‚åˆ›å»ºä¸å¸¦ä»£ç†çš„ Axios å®ä¾‹ã€‚`);
    return axios.create();
  }
})();

class GeminiLLM extends BaseLLM {

  /**
   * 
   * @param {*} onTokenStream 
   * @param {*} model gemini-1.0-pro | gemini-1.5-pro | gemini-1.5-flash-latest
   */
  constructor(onTokenStream, model, options = {}) {
    console.log('GeminiLLM', model, options);
    super(onTokenStream, model, options)
    this.GOOGLE_AI_KEY = options.config.API_KEY;
    this.splitter = '\n\r\n';
  }

  async request(messages, options = {}) {
    // gemini-1.5-pro-latest
    // const { model = 'gemini-pro' } = options;
    const model = this.model;

    const instance = await axiosInstancePromise;

    // reference: https://ai.google.dev/gemini-api/docs/get-started/tutorial?lang=rest#stream_generate_content
    //å¦‚æœmessageç¬¬ä¸€æ¡æ˜¯system æ¨å‡ºmessagesé‡Œçš„ç¬¬ä¸€æ¡ä¸ºsystemPrompt
    let systemPrompt = null
    if (messages[0] && messages[0].role === 'system') {
      systemPrompt = messages.shift()
    }
    const config = {
      method: "post",
      maxBodyLength: Infinity,
      url: `https://generativelanguage.googleapis.com/v1beta/models/${model}:streamGenerateContent?alt=sse`,
      headers: {
        "Content-Type": 'application/json',
        "x-goog-api-key": this.GOOGLE_AI_KEY
      },
      transformResponse: [],
      data: {
        "contents": messages,
        "generationConfig": {
          "temperature": options.temperature || 0,
        },
        "systemInstruction": systemPrompt
      },
      responseType: "stream",
    };
    console.log("config", JSON.stringify(config, null, 2));

    // @ts-ignore
    const response = await instance.request(config).catch(err => {
      return err;
    });
    console.log(response.status);
    return response;
  }

  async call(prompt, context = {}) {
    const massageUser = [{ "role": "user", "parts": [{ "text": prompt }] }]
    const newContextMessage = context.messages.map(item => {
      //å¦‚æœroleæ˜¯assistentï¼Œæ”¹æˆmodel
      return {
        "role": item.role === 'assistant' ? 'model' : item.role,
        "parts": [{ "text": item.content }]
      }
    })
    const messages = (newContextMessage || []).concat(massageUser);
    return this.request(messages);
  }

  messageToValue(message) {
    // console.log("message", message);
    if (message == "data: [DONE]" || message.startsWith("data: [DONE]")) {
      return { type: "done" };
    }
    const data = message.split("data:")[1];
    let value = {}
    try {
      value = JSON.parse(data)
    } catch (error) {
      return { type: "done" };
    }
    const candidates = value.candidates || []
    if (!candidates.length) {
      return { type: "assistant" };
    }
    const candidate = candidates[0];
    const content = candidate.content;
    if (content && content.parts) {
      const part = content.parts[0];
      const text = part.text;
      return { type: 'text', text };
    }
    return { type: "assistant" };
  }
}

module.exports = exports = GeminiLLM;


================================================
FILE: src/completion/llm.one.js
================================================
const CHANNEL = {
  OFFICIAL: 'official', // å®˜æ–¹éƒ¨ç½²-ä»£ç†å¤§æ¨¡å‹æœåŠ¡
  PROVIDER: 'provider', // æ¨¡å‹æœåŠ¡å•†
  PRIVATE: 'private' // ç§æœ‰åŒ–éƒ¨ç½²
}

const serviceHash = {
  'azure': require('./llm.azure.openai'),
  'gemini': require('./llm.gemini'),
}

const resolveServiceConfig = require('./resolveServiceConfig');
const resolvePlatformServiceConfig = async (model_info) => {
  const config = {
    channel: 'provider',
    service: model_info.platform_name,
    name: model_info.model_name,
    host: model_info.api_url,
    config: {
      API_KEY: model_info.api_key,
    }
  }
  return config
}

// é€šç”¨ LLM.config
const LLMStandard = require('./llm.config');
const resolveLLMStandard = (llm_config, model, onTokenStream) => {
  const configure = {
    url: llm_config.host,
    model: model,
    api_key: llm_config.config.API_KEY,
  }
  if (llm_config.config.appid) {
    configure.appid = llm_config.config.appid;
  }
  const llm = new LLMStandard(configure, onTokenStream);
  return llm;
}

const resolveKey = (model) => {
  if (model && model.startsWith('doubao')) {
    const envKey = 'ALIAS_' + model.replaceAll('-', '_').toUpperCase();
    console.log('envKey', envKey);
    return process.env[envKey] || model
  }
  return model
}

/**
 * åˆ›å»º LLM è°ƒç”¨å®ä¾‹
 * @param {*} config 
 * @param {*} onTokenStream 
 * @returns 
 */
const createLLMInstance = async (config, onTokenStream, options = {}) => {

  if (typeof config === 'string') {
    const [channel, service, model] = config.split('#')
    config = {
      channel,
      service,
      model: resolveKey(model)
    }
  }
  console.log('config', config);
  const { channel, service, model } = config;

  if (channel === CHANNEL.PROVIDER) {
    const LLM = serviceHash[service.toLowerCase()];
    console.log('options:', options);
    const llm_config = await resolvePlatformServiceConfig(options.model_info)
    if (!LLM) {
      return resolveLLMStandard(llm_config, model, onTokenStream);
    }
    // console.log("llm_config", llm_config);
    const llm = new LLM(onTokenStream, model, llm_config || {});
    return llm;
  }

  if (channel === CHANNEL.PRIVATE) {
    const llm_config = await resolveServiceConfig(CHANNEL.PRIVATE, service);
    const configure = {
      url: llm_config.host,
      model: model,
      api_key: llm_config.config.API_KEY
    }
    const llm = new LLMStandard(configure, onTokenStream);
    return llm;
  }
}

module.exports = exports = createLLMInstance


================================================
FILE: src/completion/log.record.js
================================================
const LLMLogs = require("@src/models/LLMLogs");

const calcToken = require('./calc.token');

const calcTokenInput = (prompt, messages) => {
  let content = prompt;
  for (const message of messages) {
    content += message.content;
  }
  return calcToken(content);
}

const recordLLMLogs = async (model, userId, chainId, prompt, content, messages = []) => {
  const logValue = {
    model,
    userId,
    chainId,
    prompt,
    content,
    messages,
    tokenInput: calcTokenInput(prompt, messages),
    tokenOutput: calcToken(content),
    createTime: new Date(),
    updateTime: new Date()
  }
  // console.log('log.value', logValue);
  const r = await LLMLogs.create(logValue);
  return r;
}

module.exports = exports = recordLLMLogs;


================================================
FILE: src/completion/resolveServiceConfig.js
================================================
const configs = require('./configs.js')

const resolveServiceConfig = async (channel, service = '') => {
  const config = configs.find(item => {
    return item.channel === channel && item.service === service
  });
  return config || {}
}

module.exports = exports = resolveServiceConfig


================================================
FILE: src/editor/coding.continue.js
================================================
const { resolveAction } = require('./resolve');
const { execute: execute_action } = require('./execute.js');
const { withLLMRetry } = require('./withRetry');
const chat_completion = require('@src/agent/chat-completion/index')
const fs = require('fs');
const path = require('path');

const { resolveTemplate } = require("@src/utils/template");

const template_path = path.join(__dirname, 'template.txt');
const template = fs.readFileSync(template_path, 'utf-8');

const load_prompt = async (params = {}) => {

  const { filepath, selection, requirement } = params;
  const full_code = fs.readFileSync(filepath, 'utf-8');

  const template_options = { full_code, selection, requirement };
  const prompt = await resolveTemplate(template, template_options);
  return prompt;
}

const coding = async (params = {}, context = {}) => {

  const { filepath } = context;
  const { conversation_id = '' } = context;

  // ä½¿ç”¨å¸¦é‡è¯•æœºåˆ¶çš„ LLM è°ƒç”¨
  const callWithRetry = withLLMRetry(
    async () => {
      const prompt = await load_prompt({
        filepath,
        selection: params.selection,
        requirement: params.requirement,
      });

      const content = await chat_completion(prompt,{},conversation_id)

      return content;
    },
    {
      maxRetries: 3,
      delay: 1500,
      onRetry: (error, attempt) => {
        console.log(`[Retry ${attempt}/3] LLM response parsing failed:`, error.message);
        console.log(`[Retry ${attempt}/3] Retrying with format correction...`);
      }
    }
  );

  try {
    const content = await callWithRetry();

    const action = resolveAction(content);
    if (!action) {
      throw new Error('Failed to resolve action after all retries');
    }

    const result = await execute_action(action, context);
    console.log('result', result);
    return result;
  } catch (error) {
    console.error('Coding operation failed:', error);
    throw error;
  }
}

module.exports = {
  coding
}


================================================
FILE: src/editor/coding.js
================================================
const { resolveActions, extractDescription } = require('./resolve');
const { execute: execute_action } = require('./execute.js');
const { withLLMRetry } = require('./withRetry');
const { createAIVersion } = require('@src/utils/versionManager');
const { sendProgressMessage, sendCodingMessage } = require("@src/routers/agent/utils/coding-messages");

const fs = require('fs');
const path = require('path');

const chat_completion = require('@src/agent/chat-completion/index')

const { resolveTemplate } = require("@src/utils/template");

const template_path = path.join(__dirname, 'template.txt');
const template = fs.readFileSync(template_path, 'utf-8');

const load_prompt = async (params = {}) => {

  const { filepath, selection, requirement, information } = params;
  const full_code = fs.readFileSync(filepath, 'utf-8');

  const template_options = { full_code, selection, requirement, information };
  const prompt = await resolveTemplate(template, template_options);
  return prompt;
}

const coding = async (params = {}, context = {}) => {

  const { filepath } = context;
  const { conversation_id = '', user_id, onTokenStream } = context;

  // ä½¿ç”¨å¸¦é‡è¯•æœºåˆ¶çš„ LLM è°ƒç”¨
  const callWithRetry = withLLMRetry(
    async () => {
      const prompt = await load_prompt({
        filepath,
        selection: params.selection,
        requirement: params.requirement,
        information: params.information,
      });

      const content = await chat_completion(prompt,{},conversation_id)
      return content;
    },
    {
      maxRetries: 3,
      delay: 1500,
      onRetry: (error, attempt) => {
        console.log(`[Retry ${attempt}/3] LLM response parsing failed:`, error.message);
        console.log(`[Retry ${attempt}/3] Retrying with format correction...`);
      }
    }
  );

  try {
    const content = await callWithRetry();
    const description = extractDescription(content);
    const actions = resolveActions(content);

    if (!actions || actions.length === 0) {
      throw new Error('Failed to resolve actions after all retries');
    }

    console.log(`[Coding] Executing ${actions.length} action(s)`);

    if (description && onTokenStream) {
      await sendProgressMessage(onTokenStream, conversation_id, description);
    }

    // Execute all actions in sequence
    for (const action of actions) {
      await execute_action(action, context);
      if (onTokenStream) {
        const json = {
          filepath,
          ...action.params,
        }
        await sendCodingMessage(onTokenStream, conversation_id, action.params.message, 'coding', json);
      }
    }

    if (conversation_id && filepath) {
      try {
        await createAIVersion(filepath, conversation_id, {
          requirement: params.requirement || '',
          selection: params.selection ? 'partial' : 'full',
          actionType: actions.map(a => a.type).join(','),
          actionCount: actions.length
        });
      } catch (versionError) {
        console.error('[Coding] Failed to create version:', versionError);
      }
    }

    return true;
  } catch (error) {
    console.error('Coding operation failed:', error);
    throw error;
  }
}

module.exports = { coding }


================================================
FILE: src/editor/content.txt
================================================
<replace>
  <find><![CDATA[<div class="grid grid-cols-4 gap-2">
            <button
              class="flex flex-col items-center text-transparent bg-clip-text bg-gradient-to-r from-dream-indigo to-dream-purple">
              <i class="fa fa-dashboard"></i>
              <span class="text-xs mt-1">ä»ªè¡¨ç›˜</span>
            </button>
            <button class="flex flex-col items-center text-neutral-light">
              <i class="fa fa-pie-chart"></i>
              <span class="text-xs mt-1">åˆ†æ</span>
            </button>
            <button class="flex flex-col items-center text-neutral-light">
              <i class="fa fa-plus-circle text-2xl"></i>
              <span class="text-xs mt-1">è®°è´¦</span>
            </button>
            <button class="flex flex-col items-center text-neutral-light">
              <i class="fa fa-user-o"></i>
              <span class="text-xs mt-1">æˆ‘çš„</span>
            </button>
          </div>]]></find>
  <with><![CDATA[<div class="grid grid-cols-5 gap-2">
            <button
              class="flex flex-col items-center text-transparent bg-clip-text bg-gradient-to-r from-dream-indigo to-dream-purple">
              <i class="fa fa-dashboard"></i>
              <span class="text-xs mt-1">ä»ªè¡¨ç›˜</span>
            </button>
            <button class="flex flex-col items-center text-neutral-light">
              <i class="fa fa-pie-chart"></i>
              <span class="text-xs mt-1">åˆ†æ</span>
            </button>
            <button class="flex flex-col items-center text-neutral-light">
              <i class="fa fa-plus-circle text-2xl"></i>
              <span class="text-xs mt-1">è®°è´¦</span>
            </button>
            <button class="flex flex-col items-center text-neutral-light">
              <i class="fa fa-history"></i>
              <span class="text-xs mt-1">å†å²</span>
            </button>
            <button class="flex flex-col items-center text-neutral-light">
              <i class="fa fa-user-o"></i>
              <span class="text-xs mt-1">æˆ‘çš„</span>
            </button>
          </div>]]></with>
</replace>


================================================
FILE: src/editor/execute.js
================================================
const fs = require('fs');

/**
 * é‡å†™æ–‡ä»¶å†…å®¹
 * @param {*} filepath æ–‡ä»¶è·¯å¾„
 * @param {*} content æ–‡ä»¶å†…å®¹
 */
const rewrite = async (filepath, content) => {
  fs.writeFileSync(filepath, content);
  return true;
}

/**
 * æ›¿æ¢æ–‡ä»¶ä¸­çš„å†…å®¹
 * @param {*} filepath æ–‡ä»¶è·¯å¾„
 * @param {*} find è¦æŸ¥æ‰¾çš„å†…å®¹
 * @param {*} with_content æ›¿æ¢åçš„å†…å®¹
 */
const replace = async (filepath, find, with_content) => {
  const content = fs.readFileSync(filepath, 'utf-8');
  console.log('filepath', filepath)
  console.log('\n=== find_content ===\n', find)
  console.log('\n=== with_content ===\n', with_content)

  const is_in = content.indexOf(find) > -1;
  if (!is_in) {
    throw new Error(`Cannot find ${find} in ${filepath}`);
  }

  const newContent = content.replace(find, with_content);
  fs.writeFileSync(filepath, newContent);
  return true;
}

const execute = async (action, context = {}) => {
  const filepath = context.filepath;
  if (action.type === 'rewrite') {
    const { content } = action.params;
    return await rewrite(filepath, content);
  }

  if (action.type === 'replace') {
    const { find, with: with_content } = action.params;
    return await replace(filepath, find, with_content);
  }

  return 'action type error';
}

module.exports = {
  execute
}


================================================
FILE: src/editor/resolve.js
================================================
// https://github.com/NaturalIntelligence/fast-xml-parser
const { XMLParser, XMLBuilder, XMLValidator } = require("fast-xml-parser");
const parser = new XMLParser({
  stopNodes: ["write_code.content", "revise_plan.tasks"],
  ignoreAttributes: false,
});

const resolveXML = (content) => {
  // è¾“å…¥éªŒè¯
  if (!content || typeof content !== 'string') {
    throw new Error('XMLå†…å®¹å¿…é¡»æ˜¯éç©ºå­—ç¬¦ä¸²');
  }

  // è§£æXMLå†…å®¹
  const result = parser.parse(content);

  // é€šç”¨CDATAå¤„ç†å‡½æ•°
  const processCDATA = (text) => {
    if (!text || typeof text !== 'string') return text;
    const trimmed = text.trim();
    if (trimmed.startsWith('<![CDATA[') && trimmed.endsWith(']]>')) {
      return trimmed.slice(9, -3); // ç§»é™¤ <![CDATA[ å’Œ ]]>
    }
    return text;
  };

  // å¤„ç†write_code.contentçš„CDATA
  if (result.write_code?.content) {
    result.write_code.content = processCDATA(result.write_code.content);
  }

  return result;
}

/**
 * Extract description from content (text before XML content)
 * Handles both cases: with ```xml wrapper and without
 */
const extractDescription = content => {
  try {
    if (!content || typeof content !== 'string') {
      return '';
    }

    const lines = content.split('\n');
    let xmlStartIndex = -1;

    // æŸ¥æ‰¾XMLå†…å®¹çš„èµ·å§‹ä½ç½®
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      // XMLå†…å®¹å¯èƒ½ä»¥ ```xml å¼€å§‹æˆ–ç›´æ¥ä»¥ < æ ‡ç­¾å¼€å§‹
      if (line.startsWith('```xml') || line.startsWith('<')) {
        xmlStartIndex = i;
        break;
      }
    }

    // å¦‚æœæ‰¾åˆ°XMLèµ·å§‹ä½ç½®ï¼Œæå–ä¹‹å‰çš„æè¿°æ–‡å­—
    if (xmlStartIndex > 0) {
      return lines.slice(0, xmlStartIndex)
        .filter(line => line.trim()) // è¿‡æ»¤ç©ºè¡Œ
        .join(' ')
        .trim();
    }

    // æ²¡æœ‰æ‰¾åˆ°XMLå†…å®¹ï¼Œè¿”å›ç©ºæè¿°
    return '';
  } catch (err) {
    console.error('[extractDescription] Failed to extract description:', err);
    return '';
  }
}

/**
 * Parse XML to extract actions (single or multiple)
 */
const resolveActions = xml => {
  try {
    const resolved = resolveXML(xml);
    const actions = [];

    for (let key in resolved) {
      const value = resolved[key];

      // Handle array of same type operations
      if (Array.isArray(value)) {
        value.forEach(params => {
          actions.push({ type: key, params });
        });
      } else {
        actions.push({ type: key, params: value });
      }
    }

    return actions;
  } catch (err) {
    console.error('[resolveActions] Failed to parse XML:', err);
    return [];
  }
}

// Backward compatibility
const resolveAction = xml => {
  const actions = resolveActions(xml);
  return actions[0] || null;
}

module.exports = {
  resolveXML,
  resolveActions,
  resolveAction,  // Keep for backward compatibility
  extractDescription
};



================================================
FILE: src/editor/template.txt
================================================
[Binary file]


================================================
FILE: src/editor/withRetry.js
================================================
const { resolveAction } = require('./resolve');

/**
 * å¸¦é‡è¯•æœºåˆ¶çš„é«˜é˜¶å‡½æ•°
 * @param {Function} fn - éœ€è¦é‡è¯•çš„å¼‚æ­¥å‡½æ•°
 * @param {Object} options - é‡è¯•é…ç½®é€‰é¡¹
 * @param {number} options.maxRetries - æœ€å¤§é‡è¯•æ¬¡æ•°ï¼Œé»˜è®¤3æ¬¡
 * @param {number} options.delay - é‡è¯•å»¶è¿Ÿï¼ˆæ¯«ç§’ï¼‰ï¼Œé»˜è®¤1000ms
 * @param {Function} options.shouldRetry - åˆ¤æ–­æ˜¯å¦éœ€è¦é‡è¯•çš„å‡½æ•°
 * @param {Function} options.onRetry - é‡è¯•æ—¶çš„å›è°ƒå‡½æ•°
 * @param {Function} options.validateResult - éªŒè¯ç»“æœçš„å‡½æ•°
 * @returns {Function} åŒ…è£…åçš„å‡½æ•°
 */
const withRetry = (fn, options = {}) => {
  const {
    maxRetries = 3,
    delay = 1000,
    shouldRetry = () => true,
    onRetry = () => { },
    validateResult = () => true
  } = options;

  return async (...args) => {
    let lastError;
    let attempt = 0;

    while (attempt <= maxRetries) {
      try {
        const result = await fn(...args);

        // éªŒè¯ç»“æœæ˜¯å¦æœ‰æ•ˆ
        if (!validateResult(result)) {
          throw new Error('Result validation failed');
        }

        return result;
      } catch (error) {
        lastError = error;
        attempt++;

        if (attempt > maxRetries || !shouldRetry(error, attempt)) {
          throw error;
        }

        // è§¦å‘é‡è¯•å›è°ƒ
        await onRetry(error, attempt, ...args);

        // å»¶è¿Ÿåé‡è¯•
        if (delay > 0) {
          await new Promise(resolve => setTimeout(resolve, delay * attempt));
        }
      }
    }

    throw lastError;
  };
};

/**
 * ä¸“é—¨ç”¨äºå¤„ç† LLM å“åº”è§£æçš„é‡è¯•åŒ…è£…å™¨
 * @param {Function} llmCall - LLM è°ƒç”¨å‡½æ•°
 * @param {Object} retryOptions - é‡è¯•é…ç½®
 */
const withLLMRetry = (llmCall, retryOptions = {}) => {
  const defaultOptions = {
    maxRetries: 3,
    delay: 1500,
    shouldRetry: (error, attempt) => {
      // åªåœ¨è§£æé”™è¯¯æˆ–æ ¼å¼é”™è¯¯æ—¶é‡è¯•
      const retryableErrors = [
        'XMLå†…å®¹å¿…é¡»æ˜¯éç©ºå­—ç¬¦ä¸²',
        'Result validation failed',
        'Invalid XML format',
        'Action resolution failed'
      ];

      const shouldRetry = retryableErrors.some(msg =>
        error.message?.includes(msg)
      ) || !error.message;

      return shouldRetry && attempt <= 3;
    },
    onRetry: (error, attempt, ...args) => {
      console.log(`[Retry ${attempt}] LLM response parsing failed:`, error.message);
      console.log(`[Retry ${attempt}] Attempting to regenerate response...`);
    },
    validateResult: (result) => {
      // éªŒè¯ LLM è¿”å›çš„å†…å®¹æ˜¯å¦å¯ä»¥è¢«æ­£ç¡®è§£æ
      if (!result || typeof result !== 'string') {
        return false;
      }

      try {
        const action = resolveAction(result);
        return action !== null && action !== undefined;
      } catch {
        return false;
      }
    },
    ...retryOptions
  };

  return withRetry(llmCall, defaultOptions);
};


/**
 * å¢å¼ºçš„ coding å‡½æ•°åŒ…è£…å™¨
 * ç”¨äºæ›¿æ¢åŸæœ‰çš„ coding å‡½æ•°ï¼Œæ·»åŠ é‡è¯•æœºåˆ¶
 */
const enhancedCoding = (originalCoding) => {
  return async (params = {}, context = {}) => {
    const { filepath } = context;
    const { conversation_id = '' } = context;

    // åŒ…è£… LLM è°ƒç”¨éƒ¨åˆ†
    const callLLMWithRetry = withLLMRetry(
      async () => {
        const chat_completion = require('@src/agent/chat-completion/index')
        const { resolveTemplate } = require("@src/utils/template");
        const fs = require('fs');
        const path = require('path');

        const template_path = path.join(__dirname, 'template.txt');
        const template = fs.readFileSync(template_path, 'utf-8');

        const full_code = fs.readFileSync(filepath, 'utf-8');
        const template_options = {
          full_code,
          selection: params.selection,
          requirement: params.requirement
        };
        const prompt = await resolveTemplate(template, template_options);

        const content = await chat_completion(prompt, {}, conversation_id)

        return content;
      },
      {
        maxRetries: 3,
        delay: 2000,
        onRetry: async (error, attempt) => {
          console.log(`[Attempt ${attempt}] Retrying LLM call due to:`, error.message);
          // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ é¢å¤–çš„æç¤ºè¯ä¼˜åŒ–é€»è¾‘
        }
      }
    );

    try {
      const content = await callLLMWithRetry();

      const action = resolveAction(content);
      if (!action) {
        throw new Error('Failed to resolve action from LLM response');
      }

      const { execute: execute_action } = require('./execute.js');
      const result = await execute_action(action, context);
      console.log('result', result);

      return result;
    } catch (error) {
      console.error('Enhanced coding failed after all retries:', error);
      throw error;
    }
  };
};

module.exports = {
  withRetry,
  withLLMRetry,
  enhancedCoding
};


================================================
FILE: src/knowledge/feedback.js
================================================
require('module-alias/register')
require('dotenv').config();

const Agent = require('@src/models/Agent')

const { resolveUsedKnowledge, handleKnowledgeReflection } = require('./knowledge.util');
const chat_completion = require('@src/agent/chat-completion/index')

const handleReflection = async (reflection = {}, agent_id) => {
  try {
    const { reasoning, operations = [] } = reflection || {};
    console.log(reasoning);
    //æ›´æ–°è¿­ä»£æ¬¡æ•°
    if (operations.some(op => op.action && op.action !== 'NO_ACTION')) {
      await Agent.increment('experience_iteration_count', { by: 1, where: { id: agent_id } });
    }
    for (const operation of operations) {
      await handleKnowledgeReflection(operation, agent_id)
    }
  } catch (error) {
    console.log(error);
  }
}

const { resolveTemplate, loadTemplate } = require("@src/utils/template");

const handle_feedback = async (options = {}) => {
  try {
    const { user_request, user_feedback, conversation_id, agent_id } = options;
    const knowledge = await resolveUsedKnowledge(agent_id);
    console.log("========knowledge==========", knowledge);

    const interaction = {
      user_request,
      user_feedback,
    }

    const template = await loadTemplate('knowledge.txt');
    const knowledge_prompt = await resolveTemplate(template, {
      knowledge: JSON.stringify(knowledge, null, 2),
      interaction: JSON.stringify(interaction, null, 2)
    })

    const reflection = await chat_completion(knowledge_prompt, { response_format: 'json' }, conversation_id);
    console.log(JSON.stringify(reflection, null, 2));
    await handleReflection(reflection, agent_id)
  } catch (error) {
    console.log(error);
  }
}

module.exports = handle_feedback;


================================================
FILE: src/knowledge/FileStorage.js
================================================
const MemoryStorage = require('./MemoryStorage');
const fs = require('fs');
const path = require('path');
const { v4: uuidv4 } = require('uuid');

// ensure the temporary directory exists
const { getDirpath } = require('@src/utils/electron');
const knowledge_dir = getDirpath('Caches/knowledge');
fs.mkdirSync(knowledge_dir, { recursive: true });

/**
 * Local file-based storage implementation
 */
class FileStorage extends MemoryStorage {
  constructor({ directory = 'coding' } = {}) {
    super();
    this.storagePath = path.resolve(knowledge_dir, directory);
    this.ensureStorageDir();
    console.log('storagePath', this.storagePath);
  }

  ensureStorageDir() {
    try {
      fs.mkdirSync(this.storagePath, { recursive: true });
    } catch (error) {
      if (error.code !== 'EEXIST') throw error;
    }
  }

  getFilePath(filename) {
    if (filename.endsWith('.json')) {
      return path.join(this.storagePath, filename);
    }
    return path.join(this.storagePath, filename + '.json');
  }

  async save(memory) {
    if (!memory.id) memory.id = uuidv4();
    if (!memory.timestamp) memory.timestamp = Date.now();
    if (memory.importance === undefined) memory.importance = 1;

    const filepath = this.getFilePath(memory.id);
    fs.writeFileSync(filepath, JSON.stringify(memory, null, 2), 'utf8');
    return memory;
  }

  async get(id) {
    try {
      const filepath = this.getFilePath(id);
      const data = fs.readFileSync(filepath, 'utf8');
      return JSON.parse(data);
    } catch (error) {
      if (error.code === 'ENOENT') return null;
      throw error;
    }
  }

  async getAll() {
    try {
      const files = await fs.readdirSync(this.storagePath);
      const json_files = files.filter(file => file.endsWith('.json'));
      console.log('json_files', json_files);
      const memories = await Promise.all(
        json_files.map(file => {
          const filepath = this.getFilePath(file);
          const data = fs.readFileSync(filepath, 'utf8');
          return JSON.parse(data);
        })
      );
      return memories.filter(Boolean);
    } catch (error) {
      if (error.code === 'ENOENT') return [];
      throw error;
    }
  }

  async update(id, updates = {}) {
    const memory = await this.get(id);
    if (!memory) return null;
    const updatedMemory = { ...memory, ...updates, updatedAt: Date.now() };
    await this.save(updatedMemory);
    return updatedMemory;
  }

  async delete(id) {
    try {
      const filepath = this.getFilePath(id);
      fs.unlinkSync(filepath);
      return true;
    } catch (error) {
      if (error.code === 'ENOENT') return false;
      throw error;
    }
  }

  async search(query, { limit = 10, offset = 0 } = {}) {
    const allMemories = await this.getAll();
    // Simple text search implementation
    const queryLower = query.toLowerCase();
    return allMemories
      .filter(memory =>
        memory.content.toLowerCase().includes(queryLower) ||
        JSON.stringify(memory.metadata || {}).toLowerCase().includes(queryLower)
      )
      .sort((a, b) => b.timestamp - a.timestamp)
      .slice(offset, offset + limit);
  }
}

module.exports = FileStorage;



================================================
FILE: src/knowledge/index.js
================================================
const FileStorage = require('./FileStorage');

const { resolveUsedKnowledgeForCategory } = require('./knowledge.util')

const resolveThinkingKnowledge = async (context) => {
  // const agent_type = context.agent_type || 'coding';
  // const storage = new FileStorage({
  //   directory: agent_type
  // });
  const memories = await resolveUsedKnowledgeForCategory(context.agent_id, ['user_profile', 'execution', 'core_directive'])
  console.log('memories', memories);
  return memories.map(item => item.content).join('\n');
}

const resolvePlanningKnowledge = async (context) => {
  // const agent_type = context.agent_type || 'planning';
  // const storage = new FileStorage({
  //   directory: agent_type
  // });
  const memories = await resolveUsedKnowledgeForCategory(context.agent_id, ['user_profile', 'core_directive', 'planning'])
  return memories.map(item => item.content).join('\n');
}

module.exports = exports = {
  resolveThinkingKnowledge,
  resolvePlanningKnowledge
}



================================================
FILE: src/knowledge/knowledge.util.js
================================================
const FileStorage = require('@src/knowledge/FileStorage');
const Knowledge = require('@src/models/Knowledge');
const Agent = require('@src/models/Agent')
const { Op } = require('sequelize'); // éœ€è¦å¼•å…¥ Op
const resolveStorage = (storage_type = 'planning') => {
  const storage = new FileStorage({
    directory: storage_type
  });
  return storage;
}

const resolveMemory = (memory, category = 'planning') => {
  return {
    id: memory.id,
    content: memory.content,
    category: category,
  }
}

const resolveUsedKnowledge = async (agent_id) => {
  // const planning_storage = resolveStorage('planning');
  // const planning_memories = await planning_storage.getAll();
  // const planning_knowledge = planning_memories.map(item => resolveMemory(item, 'planning'));
  // const coding_storage = resolveStorage('coding');
  // const coding_memories = await coding_storage.getAll();
  // const coding_knowledge = coding_memories.map(item => resolveMemory(item, 'coding'));
  // return [...planning_knowledge, ...coding_knowledge];

  let konwlages = await Knowledge.findAll({ where: { agent_id } })
  let resolveKonwlages = konwlages.map(item => {
    return {
      id: item.dataValues.id,
      content: item.dataValues.content,
      category: item.dataValues.category
    }
  })
  return resolveKonwlages
}

const resolveUsedKnowledgeForCategory = async (agent_id, categories) => {
  let konwlages = await Knowledge.findAll({
    where: {
      agent_id,
      category: { [Op.in]: categories }
    }
  });
  let resolveKonwlages = konwlages.map(item => {
    return {
      id: item.dataValues.id,
      content: item.dataValues.content,
      category: item.dataValues.category
    }
  });
  return resolveKonwlages;
}

const handleKnowledgeReflection = async (reflection = {}, agent_id) => {
  const agent = await Agent.findOne({ where: { id: agent_id } })
  const { category, action, target_knowledge_id, new_knowledge } = reflection;
  // const storage = resolveStorage(category);
  switch (action) {
    case "ADD":
      // await storage.save({
      //   content: new_knowledge,
      // });
      await Knowledge.create({
        user_id: agent.dataValues.user_id,
        agent_id,
        content: new_knowledge,
        category: category
      })
      break;
    case "MODIFY":
      const updates = { content: new_knowledge };
      // await storage.update(target_knowledge_id, updates);
      await Knowledge.update(updates, { where: { id: target_knowledge_id, agent_id } })
      break;
    case "DELETE":
      // await storage.delete(target_knowledge_id);
      await Knowledge.destroy({ where: { id: target_knowledge_id, agent_id } })
      break;
  }
}

module.exports = {
  resolveUsedKnowledge,
  handleKnowledgeReflection,
  resolveUsedKnowledgeForCategory
}


================================================
FILE: src/knowledge/MemoryStorage.js
================================================
/**
 * Base Memory Storage Interface
 * All storage implementations must implement these methods
 */
class MemoryStorage {
  /**
   * Save a memory to storage
   * @param {Object} memory - The memory object to save
   * @returns {Promise<Object>} The saved memory
   */
  async save(memory) { throw new Error('Not implemented'); }

  /**
   * Get a memory by ID
   * @param {string} id - The ID of the memory to retrieve
   * @returns {Promise<Object|null>} The memory object or null if not found
   */
  async get(id) { throw new Error('Not implemented'); }

  /**
   * Get all stored memories
   * @returns {Promise<Array<Object>>} Array of all memories
   */
  async getAll() { throw new Error('Not implemented'); }

  /**
   * Update a memory
   * @param {string} id - The ID of the memory to update
   * @param {Object} updates - The updates to apply
   * @returns {Promise<Object|null>} The updated memory or null if not found
   */
  async update(id, updates) { throw new Error('Not implemented'); }

  /**
   * Delete a memory by ID
   * @param {string} id - The ID of the memory to delete
   * @returns {Promise<boolean>} True if deleted, false if not found
   */
  async delete(id) { throw new Error('Not implemented'); }

  /**
   * Search for memories matching a query
   * @param {string} query - The search query
   * @param {Object} options - Search options
   * @param {number} [options.limit=10] - Maximum number of results to return
   * @param {number} [options.offset=0] - Number of results to skip
   * @returns {Promise<Array<Object>>} Array of matching memories
   */
  async search(query, options = {}) { throw new Error('Not implemented'); }
}


module.exports = MemoryStorage



================================================
FILE: src/logger/index.js
================================================
const { logging, getLogger } = require('./winston');

module.exports = {
  getLogger,
  logging
}



================================================
FILE: src/logger/winston.js
================================================
// logger/cache.js
const { createLogger, format, transports } = require('winston');
const path = require('path');
const fs = require('fs');
const loggerMap = {};

// ensure the temporary directory exists
const { getDirpath } = require('@src/utils/electron');
const logger_cache_dir = getDirpath('Caches/logger');
fs.mkdirSync(logger_cache_dir, { recursive: true });

function getLogger(conversation, module) {
  const logger_key = `${conversation}_${module}`;
  if (!loggerMap[logger_key]) {
    const dir = path.resolve(logger_cache_dir, conversation);
    fs.mkdirSync(dir, { recursive: true });
    const module_filepath = path.join(dir, `${module}.log`);
    loggerMap[logger_key] = createLogger({
      level: 'info',
      format: format.combine(
        format.label({ label: module }),
        format.timestamp(),
        format.printf(({ timestamp, level, message, label }) =>
          `${timestamp} [${label}] ${level}: ${message}`
        )
      ),
      transports: [
        new transports.File({
          filename: module_filepath,
          handleExceptions: true
        })
      ]
    });
  }
  return loggerMap[logger_key];
}


const logging = (context = {}, module = '', message = '') => {
  if (typeof message === 'object') {
    message = JSON.stringify(message, null, 2);
  }
  // è·å–è°ƒç”¨æ ˆä¿¡æ¯
  const stack = new Error().stack;
  const stackLines = stack.split('\n');

  let callerInfo = 'æœªçŸ¥ä½ç½®';
  if (stackLines.length > 2) {
    const callerLine = stackLines[2];
    const match = callerLine.match(/\((.+):(\d+):(\d+)\)/) || callerLine.match(/at (.+):(\d+):(\d+)/);

    if (match) {
      const fullPath = match[1];
      const lineNumber = match[2];
      const columnNumber = match[3];
      const filepath = path.relative(process.cwd(), fullPath);
      callerInfo = `${filepath}:${lineNumber}:${columnNumber}`;
    }
  }
  const formattedMessage = `[${callerInfo}] ${message}`;

  const logger = getLogger(context.conversation_id, module);
  logger.info(formattedMessage);
}

module.exports = {
  getLogger,
  logging
};



================================================
FILE: src/logging/index.js
================================================
/**
 * æ—¥å¿—æ¨¡å—å…¥å£æ–‡ä»¶
 * å¯¼å‡º Logger ç±»ï¼Œæ–¹ä¾¿å…¶ä»–æ¨¡å—å¯¼å…¥ä½¿ç”¨
 */

const Logger = require('./logger');

module.exports = {
  Logger
};


================================================
FILE: src/logging/logger.js
================================================
/**
 * Logger ç±» - ä½¿ç”¨ Pino å®ç°çš„æ—¥å¿—è®°å½•å™¨
 * æä¾›åŸºæœ¬çš„æ—¥å¿—çº§åˆ«æ–¹æ³•ï¼ˆlogã€infoã€error ç­‰ï¼‰
 */

const pino = require('pino');

class Logger {
  /**
   * åˆ›å»ºä¸€ä¸ªæ–°çš„æ—¥å¿—è®°å½•å™¨å®ä¾‹
   * @param {string} name - æ—¥å¿—è®°å½•å™¨åç§°ï¼Œç”¨äºæ ‡è¯†æ—¥å¿—æ¥æº
   * @param {object} options - Pino æ—¥å¿—é…ç½®é€‰é¡¹
   */
  constructor(name, options = {}) {
    // é»˜è®¤é…ç½®
    const defaultOptions = {
      name,
      level: process.env.LOG_LEVEL || 'info',
      timestamp: pino.stdTimeFunctions.isoTime,
      formatters: {
        level: (label) => {
          return { level: label };
        },
      },
    };

    // åˆå¹¶ç”¨æˆ·æä¾›çš„é€‰é¡¹ä¸é»˜è®¤é€‰é¡¹
    const loggerOptions = { ...defaultOptions, ...options };

    // åˆ›å»º Pino æ—¥å¿—å®ä¾‹
    this.logger = pino(loggerOptions);
  }

  /**
   * è®°å½•æ™®é€šæ—¥å¿—ä¿¡æ¯ (info çº§åˆ«)
   * @param {string} message - æ—¥å¿—æ¶ˆæ¯
   * @param {object} data - é™„åŠ æ•°æ®å¯¹è±¡
   */
  log(message, data = {}) {
    this.info(message, data);
  }

  /**
   * è®°å½•è°ƒè¯•ä¿¡æ¯
   * @param {string} message - æ—¥å¿—æ¶ˆæ¯
   * @param {object} data - é™„åŠ æ•°æ®å¯¹è±¡
   */
  debug(message, data = {}) {
    this.logger.debug(data, message);
  }

  /**
   * è®°å½•ä¿¡æ¯çº§åˆ«æ—¥å¿—
   * @param {string} message - æ—¥å¿—æ¶ˆæ¯
   * @param {object} data - é™„åŠ æ•°æ®å¯¹è±¡
   */
  info(message, data = {}) {
    this.logger.info(data, message);
  }

  /**
   * è®°å½•è­¦å‘Šä¿¡æ¯
   * @param {string} message - æ—¥å¿—æ¶ˆæ¯
   * @param {object} data - é™„åŠ æ•°æ®å¯¹è±¡
   */
  warn(message, data = {}) {
    this.logger.warn(data, message);
  }

  /**
   * è®°å½•é”™è¯¯ä¿¡æ¯
   * @param {string} message - æ—¥å¿—æ¶ˆæ¯
   * @param {object} data - é™„åŠ æ•°æ®å¯¹è±¡
   */
  error(message, data = {}) {
    this.logger.error(data, message);
  }

  /**
   * è®°å½•è‡´å‘½é”™è¯¯ä¿¡æ¯
   * @param {string} message - æ—¥å¿—æ¶ˆæ¯
   * @param {object} data - é™„åŠ æ•°æ®å¯¹è±¡
   */
  fatal(message, data = {}) {
    this.logger.fatal(data, message);
  }

  /**
   * åˆ›å»ºå­æ—¥å¿—è®°å½•å™¨
   * @param {object} bindings - ç»‘å®šåˆ°å­æ—¥å¿—è®°å½•å™¨çš„æ•°æ®
   * @returns {Logger} æ–°çš„æ—¥å¿—è®°å½•å™¨å®ä¾‹
   */
  child(bindings) {
    const childLogger = this.logger.child(bindings);
    const newLogger = new Logger();
    newLogger.logger = childLogger;
    return newLogger;
  }
}

module.exports = Logger;


================================================
FILE: src/mcp/action.js
================================================
require('module-alias/register');
require('dotenv').config();

const resolveServers = require("@src/mcp/server");

const resolveServer = async (name, context = {}) => {
  const servers = await resolveServers(context);
  const server = servers.find(server => server.name === name);
  return server;
}

const mcp_client = require('@src/mcp/client');

const mcpToolActionCall = async (params = {}, context = {}) => {
  console.log(JSON.stringify(params, null, 2))
  const { name, arguments } = params;
  const args = typeof arguments === 'string' ? JSON.parse(arguments) : arguments;
  const [serverName, toolName] = name.split('__');
  const server = await resolveServer(serverName, context);
  const options = {
    server: server,
    name: toolName,
    args
  }
  const result = await mcp_client.callTool(options);
  if (typeof result === 'object') {
    return JSON.stringify(result);
  }
  return result;
}

module.exports = mcpToolActionCall
// run();


================================================
FILE: src/mcp/binary.js
================================================
const which = require('which');
const { resolve } = require('path');
const { homedir } = require('os');

/**
 * åŠ¨æ€è·å–äºŒè¿›åˆ¶æ–‡ä»¶çš„è·¯å¾„ï¼Œä¼˜å…ˆä»ç³»ç»Ÿ PATH æŸ¥æ‰¾ï¼Œ
 * å¦‚æœæ‰¾ä¸åˆ°ï¼Œåˆ™å°è¯•åœ¨å¸¸è§çš„ç”¨æˆ·è‡ªå®šä¹‰è·¯å¾„ä¸‹æŸ¥æ‰¾ã€‚
 *
 * @param {string} command éœ€è¦æŸ¥æ‰¾çš„å‘½ä»¤ (ä¾‹å¦‚ 'bun' æˆ– 'uvx').
 * @returns {Promise<string>} è§£æå‡ºçš„äºŒè¿›åˆ¶æ–‡ä»¶è·¯å¾„.
 */
const getBinaryPath = async (command) => {
  try {
    // é¦–å…ˆå°è¯•åœ¨ç³»ç»Ÿçš„ PATH ç¯å¢ƒå˜é‡ä¸­æŸ¥æ‰¾
    const resolvedPath = await which(command);
    console.log(`[MCP] Found binary for '${command}' in system PATH: ${resolvedPath}`);
    return resolvedPath;
  } catch (error) {
    // å¦‚æœåœ¨ PATH ä¸­æ‰¾ä¸åˆ°ï¼Œå¯ä»¥æ ¹æ®éœ€è¦å°è¯•åœ¨ä¸€äº›é»˜è®¤ä½ç½®æŸ¥æ‰¾
    console.log(`[MCP] '${command}' not found in system PATH. Attempting to find in common user directories.`);
    const userPaths = {
      bun: resolve(homedir(), '.bun', 'bin', 'bun'),
      uvx: resolve(homedir(), '.local', 'bin', 'uvx'),
    };

    if (userPaths[command]) {
      try {
        const resolvedPath = await which(userPaths[command]);
        console.log(`[MCP] Found binary for '${command}' at fallback path: ${resolvedPath}`);
        return resolvedPath;
      } catch (fallbackError) {
        console.error(`[MCP] Failed to find '${command}' in both system PATH and fallback location (${userPaths[command]}).`);
      }
    }
  }

  // å¦‚æœæ‰€æœ‰æ–¹æ³•éƒ½å¤±è´¥äº†ï¼Œä½œä¸ºæœ€åçš„å¤‡é€‰æ–¹æ¡ˆï¼Œç›´æ¥è¿”å›å‘½ä»¤æœ¬èº«
  // è¿™ä¾èµ–äºæ‰§è¡Œ shell çš„ç¯å¢ƒèƒ½å¤Ÿè‡ªè¡Œè§£æ
  console.log(`[MCP] Assuming binary for '${command}' is in the system PATH and executable directly.`);
  return command;
}

module.exports = getBinaryPath

// ä½¿ç”¨ç¤ºä¾‹:
async function startMcp() {
  try {
    const bunPath = await getBinaryPath('bun');
    const uvxPath = await getBinaryPath('uvx');
    console.log('bun path:', bunPath);
    console.log('uvx path:', uvxPath);
  } catch (e) {
    console.error('Error starting MCP:', e);
  }
}

// startMcp();


================================================
FILE: src/mcp/cache.js
================================================
const CacheService = {
  _cache: new Map(),
  has(key) {
    const entry = this._cache.get(key);
    if (!entry) return false;
    if (entry.expiry && Date.now() > entry.expiry) {
      this._cache.delete(key);
      return false;
    }
    return true;
  },
  get(key) {
    if (this.has(key)) {
      return this._cache.get(key).value;
    }
    return undefined;
  },
  set(key, value, ttl) {
    const expiry = ttl ? Date.now() + ttl : null;
    this._cache.set(key, { value, expiry });
  },
  remove(key) {
    this._cache.delete(key);
  },
};



/**
 * é«˜é˜¶å‡½æ•°ï¼Œä¸ºä»»ä½•å¼‚æ­¥å‡½æ•°æ·»åŠ ç¼“å­˜èƒ½åŠ›
 * @param {Function} fn è¦è¢«åŒ…è£…çš„åŸå§‹å¼‚æ­¥å‡½æ•°
 * @param {Function} getCacheKey ä»å‡½æ•°å‚æ•°ç”Ÿæˆç¼“å­˜é”®çš„å‡½æ•°
 * @param {number} ttl ç¼“å­˜æ¡ç›®çš„å­˜æ´»æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
 * @param {string} logPrefix æ—¥å¿—æ¶ˆæ¯çš„å‰ç¼€
 * @returns {Function} åŒ…è£…åçš„å…·æœ‰ç¼“å­˜èƒ½åŠ›çš„å‡½æ•°
 */
function withCache(fn, getCacheKey, ttl, logPrefix) {
  return async (...args) => {
    const cacheKey = getCacheKey(...args);

    if (CacheService.has(cacheKey)) {
      console.log(`${logPrefix} loaded from cache`);
      const cachedData = CacheService.get(cacheKey);
      if (cachedData) {
        return cachedData;
      }
    }

    const result = await fn(...args);
    CacheService.set(cacheKey, result, ttl);
    return result;
  };
}

module.exports = {
  CacheService,
  withCache,
}


================================================
FILE: src/mcp/client.js
================================================
const os = require('node:os');
const path = require('node:path');

const resolveToolID = (server, tool) => {
  return `${server}__${tool}`;
}

const { CacheService, withCache } = require('./cache');
const { initTransport } = require('./transport');

class McpClient {
  clients = new Map();
  pendingClients = new Map();

  constructor() {
    this.initClient = this.initClient.bind(this);
    this.listTools = this.listTools.bind(this);
    this.callTool = this.callTool.bind(this);
    this.listPrompts = this.listPrompts.bind(this);
    this.getPrompt = this.getPrompt.bind(this);
    this.listResources = this.listResources.bind(this);
    this.getResource = this.getResource.bind(this);
    this.closeClient = this.closeClient.bind(this);
    this.removeServer = this.removeServer.bind(this);
    this.restartServer = this.restartServer.bind(this);
    this.stopServer = this.stopServer.bind(this);
    this.cleanup = this.cleanup.bind(this);
  }

  getServerKey(server) {
    return JSON.stringify({
      url: server.url,
      command: server.command,
      args: Array.isArray(server.args) ? server.args : [],
      registryUrl: server.registryUrl,
      env: server.env,
      id: server.id,
    });
  }

  async initClient(server) {
    const serverKey = this.getServerKey(server);

    const pendingClient = this.pendingClients.get(serverKey);
    if (pendingClient) {
      return pendingClient;
    }

    const existingClient = this.clients.get(serverKey);

    if (existingClient) {
      try {
        const pingResult = await existingClient.ping();
        console.log(`[MCP] Ping result for ${server.name}:`, pingResult);
        if (!pingResult) {
          this.clients.delete(serverKey);
        } else {
          return existingClient;
        }
      } catch (error) {
        console.error(`[MCP] Error pinging server ${server.name}:`, error?.message);
        this.clients.delete(serverKey);
      }
    }

    const initPromise = (async () => {
      try {
        const { Client } = await import("@modelcontextprotocol/sdk/client/index.js");
        const client = new Client({ name: 'LemonAI MCP Client', version: '1.0.0' }, { capabilities: {} });

        try {
          const transport = await initTransport(server);
          try {
            await client.connect(transport);
          } catch (error) {
            console.log('error', error);
          }
          this.clients.set(serverKey, client);
          console.log(`[MCP] Activated server: ${server.name}`);
          return client;
        } catch (error) {
          console.error(`[MCP] Error activating server ${server.name}:`, error?.message);
          throw new Error(`[MCP] Error activating server ${server.name}: ${error.message}`);
        }
      } finally {
        this.pendingClients.delete(serverKey);
      }
    })();

    this.pendingClients.set(serverKey, initPromise);
    return initPromise;
  }

  async closeClient(serverKey) {
    const client = this.clients.get(serverKey);
    if (client) {
      await client.close();
      console.log(`[MCP] Closed server: ${serverKey}`);
      this.clients.delete(serverKey);
      CacheService.remove(`mcp:list_tool:${serverKey}`);
      console.log(`[MCP] Cleared cache for server: ${serverKey}`);
    } else {
      console.warn(`[MCP] No client found for server: ${serverKey}`);
    }
  }

  async stopServer(server) {
    const serverKey = this.getServerKey(server);
    console.log(`[MCP] Stopping server: ${server.name}`);
    await this.closeClient(serverKey);
  }

  async removeServer(server) {
    const serverKey = this.getServerKey(server);
    if (this.clients.has(serverKey)) {
      await this.closeClient(serverKey);
    }
  }

  async restartServer(server) {
    console.log(`[MCP] Restarting server: ${server.name}`);
    const serverKey = this.getServerKey(server);
    await this.closeClient(serverKey);
    await this.initClient(server);
  }

  async cleanup() {
    for (const [key] of this.clients) {
      try {
        await this.closeClient(key);
      } catch (error) {
        console.error(`[MCP] Failed to close client: ${error?.message}`);
      }
    }
  }

  async checkMcpConnectivity(server) {
    console.log(`[MCP] Checking connectivity for server: ${server.name}`);
    try {
      const client = await this.initClient(server);
      await client.listTools();
      console.log(`[MCP] Connectivity check successful for server: ${server.name}`);
      return true;
    } catch (error) {
      console.error(`[MCP] Connectivity check failed for server: ${server.name}`, error);
      const serverKey = this.getServerKey(server);
      await this.closeClient(serverKey);
      return false;
    }
  }

  async listToolsImpl(server) {
    console.log(`[MCP] Listing tools for server: ${server.name}`);
    const client = await this.initClient(server);
    try {
      const { tools } = await client.listTools();
      return tools.map((tool) => ({
        ...tool,
        id: resolveToolID(server.name, tool.name),
        serverId: server.id,
        serverName: server.name,
      }));
    } catch (error) {
      console.error(`[MCP] Failed to list tools for server: ${server.name}`, error?.message);
      return [];
    }
  }

  async listTools(server) {
    const cachedListTools = withCache(
      this.listToolsImpl.bind(this),
      (server) => `mcp:list_tool:${this.getServerKey(server)}`,
      5 * 60 * 1000, // 5 minutes TTL
      `[MCP] Tools from ${server.name}`
    );
    return cachedListTools(server);
  }

  async callTool({ server, name, args }) {
    try {
      console.log('[MCP] Calling:', server.name, name, args);
      if (typeof args === 'string') {
        try {
          args = JSON.parse(args);
        } catch (e) {
          console.error('[MCP] args parse error', args);
        }
      }
      console.log("====args=====",args)

      const client = await this.initClient(server);
      return await client.callTool({ name, arguments: args }, undefined, {
        timeout: server.timeout ? server.timeout * 1000 : 60000, // Default timeout of 1 minute
      });
    } catch (error) {
      console.error("===!!!===",error)
      console.error(`[MCP] Error calling tool ${name} on ${server.name}:`, error);
      throw error;
    }
  }

  async getInstallInfo() {
    const dir = path.join(os.homedir(), '.cherrystudio', 'bin');
    // In node, we might not have a reliable way to get the exact binary name like in electron,
    // so we assume standard names.
    const uvName = os.platform() === 'win32' ? 'uv.exe' : 'uv';
    const bunName = os.platform() === 'win32' ? 'bun.exe' : 'bun';
    const uvPath = path.join(dir, uvName);
    const bunPath = path.join(dir, bunName);
    return { dir, uvPath, bunPath };
  }

  async listPromptsImpl(server) {
    const client = await this.initClient(server);
    console.log(`[MCP] Listing prompts for server: ${server.name}`);
    try {
      const { prompts } = await client.listPrompts();
      return prompts.map((prompt) => ({
        ...prompt,
        id: `p${Math.random()}`,
        serverId: server.id,
        serverName: server.name,
      }));
    } catch (error) {
      if (error?.code !== -32601) { // -32601 is method not found
        console.error(`[MCP] Failed to list prompts for server: ${server.name}`, error?.message);
      }
      return [];
    }
  }

  async listPrompts(server) {
    const cachedListPrompts = withCache(
      this.listPromptsImpl.bind(this),
      (server) => `mcp:list_prompts:${this.getServerKey(server)}`,
      60 * 60 * 1000, // 60 minutes TTL
      `[MCP] Prompts from ${server.name}`
    );
    return cachedListPrompts(server);
  }

  async getPromptImpl(server, name, args) {
    console.log(`[MCP] Getting prompt ${name} from server: ${server.name}`);
    const client = await this.initClient(server);
    return await client.getPrompt({ name, arguments: args });
  }

  async getPrompt({ server, name, args }) {
    const cachedGetPrompt = withCache(
      this.getPromptImpl.bind(this),
      (server, name, args) => {
        const serverKey = this.getServerKey(server);
        const argsKey = args ? JSON.stringify(args) : 'no-args';
        return `mcp:get_prompt:${serverKey}:${name}:${argsKey}`;
      },
      30 * 60 * 1000, // 30 minutes TTL
      `[MCP] Prompt ${name} from ${server.name}`
    );
    return await cachedGetPrompt(server, name, args);
  }

  async listResourcesImpl(server) {
    const client = await this.initClient(server);
    console.log(`[MCP] Listing resources for server: ${server.name}`);
    try {
      const result = await client.listResources();
      const resources = result.resources || [];
      return (Array.isArray(resources) ? resources : []).map((resource) => ({
        ...resource,
        serverId: server.id,
        serverName: server.name,
      }));
    } catch (error) {
      if (error?.code !== -32601) { // -32601 is method not found
        console.error(`[MCP] Failed to list resources for server: ${server.name}`, error?.message);
      }
      return [];
    }
  }

  async listResources(server) {
    const cachedListResources = withCache(
      this.listResourcesImpl.bind(this),
      (server) => `mcp:list_resources:${this.getServerKey(server)}`,
      60 * 60 * 1000, // 60 minutes TTL
      `[MCP] Resources from ${server.name}`
    );
    return cachedListResources(server);
  }

  async getResourceImpl(server, uri) {
    console.log(`[MCP] Getting resource ${uri} from server: ${server.name}`);
    const client = await this.initClient(server);
    try {
      const result = await client.readResource({ uri: uri });
      const contents = [];
      if (result.contents && result.contents.length > 0) {
        result.contents.forEach((content) => {
          contents.push({
            ...content,
            serverId: server.id,
            serverName: server.name,
          });
        });
      }
      return { contents: contents };
    } catch (error) {
      console.error(`[MCP] Failed to get resource ${uri} from server: ${server.name}`, error.message);
      throw new Error(`Failed to get resource ${uri} from server: ${server.name}: ${error.message}`);
    }
  }

  async getResource({ server, uri }) {
    const cachedGetResource = withCache(
      this.getResourceImpl.bind(this),
      (server, uri) => `mcp:get_resource:${this.getServerKey(server)}:${uri}`,
      30 * 60 * 1000, // 30 minutes TTL
      `[MCP] Resource ${uri} from ${server.name}`
    );
    return await cachedGetResource(server, uri);
  }

  removeProxyEnv(env) {
    delete env.HTTPS_PROXY;
    delete env.HTTP_PROXY;
    delete env.grpc_proxy;
    delete env.http_proxy;
    delete env.https_proxy;
  }
}

module.exports = new McpClient();


================================================
FILE: src/mcp/prompt.js
================================================
require('module-alias/register')
require('dotenv').config()
const { json2xml } = require("@src/utils/format");

const resolveMcpToolPrompt = async (tool = {}) => {
  const { id, serverName, name, description, inputSchema } = tool
  console.log(id);
  const tool_key = id || `mcp__${serverName}__${name}`
  const xml = json2xml({
    ['tool mcp_tool']: {
      name: tool_key,
      description,
      arguments: JSON.stringify(inputSchema)
    }
  })
  return xml;
}

const resolveMcpPrompt = async (tools = []) => {
  const list = []
  for (const tool of tools) {
    const prompt = await resolveMcpToolPrompt(tool);
    list.push(prompt);
  }
  return list.join('\n');
}

const mcp_client = require('./client');
const loadAllTools = async (servers = []) => {
  const all_tools = []
  for (const server of servers) {
    const tools = await mcp_client.listToolsImpl(server)
    all_tools.push(...tools)
  }
  return all_tools;
}

const resolveMcpServerPrompt = async (servers = []) => {
  if (servers.length === 0) {
    return ''
  }
  const tools = await loadAllTools(servers);
  const mcp_tool_prompt = await resolveMcpPrompt(tools);
  const mcp_guide_prompt = `
${mcp_tool_prompt}
=== mcp_tool call result format ===
<mcp_tool>
  <name>tool name</name>
  <arguments> {json_format args} </arguments>
</mcp_tool>
===`
  return mcp_guide_prompt
}

module.exports = exports = {
  resolveMcpToolPrompt,
  resolveMcpPrompt,
  resolveMcpServerPrompt
}


================================================
FILE: src/mcp/server.js
================================================
const path = require("path");
const fs = require("fs");

const filepath = path.resolve(__dirname, "../../mcp-local.json");
const exists = fs.existsSync(filepath);

const McpServer = require("@src/models/McpServer");
const { Op } = require("sequelize");
const resolveMcpServers = async (mcp_server_ids = []) => {
  console.log("mcp_server_ids", mcp_server_ids);
  const servers = await McpServer.findAll({
    where: {
      id: { [Op.in]: mcp_server_ids },
      activate: true,
    },
  });
  return servers;
};

const resolveServers = async (context = {}) => {
  const { mcp_server_ids = [] } = context;
  console.log("resolveServers mcp_server_ids", mcp_server_ids);
  if (mcp_server_ids.length > 0) {
    return resolveMcpServers(mcp_server_ids);
  }
  if (exists) {
    const list = require(filepath);
    // è¿”å›å¼€å¯ä½¿ç”¨çš„ mcp servers
    return list.filter((item) => item.activate);
  }
  return [];
};

module.exports = exports = resolveServers;



================================================
FILE: src/mcp/tool.js
================================================
const mcpToolCall = require('./action');

const mcp_tool = {
  name: "mcp_tool",
  description: "mcp_tool: provides a set of methods to accomplish specific task",
  params: {
    type: "object",
    properties: {
      name: {
        type: "string",
        description: "tool name"
      },
      arguments: {
        type: "object",
        description: "tool arguments"
      }
    }
  },
  memorized: true,
  getActionDescription({ name, arguments }) {
    return `${name} ${JSON.stringify(arguments)}`;
  },
  async execute(action, uuid, context = {}) {
    const result = await mcpToolCall(action, context);
    // return result;
    return {
      uuid,
      status: 'success',
      content: result,
      meta: {
        action_type: action.type,
      }
    };
  }
}

module.exports = mcp_tool;


================================================
FILE: src/mcp/transport.js
================================================
const getBinaryPath = require('./binary');

const initStreamTransport = async (server = {}) => {
  const sse_url = server.url;
  if (server.type === 'streamableHttp') {
    const { StreamableHTTPClientTransport } = await import('@modelcontextprotocol/sdk/client/streamableHttp')
    const options = {
      requestInit: { headers: server.headers || {} },
    };
    return new StreamableHTTPClientTransport(new URL(sse_url), options);
  } else if (server.type === 'sse') {
    const options = {
      // eventSourceInit: {
      //   fetch: async (url, init) => {
      //     const headers = { ...(server.headers || {}), ...(init?.headers || {}) };
      //     return fetch(url, { ...init, headers });
      //   },
      // },
      requestInit: { headers: server.headers || {} },
    };
    const { SSEClientTransport } = await import('@modelcontextprotocol/sdk/client/sse.js');
    console.log(sse_url);
    return new SSEClientTransport(new URL(sse_url), options);
  } else {
    throw new Error('Invalid server type');
  }
}

const initStdioTransport = async (server = {}) => {
  const args = [...(server.args || [])];
  let cmd = server.command;
  if (server.command === 'npx') {
    cmd = await getBinaryPath('bun');
    console.log(`[MCP] Using command: ${cmd}`);
    if (args && args.length > 0) {
      if (!args.includes('-y')) args.unshift('-y');
      if (!args.includes('x')) args.unshift('x');
    }
    if (server.registryUrl) {
      server.env = { ...server.env, NPM_CONFIG_REGISTRY: server.registryUrl };
    }
  } else if (server.command === 'uvx' || server.command === 'uv') {
    cmd = await getBinaryPath(server.command);
    if (server.registryUrl) {
      server.env = { ...server.env, UV_DEFAULT_INDEX: server.registryUrl, PIP_INDEX_URL: server.registryUrl };
    }
  }

  console.log(`[MCP] Starting server with command: ${cmd} ${args ? args.join(' ') : ''}`);
  const { StdioClientTransport } = await import('@modelcontextprotocol/sdk/client/stdio.js');
  const stdioTransport = new StdioClientTransport({
    command: cmd,
    args,
    env: { ...server.env },
    stderr: 'pipe',
  });
  stdioTransport.stderr?.on('data', (data) =>
    console.log(`[MCP] Stdio stderr for server: ${server.name} `, data.toString())
  );
  return stdioTransport;
}

const initTransport = async (server = {}) => {
  if (server.url) {
    const transport = await initStreamTransport(server);
    return transport
  }
  if (server.command) {
    const transport = await initStdioTransport(server);
    return transport;
  }
};

module.exports = exports = {
  initTransport
}


================================================
FILE: src/middlewares/auth.js
================================================

/**
 * Token æ ¡éªŒä¸­é—´ä»¶
 * é™¤äº†æŒ‡å®šçš„ä¸éœ€è¦æ ¡éªŒçš„æ¥å£å¤–ï¼Œå…¶ä»–æ¥å£å‡éœ€æ ¡éªŒ Token
 * @param {Array} excludePaths - ä¸éœ€è¦æ ¡éªŒ Token çš„æ¥å£è·¯å¾„æ•°ç»„
 */

const excludePatterns = [
  '/api/agent_store/last/'
];

module.exports = () => {
  return async (ctx, next) => {

    // ç›´æ¥è®¾ç½®é»˜è®¤ç”¨æˆ· ID ä¸º 1ï¼Œä¸è¿›è¡Œ Token æ ¡éªŒ
    ctx.state.user = { id: 1 };
    await next();
  };
};



================================================
FILE: src/middlewares/setGlobalToken.js
================================================
// middleware/setGlobalToken.js
const globals = require('../globals'); // ç¡®ä¿è¿™é‡Œçš„è·¯å¾„æ˜¯æ­£ç¡®çš„ï¼ŒæŒ‡å‘ä½ çš„globals.jsæ–‡ä»¶

module.exports = async (ctx, next) => {
  const authHeader = ctx.request.headers.authorization;

  if (authHeader && authHeader.startsWith('Bearer ')) {
    const token = authHeader.split(' ')[1];
    globals.setToken(token); // ä¸æ¨èï¼šè¿™å°†è¦†ç›–å‰ä¸€ä¸ªè¯·æ±‚çš„token
  } else {
    // å¦‚æœæ²¡æœ‰tokenï¼Œå¯ä»¥é€‰æ‹©æ¸…ç©ºå…¨å±€tokenæˆ–ä¸åšä»»ä½•æ“ä½œ
    // globals.setToken(null);
  }

  await next(); // ç»§ç»­å¤„ç†åç»­çš„ä¸­é—´ä»¶æˆ–è·¯ç”±
};


================================================
FILE: src/middlewares/wrap.context.js
================================================
const {getContentTypeByFileName} = require('@src/utils/file_type_response');

const responseWrap = (response) => {
    response.success = function (data, msg = "æˆåŠŸ", status = 200) {
      const res = {
        data,
        code: 0,
        msg,
      };
      this.body = res;
      this.status = status;
    };
  
    response.fail = function (data, msg = "æ¥å£é”™è¯¯", status = 200) {
      const res = {
        data,
        code: 1,
        msg,
      };
      this.body = res;
      this.status = status;
    };
  
    response.file = function (fileName, stream) {
      // process Content-Type by file type
      const contentType = getContentTypeByFileName(fileName)
      response.set('Content-Type', contentType)
      response.set(
        'Content-Disposition',
        `attachment; filename=${encodeURIComponent(fileName)}`
      )
      this.body = stream
    };
  };
  
  module.exports = exports = async (ctx, next) => {
    responseWrap(ctx.response);
    await next();
  };
  


================================================
FILE: src/models/Agent.js
================================================
const sequelize = require('./index.js');
const { Model, DataTypes } = require("sequelize");

class ConversationTable extends Model { }

const fields = {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true,
    allowNull: false,
    comment: 'Model ID'
  },
  user_id: {
    type: DataTypes.INTEGER,
    allowNull: true,
  },
  name: {
    type: DataTypes.STRING,
    allowNull: false,
    defaultValue: '',
    comment: 'name'
  },
  describe: {
    type: DataTypes.TEXT,
    allowNull: false,
    comment: 'describe'
  },
  mcp_server_ids: {
    type: DataTypes.JSON,
    allowNull: true,
  },
  is_public: {
    type: DataTypes.BOOLEAN,
    defaultValue: true
  },
  direct_reference_count: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 0,
    comment: 'æ­¤ä»£ç†è¢«ç”¨æˆ·ç›´æ¥å¼•ç”¨çš„æ¬¡æ•°'
  },
  auto_reference_count: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 0,
    comment: 'æ­¤ä»£ç†è¢«ç³»ç»Ÿè‡ªåŠ¨é€‰æ‹©çš„æ¬¡æ•°'
  },
  // æ–°å¢å­—æ®µï¼šæ€»çš„è¢«å¼•ç”¨æ¬¡æ•°
  total_reference_count: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 0,
    comment: 'æ­¤ä»£ç†è¢«å¼•ç”¨çš„æ€»æ¬¡æ•°'
  },
  // æ–°å¢å­—æ®µï¼šknowledgeæ¡ç›®æ•°
  knowledge_count: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 0,
    comment: 'knowledgeæ¡ç›®æ•°'
  },
  // æ–°å¢å­—æ®µï¼šç»éªŒè¿­ä»£æ¬¡æ•°
  experience_iteration_count: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 0,
    comment: 'ç»éªŒè¿­ä»£æ¬¡æ•°'
  },
  screen_shot_url:{
    type: DataTypes.STRING,
    allowNull: true,
    comment: 'æˆªå±url'
  },
  source_agent_ids: {
    type: DataTypes.JSON,
    allowNull: true,
    defaultValue: [],
    comment: 'æ­¤ä»£ç†æ¥è‡ªäºå“ªäº›agent_idçš„æ•°ç»„'
  },
  replay_conversation_id: {
    type: DataTypes.STRING,
    allowNull: true,
    comment: 'ç”¨æ¥å±•ç¤ºçš„conversation_idï¼Œå¦‚æœæ˜¯ç©ºï¼Œå±•ç¤ºæœ€æ–°çš„'
  },
  recommend:{
    type: DataTypes.INTEGER,
    defaultValue: 0,
    comment: 'æ¨èæ¬¡æ•°'
  },
  deleted_at: {
    type: DataTypes.DATE,
    allowNull: true,
    comment: 'Delete Time (for soft delete)'
  },
  create_at: {
    type: DataTypes.DATE,
    allowNull: false,
    defaultValue: DataTypes.NOW,
    comment: 'Create Time'
  },
  update_at: {
    type: DataTypes.DATE,
    allowNull: false,
    defaultValue: DataTypes.NOW,
    comment: 'Update Time'
  },
};

ConversationTable.init(fields, {
  sequelize,
  modelName: 'agent'
});

module.exports = exports = ConversationTable;


================================================
FILE: src/models/BaseModel.js
================================================
const { Model, DataTypes } = require('sequelize');
const Sequelize = require('sequelize');

/**
 * https://sequelize.org/
 * https://sequelize.org/api/v6/class/src/model.js~model#static-method-init
 */
class BaseModel extends Model {
  static init(attributes = {}, options = {}) {
    // console.log(arguments);
    // å®šä¹‰å…¬å…±å­—æ®µ
    const commonFields = {
      create_time: {
        type: DataTypes.DATE,
        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
        comment: 'Create Time'
      },
      update_time: {
        type: DataTypes.DATE,
        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
        onUpdate: Sequelize.literal('CURRENT_TIMESTAMP'),
        comment: 'Update Time'
      },
      delete_time: {
        type: DataTypes.DATE,
        comment: 'Delete Time'
      },
    };

    // åˆå¹¶å…¬å…±å­—æ®µå’Œç‰¹å®šå­—æ®µ
    const mergedAttributes = {
      id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true,
      },
      ...attributes,
      ...commonFields
    };

    // è®¾ç½®é»˜è®¤é…ç½®
    const defaultOptions = {
      timestamps: false,
      ...options
    };
    // console.log(mergedAttributes, defaultOptions);
    super.init(mergedAttributes, defaultOptions);
  }
}

module.exports = exports = BaseModel;


================================================
FILE: src/models/Conversation.js
================================================
const { type } = require('os');
const sequelize = require('./index.js');
const { Model, DataTypes } = require("sequelize");

class ConversationTable extends Model { }

const fields = {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true,
    allowNull: false,
    comment: 'Model ID'
  },
  user_id: {
    type: DataTypes.INTEGER,
    allowNull: true,
  },
  agent_id: {
    type: DataTypes.INTEGER,
    allowNull: true,
  },
  mode_type:{
    type: DataTypes.STRING,
    allowNull: false,
    defaultValue: 'task',
    comment: 'Task type' // current mode: task(default) , chat
  },
  conversation_id: {
    type: DataTypes.STRING,
    allowNull: false,
    comment: 'Conversation ID'
  },
  selected_repository: {
    type: DataTypes.STRING,
    allowNull: true,
    comment: 'Associated Code Repository'
  },
  title: {
    type: DataTypes.STRING,
    allowNull: false,
    comment: 'Title'
  },
  content: {
    type: DataTypes.TEXT,
    allowNull: false,
    comment: 'Content'
  },
  input_tokens: {
    type: DataTypes.INTEGER,
    allowNull: true,
    comment: 'Input Tokens',
    defaultValue: 0
  },
  output_tokens: {
    type: DataTypes.INTEGER,
    allowNull: true,
    comment: 'Output Tokens',
    defaultValue: 0
  },
  usage_point: {
    type: DataTypes.DECIMAL(14, 4),
    allowNull: false,
    comment: 'æ¶ˆè€—çš„ç§¯åˆ†',
    defaultValue: 0
  },
  create_at: {
    type: DataTypes.DATE,
    allowNull: false,
    defaultValue: DataTypes.NOW,
    comment: 'Create Time'
  },
  update_at: {
    type: DataTypes.DATE,
    allowNull: false,
    defaultValue: DataTypes.NOW,
    comment: 'Update Time'
  },
  is_favorite: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: false,
    comment: 'Is Favorite'
  },
  deleted_at: {
    type: DataTypes.DATE,
    allowNull: true,
    comment: 'Delete Time (for soft delete)'
  },
  status: {
    type: DataTypes.STRING,
    allowNull: false,
    defaultValue: 'done',
    comment: 'Status'
  },
  is_from_sub_server: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: false,
    comment: 'Is From Sub Server'
  },
  model_id: {
    type: DataTypes.INTEGER,
    allowNull: true,
    comment: 'model id',
  },
  docset_id: {
    type: DataTypes.STRING,
    allowNull: true,
    comment: 'Aryn Docset ID for document parsing',
  },
  twins_id:{
    type: DataTypes.STRING,
    allowNull: true,
    comment: 'twins id',
  }
  // is_public: {
  //   type: DataTypes.BOOLEAN,
  //   defaultValue: true
  // },
  // screen_shot_url:{
  //   type: DataTypes.STRING,
  //   allowNull: true,
  //   comment: 'æˆªå±url'
  // },
  // recommend:{
  //   type: DataTypes.INTEGER,
  //   defaultValue: 0,
  //   comment: 'æ¨èæ¬¡æ•°'
  // },
};

ConversationTable.init(fields, {
  sequelize,
  modelName: 'conversation'
});


module.exports = exports = ConversationTable;


================================================
FILE: src/models/DefaultModelSetting.js
================================================
const sequelize = require('./index.js');
const { Model, DataTypes } = require("sequelize");

class DefaultModelSettingTable extends Model { }

const fields = {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true,
    allowNull: false,
    comment: 'ID'
  },
  user_id: {
    type: DataTypes.BIGINT,
    allowNull: true,
    comment: 'ç”¨æˆ·ID'
  },
  setting_type: {
    type: DataTypes.STRING,
    allowNull: false,
    comment: 'Setting Type'
  },
  model_id: {
    type: DataTypes.STRING(255),
    allowNull: false,
    comment: 'Model ID'
  },
  config: {
    type: DataTypes.JSON,
    allowNull: false,
    comment: 'Configuration Information'
  },
  create_at: {
    type: DataTypes.DATE,
    allowNull: false,
    defaultValue: DataTypes.NOW,
    comment: 'Create Time'
  },
  update_at: {
    type: DataTypes.DATE,
    allowNull: false,
    defaultValue: DataTypes.NOW,
    comment: 'Update Time'
  }
};

DefaultModelSettingTable.init(fields, {
  sequelize,
  modelName: 'default_model_setting'
});

module.exports = exports = DefaultModelSettingTable;


================================================
FILE: src/models/File.js
================================================
const sequelize = require('./index.js');
const { Model, DataTypes } = require("sequelize");

class FileTable extends Model { }

const fields = {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true,
    allowNull: false,
    comment: 'Model ID'
  },
  user_id: {
    type: DataTypes.BIGINT,
    allowNull: true,
    comment: 'ç”¨æˆ·ID'
  },
  conversation_id: {
    type: DataTypes.STRING,
    allowNull: false,
    comment: 'Conversation ID'
  },
  url: {
    type: DataTypes.STRING,
    allowNull: false,
    comment: 'url'
  },
  name: {
    type: DataTypes.STRING,
    allowNull: false,
    comment: 'Title'
  },
  create_at: {
    type: DataTypes.DATE,
    allowNull: false,
    defaultValue: DataTypes.NOW,
    comment: 'Create Time'
  },
  update_at: {
    type: DataTypes.DATE,
    allowNull: false,
    defaultValue: DataTypes.NOW,
    comment: 'Update Time'
  }
};

FileTable.init(fields, {
  sequelize,
  modelName: 'file'
});


module.exports = exports = FileTable;


================================================
FILE: src/models/FileVersion.js
================================================
const sequelize = require('./index.js');
const { Model, DataTypes } = require("sequelize");

class FileVersionTable extends Model { }

const fields = {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true,
    allowNull: false,
    comment: 'Version ID'
  },
  user_id: {
    type: DataTypes.BIGINT,
    allowNull: true,
    comment: 'ç”¨æˆ·ID'
  },
  conversation_id: {
    type: DataTypes.STRING,
    allowNull: false,
    comment: 'Conversation ID'
  },
  filepath: {
    type: DataTypes.STRING,
    allowNull: false,
    comment: 'æ–‡ä»¶è·¯å¾„'
  },
  content: {
    type: DataTypes.TEXT('long'),
    allowNull: false,
    comment: 'æ–‡ä»¶å†…å®¹'
  },
  version: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 1,
    comment: 'ç‰ˆæœ¬å·'
  },
  create_at: {
    type: DataTypes.DATE,
    allowNull: false,
    defaultValue: DataTypes.NOW,
    comment: 'Create Time'
  },
  active: {
    type: DataTypes.BOOLEAN,
    defaultValue: false,
    comment: 'æ˜¯å¦å½“å‰ç‰ˆæœ¬'
  }
};

FileVersionTable.init(fields, {
  sequelize,
  modelName: 'file_version',
  indexes: [
    {
      name: 'idx_conversation_filepath',
      fields: ['conversation_id', 'filepath']
    },
    {
      name: 'idx_user_conversation',
      fields: ['user_id', 'conversation_id']
    }
  ]
});

module.exports = exports = FileVersionTable;


================================================
FILE: src/models/index.js
================================================
const { Sequelize } = require('sequelize');

const { getFilepath } = require('@src/utils/electron');
const sqliteFilepath = getFilepath('data', 'database.sqlite');

const sequelize = new Sequelize({
  dialect: 'sqlite',
  storage: sqliteFilepath,
  define: {
    timestamps: false,
    freezeTableName: true,
  },
  logging: false
});
module.exports = exports = sequelize;



================================================
FILE: src/models/Knowledge.js
================================================
const sequelize = require('./index.js');
const { Model, DataTypes } = require("sequelize");

class KnowledgeTable extends Model { }

const fields = {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true,
    allowNull: false,
    comment: 'Model ID'
  },
  user_id: {
    type: DataTypes.INTEGER,
    allowNull: true,
  },
  agent_id: {
    type: DataTypes.INTEGER,
    allowNull: true,
  },
  content: {
    type: DataTypes.TEXT,
    allowNull: false,
    defaultValue: '',
  },
  category: {
    type: DataTypes.STRING,
    allowNull: false,
  },
  is_learned: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: false,
    comment: 'æ˜¯å¦é€šè¿‡å­¦ä¹ å…¶ä»–agentçš„knowledgeè€Œæ¥'
  },
  create_at: {
    type: DataTypes.DATE,
    allowNull: false,
    defaultValue: DataTypes.NOW,
    comment: 'Create Time'
  },
  update_at: {
    type: DataTypes.DATE,
    allowNull: false,
    defaultValue: DataTypes.NOW,
    comment: 'Update Time'
  },
};

KnowledgeTable.init(fields, {
  sequelize,
  modelName: 'knowledge'
});

module.exports = exports = KnowledgeTable;


================================================
FILE: src/models/LLMLogs.js
================================================
const sequelize = require('./index.js');
const { DataTypes } = require("sequelize");
const BaseModel = require('./BaseModel.js');

class LLMLogs extends BaseModel { }

LLMLogs.init({
  id: {
    type: DataTypes.BIGINT,
    primaryKey: true,
    autoIncrement: true,
    comment: 'ID'
  },
  conversation_id: {
    type: DataTypes.STRING,
    allowNull: true,
    comment: 'Conversation ID'
  },
  model: {
    type: DataTypes.STRING(100),
    comment: 'Model'
  },
  prompt: {
    type: DataTypes.TEXT('long'),
    comment: 'Prompt'
  },
  messages: {
    type: DataTypes.JSON,
    comment: 'Messages'
  },
  content: {
    type: DataTypes.TEXT('long'),
    comment: 'Content'
  },
  json: {
    type: DataTypes.JSON,
    comment: 'JSON'
  },
}, {
  sequelize,
  tableName: 'llm_logs',
  timestamps: false,
  comment: 'LLM Logs'
});

module.exports = exports = LLMLogs;


================================================
FILE: src/models/McpServer.js
================================================
const sequelize = require('./index.js');
const { Model, DataTypes } = require("sequelize");

class McpServerTable extends Model { }

const fields = {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true,
    allowNull: false,
    comment: 'MCP Server ID'
  },
  user_id: {
    type: DataTypes.BIGINT,
    allowNull: false,
    comment: 'ç”¨æˆ·ID'
  },
  name: {
    type: DataTypes.STRING(255),
    allowNull: true,
    comment: 'MCP Server Name'
  },
  url: {
    type: DataTypes.STRING(255),
    allowNull: true,
    comment: 'MCP Server URL'
  },
  description: {
    type: DataTypes.STRING(255),
    allowNull: true,
    comment: 'MCP Server Description'
  },
  activate: {
    type: DataTypes.BOOLEAN,
    allowNull: true,
    defaultValue: false,
    comment: 'Is Active'
  },
  type: {
    type: DataTypes.STRING(50),
    allowNull: true,
    defaultValue: 'stdio',
    comment: 'Server Type'
  },
  command: {
    type: DataTypes.STRING(255),
    allowNull: true,
    comment: 'Server Command'
  },
  registryUrl: {
    type: DataTypes.STRING(255),
    allowNull: true,
    comment: 'Registry URL'
  },
  args: {
    type: DataTypes.JSON,
    allowNull: true,
    comment: 'Command Arguments'
  },
  env: {
    type: DataTypes.JSON,
    allowNull: true,
    comment: 'Environment Variables'
  },
  api_key: {
    type: DataTypes.STRING(255),
    allowNull: true,
    comment: 'API Key'
  },
  is_default: {
    type: DataTypes.BOOLEAN,
    allowNull: true,
    defaultValue: true,
    comment: 'Is Default Server'
  },
  create_at: {
    type: DataTypes.DATE,
    allowNull: true,
    defaultValue: DataTypes.NOW,
    comment: 'Created At'
  },
  update_at: {
    type: DataTypes.DATE,
    allowNull: true,
    defaultValue: DataTypes.NOW,
    comment: 'Updated At'
  }
};

McpServerTable.init(fields, {
  sequelize,
  modelName: 'mcp_server',
  timestamps: false
});

module.exports = exports = McpServerTable;



================================================
FILE: src/models/Message.js
================================================
const sequelize = require('./index.js');
const { Model, DataTypes } = require("sequelize");

class MessageTable extends Model { }

const fields = {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true,
    allowNull: false,
    comment: 'ID'
  },
  user_id: {
    type: DataTypes.BIGINT,
    allowNull: true,
    comment: 'ç”¨æˆ·ID'
  },
  role: {
    type: DataTypes.STRING(255),
    allowNull: false,
    comment: 'Role'
  },
  uuid: {
    type: DataTypes.STRING(255),
    allowNull: true,
    comment: 'UUID'
  },
  conversation_id: {
    type: DataTypes.STRING(255),
    allowNull: false,
    comment: 'Conversation ID'
  },
  status: {
    type: DataTypes.STRING(255),
    allowNull: false,
    comment: 'Status'
  },
  content: {
    type: DataTypes.TEXT,
    allowNull: false,
    comment: 'Content'
  },
  timestamp: {
    type: DataTypes.BIGINT,
    allowNull: false,
    comment: 'Timestamp'
  },
  meta: {
    type: DataTypes.JSON,
    allowNull: false,
    comment: 'Meta'
  },
  comments: {
    type: DataTypes.TEXT('long'),
    allowNull: true,
    comment: 'Comments'
  },
  memorized: {
    type: DataTypes.TEXT,
    defaultValue: '',
    allowNull: true,
    comment: 'Memorized'
  },
  create_at: {
    type: DataTypes.DATE,
    allowNull: false,
    defaultValue: DataTypes.NOW,
    comment: 'Created At'
  },
  update_at: {
    type: DataTypes.DATE,
    allowNull: false,
    defaultValue: DataTypes.NOW,
    comment: 'Updated At'
  }
};

MessageTable.init(fields, {
  sequelize,
  modelName: 'message'
});

module.exports = exports = MessageTable;


================================================
FILE: src/models/Model.js
================================================
const sequelize = require('./index.js');
const { Model, DataTypes } = require("sequelize");

class ModelTable extends Model { }

const fields = {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true,
    allowNull: false,
    comment: 'Model ID'
  },
  logo_url: {
    type: DataTypes.STRING(255),
    allowNull: true,
    comment: 'Logo URL'
  },
  platform_id: {
    type: DataTypes.INTEGER,
    allowNull: false,
    comment: 'Platform ID'
  },
  model_id: {
    type: DataTypes.STRING(255),
    allowNull: false,
    comment: 'Model ID'
  },
  model_name: {
    type: DataTypes.STRING(255),
    allowNull: false,
    comment: 'Model Name'
  },
  group_name: {
    type: DataTypes.STRING(255),
    allowNull: false,
    comment: 'Group Name'
  },
  model_types: {
    type: DataTypes.JSON,
    comment: 'Model Types'
  },
  create_at: {
    type: DataTypes.DATE,
    allowNull: false,
    defaultValue: DataTypes.NOW,
    comment: 'Created At'
  },
  update_at: {
    type: DataTypes.DATE,
    allowNull: false,
    defaultValue: DataTypes.NOW,
    comment: 'Updated At'
  }
};

ModelTable.init(fields, {
  sequelize,
  modelName: 'model'
});

module.exports = exports = ModelTable;


================================================
FILE: src/models/Platform.js
================================================
const sequelize = require('./index.js');
const { Model, DataTypes } = require("sequelize");

class PlatformTable extends Model { }

const fields = {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true,
    allowNull: false,
    comment: 'Platform ID'
  },
  name: {
    type: DataTypes.STRING(255),
    allowNull: false,
    comment: 'Platform Name'
  },
  logo_url: {
    type: DataTypes.STRING(255),
    allowNull: true,
    comment: 'Logo URL'
  },
  source_type: {
    type: DataTypes.STRING(50),
    allowNull: true,
    defaultValue: 'system',
    comment: 'Source Type'
  },
  api_key: {
    type: DataTypes.STRING(255),
    allowNull: true,
    comment: 'API Key'
  },
  api_url: {
    type: DataTypes.STRING(255),
    allowNull: true,
    comment: 'API URL'
  },
  api_version: {
    type: DataTypes.STRING(50),
    comment: 'API Version'
  },
  key_obtain_url: {
    type: DataTypes.STRING(255),
    comment: 'Key Obtain URL'
  },
  is_enabled: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: false,
    comment: 'Enabled'
  },
  is_subscribe: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: false,
    comment: 'is subscribe'
  },
  create_at: {
    type: DataTypes.DATE,
    allowNull: false,
    defaultValue: DataTypes.NOW,
    comment: 'Created At'
  },
  update_at: {
    type: DataTypes.DATE,
    allowNull: false,
    defaultValue: DataTypes.NOW,
    comment: 'Updated At'
  }
};

PlatformTable.init(fields, {
  sequelize,
  modelName: 'platform'
});

module.exports = exports = PlatformTable;


================================================
FILE: src/models/SearchProvider.js
================================================
const sequelize = require('./index.js');
const { Model, DataTypes } = require("sequelize");

class SearchProviderTable extends Model { }

const fields = {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true,
    allowNull: false,
  },
  name: {
    type: DataTypes.STRING(255),
    allowNull: false,
    comment: 'Search Engine Name'
  },
  logo_url: {
    type: DataTypes.STRING(255),
    allowNull: true,
    comment: 'Logo URL'
  },
  base_config_schema: {
    type: DataTypes.JSON,
    comment: 'Base Config Schema'
  },
  create_at: {
    type: DataTypes.DATE,
    allowNull: false,
    defaultValue: DataTypes.NOW,
    comment: 'Created At'
  },
  update_at: {
    type: DataTypes.DATE,
    allowNull: false,
    defaultValue: DataTypes.NOW,
    comment: 'Updated At'
  }
};

SearchProviderTable.init(fields, {
  sequelize,
  modelName: 'search_provider',
});

module.exports = exports = SearchProviderTable;


================================================
FILE: src/models/sync.js
================================================
require("module-alias/register");
require('dotenv').config();

const Conversation = require('./Conversation');
const File = require('./File');
const Platform = require('./Platform');
const Model = require('./Model');
const DefaultModelSettingTable = require('./DefaultModelSetting');
const SearchProviderTable = require('./SearchProvider');
const UserProviderConfigTable = require('./UserProviderConfig');
const UserSearchSettingTable = require('./UserSearchSetting');
const LLMLogs = require('./LLMLogs');
const Task = require('./Task');
const Message = require('./Message');
const McpServer = require('./McpServer');
const Agent = require('./Agent');
const FileVersion = require('./FileVersion');
const Knowledge = require('./Knowledge');
const User = require('./User');

const tableSync = async () => {
  await Conversation.sync({ alter: true });
  await File.sync({ alter: true });
  await Platform.sync({ alter: true });
  await Model.sync({ alter: true });
  await DefaultModelSettingTable.sync({ alter: true });
  await SearchProviderTable.sync({ alter: true });
  await UserProviderConfigTable.sync({ alter: true });
  await UserSearchSettingTable.sync({ alter: true });
  await LLMLogs.sync({ alter: true });
  await Task.sync({ alter: true });
  await Message.sync({ alter: true });
  await McpServer.sync({ alter: true });
  await Agent.sync({ alter: true });
  await FileVersion.sync({ alter: true });
  await Knowledge.sync({ alter: true });
  await User.sync({ alter: true });
}

const dataSync = async () => {
  const count = await Platform.count();
  if (count === 0) {
    const defaultData = require('../../public/default_data/default_platform.json');
    for (const item of defaultData) {
      const platformData = {
        name: item.name,
        logo_url: item.logo_url,
        source_type: 'system',
        api_key: item.api_key,
        api_url: item.api_url,
        api_version: item.api_version,
        key_obtain_url: item.key_obtain_url,
        is_subscribe: item.is_subscribe || false
      };
      const platform = await Platform.create(platformData);

      const modelsData = item.models.map(model => ({
        // @ts-ignore
        platform_id: platform.id,
        logo_url: model.logo_url,
        model_id: model.model_id,
        model_name: model.model_name,
        group_name: model.group_name,
        model_types: model.model_types,
      }));
      await Model.bulkCreate(modelsData);
    }
  }

  const searchProviderCount = await SearchProviderTable.count();
  if (searchProviderCount === 0) {
    const defaultSearchProviderData = require('../../public/default_data/default_search_provider.json');
    for (const item of defaultSearchProviderData) {
      const searchProviderData = {
        name: item.name,
        logo_url: item.logo_url,
        base_config_schema: item.base_config_schema,
      };
      await SearchProviderTable.create(searchProviderData);
    }
  }

  const userCount = await User.count();
  if (userCount === 0) {
    await User.create({
      id: 1,
      user_salt: 'default123'
    });
  }
}

const dataUpdate = async () => {
  const defaultData = require('../../public/default_data/default_platform.json');

  // v0.1 => v0.1.1
  await Platform.update({
    api_url: 'https://ark.cn-beijing.volces.com/api/v3'
  }, {
    where: {
      name: 'Volcengine'
    }
  })
  const platform = await Platform.findOne({ where: { name: 'Gemini' } })
  if (!platform) {
    const geminiPlatform = defaultData.find(item => item.name === 'Gemini')
    console.log(geminiPlatform)
    const platformData = {
      name: geminiPlatform.name,
      logo_url: geminiPlatform.logo_url,
      source_type: 'system',
      api_key: geminiPlatform.api_key,
      api_url: geminiPlatform.api_url,
      api_version: geminiPlatform.api_version,
      key_obtain_url: geminiPlatform.key_obtain_url,
    };
    const platform = await Platform.create(platformData);
    const modelsData = geminiPlatform.models.map(model => ({
      // @ts-ignore
      platform_id: platform.id,
      logo_url: model.logo_url,
      model_id: model.model_id,
      model_name: model.model_name,
      group_name: model.group_name,
      model_types: model.model_types,
    }));
    await Model.bulkCreate(modelsData);
  }

  // v0.1.1 => v0.1.2
  const defaultSearchProviderData = require('../../public/default_data/default_search_provider.json');
  const CloudswaySearchProvider = defaultSearchProviderData.find(item => item.name === 'Cloudsway');
  const searchProvider = await SearchProviderTable.findOne({ where: { name: CloudswaySearchProvider.name } });
  if (!searchProvider) {
    const searchProviderData = {
      name: CloudswaySearchProvider.name,
      logo_url: CloudswaySearchProvider.logo_url,
      base_config_schema: CloudswaySearchProvider.base_config_schema,
    };
    await SearchProviderTable.create(searchProviderData);
  }

  const cloudswayPlatform = await Platform.findOne({ where: { name: 'Cloudsway' } })
  if (!cloudswayPlatform) {
    const cloudswayPlatform = defaultData.find(item => item.name === 'Cloudsway')
    const platformData = {
      name: cloudswayPlatform.name,
      logo_url: cloudswayPlatform.logo_url,
      source_type: 'system',
      api_key: cloudswayPlatform.api_key,
      api_url: cloudswayPlatform.api_url,
      api_version: cloudswayPlatform.api_version,
      key_obtain_url: cloudswayPlatform.key_obtain_url,
    };
    const platform = await Platform.create(platformData);
    const modelsData = cloudswayPlatform.models.map(model => ({
      // @ts-ignore
      platform_id: platform.id,
      logo_url: model.logo_url,
      model_id: model.model_id,
      model_name: model.model_name,
      group_name: model.group_name,
      model_types: model.model_types,
    }));
    await Model.bulkCreate(modelsData);
  }
  // v0.1.2 => v0.1.3
  const platform_lemon = await Platform.findOne({ where: { name: 'Lemon' } })
  if (!platform_lemon) {
    const lemonPlatform = defaultData.find(item => item.name === 'Lemon')
    const platformData = {
      name: lemonPlatform.name,
      logo_url: lemonPlatform.logo_url,
      source_type: 'system',
      api_key: lemonPlatform.api_key,
      api_url: lemonPlatform.api_url,
      api_version: lemonPlatform.api_version,
      key_obtain_url: lemonPlatform.key_obtain_url,
      is_subscribe: true,
      is_enabled: true
    };
    const platform = await Platform.create(platformData);
    const modelsData = lemonPlatform.models.map(model => ({
      // @ts-ignore
      platform_id: platform.id,
      logo_url: model.logo_url,
      model_id: model.model_id,
      model_name: model.model_name,
      group_name: model.group_name,
      model_types: model.model_types,
    }));
    await Model.bulkCreate(modelsData);
  }

  // v0.1.3 => v0.1.4
  await Platform.update({ is_enabled: true }, { where: { name: 'Lemon' } })
  SearchProviderTable.destroy({ where: { name: 'Baidu' } });
  SearchProviderTable.destroy({ where: { name: 'Bing' } });
}

const sync = async () => {
  try {
    await tableSync();
    await dataSync();
    await dataUpdate();
  } catch (error) {
    console.error('Error during sync:', error);
  }
}

sync()

module.exports = exports = sync;


================================================
FILE: src/models/Task.js
================================================
const sequelize = require('./index.js');
const { Model, DataTypes } = require("sequelize");

class TaskTable extends Model { }

const fields = {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true,
    allowNull: false,
    comment: 'Task ID'
  },
  user_id: {
    type: DataTypes.BIGINT,
    allowNull: true,
    comment: 'ç”¨æˆ·ID'
  },
  conversation_id: {
    type: DataTypes.STRING,
    allowNull: false,
    comment: 'Conversation ID'
  },
  task_id: {
    type: DataTypes.STRING,
    allowNull: false,
    comment: 'Task ID'
  },
  parent_id: {
    type: DataTypes.STRING,
    allowNull: true,
    comment: 'çˆ¶ä»»åŠ¡ID'
  },
  requirement: {
    type: DataTypes.TEXT,
    allowNull: false,
  },
  status: {
    type: DataTypes.STRING,
    allowNull: false,
  },
  error: {
    type: DataTypes.TEXT,
    allowNull: true,
  },
  result: {
    type: DataTypes.TEXT,
    allowNull: true,
  },
  memorized: {
    type: DataTypes.TEXT('long'),
    allowNull: true,
  },
  create_at: {
    type: DataTypes.DATE,
    allowNull: false,
    defaultValue: DataTypes.NOW,
    comment: 'Created At'
  },
  update_at: {
    type: DataTypes.DATE,
    allowNull: false,
    defaultValue: DataTypes.NOW,
    comment: 'Updated At'
  }
};

TaskTable.init(fields, {
  sequelize,
  modelName: 'task'
});


module.exports = exports = TaskTable;


================================================
FILE: src/models/User.js
================================================
const sequelize = require('./index.js');
const { Model, DataTypes } = require("sequelize");

class SysUser extends Model { }

const fields = {
  id: {
    type: DataTypes.BIGINT.UNSIGNED,
    primaryKey: true,
    autoIncrement: true,
    allowNull: false,
    comment: 'ç”¨æˆ·ID'
  },
  points: {
    type: DataTypes.DECIMAL(14, 4),
    allowNull: false,
    defaultValue: '0.0000',
    comment: 'ç”¨æˆ·å½“å‰ç§¯åˆ†ä½™é¢'
  },
  user_name: {
    type: DataTypes.STRING(60),
    allowNull: false,
    defaultValue: '',
    comment: 'ç”¨æˆ·å'
  },
  mobile: {
    type: DataTypes.STRING(20),
    allowNull: false,
    defaultValue: '',
    comment: 'ä¸­å›½æ‰‹æœºä¸å¸¦å›½å®¶ä»£ç ï¼Œå›½é™…æ‰‹æœºå·æ ¼å¼ä¸ºï¼šå›½å®¶ä»£ç -æ‰‹æœºå·'
  },
  user_nickname: {
    type: DataTypes.STRING(50),
    allowNull: false,
    defaultValue: '',
    comment: 'ç”¨æˆ·æ˜µç§°'
  },
  birthday: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 0,
    comment: 'ç”Ÿæ—¥'
  },
  user_password: {
    type: DataTypes.STRING(255),
    allowNull: false,
    defaultValue: '',
    comment: 'ç™»å½•å¯†ç ;cmf_passwordåŠ å¯†'
  },
  user_salt: {
    type: DataTypes.STRING(10),
    allowNull: false,
    comment: 'åŠ å¯†ç›'
  },
  user_status: {
    type: DataTypes.TINYINT.UNSIGNED,
    allowNull: false,
    defaultValue: 1,
    comment: 'ç”¨æˆ·çŠ¶æ€;0:ç¦ç”¨,1:æ­£å¸¸,2:æœªéªŒè¯'
  },
  user_email: {
    type: DataTypes.STRING(100),
    allowNull: false,
    defaultValue: '',
    comment: 'ç”¨æˆ·ç™»å½•é‚®ç®±'
  },
  sex: {
    type: DataTypes.TINYINT,
    allowNull: false,
    defaultValue: 0,
    comment: 'æ€§åˆ«;0:ä¿å¯†,1:ç”·,2:å¥³'
  },
  avatar: {
    type: DataTypes.STRING(255),
    allowNull: false,
    defaultValue: '',
    comment: 'ç”¨æˆ·å¤´åƒ'
  },
  dept_id: {
    type: DataTypes.BIGINT.UNSIGNED,
    allowNull: false,
    defaultValue: 0,
    comment: 'éƒ¨é—¨id'
  },
  remark: {
    type: DataTypes.STRING(255),
    allowNull: false,
    defaultValue: '',
    comment: 'å¤‡æ³¨'
  },
  is_admin: {
    type: DataTypes.TINYINT,
    allowNull: false,
    defaultValue: 1,
    comment: 'æ˜¯å¦åå°ç®¡ç†å‘˜ 1 æ˜¯ 0 å¦'
  },
  address: {
    type: DataTypes.STRING(255),
    allowNull: false,
    defaultValue: '',
    comment: 'è”ç³»åœ°å€'
  },
  describe: {
    type: DataTypes.STRING(255),
    allowNull: false,
    defaultValue: '',
    comment: 'æè¿°ä¿¡æ¯'
  },
  last_login_ip: {
    type: DataTypes.STRING(15),
    allowNull: false,
    defaultValue: '',
    comment: 'æœ€åç™»å½•ip'
  },
  last_login_time: {
    type: DataTypes.DATE,
    allowNull: true,
    comment: 'æœ€åç™»å½•æ—¶é—´'
  },
  created_at: {
    type: DataTypes.DATE,
    allowNull: true,
    defaultValue: DataTypes.NOW,
    comment: 'åˆ›å»ºæ—¶é—´'
  },
  updated_at: {
    type: DataTypes.DATE,
    allowNull: true,
    defaultValue: DataTypes.NOW,
    comment: 'æ›´æ–°æ—¶é—´'
  },
  deleted_at: {
    type: DataTypes.DATE,
    allowNull: true,
    comment: 'åˆ é™¤æ—¶é—´'
  },
  open_id: {
    type: DataTypes.STRING(50),
    allowNull: false,
    defaultValue: '',
    comment: 'å¾®ä¿¡open id'
  },
  stripe_user_id: {
    type: DataTypes.STRING(50),
    allowNull: true,
    defaultValue: '',
    comment: 'stripe_user_id'
  },
  e2b_sandbox_id: {
    type: DataTypes.STRING(50),
    allowNull: true,
    defaultValue: '',
    comment: 'e2b å®¹å™¨id'
  },
  invited_by_user_id: {
    type: DataTypes.BIGINT,
    allowNull: true,
    comment: 'é‚€è¯·è¯¥ç”¨æˆ·çš„é‚€è¯·äººID'
  },
  used_invite_code_id: {
    type: DataTypes.BIGINT,
    allowNull: true,
    comment: 'æ³¨å†Œæ—¶ä½¿ç”¨çš„é‚€è¯·ç ID'
  },
};

SysUser.init(fields, {
  sequelize,
  modelName: 'sys_user',
  tableName: 'sys_user', // å¯é€‰ï¼Œç¡®ä¿æ˜ å°„åˆ°æ­£ç¡®çš„è¡¨å
  timestamps: false, // å› ä¸ºæˆ‘ä»¬æ‰‹åŠ¨å®šä¹‰äº† created_at / updated_at / deleted_at
});

module.exports = exports = SysUser;


================================================
FILE: src/models/UserProviderConfig.js
================================================
const sequelize = require('./index.js');
const { Model, DataTypes } = require("sequelize");

class UserProviderConfigTable extends Model { }

const fields = {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true,
    allowNull: false,
  },
  user_id: {
    type: DataTypes.BIGINT,
    allowNull: true,
    comment: 'ç”¨æˆ·ID'
  },
  provider_id: {
    type: DataTypes.INTEGER,
    allowNull: false,
    comment: 'Search Engine ID'
  },
  base_config: {
    type: DataTypes.JSON,
    comment: 'User Custom Configuration'
  },
  create_at: {
    type: DataTypes.DATE,
    allowNull: false,
    defaultValue: DataTypes.NOW,
    comment: 'Created At'
  },
  update_at: {
    type: DataTypes.DATE,
    allowNull: false,
    defaultValue: DataTypes.NOW,
    comment: 'Updated At'
  }
};

UserProviderConfigTable.init(fields, {
  sequelize,
  modelName: 'user_provider_config',
});

module.exports = exports = UserProviderConfigTable;


================================================
FILE: src/models/UserSearchSetting.js
================================================
const sequelize = require('./index.js');
const { Model, DataTypes } = require("sequelize");

class UserSearchSettingTable extends Model { }

const fields = {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true,
    allowNull: false,
  },
  user_id: {
    type: DataTypes.BIGINT,
    allowNull: true,
    comment: 'ç”¨æˆ·ID'
  },
  provider_id: {
    type: DataTypes.INTEGER,
    allowNull: false,
    comment: 'Search Engine ID'
  },
  include_date: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: false,
    comment: 'Whether to automatically include date range filter in search results'
  },
  cover_provider_search: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: false,
    comment: 'Whether to cover the original search logic of the service provider'
  },
  enable_enhanced_mode: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: false,
    comment: 'Whether to enable AI enhanced search mode'
  },
  result_count: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 10,
    comment: 'Number of search results'
  },
  blacklist: {
    type: DataTypes.TEXT,
    allowNull: true,
    comment: 'Blacklist'
  },
  create_at: {
    type: DataTypes.DATE,
    allowNull: false,
    defaultValue: DataTypes.NOW,
    comment: 'Created At'
  },
  update_at: {
    type: DataTypes.DATE,
    allowNull: false,
    defaultValue: DataTypes.NOW,
    comment: 'Updated At'
  }
};

UserSearchSettingTable.init(fields, {
  sequelize,
  modelName: 'user_search_setting',
});

module.exports = exports = UserSearchSettingTable;


================================================
FILE: src/routers/index.js
================================================
// @ts-ignore
const router = require("koa-router")();

// é»˜è®¤é¦–é¡µ
router.get("/", async ({ response, request, redis }) => {
  response.body = "Hello, World !";
  response.status = 200;
});

const modules = [
  "agent",
  'conversation',
  'file',
  'platform',
  'model',
  'default_model_setting',
  'search_provider_setting',
  'runtime',
  'message',
  'user',
  'version',
  'mcp_server',
  'knowledge',
  'agent_store',
  'conversation_case',
  'order',
  'points_transaction',
  'payment',
  'membership_plan',
  'recharge_product',
];

for (const module of modules) {
  try {
    // console.log('module', module);
    router.use(require(`./${module}/index.js`));
  } catch (error) {
    console.log(`load ${module} error`, error);
  }
}

module.exports = exports = router;



================================================
FILE: src/routers/agent/README.md
================================================
## run agent

```shell
curl -N --location 'http://localhost:3000/api/agent/run' \
--header 'Content-Type: application/json' \
--header 'Authorization: Bearer xxx' \
--data '{"question": "è¯·æŸ¥çœ‹å·¥ä½œç›®å½•ä¸­çš„æ–‡ä»¶, æ‰¾åˆ° README.md æ–‡ä»¶, è¯»å–æ–‡ä»¶å†…å®¹, å¹¶è¾“å‡ºå†…å®¹"}'
```



================================================
FILE: src/routers/agent/agent.js
================================================
const router = require("koa-router")();

const { Op } = require('sequelize')

const Agent = require("@src/models/Agent");
const Conversation = require("@src/models/Conversation");
const generate_agent = require('@src/agent/generate-agent/index');

// æ–°å¢ Agent
router.post("/", async ({ state, request, response }) => {
  const body = request.body || {};
  const { name, describe = '', mcp_server_ids = [], is_public = true } = body;
  try {
    const agent = await Agent.create({
      user_id: state.user.id,
      name,
      describe,
      mcp_server_ids,
      is_public
    });

    return response.success(agent);
  } catch (error) {
    console.error(error);
    return response.fail("Failed to create agent");
  }
});


router.post("/generate", async ({ state, request, response }) => {
  const body = request.body || {};
  const { question, conversation_id } = body;

  try {
    const { name, describe } = await generate_agent(question, conversation_id);
    const agent = await Agent.create({
      user_id: state.user.id,
      name,
      describe,
    });

    await Conversation.update({ agent_id: agent.dataValues.id }, { where: { conversation_id } });
    return response.success(agent);

  } catch (error) {
    console.error(error);
    return response.fail("Failed to create agent");
  }
});


// è·å– Agent åˆ—è¡¨


router.get("/", async ({ state, response }) => {
  console.log(' ==== get agent list ==== ');
  try {
    const agents = await Agent.findAll({
      where: {
        user_id: state.user.id,
        deleted_at: null  // æ‰‹åŠ¨è¿‡æ»¤å·²åˆ é™¤çš„è®°å½•
      },
      order: [['create_at', 'DESC']]
    });
    return response.success(agents);
  } catch (error) {
    console.error(error);
    return response.fail("Failed to get agent list");
  }
});

// è·å–å•ä¸ª Agent
router.get("/:id", async ({ state, params, response }) => {
  const { id } = params;
  try {
    const agent = await Agent.findOne({
      where: { id, user_id: state.user.id },
    });
    if (!agent) {
      return response.fail("Agent does not exist");
    }
    return response.success(agent);
  } catch (error) {
    console.error(error);
    return response.fail("Failed to get agent");
  }
});

// æ›´æ–° Agent
router.put("/:id", async ({ state, params, request, response }) => {
  const { id } = params;
  const body = request.body || {};
  const { name, describe, mcp_server_ids } = body;

  try {
    const agent = await Agent.findOne({
      where: { id, user_id: state.user.id },
    });
    if (!agent) {
      return response.fail("Agent does not exist");
    }
    const originalName = agent.name;
    const originalDescribe = agent.describe;
    const originalIsPublic = agent.is_public;

    const needsVectorUpdate = (name !== undefined && name !== originalName) ||
      (describe !== undefined && describe !== originalDescribe);

    if (name !== undefined) agent.name = name;
    if (describe !== undefined) agent.describe = describe;
    if (mcp_server_ids !== undefined) agent.mcp_server_ids = mcp_server_ids;
    if (is_public !== undefined) agent.is_public = is_public;
    await agent.save();

    return response.success(agent);
  } catch (error) {
    console.error(error);
    return response.fail("Failed to update agent");
  }
});

// åˆ é™¤ Agent (æ‰‹åŠ¨å‡åˆ é™¤)
router.delete("/:id", async ({ state, params, response }) => {
  const { id } = params;
  try {
    const agent = await Agent.findOne({
      where: { id, user_id: state.user.id },
    });
    if (!agent) {
      return response.fail("Agent does not exist");
    }

    // æ‰‹åŠ¨è®¾ç½®deleted_atå­—æ®µè¿›è¡Œå‡åˆ é™¤
    agent.deleted_at = new Date();
    await agent.save();

    return response.success("Agent deleted successfully");
  } catch (error) {
    console.error(error);
    return response.fail("Failed to delete agent");
  }
});

module.exports = exports = router.routes();



================================================
FILE: src/routers/agent/chat.js
================================================
// @ts-ignore
const router = require("koa-router")();
const handleStream = require("@src/utils/stream.util");

const uuid = require("uuid");
const Conversation = require("@src/models/Conversation");
const Message = require("@src/utils/message");
const MessageTable = require("@src/models/Message");
const call = require("@src/utils/llm");
const calcToken = require('@src/completion/calc.token.js')


const activeChatAbortControllers = new Map(); // conversation_id -> AbortController


router.post("/chat", async (ctx, next) => {
  const { request, response } = ctx;
  const body = request.body || {};
  let { question, conversation_id, pid, model_id = 48 } = body;
  await Conversation.update({ model_id }, { where: { conversation_id } })


  if (!conversation_id) {
    conversation_id = uuid.v4();
    const title = question.slice(0, 20);
    const newConversation = await Conversation.create({
      user_id: ctx.state.user.id,
      conversation_id: conversation_id,
      content: question,
      title: title,
      status: 'done'
    });
  }

  body.responseType = body.responseType || "sse";
  const { stream, onTokenStream } = handleStream(body.responseType, response);

  // æ–°å¢ï¼šä¸ºæœ¬æ¬¡ä¼šè¯åˆ›å»º AbortController
  const abortController = new AbortController();
  activeChatAbortControllers.set(conversation_id, abortController);

  // ä¿®æ”¹ onCompletedï¼Œæ¥æ”¶ message_id å¹¶ base64 ç¼–ç 
  const onCompleted = (message_id, new_pid) => {
    // 1. æ„é€ åŸå§‹å­—ç¬¦ä¸²
    const raw = `__lemon_out_end__{"message_id":"${message_id}","pid":"${new_pid}"}\n\n`;
    // 2. base64 ç¼–ç 
    const base64_content = Buffer.from(raw).toString('base64');
    // 3. å†™å…¥æµ
    onTokenStream(raw);
    stream.end();
  };

  let messagesContext = []
  if (pid != -1) {
    // å¯»æ‰¾ä¸Šä¸‹æ–‡
    const messages = await MessageTable.findAll({
      where: {
        conversation_id: conversation_id
      }
    })
    messagesContext = getMessagesContext(messages, pid)
  }


  let sysPromptMessage = {
    role: 'system',
    content: `
    You are a friendly and helpful chatbot named Lemon. 
    Your role is to assist users by providing concise and accurate responses to their questions or messages. 
    Politely and friendly acknowledge the user's message and provide a clear and relevant answer.
    `
  }
  messagesContext.unshift(sysPromptMessage)

  const msg = Message.format({
    role: 'user',
    status: 'success',
    content: question,
    action_type: 'chat',
    task_id: conversation_id,
    type: 'chat',
    pid: pid
  });
  let message = await Message.saveToDB(msg, conversation_id);
  let new_pid = message.id

  // è°ƒç”¨å¤§æ¨¡å‹
  let content

  call(question, conversation_id, 'assistant', { temperature: 0.7, messages: messagesContext, signal: abortController.signal }, onTokenStream).then(async (content) => {
    const assistant_msg = Message.format({
      role: 'assistant',
      status: 'success',
      content: content,
      action_type: 'chat',
      task_id: conversation_id,
      type: 'chat',
      pid: new_pid
    });
    let new_message = await Message.saveToDB(assistant_msg, conversation_id);

    // åœ¨è¿™é‡Œè°ƒç”¨ onCompleted
    onCompleted(new_message.id, new_pid);

    await Conversation.update({ status: 'done' }, { where: { conversation_id } })
  }).catch(async (error) => {
    content = error.message
    const assistant_msg = Message.format({
      role: 'assistant',
      status: 'success',
      content: content,
      action_type: 'chat',
      task_id: conversation_id,
      type: 'chat',
      pid: new_pid
    });
    let new_message = await Message.saveToDB(assistant_msg, conversation_id);

    // åœ¨è¿™é‡Œè°ƒç”¨ onCompleted
    onCompleted(new_message.id, new_pid);
  }).finally(() => {
    activeChatAbortControllers.delete(conversation_id);
  })

  // completeCodeAct(task, context).then(async content => {
  //   console.log('content', content);
  //   onCompleted();
  // });
  ctx.body = stream;
  ctx.status = 200;
});

// é‡æ–°å›ç­”
router.post("/re_chat", async (ctx, next) => {
  const { request, response } = ctx;
  const body = request.body || {};
  const user_id = ctx.state.user.id
  let { conversation_id, pid, model_id = 48 } = body;

  await Conversation.update({ status: 'running', model_id }, { where: { conversation_id } })

  body.responseType = body.responseType || "sse";
  const { stream, onTokenStream } = handleStream(body.responseType, response);

  const messages = await MessageTable.findAll({
    where: {
      conversation_id: conversation_id
    }
  })

  // æ ¹æ®pidæ‰¾åˆ°å¦ä¸€ä¸ªmessageçš„is_activeæ˜¯trueçš„ï¼Œæ”¹æˆfalse
  // åªå¤„ç†åŒä¸€conversationä¸‹ï¼Œé™¤å½“å‰pidå¤–çš„is_activeä¸ºtrueçš„assistantæ¶ˆæ¯
  for (const msg of messages) {
    if (msg.get('role') === 'assistant') {
      let meta = msg.get('meta');
      if (typeof meta === 'string') meta = JSON.parse(meta);
      if (meta && typeof meta === 'object' && 'is_active' in meta && meta.is_active && meta.pid == pid) {
        meta.is_active = false;
        console.log("====debug====", msg.id)
        await MessageTable.update({ meta: JSON.stringify(meta) }, { where: { id: msg.id } });
      }
    }
  }

  const abortController = new AbortController();
  activeChatAbortControllers.set(conversation_id, abortController);

  const onCompleted = (message_id, new_pid) => {
    // 1. æ„é€ åŸå§‹å­—ç¬¦ä¸²
    const raw = `__lemon_out_end__{"message_id":"${message_id}","pid":"${new_pid}"}\n\n`;
    // 2. base64 ç¼–ç 
    const base64_content = Buffer.from(raw).toString('base64');
    // 3. å†™å…¥æµ
    onTokenStream(raw);
    stream.end();
  };

  const messagesContext = getMessagesContext(messages, pid)


  const message = getMessageByPid(messages, pid)
  const question = message.content
  console.log("messagesContext[messagesContext.length - 1]", message)
  const contextMessages = messagesContext.slice(0, -1)
  call(question, conversation_id, 'assistant', { temperature: 0.7, messages: contextMessages }, onTokenStream).then(async (content) => {
    const assistant_msg = Message.format({
      role: 'assistant',
      status: 'success',
      content: content,
      action_type: 'chat',
      task_id: conversation_id,
      type: 'chat',
      pid: message.id,
      is_active: true
    });
    let new_message = await Message.saveToDB(assistant_msg, conversation_id);

    onCompleted(new_message.id, message.id);

    await Conversation.update({ status: 'done' }, { where: { conversation_id } })
  }).catch(async (error) => {
    let content = error.message
    const assistant_msg = Message.format({
      role: 'assistant',
      status: 'success',
      content: content,
      action_type: 'chat',
      task_id: conversation_id,
      type: 'chat',
      pid: message.id,
      is_active: true
    });
    let new_message = await Message.saveToDB(assistant_msg, conversation_id);

    onCompleted(new_message.id, message.id);

    await Conversation.update({ status: 'done' }, { where: { conversation_id } })
  }).finally(() => {
    activeChatAbortControllers.delete(conversation_id);
  })




  ctx.body = stream;
  ctx.status = 200;
});

// å›ç­”åˆ‡æ¢
router.post("/change", async (ctx, next) => {
  const { request, response } = ctx;
  const body = request.body || {};
  const user_id = ctx.state.user.id
  let { conversation_id, pid, old_message_id, new_message_id } = body;

  // 1. æŸ¥æ‰¾æ‰€æœ‰ assistant æ¶ˆæ¯ï¼Œç­›é€‰ meta.pid ç›¸åŒçš„ï¼Œè®¾ä¸º false
  const messages = await MessageTable.findAll({
    where: {
      conversation_id: conversation_id,
    }
  });
  for (const msg of messages) {
    let meta = msg.get('meta');
    if (typeof meta === 'string') meta = JSON.parse(meta);
    meta = meta || {};
    if (meta.pid === pid) {
      meta.is_active = false;
      await MessageTable.update({ meta: JSON.stringify(meta) }, { where: { id: msg.get('id') } });
    }
  }

  // 2. è®¾å®š new_message_id çš„ is_active ä¸º true
  const targetMsg = await MessageTable.findOne({ where: { id: new_message_id } });
  if (targetMsg) {
    let meta = targetMsg.get('meta');
    if (typeof meta === 'string') meta = JSON.parse(meta);
    meta = meta || {};
    meta.is_active = true;
    await MessageTable.update({ meta }, { where: { id: new_message_id } });
  }

  ctx.body = { success: true };
  ctx.status = 200;
})

// åœæ­¢å›ç­”
router.post("/stop_chat", async (ctx, next) => {
  const { conversation_id } = ctx.request.body || {};
  if (!conversation_id) {
    ctx.body = { success: false, message: "conversation_id is required" };
    ctx.status = 400;
    return;
  }
  const controller = activeChatAbortControllers.get(conversation_id);
  if (controller) {
    controller.abort();
    activeChatAbortControllers.delete(conversation_id);
    ctx.body = { success: true, message: "Chat stopped" };
    ctx.status = 200;
  } else {
    ctx.body = { success: false, message: "No active chat for this conversation_id" };
    ctx.status = 404;
  }
});

// è·å–ä»æ ¹åˆ°pidçš„æ¶ˆæ¯é“¾ï¼Œä¸”æ€»tokenä¸è¶…è¿‡128kï¼Œä»æœ€æ–°å¾€æ—§ç´¯åŠ 
function getMessagesContext(messages, pid) {
  const idMap = {};
  messages.forEach(msg => {
    idMap[msg.id] = msg;
  });

  // å›æº¯é“¾è·¯ï¼Œå…ˆæ”¶é›†å®Œæ•´é“¾è·¯
  const context = [];
  let cur = idMap[pid];
  const visited = new Set();
  while (cur) {
    if (visited.has(cur.id)) break; // é˜²æ­¢è‡ªç¯
    visited.add(cur.id);

    context.unshift(cur); // å…ˆunshiftï¼Œæœ€åæ˜¯ä»æ—§åˆ°æ–°
    const meta = typeof cur.meta === 'string' ? JSON.parse(cur.meta) : cur.meta;
    if (!meta || meta.pid === undefined || meta.pid === -1) break;
    cur = idMap[meta.pid];
  }

  // åè½¬ä¸ºä»æ–°åˆ°æ—§
  const reversed = context.slice().reverse();

  // ç´¯åŠ tokenï¼Œè¶…è¿‡128kå°±ä¸¢å¼ƒæ›´æ—§çš„
  let totalTokens = 0;
  const limited = [];
  for (const msg of reversed) {
    const tokens = calcToken(msg.content || "");
    if (totalTokens + tokens > 131072) break;
    limited.push(msg);
    totalTokens += tokens;
  }

  // å†åè½¬å›æ¥ï¼Œä¿æŒä»æ—§åˆ°æ–°
  const finalContext = limited.reverse();

  // è½¬æ¢ä¸º openai æ ‡å‡†æ ¼å¼
  return finalContext.map(msg => ({
    role: msg.role,
    content: msg.content
  }));
}


//æ ¹æ®pid è·å–message
function getMessageByPid(messages, pid) {
  return messages.find(msg => msg.id === pid);
}

module.exports = exports = router.routes();


================================================
FILE: src/routers/agent/coding.js
================================================
// @ts-ignore
const router = require("koa-router")();
const { coding } = require("@src/editor/coding.js");

// æ¥å£åœ°å€: /api/agent/coding/ai

router.post("/coding/ai", async (ctx, next) => {
  const { request, response } = ctx;
  const body = request.body || {};
  const { user_id } = ctx.state.user;
  const { conversation_id, selection, requirement, filepath } = body;
  console.log('conversation_id', conversation_id);

  const params = {
    selection,
    requirement
  }
  const context = { user_id, filepath, conversation_id }
  try {
    await coding(params, context);
  } catch (error) {
    console.error(error);
    response.error(error.message);
    return;
  }

  response.success({
    status: 'success'
  })
});

module.exports = exports = router.routes();


================================================
FILE: src/routers/agent/coding.sse.js
================================================
// @ts-ignore
const router = require("koa-router")();
const Conversation = require("@src/models/Conversation");
const { getContainerCloseHandler } = require('./utils/coding-helpers');
const { setupCodingTask } = require('./utils/coding-setup');
const { executeCoding } = require('./utils/coding-executor');
const { handleCodingResult, setupStreamCloseHandler } = require('./utils/coding-cleanup');

// Store active tasks
const activeTasks = new Map();

/**
 * POST /api/agent/coding/sse
 * 
 * Core logic is extremely simple:
 * 1. Setup
 * 2. Execute 
 * 3. Cleanup
 */
router.post("/coding/sse", async (ctx, next) => {
  try {
    // 1. Setup everything
    console.log('coding.sse');
    const setup = await setupCodingTask(ctx);

    // Register active task
    activeTasks.set(setup.conversation_id, { stop: () => setup.stream.end() });

    // Setup cleanup handler
    setupStreamCloseHandler({
      stream: setup.stream,
      conversation_id: setup.conversation_id,
      agent_id: setup.agent_id,
      userId: setup.userId,
      dir_path: setup.dir_path,
      filepath: setup.filepath,
      token: ctx.headers.authorization,
      onCleanup: () => activeTasks.delete(setup.conversation_id)
    });

    // 2. Execute core logic
    executeCoding({
      conversation_id: setup.conversation_id,
      agent_id: setup.agent_id,
      filepath: setup.filepath,
      selection: setup.selection,
      screenshot: setup.screenshot,
      requirement: setup.requirement,
      userId: setup.userId,
      onTokenStream: setup.onTokenStream,
      mcp_server_ids: setup.mcp_server_ids || []
    }).then((result) => {
      console.log('Coding result:', result);
      handleCodingResult(setup, result);
    });

    ctx.body = setup.stream;
    ctx.status = 200;

  } catch (error) {
    console.error('Unexpected error:', error);
    ctx.response.fail({}, error.message);
  }
});

/**
 * Stop coding task
 * POST /api/agent/coding/stop
 */
router.post("/coding/stop", async (ctx) => {
  const { conversation_id } = ctx.request.body || {};
  const userId = ctx.state.user.id;

  const task = activeTasks.get(conversation_id);

  if (!task) {
    return ctx.response.fail(`Task ${conversation_id} not found`);
  }

  try {
    if (task.stop) task.stop();
    activeTasks.delete(conversation_id);

    await Conversation.update(
      { status: 'stopped' },
      { where: { conversation_id } }
    );

    const closeContainer = getContainerCloseHandler();
    await closeContainer(userId);

    ctx.response.success('Coding task stopped');
  } catch (error) {
    ctx.response.fail(`Error: ${error.message}`);
  }
});

/**
 * Get task status
 * GET /api/agent/coding/status/:conversation_id
 */
router.get("/coding/status/:conversation_id", async (ctx) => {
  const { conversation_id } = ctx.params;

  const conversation = await Conversation.findOne({ where: { conversation_id } });

  if (!conversation) {
    return ctx.response.fail('Conversation not found');
  }

  ctx.response.success({
    conversation_id,
    status: conversation.status,
    is_active: activeTasks.has(conversation_id),
  });
});

module.exports = exports = router.routes();


================================================
FILE: src/routers/agent/format.mock.js
================================================
require('module-alias/register');
require("dotenv").config();

const path = require('path');
const fs = require('fs');
const xmlPath = path.join(__dirname, 'xml.txt');
const xmlContent = fs.readFileSync(xmlPath, 'utf-8');

const { resolveActions, extractDescription } = require("@src/editor/resolve");
const { sendProgressMessage, sendCodingMessage } = require("@src/routers/agent/utils/coding-messages");

const actions = resolveActions(xmlContent);
const description = extractDescription(xmlContent);

// console.log(actions);
console.log(description);

const run = async () => {
  const conversation_id = '11977bf4-7c1f-4193-8c21-94e6011d1bd9';
  const onTokenStream = () => { };
  // await sendProgressMessage(onTokenStream, conversation_id, description);
  // console.log('sendProgressMessage success');
  console.log('actions', actions);

  for (const action of actions) {
    const { params = {} } = action;
    await sendCodingMessage(onTokenStream, conversation_id, '', 'coding', params);
  }
  process.exit(0);
}

run();




================================================
FILE: src/routers/agent/index.js
================================================
// @ts-ignore
const router = require("koa-router")();

router.prefix("/api/agent");

router.use(require('./run.js'));
router.use(require('./proxy.js'));
router.use(require('./chat.js'));
router.use(require('./agent.js'));
router.use(require('./coding.js'));
router.use(require('./coding.sse.js'));

module.exports = router.routes();



================================================
FILE: src/routers/agent/proxy.js
================================================
// @ts-ignore
const router = require("koa-router")();
const axios = require('axios')
const { PassThrough } = require("stream");

const calcToken = require('@src/completion/calc.token.js')

const OPENAI_API_KEY = process.env.API_KEY;
const OPENAI_BASE_URL = process.env.BASE_URL;
const MODEL_NAME = process.env.MODEL_NAME

router.post("/v1/chat/completions", async (ctx, next) => {
  const { request, response, state } = ctx;
  const body = request.body || {};
  const conversation_id = body.conversation_id

  // æ£€æŸ¥ API Key æ˜¯å¦è®¾ç½®
  if (!OPENAI_API_KEY) {
    ctx.status = 500;
    ctx.body = {
      error: {
        message: "OpenAI API Key not configured. Please set OPENAI_API_KEY environment variable.",
        type: "server_error",
        code: "api_key_missing",
      },
    };
    return;
  }

  // æ ¹æ®å®¢æˆ·ç«¯è¯·æ±‚åˆ¤æ–­æ˜¯å¦éœ€è¦æµå¼å“åº”
  const isStream = body.stream === true;

  // Koa çš„ response body å¯ä»¥ç›´æ¥æ˜¯ stream
  const clientResponseStream = new PassThrough();
  ctx.body = clientResponseStream;
  ctx.status = 200;

  try {
    // æ„å»ºè½¬å‘ç»™ OpenAI çš„è¯·æ±‚ä½“
    // å‡è®¾å®¢æˆ·ç«¯å‘é€çš„ body ç»“æ„ä¸ OpenAI çš„ Chat Completion API ç›¸åŒ
    const openaiRequestBody = { ...body };
    // ç¡®ä¿ stream å‚æ•°ä¸æˆ‘ä»¬æœŸæœ›çš„è½¬å‘è¡Œä¸ºä¸€è‡´
    openaiRequestBody.model = MODEL_NAME;
    openaiRequestBody.stream = isStream;

    console.log("111111", JSON.stringify(openaiRequestBody))
    // æ„å»º OpenAI API è¯·æ±‚å¤´
    const openaiHeaders = {
      "Content-Type": "application/json",
      Authorization: `Bearer ${OPENAI_API_KEY}`,
    };

    // å¦‚æœæ˜¯æµå¼è¯·æ±‚ï¼Œè®¾ç½®ç›¸åº”çš„å“åº”å¤´
    if (isStream) {
      response.type = "text/event-stream";
      response.set("Cache-Control", "no-cache");
      response.set("Connection", "keep-alive");
      response.set("X-Accel-Buffering", "no"); // ç¦ç”¨ Nginx ç¼“å†²
    } else {
      // éæµå¼è¯·æ±‚ï¼Œä¿æŒé»˜è®¤çš„ application/json æˆ–ç”± OpenAI è¿”å›å†³å®š
      response.type = "application/json";
    }

    // å‘é€è¯·æ±‚åˆ° OpenAI API
    const openaiResponse = await axios({
      method: "post",
      url: `${OPENAI_BASE_URL}/chat/completions`, // ä½¿ç”¨ chat/completions æ¥å£
      headers: openaiHeaders,
      data: openaiRequestBody,
      responseType: isStream ? "stream" : "json", // æ ¹æ®æ˜¯å¦æµå¼å†³å®šå“åº”ç±»å‹
    });

    if (isStream) {
      // **æµå¼è½¬å‘ï¼šå°† OpenAI çš„å“åº”æµç›´æ¥ pipe åˆ°å®¢æˆ·ç«¯å“åº”æµ**
      let fullContent = "";

      // è®¡ç®—è¾“å…¥ tokens
      const input_tokens = calcTokenInput('', openaiRequestBody.messages);

      openaiResponse.data.on('data', (chunk) => {
        // æ”¶é›†å®Œæ•´å“åº”å†…å®¹
        const lines = chunk.toString().split('\n');

        for (const line of lines) {
          if (line.startsWith('data: ')) {
            const data = line.slice(6);
            if (data === '[DONE]') return;
            try {
              const parsed = JSON.parse(data);
              if (parsed.choices?.[0]?.delta?.content) {
                fullContent += parsed.choices[0].delta.content;
              }
              // å¤„ç† tool_calls
              if (parsed.choices?.[0]?.delta?.tool_calls) {
                const toolCalls = parsed.choices[0].delta.tool_calls;
                for (const toolCall of toolCalls) {
                  if (toolCall.function) {
                    if (toolCall.function.name) {
                      fullContent += `Function: ${toolCall.function.name}\n`;
                    }
                    if (toolCall.function.arguments) {
                      fullContent += `Arguments: ${toolCall.function.arguments}\n`;
                    }
                  }
                }
              }
            } catch (e) {
              console.error('Error parsing SSE data:', e);
            }
          }
        }
      });

      openaiResponse.data.pipe(clientResponseStream);

      // ç›‘å¬ OpenAI å“åº”æµçš„ç»“æŸäº‹ä»¶
      openaiResponse.data.on('end', async () => {
        // è®¡ç®—è¾“å‡º tokens
        const output_tokens = calcToken(fullContent);

        // æ‰£é™¤ç§¯åˆ†
        console.log("===input_tokens, output_tokens======", input_tokens, output_tokens)

        clientResponseStream.end();
        console.log("OpenAI stream ended, client stream closed.");
      });

      // ç›‘å¬ OpenAI å“åº”æµçš„é”™è¯¯äº‹ä»¶
      openaiResponse.data.on('error', (err) => {
        console.error("Error piping OpenAI stream:", err);
        // å°è¯•å‘é€é”™è¯¯äº‹ä»¶ç»™å®¢æˆ·ç«¯
        const errorData = JSON.stringify({
          error: {
            message: err.message || "An error occurred during streaming from OpenAI.",
            type: "openai_stream_error",
            code: null,
          },
        });
        clientResponseStream.write(`data: ${errorData}\n\n`);
        clientResponseStream.end();
        ctx.status = 500; // è®¾ç½®çŠ¶æ€ç 
      });

    } else {
      // éæµå¼è½¬å‘ï¼šç›´æ¥è¿”å› OpenAI çš„ JSON å“åº”
      const input_tokens = openaiResponse.data.usage.prompt_tokens
      const output_tokens = openaiResponse.data.usage.completion_tokens

      console.log("===input_tokens, output_tokens======nostream:", input_tokens, output_tokens)


      ctx.body = openaiResponse.data;
      ctx.status = openaiResponse.status;
    }

  } catch (error) {
    console.error("Error during OpenAI API proxy:", error);

    // å¤„ç† Axios é”™è¯¯
    if (axios.isAxiosError(error) && error.response) {
      // å¦‚æœ OpenAI è¿”å›äº†é”™è¯¯å“åº”
      console.error("OpenAI API error response:", error.response.data);
      ctx.status = error.response.status; // ä½¿ç”¨ OpenAI è¿”å›çš„çŠ¶æ€ç 
      ctx.body = error.response.data; // ç›´æ¥è¿”å› OpenAI çš„é”™è¯¯ä½“
    } else {
      // å…¶ä»–æœªçŸ¥é”™è¯¯
      ctx.status = 500;
      ctx.body = {
        error: {
          message: error.message || "An unknown error occurred during proxying to OpenAI.",
          type: "proxy_server_error",
          code: null,
        },
      };
    }

    // å¦‚æœæµå·²ç»æ‰“å¼€ï¼Œç¡®ä¿å®ƒè¢«å…³é—­
    if (isStream && !clientResponseStream.writableEnded) {
      clientResponseStream.end();
    }
  }
});

const calcTokenInput = (prompt, messages) => {
  let content = prompt;
  for (const message of messages) {
    // æ·»åŠ  role ä¿¡æ¯
    content += `role: ${message.role}\n`;

    // å¤„ç† content
    if (message.content) {
      if (typeof message.content === 'string') {
        content += message.content;
      } else if (Array.isArray(message.content)) {
        // å¤„ç†æ•°ç»„å½¢å¼çš„ content
        for (const item of message.content) {
          if (item.type === 'text') {
            content += item.text;
          }
        }
      }
    }

    // å¤„ç† tool_calls
    if (message.tool_calls) {
      for (const toolCall of message.tool_calls) {
        content += `tool_call: ${toolCall.type}\n`;
        if (toolCall.function) {
          content += `function: ${toolCall.function.name}\n`;
          if (toolCall.function.arguments) {
            content += `arguments: ${toolCall.function.arguments}\n`;
          }
        }
      }
    }

    // æ·»åŠ æ¶ˆæ¯åˆ†éš”ç¬¦
    content += '\n---\n';
  }
  return calcToken(content);
}

module.exports = exports = router.routes();


================================================
FILE: src/routers/agent/run.js
================================================
// @ts-ignore
const router = require("koa-router")();
const handleStream = require("@src/utils/stream.util");

const uuid = require("uuid");
const { Op } = require('sequelize');
const Conversation = require("@src/models/Conversation");
const AgenticAgent = require("@src/agent/AgenticAgent");
const detect_intent = require("@src/agent/intent-detection");
const chat_completion = require('@src/agent/chat-completion/index')
const Message = require("@src/utils/message");
const Agent = require('@src/models/Agent')
const calcToken = require('@src/completion/calc.token.js');
const File = require('@src/models/File')
const Model = require('@src/models/Model')
const path = require('path')
const fs = require('fs').promises
const { getDirpath } = require('@src/utils/electron');
const RUNTIME_TYPE = process.env.RUNTIME_TYPE || 'local-docker'
const { search_intent } = require('@src/agent/chatbot');
const WebSearch = require('@src/tools/WebSearch');

let closeContainer
if (RUNTIME_TYPE && RUNTIME_TYPE === 'local-docker') {
  closeContainer = async () => {
    console.log('æœ¬åœ°ä¸æ‰§è¡Œ')
  }
}

const activeAgents = new Map();
const MessageTable = require('@src/models/Message');

const handle_feedback = require("@src/knowledge/feedback");
const Knowledge = require("@src/models/Knowledge");
const ENABLE_KNOWLEDGE = process.env.ENABLE_KNOWLEDGE || "ON"

/**
 * @swagger
 * /api/agent/run:
 *   post:
 *     tags:
 *       - Agent
 *     summary: Execute code task and push results in real-time via SSE
 *     description: |
 *       Intelligent task execution endpoint that can automatically choose between agent mode and chat mode.
 *       - Agent mode: For complex tasks requiring code execution, file operations, or system interactions
 *       - Chat mode: For simple conversations and general Q&A
 *       - Auto mode (default): Uses AI-based intent detection to choose the appropriate mode
 *       Results are streamed in real-time via SSE.
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               question:
 *                 type: string
 *                 description: User's question or instruction
 *               conversation_id:
 *                 type: string
 *                 description: Conversation ID, used to identify the current conversation
 *               mode:
 *                 type: string
 *                 enum: [auto, agent, chat, twins]
 *                 default: auto
 *                 description: |
 *                   Execution mode:
 *                   - 'auto': Automatically choose between agent and chat based on intent detection
 *                   - 'agent': Force use agent mode for complex tasks
 *                   - 'chat': Force use chat mode for simple conversation
 *                   - 'twins': Execute both chat and agent modes in sequence
 *               fileIds:
 *                 type:json
 *             required:
 *               - question
 *     responses:
 *       200:
 *         description: æµå¼å“åº”å¼€å¯
 *         content:
 *           text/event-stream:
 *             schema:
 *               type: string
 *               description: SSE æ•°æ®æµï¼Œæ¯æ¡æ•°æ®ä¸ºä¸€ä¸ª token
 */
router.post("/run", async (ctx, next) => {
  const { request, response } = ctx;
  const body = request.body || {};
  let { question, conversation_id, fileIds, mcp_server_ids = [], model_id, agent_id, mode = 'auto' } = body;


  await Conversation.update({ model_id, status: "running" }, { where: { conversation_id } })
  await Agent.update({ mcp_server_ids }, { where: { id: agent_id } })
  let files = [];
  console.log("å½“å‰è¿è¡Œä»»åŠ¡ï¼š")
  const WORKSPACE_DIR = getDirpath(process.env.WORKSPACE_DIR || 'workspace', ctx.state.user.id);
  const dir_name = 'Conversation_' + conversation_id.slice(0, 6);
  const dir_path = path.join(WORKSPACE_DIR, dir_name);
  await fs.mkdir(dir_path, { recursive: true });

  // å‡†å¤‡è®°å¿†æ¨¡å—å¤„ç†é€‰é¡¹ï¼ˆä½†æ ¹æ®æ¨¡å¼ä¸åŒæ—¶æœºå¤„ç†ï¼‰
  const feedbackOptions = {
    user_feedback: question,
    conversation_id,
    agent_id,
  };

  if (Array.isArray(fileIds) && fileIds.length > 0) {
    const newFileIds = [];
    for (const fileId of fileIds) {
      // å…ˆæŸ¥è¯¢æ–‡ä»¶
      const file = await File.findOne({ where: { id: fileId } });

      if (file) {
        const originalConversationId = file.conversation_id;
        console.log(`Processing file ${fileId}, current conversation_id: ${originalConversationId}, target: ${conversation_id}`);

        // å¦‚æœ conversation_id ä¸ä¸ºç©ºä¸”ä¸ç­‰äºå½“å‰ conversation_idï¼Œåˆ™å¤åˆ¶
        if (originalConversationId && originalConversationId !== conversation_id) {
          // å¤åˆ¶æ–‡ä»¶è®°å½•
          const fileData = file.toJSON();
          delete fileData.id; // åˆ é™¤ idï¼Œè®©æ•°æ®åº“è‡ªåŠ¨ç”Ÿæˆæ–°çš„ id
          delete fileData.create_at; // åˆ é™¤æ—¶é—´æˆ³
          delete fileData.update_at;
          fileData.conversation_id = conversation_id;
          const newFile = await File.create(fileData);
          console.log(`Copied file ${fileId} to new file ${newFile.id} with conversation_id: ${conversation_id}`);
          newFileIds.push(newFile.id);
        } else {
          // å°è¯•æ›´æ–°ï¼Œä½¿ç”¨ä¹è§‚é”ï¼šåªæœ‰å½“ conversation_id ä»ä¸ºåŸå€¼æ—¶æ‰æ›´æ–°
          const [affectedCount] = await File.update(
            { conversation_id: conversation_id },
            {
              where: {
                id: fileId,
                conversation_id: originalConversationId // ä¹è§‚é”ï¼šåªæœ‰å½“å€¼æœªå˜æ—¶æ‰æ›´æ–°
              }
            }
          );

          // å¦‚æœæ›´æ–°æˆåŠŸï¼ˆaffectedCount > 0ï¼‰ï¼Œä½¿ç”¨åŸæ–‡ä»¶ ID
          if (affectedCount > 0) {
            console.log(`Updated file ${fileId} with conversation_id: ${conversation_id}`);
            newFileIds.push(fileId);
          } else {
            // æ›´æ–°å¤±è´¥ï¼Œè¯´æ˜æ–‡ä»¶å·²è¢«å…¶ä»–è¯·æ±‚ä¿®æ”¹ï¼Œå¤åˆ¶ä¸€ä»½
            console.log(`File ${fileId} was modified by another request, creating a copy`);
            const fileData = file.toJSON();
            delete fileData.id;
            delete fileData.create_at;
            delete fileData.update_at;
            fileData.conversation_id = conversation_id;
            const newFile = await File.create(fileData);
            console.log(`Copied file ${fileId} to new file ${newFile.id} with conversation_id: ${conversation_id}`);
            newFileIds.push(newFile.id);
          }
        }
      }
    }
    console.log(`Final newFileIds:`, newFileIds);
    files = await File.findAll({
      where: {
        id: newFileIds
      }
    });
    console.log(`Found ${files.length} files with conversation_id: ${conversation_id}`);

    // æ ¹æ®æ–‡ä»¶åæŠŠæ–‡ä»¶ä» uploadæ–‡ä»¶å¤¹å†…ï¼Œç§»åŠ¨åˆ° dir_nameä¸‹é¢çš„uploadæ–‡ä»¶å¤¹å†…
    const uploadDir = path.join(WORKSPACE_DIR, 'upload');
    const targetUploadDir = path.join(dir_path, 'upload');
    await fs.mkdir(targetUploadDir, { recursive: true });


    // å¹¶è¡Œå¤åˆ¶æ‰€æœ‰æ–‡ä»¶
    const copyFilePromises = files.map(async (file) => {
      const srcPath = path.join(uploadDir, file.name);
      const destPath = path.join(targetUploadDir, file.name);

      try {
        // å¤åˆ¶æ–‡ä»¶åˆ°ç›®æ ‡ä½ç½®
        await fs.copyFile(srcPath, destPath);
      } catch (err) {
        if (err.code === 'ENOENT') {
          // æ–‡ä»¶ä¸å­˜åœ¨ï¼Œå¯èƒ½å·²ç»è¢«ç§»åŠ¨ï¼Œå¿½ç•¥æ­¤é”™è¯¯
          console.warn(`File not found: ${srcPath}, possibly already moved`);
        } else {
          // å…¶ä»–é”™è¯¯æŠ›å‡º
          throw err;
        }
      }
    });

    await Promise.all(copyFilePromises);
    console.log(`Copied ${files.length} files in parallel`);

  }
  if (!conversation_id) {
    conversation_id = uuid.v4();
    const title = 'Conversation_' + conversation_id.slice(0, 6);
    const newConversation = await Conversation.create({
      conversation_id: conversation_id,
      content: question,
      title: title,
      status: 'running',
      modeType: 'task',
    });
  }

  body.responseType = body.responseType || "sse";
  const { stream, onTokenStream } = handleStream(body.responseType, response);
  // å¤„ç†æ–‡ä»¶ä¿¡æ¯ï¼Œç”¨äºæ¶ˆæ¯ä¿å­˜
  for (let file of files) {
    file.filename = file.name
    file.filepath = path.join(dir_path, file.url)
  }

  const newFiles = files.map(file => {
    let obj = file.dataValues
    obj.filename = obj.name
    obj.filepath = path.join(dir_path, obj.url)
    return obj
  })

  const context = {
    onTokenStream,
    conversation_id,
    user_id: ctx.state.user.id,
    mcp_server_ids,
    agent_id,
  }

  // æ ¹æ® mode å‚æ•°ç¡®å®šå¤„ç†æ–¹å¼
  let intent;
  if (mode === 'auto') {
    // è‡ªåŠ¨é€‰æ‹©ï¼šä½¿ç”¨æ„å›¾è¯†åˆ«
    console.log('è‡ªåŠ¨æ¨¡å¼ï¼šå¼€å§‹æ„å›¾è¯†åˆ«...');
    try {
      // è·å–ä¸Šä¸‹æ–‡æ¶ˆæ¯ç”¨äºæ„å›¾è¯†åˆ«
      const contextMessages = await MessageTable.findAll({
        where: {
          conversation_id: conversation_id
        },
        order: [['create_at', 'ASC']]
      })

      // æ„å»ºä¸Šä¸‹æ–‡æ ¼å¼
      const messagesContext = contextMessages.map(msg => ({
        role: msg.role,
        content: msg.content
      }));

      intent = await detect_intent(question, conversation_id, messagesContext);
      console.log('æ„å›¾è¯†åˆ«ç»“æœ:', intent);
      // å°†ç»“æœæ ‡å‡†åŒ–ä¸ºå°å†™
      intent = intent.toLowerCase().trim();
      if (intent !== 'chat' && intent !== 'agent') {
        console.log('æ„å›¾è¯†åˆ«ç»“æœå¼‚å¸¸ï¼Œé»˜è®¤ä½¿ç”¨agentæ¨¡å¼');
        intent = 'agent';
      }
    } catch (error) {
      console.error('æ„å›¾è¯†åˆ«å¤±è´¥ï¼Œé»˜è®¤ä½¿ç”¨agentæ¨¡å¼:', error);
      intent = 'agent';
    }
  } else {
    // ç”¨æˆ·æŒ‡å®šæ¨¡å¼
    intent = mode.toLowerCase();
    console.log('ç”¨æˆ·æŒ‡å®šæ¨¡å¼:', intent);
    // éªŒè¯æ¨¡å¼å‚æ•°
    if (intent !== 'chat' && intent !== 'agent' && intent !== 'twins') {
      console.log('æ— æ•ˆçš„æ¨¡å¼å‚æ•°ï¼Œé»˜è®¤ä½¿ç”¨agentæ¨¡å¼');
      intent = 'agent';
    }
  }

  // æ ¹æ®æœ€ç»ˆç¡®å®šçš„æ„å›¾é€‰æ‹©ä¸åŒçš„å¤„ç†æ–¹å¼
  // å‘é€æ¨¡å¼é€šçŸ¥åˆ°å‰ç«¯
  const modeNotification = `__lemon_mode__${JSON.stringify({ mode: intent })}\n\n`;
  onTokenStream(modeNotification);

  // æå–å…¬å…±å‚æ•°
  const commonParams = {
    conversation_id, question, newFiles, feedbackOptions,
    onTokenStream, stream, context, agent_id, ctx,
    files, WORKSPACE_DIR
  };

  // æ‰§è¡Œå¯¹åº”çš„æ¨¡å¼
  if (intent === 'chat') {
    await executeChatMode(commonParams, ctx);
  } else if (intent === 'twins') {
    await executeTwinsMode(commonParams, dir_path);
  } else {
    // Agent æ¨¡å¼ï¼šå…ˆå¤„ç†åé¦ˆï¼Œå†æ‰§è¡Œä»»åŠ¡
    console.log('ä½¿ç”¨æ™ºèƒ½ä½“æ¨¡å¼');

    // Agentæ¨¡å¼ï¼šåŒæ­¥å¤„ç†åé¦ˆï¼ˆç¡®ä¿è®°å¿†æ›´æ–°åå†æ‰§è¡Œä»»åŠ¡ï¼‰
    if (ENABLE_KNOWLEDGE === "ON") {
      try {
        await handle_feedback(feedbackOptions);
        // æ›´æ–°æ¡ç›®æ•°
        const knowledge_count = await Knowledge.count({ where: { agent_id: agent_id } });
        await Agent.update({ knowledge_count }, { where: { id: agent_id } });
        console.log('Agentæ¨¡å¼åé¦ˆå¤„ç†å®Œæˆï¼Œå¼€å§‹æ‰§è¡Œä»»åŠ¡');
      } catch (error) {
        console.error('Agentæ¨¡å¼åé¦ˆå¤„ç†å¤±è´¥:', error);
      }
    }

    // Agentæ¨¡å¼çš„streamå…³é—­å¤„ç†ï¼ˆåŒ…å«æˆªå›¾é€»è¾‘ï¼‰
    stream.on('close', async () => {
      console.log('Agent stream closed');
      await closeContainer(ctx.state.user.id)

      //æ›´æ–° Conversation çš„æˆªå›¾
      // await Conversation.update({ screen_shot_url: screen_url }, { where: { conversation_id } })

      // Check if task completed successfully and update recommend field
      await updateAgentRecommend(conversation_id, agent_id);

      // åˆ é™¤åŸuploadæ–‡ä»¶å¤¹ä¸­çš„æ–‡ä»¶
      await deleteSourceFiles(files, WORKSPACE_DIR);
    });

    const onCompleted = () => {
      stream.end();
    };

    // ä¿å­˜ç”¨æˆ·æ¶ˆæ¯ (æ™ºèƒ½ä½“æ¨¡å¼)
    const msg = Message.format({
      role: 'user',
      status: 'success',
      content: question,
      action_type: 'question',
      task_id: conversation_id,
      json: newFiles
    });
    const message = await Message.saveToDB(msg, conversation_id);
    // await syncQuestionVectorData(message.id,question,conversation_id)

    const agent = new AgenticAgent(context);
    activeAgents.set(conversation_id, agent);

    agent.run(question).then(async (content) => {
      console.log('content', content);
      onCompleted();
      activeAgents.delete(conversation_id);
    }).catch(async (error) => {
      const msg = Message.format({ status: 'success', action_type: 'error', content: error.message });
      onTokenStream(msg);
      await Message.saveToDB(msg, conversation_id);
      console.error('Agent run error:', error);
      onCompleted();
      activeAgents.delete(conversation_id);
    });
  }

  ctx.body = stream;
  ctx.status = 200;
});

// æ£€æŸ¥ä»»åŠ¡æ˜¯å¦æ­£å¸¸å®Œæˆå¹¶æ›´æ–° agent recommend å­—æ®µ
async function updateAgentRecommend(conversation_id, agent_id) {
  try {
    const agent = await Agent.findOne({ where: { id: agent_id } });
    if (!agent) {
      console.log(`Agent ${agent_id} not found`);
      return;
    }

    // æ£€æŸ¥æ˜¯å¦å­˜åœ¨ action_type ä¸º "finish_summery" çš„æ¶ˆæ¯
    const messages = await MessageTable.findAll({
      where: {
        conversation_id: conversation_id
      }
    });

    let finishMessage = null;
    for (const message of messages) {
      try {
        let meta = message.meta;
        if (typeof meta === 'string') {
          meta = JSON.parse(meta);
        }
        console.log('meta', meta.action_type)
        if (meta && meta.action_type === 'finish_summery') {
          finishMessage = message;
          break;
        }
      } catch (error) {
        // å¿½ç•¥JSONè§£æé”™è¯¯ï¼Œç»§ç»­æ£€æŸ¥ä¸‹ä¸€æ¡æ¶ˆæ¯
        continue;
      }
    }

    const conversation = await Conversation.findOne({ where: { conversation_id } });
    if (finishMessage && (conversation.status === 'done' || conversation.status === 'completed')) {
      // ä»»åŠ¡æ­£å¸¸å®Œæˆï¼Œå°† recommend è®¾ä¸º 0ï¼ˆå¦‚æœä¹‹å‰æ˜¯ -1ï¼‰
      if (agent.recommend === -1) {
        await Agent.update({ recommend: 0 }, { where: { id: agent_id } });
        console.log(`Agent ${agent_id} recommend updated to 0 (task completed successfully)`);
      }
    } else {
      // ä»»åŠ¡æœªæ­£å¸¸å®Œæˆï¼Œå°† recommend è®¾ä¸º -1
      await Agent.update({ recommend: -1 }, { where: { id: agent_id } });
      console.log(`Agent ${agent_id} recommend updated to -1 (task not completed)`);
    }
  } catch (error) {
    console.error(`Error updating agent recommend for agent ${agent_id}:`, error);
  }
}

// åˆ é™¤uploadæ–‡ä»¶å¤¹ä¸­çš„æºæ–‡ä»¶
async function deleteSourceFiles(files, workspaceDir) {
  if (!files || files.length === 0) {
    return;
  }

  const uploadDir = path.join(workspaceDir, 'upload');
  const deleteFilePromises = files.map(async (file) => {
    const srcPath = path.join(uploadDir, file.name);
    try {
      await fs.unlink(srcPath);
      console.log(`Deleted source file: ${srcPath}`);
    } catch (err) {
      if (err.code === 'ENOENT') {
        // æ–‡ä»¶ä¸å­˜åœ¨ï¼Œå¯èƒ½å·²ç»è¢«åˆ é™¤ï¼Œå¿½ç•¥æ­¤é”™è¯¯
        console.warn(`File not found for deletion: ${srcPath}`);
      } else {
        // å…¶ä»–é”™è¯¯ä»…è®°å½•è­¦å‘Šï¼Œä¸å½±å“ä¸»æµç¨‹
        console.warn(`Failed to delete file: ${srcPath}, error: ${err.message}`);
      }
    }
  });

  await Promise.all(deleteFilePromises);
  console.log(`Deleted ${files.length} source files in parallel`);
}

// æ‰¾åˆ°é™¤äº†todo.mdä»¥å¤–æœ€åç”Ÿæˆçš„æ–‡ä»¶
async function getFinalFile(dir_path) {
  const files = await fs.readdir(dir_path, { withFileTypes: true });
  let latestFile = null;
  let latestMtime = 0;
  let todoFile = null;

  for (const entry of files) {
    if (entry.isFile()) {
      if (entry.name === 'todo.md') {
        todoFile = path.join(dir_path, entry.name);
        continue;
      }
      const filePath = path.join(dir_path, entry.name);
      const stat = await fs.stat(filePath);
      if (stat.mtimeMs > latestMtime) {
        latestMtime = stat.mtimeMs;
        latestFile = filePath;
      }
    }
  }

  if (latestFile) {
    return latestFile;
  } else if (todoFile) {
    return todoFile;
  } else {
    // fallback: if even todo.md doesn't exist, return null
    return null;
  }
}

/**
 * @swagger
 * /api/agent/stop:
 *   post:
 *     tags:
 *       - Agent
 *     summary: åœæ­¢æ­£åœ¨æ‰§è¡Œçš„ Agent ä»»åŠ¡
 *     description: |
 *       æ¥æ”¶ä¸€ä¸ª `conversation_id` å¹¶å°è¯•åœæ­¢å¯¹åº”çš„ AgenticAgent å®ä¾‹ã€‚
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               conversation_id:
 *                 type: string
 *                 description: è¦åœæ­¢çš„ Agent çš„å¯¹è¯ ID
 *             required:
 *               - conversation_id
 *     responses:
 *       200:
 *         description: Agent æˆåŠŸåœæ­¢æˆ–æœªæ‰¾åˆ°æ´»è·ƒ Agent
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   type: string
 *                 code:
 *                   type: integer
 *                   description: Status code
 *                 msg:
 *                   type: string
 *                   description: Message
 */
router.post("/stop", async ({ state, request, response }) => {
  const { conversation_id } = request.body || {};

  const agent = activeAgents.get(conversation_id);

  await Conversation.update({ status: 'stop' }, { where: { conversation_id: conversation_id } });
  await closeContainer(state.user.id)

  // Get agent_id from conversation
  const conversation = await Conversation.findOne({ where: { conversation_id } });
  const agent_id = conversation ? conversation.agent_id : null;

  if (agent) {
    try {
      if (typeof agent.stop === 'function') {
        await agent.stop();
        activeAgents.delete(conversation_id);

        // Check completion status after stop
        if (agent_id) {
          await updateAgentRecommend(conversation_id, agent_id);
        }

        response.success('Agent is stopped')
      } else {
        response.fail('Agent has no stop method')
      }
    } catch (error) {
      response.fail(`Error stopping Agent ${conversation_id}: ${error.message}`)
    }
  } else {
    response.fail(`Agent with conversation_id ${conversation_id} not found`)
  }
});

async function getHistoryMessageSequence(messages, pid) {
  let history_messages = []
  let current_message = messages.find(message => message.id === pid)
  history_messages.push(current_message)
  if (typeof current_message.meta === 'string') {
    current_message.meta = JSON.parse(current_message.meta);
  }
  while (!(current_message.meta.pid === -1)) {
    current_message = messages.find(message => message.id === current_message.meta.pid)
    if (typeof current_message.meta === 'string') {
      current_message.meta = JSON.parse(current_message.meta);
    }
    history_messages.push(current_message)
  }
  // reverse
  history_messages.reverse()
  return history_messages
}

// æŒ‰æ—¶é—´é¡ºåºè·å–æ¶ˆæ¯ä¸Šä¸‹æ–‡ï¼Œä¸”æ€»tokenä¸è¶…è¿‡128k
function getMessagesContextByTime(messages) {
  // æ¶ˆæ¯å·²ç»æŒ‰æ—¶é—´æ’åºï¼Œä»æœ€æ–°å¾€æ—§ç´¯åŠ tokenï¼Œè¶…è¿‡128kå°±ä¸¢å¼ƒæ›´æ—§çš„
  const reversed = messages.slice().reverse();

  let totalTokens = 0;
  const limited = [];
  for (const msg of reversed) {
    const tokens = calcToken(msg.content || "");
    if (totalTokens + tokens > 131072) break;
    limited.push(msg);
    totalTokens += tokens;
  }

  // å†åè½¬å›æ¥ï¼Œä¿æŒä»æ—§åˆ°æ–°çš„æ—¶é—´é¡ºåº
  const finalContext = limited.reverse();

  // è½¬æ¢ä¸º openai æ ‡å‡†æ ¼å¼
  return finalContext.map(msg => ({
    role: msg.role,
    content: msg.content
  }));
}

// æ‰§è¡ŒChatæ¨¡å¼
async function executeChatMode(params, ctx) {
  const { stream, conversation_id, span, startTime } = params;
  console.log('ä½¿ç”¨å¯¹è¯æ¨¡å¼');

  // Chatæ¨¡å¼çš„streamå…³é—­å¤„ç†ï¼ˆæ— éœ€æˆªå›¾é€»è¾‘ï¼‰
  stream.on('close', async () => {
    console.log('Chat stream closed');
    // åˆ é™¤åŸuploadæ–‡ä»¶å¤¹ä¸­çš„æ–‡ä»¶
    const { files, WORKSPACE_DIR } = params;
    await deleteSourceFiles(files, WORKSPACE_DIR);
  });

  await runChatPhase(params, false, ctx); // standalone chat mode
}

// æ‰§è¡ŒTwinsæ¨¡å¼
async function executeTwinsMode(params, dir_path) {
  const { stream, ctx, agent_id, conversation_id, onTokenStream } = params;
  console.log('ä½¿ç”¨åŒé‡æ¨¡å¼ï¼šå…ˆå¯¹è¯ï¼Œåæ™ºèƒ½ä½“');

  // Twinsæ¨¡å¼çš„streamå…³é—­å¤„ç†ï¼ˆåŒ…å«æˆªå›¾é€»è¾‘ï¼Œå› ä¸ºæœ€ç»ˆä¼šæ‰§è¡Œagentï¼‰
  stream.on('close', async () => {
    console.log('Twins stream closed');
    await closeContainer(ctx.state.user.id)
    const screen_url = ''
    const agent = await Agent.findOne({ where: { id: agent_id } })
    if (agent.replay_conversation_id == null) {
      console.log('update screen_shot_url', screen_url)
      await Agent.update({ screen_shot_url: screen_url }, { where: { id: agent_id } })
    }
    // await Conversation.update({ screen_shot_url: screen_url }, { where: { conversation_id } })
    await updateAgentRecommend(conversation_id, agent_id);

    // åˆ é™¤åŸuploadæ–‡ä»¶å¤¹ä¸­çš„æ–‡ä»¶
    const { files, WORKSPACE_DIR } = params;
    await deleteSourceFiles(files, WORKSPACE_DIR);
  });

  // ç¬¬ä¸€é˜¶æ®µï¼šChat
  console.log('Twinsæ¨¡å¼ - ç¬¬ä¸€é˜¶æ®µï¼šå¯¹è¯æ¨¡å¼');
  const chatModeNotification = `__lemon_mode__${JSON.stringify({ mode: 'chat', stage: 'first' })}\n\n`;
  onTokenStream(chatModeNotification);

  await runChatPhase(params, true); // twins mode
}

// é€šç”¨Chatæ‰§è¡Œå‡½æ•°
async function runChatPhase(params, isTwinsMode, ctx) {
  const { conversation_id, question, newFiles, onTokenStream, stream, agent_id, feedbackOptions } = params;

  // å‡†å¤‡ä¸Šä¸‹æ–‡æ¶ˆæ¯
  let messagesContext = []
  const messages = await MessageTable.findAll({
    where: {
      conversation_id: conversation_id
    },
    order: [['create_at', 'ASC']]
  })

  if (messages.length > 0) {
    messagesContext = getMessagesContextByTime(messages)
  }

  let sysPromptMessage = {
    role: 'system',
    content: `
    You are a friendly and helpful chatbot named Lemon. 
    Your role is to assist users by providing concise and accurate responses to their questions or messages. 
    Politely and friendly acknowledge the user's message and provide a clear and relevant answer.
    `
  }
  messagesContext.unshift(sysPromptMessage)

  let search_results = null;
  // åˆ¤æ–­å›ç­”ç”¨æˆ·æ˜¯å¦éœ€è¦æœç´¢
  const document_list = await File.findAll({ where: { conversation_id: conversation_id } })
  let document_list_str = document_list.map(file => file.name).join('\n')
  let search_intent_result = await search_intent(messagesContext, question, document_list_str, conversation_id);
  // å¦‚æœéœ€è¦æœç´¢ï¼Œè¿›è¡Œæœç´¢ï¼Œå¹¶è¿”å›æœç´¢ç»“æœ
  if (search_intent_result.source_type == 'SEARCH') {
    search_results = await WebSearch.execute({ query: search_intent_result.search_query, num_results: 5, conversation_id: conversation_id });
    search_results.json = search_results.meta.json;
    delete search_results.meta;
    messagesContext.push({
      role: 'assistant',
      content: search_results.content
    })
  }

  if (search_results) {
    onTokenStream(`__lemon_chat_${search_intent_result.source_type}_start__\n${JSON.stringify(search_results)}\n__lemon_chat_${search_intent_result.source_type}_end__`)
  }

  // ä¿å­˜ç”¨æˆ·æ¶ˆæ¯
  const userMsg = Message.format({
    role: 'user',
    status: 'success',
    content: question,
    action_type: 'question',
    task_id: conversation_id,
    type: 'chat',
    pid: -1,
    json: newFiles
  });
  let userMessage = await Message.saveToDB(userMsg, conversation_id);
  // await syncQuestionVectorData(userMessage.id,question,conversation_id)
  let new_pid = userMessage.id

  // åˆ›å»º AbortController ç”¨äºæµæ§åˆ¶
  const abortController = new AbortController();
  activeAgents.set(conversation_id, { abort: () => abortController.abort() });

  // Chatå®Œæˆå›è°ƒ
  const onChatCompleted = async (message_id, new_pid) => {
    if (isTwinsMode) {
      // Twinsæ¨¡å¼ï¼šChatå®Œæˆåå‘é€ç»“æŸæ ‡è®°ï¼Œç„¶åæ‰§è¡ŒAgent
      const raw = `__lemon_out_end__{"message_id":"${message_id}","pid":"${new_pid}"}\n\n`;
      onTokenStream(raw);
      await runAgentPhase(params);
    } else {
      // çº¯Chatæ¨¡å¼ï¼šç»“æŸæµ
      const raw = `__lemon_out_end__{"message_id":"${message_id}","pid":"${new_pid}"}\n\n`;
      onTokenStream(raw);
      stream.end();
      await Conversation.update({ status: 'done' }, { where: { conversation_id } })
      activeAgents.delete(conversation_id);
    }

    // Chatæ¨¡å¼åé¦ˆå¤„ç†ï¼ˆå¼‚æ­¥ï¼‰
    if (ENABLE_KNOWLEDGE === "ON") {
      try {
        await handle_feedback(feedbackOptions);
        const knowledge_count = await Knowledge.count({ where: { agent_id: agent_id } });
        await Agent.update({ knowledge_count }, { where: { id: agent_id } });
        console.log('Chaté˜¶æ®µåé¦ˆå¤„ç†å®Œæˆ');
      } catch (error) {
        console.error('Chaté˜¶æ®µåé¦ˆå¤„ç†å¤±è´¥:', error);
      }
    }
  };

  // è°ƒç”¨å¤§æ¨¡å‹
  const options = {
    temperature: 0.7,
    messages: messagesContext,
    signal: abortController.signal
  }

  chat_completion(question, options, conversation_id, onTokenStream).then(async (content) => {
    const assistant_msg = Message.format({
      role: 'assistant',
      status: 'success',
      content: content,
      action_type: 'chat',
      task_id: conversation_id,
      type: 'chat',
      pid: new_pid,
      json: search_results ? search_results.json : null,
      // search_resultså¹¶ä¸”search_results.metaå¹¶ä¸”search_results.meta.contentå­˜åœ¨ å°±èµ‹å€¼ã€‚å¦åˆ™ä¸ºnull
      meta_content: (search_results && search_results.content) ? search_results.content : null
    });
    let new_message = await Message.saveToDB(assistant_msg, conversation_id);
    await onChatCompleted(new_message.id, new_pid);
  }).catch(async (error) => {
    console.error('Chat phase error:', error);
    const content = error.message
    const assistant_msg = Message.format({
      role: 'assistant',
      status: 'success',
      content: content,
      action_type: 'chat',
      task_id: conversation_id,
      type: 'chat',
      pid: new_pid,
      json: search_results ? search_results.json : null
    });
    let new_message = await Message.saveToDB(assistant_msg, conversation_id);
    await onChatCompleted(new_message.id, new_pid);
  });
}

// æ‰§è¡ŒAgenté˜¶æ®µï¼ˆç”¨äºTwinsæ¨¡å¼çš„ç¬¬äºŒé˜¶æ®µï¼‰
async function runAgentPhase(params) {
  const { conversation_id, question, newFiles, onTokenStream, stream, context, agent_id, feedbackOptions } = params;

  console.log('Twinsæ¨¡å¼ - ç¬¬äºŒé˜¶æ®µï¼šæ™ºèƒ½ä½“æ¨¡å¼');
  const agentModeNotification = `__lemon_mode__${JSON.stringify({ mode: 'agent', stage: 'second' })}\n\n`;
  onTokenStream(agentModeNotification);

  // Agentæ¨¡å¼ï¼šåŒæ­¥å¤„ç†åé¦ˆ
  if (ENABLE_KNOWLEDGE === "ON") {
    try {
      await handle_feedback(feedbackOptions);
      const knowledge_count = await Knowledge.count({ where: { agent_id: agent_id } });
      await Agent.update({ knowledge_count }, { where: { id: agent_id } });
      console.log('Agenté˜¶æ®µåé¦ˆå¤„ç†å®Œæˆï¼Œå¼€å§‹æ‰§è¡Œä»»åŠ¡');
    } catch (error) {
      console.error('Agenté˜¶æ®µåé¦ˆå¤„ç†å¤±è´¥:', error);
    }
  }

  // ä¿å­˜ç”¨æˆ·æ¶ˆæ¯ (æ™ºèƒ½ä½“æ¨¡å¼)
  const agentMsg = Message.format({
    role: 'user',
    status: 'success',
    content: question,
    action_type: 'question',
    task_id: conversation_id,
    json: newFiles
  });
  const message = await Message.saveToDB(agentMsg, conversation_id);
  // await syncQuestionVectorData(message.id,question,conversation_id)
  const agentOnCompleted = () => {
    stream.end();
  };

  const agent = new AgenticAgent(context);
  activeAgents.set(conversation_id, agent);

  agent.run(question).then(async (content) => {
    console.log('Agenté˜¶æ®µå®Œæˆ');
    agentOnCompleted();
    activeAgents.delete(conversation_id);
  }).catch(async (error) => {
    const msg = Message.format({ status: 'success', action_type: 'error', content: error.message });
    onTokenStream(msg);
    await Message.saveToDB(msg, conversation_id);
    console.error('Agenté˜¶æ®µé”™è¯¯:', error);
    agentOnCompleted();
    activeAgents.delete(conversation_id);
  });
}


module.exports = exports = router.routes();


================================================
FILE: src/routers/agent/xml.txt
================================================
[Binary file]


================================================
FILE: src/routers/agent/utils/coding-agent.js
================================================
const AgenticAgent = require("@src/agent/AgenticAgent");
const Agent = require('@src/models/Agent');
const { getMessageHistory } = require('./coding-messages');

// Get agent information and context
async function getAgentContext(agent_id, conversation_id) {
  if (!agent_id) {
    return {
      agent: null,
      messages: []
    };
  }

  try {
    // Get agent configuration
    const agent = await Agent.findOne({ where: { id: agent_id } });
    if (!agent) {
      console.warn(`Agent ${agent_id} not found`);
      return { agent: null, messages: [] };
    }

    // Get conversation history
    const messages = await getMessageHistory(conversation_id);

    return {
      agent: {
        id: agent.id,
        name: agent.name,
        description: agent.description,
        model_id: agent.model_id,
        mcp_server_ids: agent.mcp_server_ids || [],
        settings: agent.settings || {},
        knowledge_count: agent.knowledge_count || 0
      },
      messages
    };
  } catch (error) {
    console.error('Failed to get agent context:', error);
    return { agent: null, messages: [] };
  }
}

// Create and initialize agent instance
async function initializeAgent(params) {
  const {
    conversation_id,
    user_id,
    agent_id,
    mcp_server_ids = [],
    onTokenStream
  } = params;

  // Build context for AgenticAgent
  const context = {
    onTokenStream,
    conversation_id,
    user_id,
    mcp_server_ids,
    agent_id,
    planning_mode: 'search'
  };

  const agent = new AgenticAgent(context);
  return agent;
}

// Execute agent task
async function executeAgentTask(agent, question) {
  try {
    const result = await agent.run(question);
    return { success: true, result };
  } catch (error) {
    console.error('Agent execution failed:', error);
    return { success: false, error: error.message };
  }
}

module.exports = {
  getAgentContext,
  initializeAgent,
  executeAgentTask
};


================================================
FILE: src/routers/agent/utils/coding-api.js
================================================
/**
 * Simplified API for coding tasks
 * Can be used from anywhere in the codebase
 */

const { executeCoding } = require('./coding-executor');

/**
 * Simple API to execute coding task
 * @param {Object} params - Task parameters
 * @returns {Promise<{success: boolean, data?: any, error?: string}>}
 */
async function runCodingTask(params) {
  const {
    conversation_id,
    agent_id,
    filepath,
    selection,
    requirement,
    userId,
    docsetId = null,
    onProgress = null
  } = params;

  return await executeCoding({
    conversation_id,
    agent_id,
    filepath,
    selection,
    requirement,
    userId,
    docsetId,
    onTokenStream: onProgress
  });
}

/**
 * Execute coding without setup (for internal use)
 * @param {Object} context - Pre-built context
 * @returns {Promise<{success: boolean, data?: any, error?: string}>}
 */
async function runCodingDirect(context) {
  const { coding } = require("@src/editor/coding.js");

  try {
    const result = await coding(
      {
        selection: context.selection,
        requirement: context.requirement
      },
      context
    );
    return { success: true, data: result };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

module.exports = {
  runCodingTask,
  runCodingDirect
};


================================================
FILE: src/routers/agent/utils/coding-cleanup.js
================================================
const Conversation = require("@src/models/Conversation");
const {
  handlePostExecution,
  getContainerCloseHandler
} = require('./coding-helpers');
const { saveCodingResult } = require('./coding-messages');

const fs = require('fs').promises;
const path = require('path');

const resolveFiles = async (files) => {
  const filesMetadata = await Promise.all(
    files.map(async (file) => {
      const stats = await fs.stat(file);
      return {
        filepath: file,
        filename: path.basename(file), // ä½¿ç”¨ path.basename æ›´å®‰å…¨åœ°æå–æ–‡ä»¶å
        filesize: stats.size,
        mtime: stats.mtime, // æ·»åŠ ä¿®æ”¹æ—¶é—´ç”¨äºæ’åº
      };
    })
  );

  // æŒ‰ä¿®æ”¹æ—¶é—´å€’åºæ’åºï¼ˆæœ€æ–°çš„æ–‡ä»¶åœ¨å‰é¢ï¼‰
  return filesMetadata.sort((a, b) => b.mtime - a.mtime).map(({ mtime, ...rest }) => rest);
}

async function handleCodingResult(setup = {}, result) {
  const { conversation_id, onTokenStream, stream, filepath } = setup;
  console.log("filepath", filepath);
  const files = await resolveFiles([filepath]);
  const message = 'Coding task completed successfully';
  await saveCodingResult(onTokenStream, conversation_id, message, files);
  await Conversation.update({ status: 'done' }, { where: { conversation_id } });
  stream.end();
}

/**
 * Setup stream close handler
 */
function setupStreamCloseHandler(params) {
  const {
    stream,
    conversation_id,
    agent_id,
    userId,
    dir_path,
    filepath,
    token,
    onCleanup
  } = params;

  stream.on('close', async () => {
    console.log('Coding stream closed');

    try {
      // Close container
      const closeContainer = getContainerCloseHandler();
      await closeContainer(userId);

      // Handle post-execution tasks
      await handlePostExecution(
        conversation_id,
        agent_id,
        dir_path,
        filepath,
        token
      );

      // Custom cleanup callback
      if (onCleanup) {
        await onCleanup();
      }
    } catch (error) {
      console.error('Stream cleanup error:', error);
    }
  });
}

module.exports = {
  handleCodingResult,
  setupStreamCloseHandler
};


================================================
FILE: src/routers/agent/utils/coding-executor.js
================================================
const { coding } = require("@src/editor/coding.js");
const { getAgentContext, initializeAgent, executeAgentTask } = require('./coding-agent');
const { analyzeRequirementForAgent } = require('./coding-intent');

/**
 * Core coding execution logic
 * Step 1: Analyze if agent is needed
 * Step 2: Execute agent to gather information (if needed)
 * Step 3: Use agent results to execute coding
 */
async function executeCoding({
  conversation_id,
  agent_id,
  filepath,
  selection,
  screenshot,
  requirement,
  userId,
  onTokenStream,
  mcp_server_ids = []
}) {
  let agentResult = null;
  let agentContext = null;

  // Step 1: Analyze if agent is needed based on requirement
  let shouldUseAgent = false;
  let agentQuery = '';

  if (agent_id) {
    // Check if we should use agent based on requirement analysis
    const analysis = await analyzeRequirementForAgent(requirement, conversation_id);
    console.log('Agent requirement analysis:', analysis);

    shouldUseAgent = analysis.needsAgent;
    agentQuery = analysis.agentQuery;

    // Log decision for monitoring
    if (!shouldUseAgent) {
      console.log('Agent not needed for this requirement, proceeding directly with coding');
    }
  }

  // Step 2: Execute agent if needed
  if (agent_id && shouldUseAgent) {
    // Get agent context
    const { agent, messages } = await getAgentContext(agent_id, conversation_id);
    agentContext = agent;

    // Initialize and run agent to gather information
    const agentInstance = await initializeAgent({
      conversation_id,
      user_id: userId,
      agent_id,
      mcp_server_ids,
      onTokenStream
    });

    // Execute agent with the requirement to gather context
    const agent_goal = agentQuery || formatAgentGoal(requirement);
    console.log('coding pre agent goal:', agent_goal);
    const agentExecution = await executeAgentTask(agentInstance, agent_goal);

    if (agentExecution.success) {
      agentResult = agentExecution.result;
      console.log('Agent analysis completed:', agentResult);
    } else {
      console.warn('Agent execution failed:', agentExecution.error);
    }
  }

  // Step 3: Execute coding with agent results (if any)
  return await executeCodingWithRetry({
    filepath,
    selection,
    requirement,
    conversation_id,
    userId,
    agent: agentContext,
    agentResult,
    messages: [],
    onTokenStream
  });
}

/**
 * Format agent goal based on requirement
 */
function formatAgentGoal(requirement) {
  return `è¯·æ ¹æ®ä¸‹é¢çš„éœ€æ±‚æä¾›å‡†ç¡®çš„å†…å®¹ä¿¡æ¯è¿”å›, ä¸è¦å†™å…¥åˆ°æ–‡ä»¶ä¸­, è¯·åœ¨æ€»ç»“ä¸­è¾“å‡ºå†…å®¹ä¿¡æ¯, ä½¿ç”¨æœ€å°‘çš„æ­¥éª¤é€šè¿‡æœç´¢/è¯»å–å®Œæˆ, ä¸è¦ç¼–é€ ä¿¡æ¯
éœ€æ±‚æ˜¯: ${requirement}`;
}

/**
 * Execute coding with retry wrapper
 */
async function executeCodingWithRetry(params = {}) {

  const { filepath, selection, requirement, conversation_id, userId, agent, agentResult, messages, onTokenStream } = params;

  const context = {
    filepath,
    conversation_id,
    user_id: userId,
    agent_context: agent,
    agent_result: agentResult,
    messages,
    onTokenStream
  };

  const information = agentResult?.summary || '';
  console.log('Information:', information);
  const options = { selection, requirement, information };
  return await coding(options, context);
}

module.exports = {
  executeCoding,
  executeCodingWithRetry,
  analyzeRequirementForAgent
};


================================================
FILE: src/routers/agent/utils/coding-helpers.js
================================================
const uuid = require("uuid");
const fs = require('fs').promises;
const path = require('path');
const { Op } = require('sequelize');
const { getDirpath } = require('@src/utils/electron');
const Conversation = require("@src/models/Conversation");
const File = require('@src/models/File');
const Model = require('@src/models/Model');
const Agent = require('@src/models/Agent');
const MessageModel = require("@src/models/Message");
const handle_feedback = require("@src/knowledge/feedback");
const Knowledge = require("@src/models/Knowledge");

const ensureConversation = async (conversation_id, requirement, user_id, agent_id) => {
  if (!conversation_id) {
    conversation_id = uuid.v4();
    const title = `Conversation_${conversation_id.slice(0, 6)}`;
    await Conversation.create({
      conversation_id,
      content: requirement,
      title,
      status: 'running',
      modeType: 'coding',
      agent_id,
      user_id
    });
  } else {
    await Conversation.update(
      { status: 'running', agent_id },
      { where: { conversation_id } }
    );
  }
  return conversation_id;
}

const prepareWorkspace = async (conversation_id, user_id) => {
  const WORKSPACE_DIR = getDirpath(process.env.WORKSPACE_DIR || 'workspace', user_id);
  const dir_name = 'Conversation_' + conversation_id.slice(0, 6);
  const dir_path = path.join(WORKSPACE_DIR, dir_name);
  await fs.mkdir(dir_path, { recursive: true });
  return { WORKSPACE_DIR, dir_path };
}

const processFileUploads = async (fileIds, conversation_id, dir_path, WORKSPACE_DIR, user_id) => {
  if (!Array.isArray(fileIds) || fileIds.length === 0) {
    return { files: [], docsetId: null };
  }

  // Update file associations
  for (const fileId of fileIds) {
    await File.update({ conversation_id }, { where: { id: fileId } });
  }

  const files = await File.findAll({ where: { id: fileIds } });

  // Move files
  const uploadDir = path.join(WORKSPACE_DIR, 'upload');
  const targetUploadDir = path.join(dir_path, 'upload');
  await fs.mkdir(targetUploadDir, { recursive: true });

  let conversation = await Conversation.findOne({ where: { conversation_id } });
  let docsetId = conversation?.docset_id || null;
  const apiKey = process.env.ARYN_API_KEY;

  for (const file of files) {
    const srcPath = path.join(uploadDir, file.name);
    const destPath = path.join(targetUploadDir, file.name);

    try {
      await fs.rename(srcPath, destPath);
    } catch (err) {
      if (err.code === 'EXDEV' || err.code === 'EEXIST') {
        await fs.copyFile(srcPath, destPath);
        await fs.unlink(srcPath);
      } else {
        throw err;
      }
    }

    // Upload to docset if supported
    if (apiKey) {
      docsetId = await uploadToDocset(file, destPath, conversation, conversation_id, user_id, docsetId, apiKey);
    }
  }

  return {
    files: files.map(file => ({
      ...file.dataValues,
      filename: file.name,
      filepath: path.join(dir_path, 'upload', file.name)
    })),
    docsetId
  };
}

// Process knowledge feedback
async function processKnowledgeFeedback(requirement, conversation_id, agent_id) {
  const ENABLE_KNOWLEDGE = process.env.ENABLE_KNOWLEDGE || "ON";

  if (ENABLE_KNOWLEDGE !== "ON" || !agent_id) {
    return;
  }

  try {
    await handle_feedback({
      user_feedback: requirement,
      conversation_id,
      agent_id,
    });

    const knowledge_count = await Knowledge.count({ where: { agent_id } });
    await Agent.update({ knowledge_count }, { where: { id: agent_id } });

    // æ›´æ–° system knowledge_count
    const currentAgent = await Agent.findOne({ where: { id: agent_id } });
    if (currentAgent && currentAgent.role_id) {
      const systemKnowledgeCount = await Knowledge.count({ where: { agent_id: currentAgent.role_id } });
      await Agent.update({ knowledge_count: systemKnowledgeCount }, { where: { id: currentAgent.role_id } });
    }

    console.log('Knowledge feedback processed');
  } catch (error) {
    console.error('Knowledge feedback failed:', error);
  }
}

// Handle post-execution tasks
async function handlePostExecution(conversation_id, agent_id, dir_path, filepath, token) {
  const tasks = [];

  // Take screenshot if needed
  if (agent_id) {
    tasks.push(captureScreenshot(dir_path, filepath, conversation_id, agent_id, token));
  }

  // Update agent recommendation
  if (agent_id) {
    tasks.push(updateAgentRecommend(conversation_id, agent_id));
  }

  // Update conversation status
  tasks.push(Conversation.update({ status: 'done' }, { where: { conversation_id } }));

  await Promise.allSettled(tasks);
}

const captureScreenshot = async (dir_path, filepath, conversation_id, agent_id, token) => {
  try {
    const final_file = await findFinalFile(dir_path, filepath);
    if (!final_file) return;

    const url = `${process.env.SUB_SERVER_DOMAIN}/file/?url=${final_file}`;
    const tokenString = token?.startsWith('Bearer ') ? token.slice(7) : token;

    if (!tokenString) return;

    // const result = await takeScreenshotAndUpload(url, {
    //   accessToken: tokenString,
    //   conversation_id
    // });

    // if (result?.screenshotUrl) {
    //   const agent = await Agent.findOne({ where: { id: agent_id } });
    //   if (agent && !agent.replay_conversation_id) {
    //     await Agent.update(
    //       { screen_shot_url: result.screenshotUrl },
    //       { where: { id: agent_id } }
    //     );
    //     console.log('Screenshot updated:', result.screenshotUrl);
    //   }
    // }
  } catch (error) {
    console.error('Screenshot capture failed:', error);
  }
}

const findFinalFile = async (dir_path, filepath) => {
  try {
    if (filepath) {
      const fullPath = path.isAbsolute(filepath) ? filepath : path.join(dir_path, filepath);
      const exists = await fs.access(fullPath).then(() => true).catch(() => false);
      if (exists) return fullPath;
    }

    const files = await fs.readdir(dir_path, { withFileTypes: true });
    let latestFile = null;
    let latestMtime = 0;

    for (const entry of files) {
      if (entry.isFile() && !entry.name.startsWith('.')) {
        const filePath = path.join(dir_path, entry.name);
        const stat = await fs.stat(filePath);
        if (stat.mtimeMs > latestMtime) {
          latestMtime = stat.mtimeMs;
          latestFile = filePath;
        }
      }
    }

    return latestFile;
  } catch (error) {
    console.error('Error finding final file:', error);
    return null;
  }
}

const updateAgentRecommend = async (conversation_id, agent_id) => {
  try {
    const agent = await Agent.findOne({ where: { id: agent_id } });
    if (!agent) return;

    const messages = await MessageModel.findAll({ where: { conversation_id } });

    let hasCompletion = false;
    for (const message of messages) {
      try {
        let meta = message.meta;
        if (typeof meta === 'string') {
          meta = JSON.parse(meta);
        }
        if (meta?.action_type === 'coding_complete') {
          hasCompletion = true;
          break;
        }
      } catch (e) {
        continue;
      }
    }

    const newRecommend = hasCompletion ? 0 : -1;
    if (agent.recommend !== newRecommend) {
      await Agent.update({ recommend: newRecommend }, { where: { id: agent_id } });
      console.log(`Agent ${agent_id} recommendation updated to ${newRecommend}`);
    }
  } catch (error) {
    console.error(`Error updating agent recommendation:`, error);
  }
}

const updateAgentSettings = async (agent_id, mcp_server_ids) => {
  if (!agent_id) return;

  try {
    await Agent.update(
      { mcp_server_ids },
      { where: { id: agent_id } }
    );
    console.log(`Agent ${agent_id} settings updated`);
  } catch (error) {
    console.error('Failed to update agent settings:', error);
  }
}

const getContainerCloseHandler = () => {
  const RUNTIME_TYPE = process.env.RUNTIME_TYPE;

  if (RUNTIME_TYPE === 'e2b') {
    return require('@src/utils/e2b').closeContainer;
  } else if (RUNTIME_TYPE === 'local-docker') {
    return async () => console.log('Local environment - skip container close');
  } else {
    return require('@src/utils/eci_server').closeContainer;
  }
}

module.exports = {
  ensureConversation,
  prepareWorkspace,
  processFileUploads,
  processKnowledgeFeedback,
  handlePostExecution,
  updateAgentRecommend,
  updateAgentSettings,
  getContainerCloseHandler
};


================================================
FILE: src/routers/agent/utils/coding-intent.js
================================================
const chat_completion = require('@src/agent/chat-completion/index')

/**
 * Analyze requirement to determine if agent is needed for information gathering
 * Returns structured decision result for engineering use
 */
async function analyzeRequirementForAgent(requirement, conversation_id) {

  const prompt = `You are an AI assistant specializing in analyzing front-end web development requests. 
Your primary goal is to determine if a user's request can be completed with coding and general knowledge, or if it requires an agent to fetch external, real-time, or specific data.

If an agent is required, you must also translate the user's request into a clear, actionable search or data-fetching goal for that agent.

## Requirement
${requirement}

## Analysis Rules

Does the request need external data?

### YES (needsAgent: true) 

if it involves:
Real-time information: Stock prices, weather forecasts, news headlines, currency exchange rates.
Specific, non-common knowledge: Financial reports, technical specifications, data for a specific year/company not generally known.
Calling external APIs: Explicitly asking to fetch data from a URL.

### NO (needsAgent: false) 

if it's a self-contained task:
Styling, layout, or logic changes to the existing HTML, CSS, or JavaScript.
Adding content based on general knowledge (e.g., language translations, simple facts).
Code refactoring or formatting.

### If needsAgent: true, what is the agent's goal?

Rewrite the user's request into a precise goal. Be specific about the entity, time frame, and data points needed.

#### Examples
User Requirement: "å¸®sæˆ‘åŠ ä¸€ä¸ªæ³•è¯­ç‰ˆæœ¬"
Analysis: This is a self-contained task based on general knowledge.
Result:

{
  "needsAgent": false,
  "agentQuery": null,
  "reason": "è¯¥ä»»åŠ¡ä»…éœ€è¦é€šç”¨çš„ç¿»è¯‘çŸ¥è¯†ï¼Œæ— éœ€å¤–éƒ¨æ•°æ®æŸ¥è¯¢ã€‚"
}

User Requirement: "å¸®æˆ‘åœ¨é¡µé¢ä¸Šè¡¥å…… A å…¬å¸åœ¨2025å¹´çš„è‚¡ç¥¨èµ°åŠ¿æŠ˜çº¿å›¾"

Analysis: This requires specific, external financial data for a particular company and year. The user's request must be translated into an actionable query.
Result:
{
  "needsAgent": true,
  "agentQuery": "æŸ¥è¯¢ A å…¬å¸åœ¨2025å¹´æ¯ä¸ªæœˆçš„è‚¡ç¥¨ä»·æ ¼æ•°æ®, åŒ…å«æ—¥æœŸã€å¼€ç›˜ä»·ã€æ”¶ç›˜ä»·ã€æœ€é«˜ä»·å’Œæœ€ä½ä»·",
  "reason": "éœ€è¦ä»å¤–éƒ¨æŸ¥è¯¢ç²¾ç¡®çš„ã€å†å²æ€§çš„è‚¡ç¥¨æ•°æ®æ¥ç»˜åˆ¶å›¾è¡¨"
}

User Requirement: "è·å–åŒ—äº¬å½“å‰çš„å¤©æ°”ï¼Œå¹¶æ˜¾ç¤ºåœ¨é¡µé¢çš„ä¸€ä¸ªå¡ç‰‡é‡Œ"

Analysis: This requires fetching real-time data from an external weather service.
Result:
{
  "needsAgent": true,
  "agentQuery": "æŸ¥è¯¢ä¸­å›½åŒ—äº¬å½“å‰çš„å¤©æ°”ä¿¡æ¯, åŒ…æ‹¬æ¸©åº¦ã€å¤©æ°”çŠ¶å†µï¼ˆå¦‚æ™´ã€å¤šäº‘ï¼‰ã€æ¹¿åº¦å’Œé£åŠ›ç­‰çº§",
  "reason": "éœ€è¦è°ƒç”¨å¤–éƒ¨APIè·å–å®æ—¶çš„å¤©æ°”æ•°æ®"
}

## RESPONSE FORMAT (IMPORTANT - respond with ONLY this JSON):

{
  "needsAgent": true/false,
  "agentQuery": "The specific, actionable goal for the agent, or null if not needed.",
  "reason": "A brief explanation for your decision."
}
`;

  try {
    let response = await chat_completion(prompt, {
      temperature: 0.1,  // Low temperature for stable results
      response_format: 'json'
    }, conversation_id)

    // Parse JSON response with fallback
    try {
      console.log('Agent requirement analysis response:', response);
      if (typeof response === 'string') {
        response = JSON.parse(response);
      }
      // Validate response structure
      if (typeof response.needsAgent !== 'boolean') {
        throw new Error('Invalid response structure');
      }

      return {
        needsAgent: response.needsAgent,
        agentQuery: response.agentQuery,
        reason: response.reason || '',
        confidence: response.confidence || 0.5
      };
    } catch (parseError) {
      // Fallback: look for keywords if JSON parsing fails
      const lowerResponse = response.toLowerCase();
      const needsAgent = lowerResponse.includes('true') ||
        lowerResponse.includes('éœ€è¦') ||
        lowerResponse.includes('yes');

      console.warn('JSON parsing failed, using fallback detection:', needsAgent);
      return {
        needsAgent,
        reason: 'Fallback detection used',
        confidence: 0.3
      };
    }
  } catch (error) {
    console.error('Requirement analysis failed:', error);
    // Default to using agent on error for safety
    return {
      needsAgent: true,
      reason: 'Analysis failed, defaulting to safe option',
      confidence: 0.0
    };
  }
}

module.exports = {
  analyzeRequirementForAgent
};


================================================
FILE: src/routers/agent/utils/coding-messages.js
================================================
const Message = require("@src/utils/message");
const MessageModel = require("@src/models/Message");
const calcToken = require('@src/completion/calc.token.js');

// Send progress message
async function sendProgressMessage(onTokenStream, conversation_id, content, action_type = 'progress') {
  const msg = Message.format({
    role: 'system',
    status: 'success',
    content,
    action_type,
    task_id: conversation_id
  });
  onTokenStream(msg);
  await Message.saveToDB(msg, conversation_id);
  return msg;
}

const sendCodingMessage = async (onTokenStream, conversation_id, content, action_type = 'coding', json = {}) => {
  const msg = Message.format({
    role: 'system',
    status: 'success',
    content,
    action_type,
    task_id: conversation_id,
    json
  });
  onTokenStream(msg);
  await Message.saveToDB(msg, conversation_id);
  return msg;
}


// Save user message
async function saveUserMessage(conversation_id, requirement, filepath, selection, files, screenshot) {
  const msg = Message.format({
    role: 'user',
    status: 'success',
    content: requirement,
    action_type: 'question',
    task_id: conversation_id,
    json: { filepath, selection, files, screenshot }
  });
  await Message.saveToDB(msg, conversation_id);
  return msg;
}

// Save coding result message
const saveCodingResult = async (onTokenStream, conversation_id, content, files) => {
  const msg = Message.format({
    role: 'assistant',
    status: 'success',
    content,
    action_type: 'progress',
    task_id: conversation_id,
    json: files
  });
  onTokenStream(msg);
  await Message.saveToDB(msg, conversation_id);
  return msg;
}

// Get message history with token limit
async function getMessageHistory(conversation_id, maxTokens = 131072) {
  const messages = await MessageModel.findAll({
    where: { conversation_id },
    order: [['create_at', 'ASC']]
  });

  if (messages.length === 0) return [];

  // Reverse to count from newest
  const reversed = messages.slice().reverse();

  let totalTokens = 0;
  const limited = [];

  for (const msg of reversed) {
    const tokens = calcToken(msg.content || "");
    if (totalTokens + tokens > maxTokens) break;
    limited.push(msg);
    totalTokens += tokens;
  }

  // Reverse back to chronological order
  return limited.reverse().map(msg => ({
    role: msg.role,
    content: msg.content
  }));
}

module.exports = {
  sendProgressMessage,
  sendCodingMessage,
  saveUserMessage,
  saveCodingResult,
  getMessageHistory
};


================================================
FILE: src/routers/agent/utils/coding-setup.js
================================================
const uuid = require("uuid");
const handleStream = require("@src/utils/stream.util");
const {
  ensureConversation,
  prepareWorkspace,
  processFileUploads,
  updateAgentSettings
} = require('./coding-helpers');

const { saveUserMessage } = require('./coding-messages');
const { uploadBase64Image } = require('@src/utils/img_upload');
/**
 * å¤„ç†screenshotæ•°æ®ï¼Œä¸Šä¼ åˆ°OSSå¹¶è¿”å›URL
 * @param {string} screenshot - base64å›¾ç‰‡æ•°æ®
 * @param {string} conversation_id - å¯¹è¯ID
 * @returns {Promise<string>} å¤„ç†åçš„URLæˆ–åŸå§‹æ•°æ®
 */
async function processScreenshot(screenshot, conversation_id) {
  if (!screenshot || typeof screenshot !== 'string' || !screenshot.startsWith('data:image/')) {
    return screenshot;
  }

  try {
    console.log('å¤„ç†æˆªå›¾æ•°æ®...');

    // todo å®ç°æ–°çš„uploadBase64Image
    const uploadResult = await uploadBase64Image(screenshot, {
      prefix: `coding-screenshots/${conversation_id}`,
      fileName: `selection-${Date.now()}.png`
    });

    if (uploadResult.success) {
      console.log('æˆªå›¾ä¸Šä¼ æˆåŠŸ:', uploadResult.url);
      return uploadResult.url;
    } else {
      console.error('æˆªå›¾ä¸Šä¼ å¤±è´¥:', uploadResult.error);
      return screenshot;
    }
  } catch (error) {
    console.error('å¤„ç†æˆªå›¾æ•°æ®æ—¶å‡ºé”™:', error.message);
    return screenshot;
  }
}

/**
 * Setup everything needed for coding task
 * Returns all necessary context and utilities
 */
async function setupCodingTask(ctx) {
  const { request, response } = ctx;
  const body = request.body || {};
  const userId = ctx.state.user.id;

  let {
    conversation_id,
    selection,
    screenshot,
    requirement,
    filepath,
    fileIds,
    agent_id,
    model_id,
    mcp_server_ids = []
  } = body;

  // Validate permissions
  // await validateModelPermissions(model_id, userId);

  // Ensure conversation exists
  conversation_id = await ensureConversation(conversation_id, requirement, userId, agent_id);

  // Process screenshot and upload to OSS
  const processedScreenshot = await processScreenshot(screenshot, conversation_id);

  // Update agent settings if needed
  if (agent_id) {
    await updateAgentSettings(agent_id, mcp_server_ids);
  }

  // Prepare workspace
  const { dir_path, WORKSPACE_DIR } = await prepareWorkspace(conversation_id, userId);

  // Process file uploads
  const { files, docsetId } = await processFileUploads(
    fileIds, conversation_id, dir_path, WORKSPACE_DIR, userId
  );

  // Setup SSE stream
  const { stream, onTokenStream } = handleStream('sse', response);

  // Send initial messages  
  await saveUserMessage(conversation_id, requirement, filepath, selection, files, processedScreenshot);

  return {
    // Request data
    conversation_id,
    selection,
    screenshot: processedScreenshot,
    requirement,
    filepath,
    agent_id,
    userId,
    mcp_server_ids,

    // Processed data
    dir_path,
    files,
    docsetId,

    // Stream utilities
    stream,
    onTokenStream,

    // Context
    ctx
  };
}

module.exports = {
  setupCodingTask,
  processScreenshot
};


================================================
FILE: src/routers/agent_store/agent_remix.js
================================================
const Agent = require("@src/models/Agent");
const Knowledge = require('@src/models/Knowledge')
const { Op } = require("sequelize");

const agent_remix = async (agent_id,user_id) => { 
    try {
        await Agent.increment('direct_reference_count', { by: 1, where: { id: agent_id } });
        await Agent.increment('total_reference_count', { by: 1, where: { id: agent_id } });
    
        const agent = await Agent.findOne({ where: { id: agent_id } })
    
        const knowledges = await Knowledge.findAll({
          where: {
            agent_id,
            category: { [Op.in]: ['planning', 'execution', 'core_directive'] }
          }
        });
    
        const new_agent = await Agent.create({
          user_id,
          name: agent.dataValues.name,
          describe: agent.dataValues.describe,
          screen_shot_url:agent.dataValues.screen_shot_url,
          is_public: true,
          knowledge_count: knowledges.length,
          source_agent_ids: [agent_id]
        })
    
    
        let insert_knowledges = knowledges.map(item => {
          return {
            'user_id': user_id,
            'agent_id': new_agent.dataValues.id,
            'category': item.dataValues.category,
            'content': item.dataValues.content,
            'is_learned': true
          }
        })
    
        await Knowledge.bulkCreate(insert_knowledges)
    
        return new_agent
      } catch (e) {
        console.log(e)
        return null
      }
}

module.exports = exports = agent_remix


================================================
FILE: src/routers/agent_store/agent_store.js
================================================
const router = require("koa-router")();
require("module-alias/register");

const agent_remix = require("@src/routers/agent_store/agent_remix");

const Agent = require("@src/models/Agent");
const Knowledge = require('@src/models/Knowledge')
const Conversation = require("@src/models/Conversation");
const { Op } = require("sequelize");

const ALLOWED_SORT_FIELDS = [
  "direct_reference_count",
  "total_reference_count",
  "knowledge_count",
  "experience_iteration_count",
  "create_at"
];

router.get("/", async ({ query, response }) => {
  try {
    // åˆ†é¡µå‚æ•°
    const page = parseInt(query.page, 10) > 0 ? parseInt(query.page, 10) : 1;
    const pageSize = parseInt(query.page_size, 10) > 0 ? parseInt(query.page_size, 10) : 20;
    const offset = (page - 1) * pageSize;
    const limit = pageSize;

    // æ’åºå‚æ•°
    let orderField = "recommend";
    let orderDirection = "DESC";
    if (query && query.order_by && ALLOWED_SORT_FIELDS.includes(query.order_by)) {
      orderField = query.order_by;
    }
    if (query && query.order && ["ASC", "DESC"].includes(query.order.toUpperCase())) {
      orderDirection = query.order.toUpperCase();
    }

    // æ„å»ºæŸ¥è¯¢æ¡ä»¶
    const where = {
      is_public: true,
      deleted_at: null,
      experience_iteration_count: { [Op.gt]: 0 }
    };

    if (query && query.name) {
      where.name = { [Op.like]: `%${query.name}%` };
    }

    // æ„å»ºç”¨æˆ·æŸ¥è¯¢æ¡ä»¶
    let userWhere = {};
    if (query && query.username) {
      userWhere.user_name = { [Op.like]: `%${query.username}%` };
    }

    // ä½¿ç”¨åŸç”ŸSQLæŸ¥è¯¢ï¼Œä¿®å¤MySQLè¯­æ³•
    const sequelize = Agent.sequelize;

    // æ„å»ºWHEREæ¡ä»¶
    let whereConditions = ['a.is_public = 1', 'a.experience_iteration_count > 0', 'a.deleted_at IS NULL', 'a.recommend != -1'];
    let replacements = {};

    if (query && query.name) {
      whereConditions.push('a.name LIKE :name');
      replacements.name = `%${query.name}%`;
    }

    if (query && query.username) {
      whereConditions.push('u.user_name LIKE :username');
      replacements.username = `%${query.username}%`;
    }

    // ç»Ÿè®¡æ€»æ•°
    const countSql = `
      SELECT COUNT(*) AS count 
      FROM agent a
      LEFT JOIN sys_user u ON a.user_id = u.id
      WHERE ${whereConditions.join(' AND ')}
    `;

    // æŸ¥è¯¢æ•°æ®
    const dataSql = `
      SELECT a.*, u.user_name as username 
      FROM agent a
      LEFT JOIN sys_user u ON a.user_id = u.id
      WHERE ${whereConditions.join(' AND ')}
      ORDER BY a.${orderField} ${orderDirection}
      LIMIT :limit OFFSET :offset
    `;

    // æ‰§è¡ŒæŸ¥è¯¢
    const countResult = await sequelize.query(countSql, {
      replacements,
      type: sequelize.QueryTypes.SELECT
    });

    const dataReplacements = { ...replacements, limit, offset };
    const rows = await sequelize.query(dataSql, {
      replacements: dataReplacements,
      type: sequelize.QueryTypes.SELECT
    });

    const total = parseInt(countResult[0].count, 10);

    return response.success({
      data: rows,
      pagination: {
        total,
        page,
        page_size: pageSize,
        total_page: Math.ceil(total / pageSize)
      }
    });

  } catch (error) {
    console.error('Agent store query error:', error);
    return response.fail({}, "Failed to get agent list");
  }
});



//æŸ¥è¯¢æœ€åä¸€æ¡ conversations çš„ID æ ¹æ®agent_id
router.get("/last/:agent_id", async ({ state, params, response }) => {
  const { agent_id } = params;
  //å…ˆåˆ¤æ–­ agent æ˜¯ä¸æ˜¯ å…¬å¼€çš„
  const agent = await Agent.findOne({
    where: { id: agent_id, is_public: true },
  });
  if (!agent) {
    return response.fail("Agent does not exist");
  }
  const conversations = await Conversation.findOne({
    where: { 
      agent_id,
      status: 'done',
      deleted_at: null  // è¿‡æ»¤å·²åˆ é™¤çš„è®°å½•
    },
    order: [["id", "DESC"]],
  });
  return response.success(conversations);
})

router.post("/remix", async ({ state, request, response }) => {
  const { agent_id } = request.body
  const user_id = state.user.id

  try {
    let new_agent = await agent_remix(agent_id,user_id)
    return response.success(new_agent)
  } catch (e) {
    console.log(e)
    return response.fail({}, e)
  }
})

module.exports = exports = router.routes();


================================================
FILE: src/routers/agent_store/index.js
================================================
const router = require("koa-router")();

router.prefix("/api/agent_store");

const modules = [
  "agent_store",
]

for (const module of modules) {
  try {
    router.use(require(`./${module}.js`));
  }
  catch (error) { console.log(`load ${module} error`, error); }
}

module.exports = router.routes();



================================================
FILE: src/routers/conversation/conversation.js
================================================
const router = require("koa-router")();
require("module-alias/register");

const Conversation = require("@src/models/Conversation");
const Message = require("@src/models/Message");
const ModelTable = require('@src/models/Model')
const auto_generate_title = require('@src/agent/generate-title')

const { getDirpath } = require('@src/utils/electron');

const uuid = require("uuid");
const { Op,literal } = require("sequelize");
const fs = require('fs').promises;
const path = require('path');

// Create a new conversation
/**
 * @swagger
 * /api/conversation:
 *   post:
 *     summary: Create a new conversation
 *     tags:  
 *       - Conversation
 *     description: This endpoint creates a new conversation with the provided content.
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               content:
 *                 type: string
 *                 description: Conversation content
 *     responses:
 *       200:
 *         description: Successfully created a new conversation
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   $ref: './schemas/conversation.json'
 *                 code:
 *                   type: integer
 *                   description: Status code
 *                 msg:
 *                   type: string
 *                   description: Message
 *                 
 */
router.post("/", async ({ state, request, response }) => {
  const body = request.body || {};
  const { content, mode_type, agent_id, model_id } = body
  let modeType = mode_type || 'task'
  const conversation_id = uuid.v4();
  const title = content.slice(0, 20);

  // æ„å»ºè¦åˆ›å»ºçš„å¯¹è±¡
  const newConversationData = {
    conversation_id,
    content,
    title,
    status: 'running',
    user_id: state.user.id,
    mode_type: modeType,
    agent_id:agent_id,
    model_id,
  };

  const newConversation = await Conversation.create(newConversationData);
  return response.success(newConversation);
});

// Get conversation list
/**
 * @swagger
 * /api/conversation:
 *   get:
 *     summary: Get conversation list
 *     tags:  
 *       - Conversation
 *     description: This endpoint retrieves a list of all conversations ordered by update time in descending order.
 *     responses:
 *       200:
 *         description: Successfully returned the conversation list
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   type: array
 *                   items:
 *                     $ref: './schemas/conversation.json'
 *                 code:
 *                   type: integer
 *                   description: Status code
 *                 msg:
 *                   type: string
 *                   description: Message
 *               
 */
router.get("/", async ({ state, query, response }) => {
  try {

    console.time("get conversations");
    console.log("get conversations", query);
    // const mode_type = query.mode_type || 'task';
    const agent_id = query.agent_id
    // 1. ä¸€æ¬¡æ€§æŸ¥å‡ºæ‰€æœ‰ä¼šè¯

    // æ„å»ºæŸ¥è¯¢æ¡ä»¶
    const whereClause = {
      user_id: state.user.id,
      // mode_type,
      is_from_sub_server: false,
      agent_id: agent_id,
      deleted_at: null,  // è¿‡æ»¤å·²åˆ é™¤çš„è®°å½•
      conversation_id: {
        [Op.notIn]: literal(
          `(SELECT twins_id FROM conversation WHERE twins_id IS NOT NULL)`
        )
      }
    };
    const conversations = await Conversation.findAll({
      where: whereClause,
      order: [['update_at', 'DESC']],
    });
    console.timeEnd("get conversations");
    // 2. æ‹¿åˆ°æ‰€æœ‰ä¼šè¯ID
    const conversationIds = conversations.map(c => c.conversation_id);
    if (conversationIds.length === 0) {
      return response.success([]);
    }

    // æ–°å¢ï¼šæ”¶é›†æ‰€æœ‰ model_id
    const modelIds = [...new Set(conversations.map(c => c.model_id).filter(Boolean))];
    let modelMap = new Map();
    if (modelIds.length > 0) {
      const models = await ModelTable.findAll({
        where: { id: modelIds },
        attributes: ['id', 'model_name'],
      });
      modelMap = new Map(models.map(m => [m.id, m.model_name]));
    }

    console.time("get latest messages");
    // 3. ä¸€æ¬¡æ€§æŸ¥å‡ºæ‰€æœ‰ä¼šè¯çš„æœ€æ–°æ¶ˆæ¯ï¼ŒåªæŸ¥éœ€è¦çš„å­—æ®µ
    const latestMessages = await Message.findAll({
      attributes: ['conversation_id', 'content', 'user_id'], // åªæŸ¥ä¸»é”®å’Œcontent
      where: {
        conversation_id: { [Op.in]: conversationIds },
        user_id: state.user.id
      },
      order: [['conversation_id', 'ASC'], ['create_at', 'DESC']],
    });
    console.timeEnd("get latest messages");

    // 4. ç”¨ Map æ–¹ä¾¿æŸ¥æ‰¾
    console.time("build latestMessageMap");
    const latestMessageMap = new Map();
    for (const msg of latestMessages) {
      if (!latestMessageMap.has(msg.conversation_id)) {
        latestMessageMap.set(msg.conversation_id, msg);
      }
    }
    console.timeEnd("build latestMessageMap");

    // 5. æ‹¼è£…
    console.time("assemble conversations");
    const new_conversations = conversations.map(conversation => ({
      ...conversation.toJSON(),
      latest_message: latestMessageMap.get(conversation.conversation_id) || null,
      model_name: modelMap.get(conversation.model_id) || null, // æ–°å¢
    }));
    console.timeEnd("assemble conversations");

    return response.success(new_conversations);
  } catch (error) {
    console.error(error);
    return response.fail({}, "Failed to get conversation list");
  }
});

// Get a single conversation
/**
 * @swagger
 * /api/conversation/{conversation_id}:
 *   get:
 *     summary: Get a single conversation
 *     tags:  
 *       - Conversation
 *     description: This endpoint retrieves a single conversation by its unique identifier.
 *     parameters:
 *       - in: path
 *         name: conversation_id
 *         required: true
 *         description: Unique identifier for the conversation
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Successfully returned the conversation
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   $ref: './schemas/conversation.json'
 *                 code:
 *                   type: integer
 *                   description: Status code
 *                 msg:
 *                   type: string
 *                   description: Message
 */
router.get("/:conversation_id", async ({ state, params, response }) => {
  const { conversation_id } = params;
  try {
    const conversation = await Conversation.findOne({
      where: { conversation_id: conversation_id, deleted_at: null },
    });
    if (!conversation) {
      return response.fail("Conversation does not exist");
    }


    const modelIds = [...new Set([conversation.model_id])];
    console.log("modelIds", modelIds);
    let modelMap = new Map();
    if (modelIds.length > 0) {
      const models = await ModelTable.findAll({
        where: { id: modelIds },
        attributes: ['id', 'model_name'],
      });
      modelMap = new Map(models.map(m => [m.id, m.model_name]));
    }
    conversation.dataValues.model_name = modelMap.get(conversation.model_id) || null;

    return response.success(conversation);
  } catch (error) {
    console.error(error);
    return response.fail("Failed to get conversation");
  }
});

// Update conversation
/**
 * @swagger
 * /api/conversation/{id}:
 *   put:
 *     summary: Update conversation
 *     tags:  
 *       - Conversation
 *     description: This endpoint updates the title of a conversation by its unique identifier.
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         description: Unique identifier for the conversation
 *         schema:
 *           type: string
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               title:
 *                 type: string
 *                 description: New conversation title
 *     responses:
 *       200:
 *         description: Successfully updated the conversation
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   $ref: './schemas/conversation.json'
 *                 code:
 *                   type: integer
 *                   description: Status code
 *                 msg:
 *                   type: string
 *                   description: Message
 */
router.put("/:id", async ({ state, params, request, response }) => {
  const { id: conversation_id } = params;
  const body = request.body || {};
  let { title } = body;

  try {
    const conversation = await Conversation.findOne({
      where: { conversation_id: conversation_id, user_id: state.user.id, deleted_at: null },
    });
    if (!conversation) {
      return response.error("Conversation does not exist");
    }

    if (!title || title === "") {
      title = await auto_generate_title(conversation.dataValues.content, conversation.dataValues.conversation_id)
      if (title == 'ERR_BAD_REQUEST') {
        return response.fail("llm api ERR_BAD_REQUEST");
      }
    }
    conversation.title = title;
    await conversation.save();
    return response.success(conversation);
  } catch (error) {
    console.error(error);
    return response.fail("Failed to update conversation");
  }
});

// Delete conversation
/**
 * @swagger
 * /api/conversation/{conversation_id}:
 *   delete:
 *     summary: Delete conversation
 *     tags:  
 *       - Conversation
 *     description: This endpoint deletes a conversation by its unique identifier.
 *     parameters:
 *       - in: path
 *         name: conversation_id
 *         required: true
 *         description: Unique identifier for the conversation
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Successfully deleted the conversation
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 code:
 *                   type: integer
 *                   description: Status code
 *                 msg:
 *                   type: string
 *                   description: Success message
 *                 data:
 *                   type: string
 *                   description: Success message
 */
router.delete("/:conversation_id", async ({ state, params, response }) => {
  const { conversation_id } = params;
  try {
    const conversation = await Conversation.findOne({
      where: { conversation_id: conversation_id, user_id: state.user.id, deleted_at: null },
    });
    if (!conversation) {
      return response.error("Conversation does not exist");
    }

    // è®¾ç½®deleted_atå­—æ®µè¿›è¡Œå‡åˆ é™¤
    conversation.deleted_at = new Date();
    await conversation.save();

    return response.success("Conversation deleted successfully");
  } catch (error) {
    console.error(error);
    return response.error("Failed to delete conversation");
  }
});

// search conversation
/**
 * @swagger
 * /api/conversation/query:
 *   post:
 *     summary: Search conversation by title
 *     tags:  
 *       - Conversation
 *     description: This endpoint searches for conversations by title.
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               query:
 *                 type: string
 *                 description: Conversation title
 *     responses:
 *       200:
 *         description: Successfully searched for conversations
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   type: array
 *                   items:
 *                     $ref: './schemas/conversation.json'
 *                 code:
 *                   type: integer
 *                   description: Status code
 *                 msg:
 *                   type: string
 *                   description: Message
 *                 
 */
router.post("/query", async ({ state, request, response }) => {
  const body = request.body || {};
  const { query } = body

  const conversations = await Conversation.findAll({
    where: {
      title: {
        [Op.like]: `%${query}%`
      },
      user_id: state.user.id,
      deleted_at: null  // è¿‡æ»¤å·²åˆ é™¤çš„è®°å½•
    }
  });

  return response.success(conversations);
});


router.put("/visibility/:id", async ({ state, params, request, response }) => {
  try {
    const { id } = params;
    const { is_public } = request.body;

    // éªŒè¯ is_public å‚æ•°
    if (typeof is_public !== 'boolean') {
      return response.fail({}, "is_public must be a boolean value");
    }

    // æŸ¥æ‰¾å¹¶éªŒè¯ä¼šè¯æ˜¯å¦å­˜åœ¨ä¸”å±äºå½“å‰ç”¨æˆ·
    const conversation = await Conversation.findOne({
      where: {
        conversation_id: id,
        user_id: state.user.id,
        deleted_at: null
      }
    });

    if (!conversation) {
      return response.fail({}, "Conversation not found or access denied");
    }

    // æ›´æ–° is_public å­—æ®µ
    await Conversation.update(
      { is_public: is_public },
      {
        where: {
          conversation_id: id,
          user_id: state.user.id
        }
      }
    );

    // è¿”å›æ›´æ–°åçš„ä¼šè¯ä¿¡æ¯
    const updatedConversation = await Conversation.findOne({
      where: {
        conversation_id: id,
        user_id: state.user.id
      }
    });

    return response.success({
      conversation_id: id,
      is_public: updatedConversation.is_public,
      message: `Conversation ${is_public ? 'made public' : 'made private'} successfully`
    });

  } catch (error) {
    console.error('Error updating conversation public status:', error);
    return response.fail({}, "Failed to update conversation public status");
  }
})

/**
 * è·å–ç›®å½•ä¸­çš„æœ€ç»ˆæ–‡ä»¶ï¼ˆæœ€æ–°æ–‡ä»¶æˆ– todo.mdï¼‰
 * @param {string} dir_path - ç›®å½•è·¯å¾„
 * @returns {Promise<string|null>} æ–‡ä»¶è·¯å¾„æˆ– null
 */
async function getFinalFile(dir_path) {
  try {
    const files = await fs.readdir(dir_path, { withFileTypes: true });
    let latestFile = null;
    let latestMtime = 0;
    let todoFile = null;

    for (const entry of files) {
      if (entry.isFile()) {
        if (entry.name === 'todo.md') {
          todoFile = path.join(dir_path, entry.name);
          continue;
        }
        const filePath = path.join(dir_path, entry.name);
        const stat = await fs.stat(filePath);
        if (stat.mtimeMs > latestMtime) {
          latestMtime = stat.mtimeMs;
          latestFile = filePath;
        }
      }
    }

    if (latestFile) {
      return latestFile;
    } else if (todoFile) {
      return todoFile;
    } else {
      return null;
    }
  } catch (error) {
    console.error('Error reading directory:', error);
    return null;
  }
}

/**
 * @swagger
 * /api/conversation/screenshots/batch:
 *   post:
 *     summary: Take screenshots for all conversations
 *     tags:  
 *       - Conversation
 *     description: This endpoint takes screenshots for all conversations in the database and updates their screenshot URLs.
 *     responses:
 *       200:
 *         description: Screenshots processed successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 code:
 *                   type: integer
 *                   description: Status code
 *                 msg:
 *                   type: string
 *                   description: Success message
 *                 data:
 *                   type: object
 *                   properties:
 *                     totalProcessed:
 *                       type: integer
 *                       description: Total conversations processed
 *                     successCount:
 *                       type: integer
 *                       description: Successfully processed screenshots
 *                     failedCount:
 *                       type: integer
 *                       description: Failed screenshots
 */
router.post("/screenshots/batch", async (ctx) => {
  const { state, response } = ctx;

  try {
    // è·å–æ‰€æœ‰æœªåˆ é™¤çš„ä¼šè¯
    const conversations = await Conversation.findAll({
      where: {
        deleted_at: null
      },
    });

    if (!conversations || conversations.length === 0) {
      return response.success({
        message: "No conversations found to process",
        totalProcessed: 0,
        successCount: 0,
        failedCount: 0
      });
    }

    console.log(`ğŸš€ Starting batch screenshot processing for ${conversations.length} conversations`);

    let successCount = 0;
    let failedCount = 0;
    const results = [];

    // è·å–æˆæƒtoken
    const token = ctx.headers.authorization;
    const tokenString = token && token.startsWith('Bearer ') ? token.slice(7) : token;

    // å¤„ç†æ¯ä¸ªä¼šè¯
    for (const conversation of conversations) {
      try {
        const conversation_id = conversation.conversation_id;
        const user_id = conversation.user_id;

        // æ„å»ºå·¥ä½œç©ºé—´è·¯å¾„
        const WORKSPACE_DIR = getDirpath(process.env.WORKSPACE_DIR || 'workspace', user_id);
        const dir_name = 'Conversation_' + conversation_id.slice(0, 6);
        const dir_path = path.join(WORKSPACE_DIR, dir_name);

        // è·å–æœ€ç»ˆæ–‡ä»¶è·¯å¾„
        const final_file_path = await getFinalFile(dir_path);

        if (!final_file_path) {
          console.log(`âš ï¸ No files found for conversation ${conversation_id}`);
          failedCount++;
          results.push({
            conversation_id,
            status: 'failed',
            error: 'No files found in workspace'
          });
          continue;
        }

        // æ„å»ºé¢„è§ˆURL
        const url = `${process.env.SUB_SERVER_DOMAIN}/file/?url=${final_file_path}`;

        // æˆªå›¾å¹¶ä¸Šä¼ 
        // const screen_result = await takeScreenshotAndUpload(url, { 
        //   accessToken: tokenString, 
        //   conversation_id 
        // });
        const screen_result = null;
        if (!screen_result || !screen_result.screenshotUrl) {
          console.log(`âŒ Failed to take screenshot for conversation ${conversation_id}`);
          failedCount++;
          results.push({
            conversation_id,
            status: 'failed',
            error: 'Screenshot upload failed'
          });
          continue;
        }

        const screen_url = screen_result.screenshotUrl;

        // æ›´æ–° Conversation çš„æˆªå›¾URL
        await Conversation.update(
          { screen_shot_url: screen_url },
          { where: { conversation_id } }
        );

        console.log(`âœ… Screenshot updated for conversation ${conversation_id}: ${screen_url}`);
        successCount++;
        results.push({
          conversation_id,
          status: 'success',
          screenshotUrl: screen_url
        });

      } catch (error) {
        console.error(`âŒ Error processing conversation ${conversation.conversation_id}:`, error);
        failedCount++;
        results.push({
          conversation_id: conversation.conversation_id,
          status: 'failed',
          error: error.message
        });
      }
    }

    console.log(`ğŸ Batch screenshot processing completed. Success: ${successCount}, Failed: ${failedCount}`);

    return response.success({
      message: "Batch screenshot processing completed",
      totalProcessed: conversations.length,
      successCount: successCount,
      failedCount: failedCount,
      results: results
    });

  } catch (error) {
    console.error('Error in batch screenshot processing:', error);
    return response.fail(`Failed to process batch screenshots: ${error.message}`);
  }
});


router.post("/screenshots/single", async ({ request, response, state }) => {
  const { conversation_id } = request.body;

  if (!conversation_id) {
    return response.fail("conversation_id is required");
  }

  try {
    const conversation = await Conversation.findOne({
      where: {
        conversation_id,
        deleted_at: null
      }
    });

    if (!conversation) {
      return response.fail("Conversation not found");
    }

    const user_id = conversation.user_id;

    const WORKSPACE_DIR = getDirpath(process.env.WORKSPACE_DIR || 'workspace', user_id);
    const dir_name = 'Conversation_' + conversation_id.slice(0, 6);
    const dir_path = path.join(WORKSPACE_DIR, dir_name);

    const final_file_path = await getFinalFile(dir_path);

    if (!final_file_path) {
      return response.fail("No files found in workspace");
    }

    const url = `${process.env.SUB_SERVER_DOMAIN}/file/?url=${final_file_path}`;

    const token = request.headers.authorization;
    const tokenString = token && token.startsWith('Bearer ') ? token.slice(7) : token;

    const screen_result = await takeScreenshotAndUpload(url, {
      accessToken: tokenString,
      conversation_id
    });

    if (!screen_result || !screen_result.screenshotUrl) {
      return response.fail("Screenshot generation failed");
    }

    const screen_url = screen_result.screenshotUrl;

    await Conversation.update(
      { screen_shot_url: screen_url },
      { where: { conversation_id } }
    );

    console.log(`Screenshot updated for conversation ${conversation_id}: ${screen_url}`);

    return response.success({
      message: "Screenshot generated successfully",
      conversation_id,
      screenshotUrl: screen_url
    });

  } catch (error) {
    console.error(`Error generating screenshot for conversation ${conversation_id}:`, error);
    return response.fail(`Failed to generate screenshot: ${error.message}`);
  }
});

// Twins conversation management
/**
 * @swagger
 * /api/conversation/twins:
 *   post:
 *     summary: Handle twins conversation
 *     tags:  
 *       - Conversation
 *     description: This endpoint handles twins conversation creation and retrieval based on conversation_id.
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               conversation_id:
 *                 type: string
 *                 description: Current conversation ID
 *             required:
 *               - conversation_id
 *     responses:
 *       200:
 *         description: Successfully handled twins conversation
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   type: object
 *                   properties:
 *                     conversation_id:
 *                       type: string
 *                       description: Target conversation ID
 *                     is_new:
 *                       type: boolean
 *                       description: Whether a new conversation was created
 *                 code:
 *                   type: integer
 *                   description: Status code
 *                 msg:
 *                   type: string
 *                   description: Message
 */
router.post("/twins", async ({ state, request, response }) => {
  try {
    const body = request.body || {};
    const { conversation_id } = body;

    if (!conversation_id) {
      return response.fail("conversation_id is required");
    }

    // æŸ¥æ‰¾å½“å‰ä¼šè¯
    const currentConversation = await Conversation.findOne({
      where: { 
        conversation_id: conversation_id, 
        user_id: state.user.id, 
        deleted_at: null 
      }
    });

    if (!currentConversation) {
      return response.fail("Current conversation not found");
    }

    let targetConversationId = null;
    let isNew = false;

    // æ£€æŸ¥å½“å‰ä¼šè¯æ˜¯å¦æœ‰ twins_id
    if (currentConversation.twins_id) {
      // twins_id å°±æ˜¯ twins ä¼šè¯çš„ conversation_idï¼Œç›´æ¥ä½¿ç”¨
      targetConversationId = currentConversation.twins_id;
    } else {
      // å½“å‰ä¼šè¯æ²¡æœ‰ twins_idï¼Œåˆ›å»ºæ–°çš„ twins å…³ç³»
      const newConversationId = uuid.v4();
      const newTwinsId = newConversationId;
      
      // åˆ›å»ºæ–°çš„ twins ä¼šè¯
      const newConversation = await Conversation.create({
        conversation_id: newConversationId,
        content: currentConversation.content,
        title: currentConversation.title,
        status: 'ready',
        user_id: state.user.id,
        mode_type: currentConversation.mode_type,
        agent_id: currentConversation.agent_id,
        model_id: currentConversation.model_id
      });

      // æ›´æ–°å½“å‰ä¼šè¯çš„ twins_id
      await Conversation.update(
        { twins_id: newTwinsId },
        { where: { conversation_id: conversation_id } }
      );

      targetConversationId = newConversationId;
      isNew = true;
    }

    return response.success({
      conversation_id: targetConversationId,
      is_new: isNew
    });

  } catch (error) {
    console.error('Error handling twins conversation:', error);
    return response.fail(`Failed to handle twins conversation: ${error.message}`);
  }
});

// è·å– twins conversation çš„ token ä¿¡æ¯
/**
 * @swagger
 * /api/conversation/twins/tokens/{conversation_id}:
 *   get:
 *     summary: Get twins conversation token information
 *     tags:  
 *       - Conversation
 *     description: This endpoint retrieves token usage information for twins conversation.
 *     parameters:
 *       - in: path
 *         name: conversation_id
 *         required: true
 *         description: Twins conversation ID
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Successfully retrieved token information
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   type: object
 *                   properties:
 *                     input_tokens:
 *                       type: integer
 *                       description: Input tokens count
 *                     output_tokens:
 *                       type: integer
 *                       description: Output tokens count
 *                     total:
 *                       type: integer
 *                       description: Total tokens count
 *                 code:
 *                   type: integer
 *                   description: Status code
 *                 msg:
 *                   type: string
 *                   description: Message
 */
router.get("/twins/tokens/:conversation_id", async ({ state, params, response }) => {
  try {
    const { conversation_id } = params;

    // æŸ¥æ‰¾ twins conversation
    const conversation = await Conversation.findOne({
      where: { 
        conversation_id: conversation_id, 
        deleted_at: null 
      }
    });

    if (!conversation) {
      return response.fail("Twins conversation not found");
    }

    // è¿”å› token ä¿¡æ¯
    const tokenInfo = {
      input_tokens: conversation.input_tokens || 0,
      output_tokens: conversation.output_tokens || 0,
      total: (conversation.input_tokens || 0) + (conversation.output_tokens || 0)
    };

    return response.success(tokenInfo);

  } catch (error) {
    console.error('Error getting twins token info:', error);
    return response.fail(`Failed to get twins token info: ${error.message}`);
  }
});


module.exports = exports = router.routes();


================================================
FILE: src/routers/conversation/favorite.js
================================================
const router = require("koa-router")();

const Conversation = require("@src/models/Conversation");
const uuid = require("uuid");

// favorite
/**
 * @swagger
 * /api/conversation/favorite:
 *   post:
 *     summary: Favorite a conversation
 *     tags:  
 *       - Conversation
 *     description: This endpoint marks a conversation as favorite by its unique identifier.
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               conversation_id:
 *                 type: string
 *                 description: Unique identifier for the conversation
 *     responses:
 *       200:
 *         description: Successfully created a new conversation
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   $ref: './schemas/conversation.json'
 *                 code:
 *                   type: integer
 *                   description: Status code
 *                 msg:
 *                   type: string
 *                   description: Message
 *                 
 */
router.post("/favorite", async ({ request, response }) => {
  const body = request.body || {};
  const { conversation_id } = body

  await Conversation.update(
    { is_favorite: true },
    { where: { conversation_id: conversation_id } }
  );
  const conversation = await Conversation.findOne({
    where: { conversation_id: conversation_id },
  });
  if (!conversation) {
    return response.error("Conversation does not exist");
  }

  return response.success(conversation);
});

// unfavorite
/**
 * @swagger
 * /api/conversation/unfavorite:
 *   post:
 *     summary: Unfavorite a conversation
 *     tags:  
 *       - Conversation
 *     description: This endpoint marks a conversation as not favorite by its unique identifier.
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               conversation_id:
 *                 type: string
 *                 description: Unique identifier for the conversation
 *     responses:
 *       200:
 *         description: Successfully updated the conversation
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   $ref: './schemas/conversation.json'
 *                 code:
 *                   type: integer
 *                   description: Status code
 *                 msg:
 *                   type: string
 *                   description: Message
 *                 
 */
router.post("/unfavorite", async ({ request, response }) => {
  const body = request.body || {};
  const { conversation_id } = body

  await Conversation.update(
    { is_favorite: false },
    { where: { conversation_id: conversation_id } }
  );
  const conversation = await Conversation.findOne({
    where: { conversation_id: conversation_id },
  });
  if (!conversation) {
    return response.error("Conversation does not exist");
  }

  return response.success(conversation);
});

module.exports = exports = router.routes();


================================================
FILE: src/routers/conversation/index.js
================================================
const router = require("koa-router")();

router.prefix("/api/conversation");

const modules = [
  "conversation",
  "favorite"
]

for (const module of modules) {
  try {
    router.use(require(`./${module}.js`));
  }
  catch (error) { console.log(`load ${module} error`, error); }
}

module.exports = router.routes();



================================================
FILE: src/routers/conversation_case/conversation_case.js
================================================
const router = require("koa-router")();
require("module-alias/register");

const Conversation = require("@src/models/Conversation");
const { Op } = require("sequelize");

const ALLOWED_SORT_FIELDS = [
  "create_at",
  "recommend"
];

router.get("/", async ({ query, response }) => {
  try {
    // åˆ†é¡µå‚æ•°
    const page = parseInt(query.page, 10) > 0 ? parseInt(query.page, 10) : 1;
    const pageSize = parseInt(query.page_size, 10) > 0 ? parseInt(query.page_size, 10) : 20;
    const offset = (page - 1) * pageSize;
    const limit = pageSize;

    // æ’åºå‚æ•°
    let orderField = "recommend";
    let orderDirection = "DESC";
    if (query && query.order_by && ALLOWED_SORT_FIELDS.includes(query.order_by)) {
      orderField = query.order_by;
    }
    if (query && query.order && ["ASC", "DESC"].includes(query.order.toUpperCase())) {
      orderDirection = query.order.toUpperCase();
    }

    const sequelize = Conversation.sequelize;
    // æ„å»ºWHEREæ¡ä»¶
    let whereConditions = ['c.is_public = 1', 'c.deleted_at IS NULL', 'c.recommend != -1'];
    let replacements = {};

    if (query && query.name) {
      whereConditions.push('c.title LIKE :name');
      replacements.name = `%${query.name}%`;
    }

    // ç»Ÿè®¡æ€»æ•°
    const countSql = `
      SELECT COUNT(*) AS count 
      FROM conversation c
      WHERE ${whereConditions.join(' AND ')}
    `;

    // æŸ¥è¯¢æ•°æ®
    const dataSql = `
      SELECT c.*
      FROM conversation c
      WHERE ${whereConditions.join(' AND ')}
      ORDER BY c.${orderField} ${orderDirection}
      LIMIT :limit OFFSET :offset
    `;

    // æ‰§è¡ŒæŸ¥è¯¢
    const countResult = await sequelize.query(countSql, {
      replacements,
      type: sequelize.QueryTypes.SELECT
    });

    const dataReplacements = { ...replacements, limit, offset };
    const rows = await sequelize.query(dataSql, {
      replacements: dataReplacements,
      type: sequelize.QueryTypes.SELECT
    });

    const total = parseInt(countResult[0].count, 10);

    return response.success({
      data: rows,
      pagination: {
        total,
        page,
        page_size: pageSize,
        total_page: Math.ceil(total / pageSize)
      }
    });

  } catch (error) {
    console.error(error);
    return response.fail({}, "Failed to get conversation list");
  }
});

module.exports = exports = router.routes();


================================================
FILE: src/routers/conversation_case/index.js
================================================
const router = require("koa-router")();

router.prefix("/api/user_case");

const modules = [
  "conversation_case",
]

for (const module of modules) {
  try {
    router.use(require(`./${module}.js`));
  }
  catch (error) { console.log(`load ${module} error`, error); }
}

module.exports = router.routes();



================================================
FILE: src/routers/default_model_setting/default_model_setting.js
================================================
const router = require("koa-router")();
const DefaultModelSetting = require("@src/models/DefaultModelSetting");
const Model = require('@src/models/Model')
const { updateDefaultModel } = require('@src/utils/default_model')
const Platform = require('@src/models/Platform')
const UserSearchSetting = require('@src/models/UserSearchSetting')

// change default_model_setting 
/**
 * @swagger
 * /api/default_model_setting:
 *   put:
 *     summary: update default_model_setting
 *     tags:  
 *       - DefaultModelSetting
 *     description: This endpoint creates a new platform with the provided content.
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               setting_type:
 *                 type: string
 *                 description: setting_type 'assistant', 'topic_naming', 'translation'
 *               model_id:
 *                 type: integer
 *                 description: model id
 *               config:
 *                 type: object
 *                 description: config
 * 
 *     responses:
 *       200:
 *         description: Successfully 
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   $ref: './schemas/default_model_setting.json'
 *                 code:
 *                   type: integer
 *                   description: Status code
 *                 msg:
 *                   type: string
 *                   description: Message
 *                 
 */
router.put("/", async ({ state, request, response }) => {
    const body = request.body || {};
    const { setting_type, model_id, config } = body
    const existingModelSetting = await DefaultModelSetting.findOne({ where: { setting_type: setting_type, user_id: state.user.id } });
    if (existingModelSetting) {
        await DefaultModelSetting.update(
            { model_id: model_id, config: config },
            { where: { setting_type: setting_type, user_id: state.user.id } }
        );
    } else {
        await DefaultModelSetting.create({
            setting_type: setting_type,
            model_id: model_id,
            config: config,
            user_id: state.user.id
        });
    }
    await updateDefaultModel(setting_type)
    return response.success();
});

// get default_model_setting
/**
 * @swagger
 * /api/default_model_setting:
 *   get:
 *     summary: Get default model setting
 *     tags:  
 *       - DefaultModelSetting
 *     description: This endpoint gets default model setting.
 *     responses:
 *       200:
 *         description: Successfully get default model setting
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   $ref: './schemas/default_model_setting.json'
 *                 code:
 *                   type: integer
 *                   description: Status code
 *                 msg:
 *                   type: string
 *                   description: Message
 */
router.get("/", async ({ state, response }) => {
    const defaultModelSetting = await DefaultModelSetting.findAll({ where: { user_id: state.user.id }, order: [['create_at', 'DESC']] });
    return response.success(defaultModelSetting);
});


/**
 * @swagger
 * /api/default_model_setting/check:
 *   get:
 *     summary: do check default_model_setting
 *     tags:  
 *       - DefaultModelSetting
 *     description: do check default_model_setting
 *     responses:
 *       200:
 *         description: Successfully 
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   type: object
 *                 code:
 *                   type: integer
 *                   description: Status code
 *                 msg:
 *                   type: string
 *                   description: Message
 *                 
 */
router.get("/check", async ({ response }) => {
    let check_map = {
        has_enabled_platform: true,
        has_default_platform: true,
        has_search_setting: true,
    }
    // æ£€æŸ¥æ˜¯å¦é…ç½®å¹¶å¼€å¯æ¨¡å‹
    const platform = await Platform.findOne({ where: { is_enabled: true } })
    if (!platform) {
        check_map.has_enabled_platform = false
    }
    // æ£€æŸ¥æ˜¯å¦é…ç½®é»˜è®¤æ¨¡å‹
    let defaultModelSetting = await DefaultModelSetting.findOne({ where: { setting_type: 'assistant' } })
    if (!defaultModelSetting) {
        check_map.has_default_platform = false
    } else {
        const model = await Model.findOne({ where: { id: defaultModelSetting.model_id } })

        const platform = await Platform.findOne({ where: { id: model.platform_id } })
        if (!platform || !platform.is_enabled) {
            check_map.has_default_platform = false
        }
    }

    // æ£€æŸ¥æ˜¯å¦æœ‰æœç´¢é…ç½®
    const userSearchSetting = await UserSearchSetting.findOne()
    if (!userSearchSetting) {
        check_map.has_search_setting = false
    }

    return response.success(check_map);
});

module.exports = exports = router.routes();


================================================
FILE: src/routers/default_model_setting/index.js
================================================
const router = require("koa-router")();

router.prefix("/api/default_model_setting");

const modules = [
  "default_model_setting",
]

for (const module of modules) {
  try {
    router.use(require(`./${module}.js`));
  }
  catch (error) { console.log(`load ${module} error`, error); }
}

module.exports = router.routes();



================================================
FILE: src/routers/file/editor.js
================================================
const Router = require("koa-router");
const router = new Router();

const fs = require('fs');
const { quickCreateVersion, getVersions, switchToVersion } = require('@src/utils/versionManager');
const { resolveAbsolutePath } = require('@src/utils/filePathHelper');

router.put("/editor", async ({ request, response, state }) => {
  const { path: filepath, content, conversation_id } = request.body || {};
  if (!filepath || !content) {
    return response.error("Missing file");
  }
  if (!conversation_id) {
    return response.fail(null, 'conversation_id is required');
  }
  const absolutePath = resolveAbsolutePath(filepath, state);
  if (!absolutePath) {
    response.fail(null, 'File path is required');
    return;
  }
  if (!fs.existsSync(absolutePath)) {
    response.fail(null, 'File does not exist');
    return;
  }
  try {
    // å†™å…¥æ–‡ä»¶
    fs.writeFileSync(absolutePath, content);

    // ç®€åŒ–ï¼šä¸€è¡Œä»£ç åˆ›å»ºç‰ˆæœ¬
    const versionInfo = await quickCreateVersion(filepath, conversation_id, state);

    response.success(versionInfo, 'File updated successfully');
  } catch (err) {
    console.error(err);
    response.fail(null, 'Failed to update file');
  }
});


// read file by path
const path = require('path');
router.post('/editor/read', async ({ request, response, state }) => {
  const { path: filepath } = request.body;
  const absolutePath = resolveAbsolutePath(filepath, state);
  console.log('absolutePath', absolutePath);
  if (!absolutePath) {
    response.fail(null, 'File path is required');
    return;
  }
  if (!fs.existsSync(absolutePath)) {
    response.fail(null, 'File does not exist');
    return;
  }
  try {
    const stream = fs.createReadStream(absolutePath);
    response.file(path.basename(absolutePath), stream);
  } catch (err) {
    console.error(err);
    response.fail(null, 'Failed to read file');
  }
});

// è·å–æ–‡ä»¶ç‰ˆæœ¬åˆ—è¡¨
router.post('/editor/versions', async ({ request, response }) => {
  const { conversation_id, filepath } = request.body || {};

  if (!conversation_id || !filepath) {
    return response.fail(null, 'conversation_id and filepath are required');
  }

  try {
    // ä½¿ç”¨ç»Ÿä¸€çš„ç‰ˆæœ¬ç®¡ç†å™¨è·å–ç‰ˆæœ¬åˆ—è¡¨
    const versions = await getVersions(conversation_id, filepath);
    response.success(versions, 'Versions retrieved successfully');
  } catch (err) {
    console.error(err);
    response.fail(null, 'Failed to retrieve versions');
  }
});

// è·å–ç‰¹å®šç‰ˆæœ¬å†…å®¹
router.get('/editor/version/:id', async ({ params, response }) => {
  const { id } = params;
  if (!id) {
    return response.fail(null, 'Version ID is required');
  }

  try {
    const version = await FileVersion.findOne({
      where: { id },
      attributes: ['id', 'conversation_id', 'filepath', 'content', 'version', 'create_at']
    });

    if (!version) {
      return response.fail(null, 'Version not found');
    }

    response.success(version, 'Version content retrieved successfully');
  } catch (err) {
    console.error(err);
    response.fail(null, 'Failed to retrieve version content');
  }
});

// åˆ‡æ¢åˆ°æŒ‡å®šç‰ˆæœ¬
router.post('/editor/switch-version', async ({ request, response, state }) => {
  const { version_id, conversation_id, filepath } = request.body || {};

  if (!version_id || !conversation_id || !filepath) {
    return response.fail(null, 'version_id, conversation_id and filepath are required');
  }

  try {
    // ç®€åŒ–ï¼šç›´æ¥è°ƒç”¨åˆ‡æ¢ç‰ˆæœ¬
    const result = await switchToVersion(version_id, conversation_id, filepath, state);
    response.success(result, 'Version switched successfully');
  } catch (err) {
    console.error(err);
    response.fail(null, err.message || 'Failed to switch version');
  }
});

module.exports = exports = router.routes()


================================================
FILE: src/routers/file/file.js
================================================
const router = require("koa-router")();

const path = require('path');
const fs = require('fs');
const File = require("@src/models/File");
const { getDirpath } = require('@src/utils/electron');

/**
 * @swagger
 * /api/file/upload:
 *   post:
 *     summary: Upload multiple files
 *     tags:  
 *       - File
 *     description: This endpoint uploads multiple files to the workspace directory.
 *     requestBody:
 *       required: true
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             properties:
 *               files:
 *                 type: array
 *                 items:
 *                   type: string
 *                   format: binary
 *                 description: The files to be uploaded
 *               conversation_id:
 *                 type: string
 *                 description: Conversation id
 *     responses:
 *       200:
 *         description: Files uploaded successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   type: array
 *                   items:
 *                     $ref: './schemas/file.json'
 *                 code:
 *                   type: integer
 *                   description: Status code
 *                 msg:
 *                   type: string
 *                   description: Message
 *                 
 */
router.post("/upload", async ({ state, request, response }) => {
  const files = request.files.files;
  const { conversation_id = '' } = request.body;

  // Handle both single and multiple file uploads
  const fileArray = Array.isArray(files) ? files : [files];

  const uploadedFiles = [];

  const WORKSPACE_DIR = getDirpath(process.env.WORKSPACE_DIR || 'workspace', state.user.id);

  for (const file of fileArray) {
    const uploadDir = path.join(WORKSPACE_DIR, 'upload');
    if (!fs.existsSync(uploadDir)) {
      fs.mkdirSync(uploadDir, { recursive: true });
    }
    const filePath = path.join(uploadDir, file.originalFilename);

    fs.copyFileSync(file.filepath, filePath);

    const fileDoc = await File.create({
      url: `upload/${file.originalFilename}`,
      name: file.originalFilename,
      conversation_id: conversation_id,
    });

    fileDoc.dataValues.workspace_dir = WORKSPACE_DIR

    uploadedFiles.push(fileDoc.dataValues);
  }

  return response.success(uploadedFiles);
});

/**
 * @swagger
 * /api/file:
 *   put:
 *     summary: Update file's conversation_id
 *     tags:  
 *       - File
 *     description: Update the conversation_id of a file by its id.
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               id:
 *                 type: integer
 *                 description: The id of the file to update
 *               conversation_id:
 *                 type: string
 *                 description: The new conversation id
 *     responses:
 *       200:
 *         description: File updated successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   $ref: './schemas/file.json'
 *                 code:
 *                   type: integer
 *                   description: Status code
 *                 msg:
 *                   type: string
 *                   description: Message
 */
router.put("/", async ({ request, response }) => {
  const { id, conversation_id } = request.body || {};
  if (!id || !conversation_id) {
    return response.error("Missing id or conversation_id");
  }

  try {
    const file = await File.findOne({ where: { id } });
    if (!file) {
      return response.error("File does not exist");
    }
    file.conversation_id = conversation_id;
    await file.save();
    return response.success(file, "File updated successfully");
  } catch (error) {
    return response.fail("Failed to update file");
  }
});


/**
 * @swagger
 * /api/file/delete/{file_id}:
 *   delete:
 *     summary: Delete file
 *     tags:  
 *       - File
 *     description: This endpoint deletes a specified file.
 *     parameters:
 *       - in: path
 *         name: file_id
 *         required: true
 *         schema:
 *           type: integer
 *         description: The id of the file to be deleted
 *     responses:
 *       200:
 *         description: File deleted successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   $ref: './schemas/file.json'
 *                 code:
 *                   type: integer
 *                   description: Status code
 *                 msg:
 *                   type: string
 *                   description: Message
 */
router.delete("/delete/:file_id", async ({ state, params, request, response }) => {

  const { file_id } = params;
  // å‡è®¾ conversation_id é€šè¿‡ query ä¼ é€’
  const { conversation_id } = request.query || {};

  const WORKSPACE_DIR = getDirpath(process.env.WORKSPACE_DIR || 'workspace', state.user.id);
  try {
    const file = await File.findOne({
      where: { id: file_id }
    });
    if (!file) {
      return response.error("File does not exist");
    }
    await file.destroy();

    // conversation_id å­˜åœ¨æ—¶æ‹¼æ¥ Conversation_xxxxx
    let filePath;
    if (conversation_id) {
      filePath = path.join(WORKSPACE_DIR, `Conversation_${conversation_id.slice(0, 6)}`, file.name);
    } else {
      filePath = path.join(WORKSPACE_DIR, 'upload', file.name);
    }

    fs.unlinkSync(filePath);
    return response.success(null, "File deleted successfully");
  } catch (error) {
    console.error(error);
    return response.error("Failed to delete file");
  }
});

/**
 * @swagger
 * /api/file/list:
 *   get:
 *     summary: Get file list
 *     tags:  
 *       - File
 *     description: This endpoint returns the list of all files in the public/files directory.
 *     responses:
 *       200:
 *         description: File list retrieved successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   type: array
 *                   items:
 *                     $ref: './schemas/file.json'
 *                 code:
 *                   type: integer
 *                   description: Status code
 *                 msg:
 *                   type: string
 *                   description: Message
 */
router.get("/list", async ({ response }) => {
  const files = await File.findAll();

  return response.success(files);
});

// read file by path
/**
 * @swagger
 * /api/file/read:
 *   post:
 *     summary: Read file
 *     tags:  
 *       - File
 *     description: This endpoint reads a specified file and returns it as a stream.
 *     parameters:
 *       - in: query
 *         name: path
 *         required: true
 *         schema:
 *           type: string
 *         description: The path of the file to be read
 *     responses:
 *       200:
 *         description: File read successfully
 *         content:
 *           application/octet-stream:
 *             schema:
 *               type: string
 *               format: binary
 */
router.post('/read', async ({ request, response }) => {
  const { path: filePath } = request.body;
  if (!filePath) {
    response.fail(null, 'File path is required');
    return;
  }
  if (!fs.existsSync(filePath)) {
    response.fail(null, 'File does not exist');
    return;
  }
  try {
    const stream = fs.createReadStream(filePath);
    response.file(path.basename(filePath), stream);
  } catch (err) {
    console.error(err);
    response.fail(null, 'Failed to read file');
  }
});

module.exports = exports = router.routes()


================================================
FILE: src/routers/file/index.js
================================================
const router = require("koa-router")();

router.prefix("/api/file");

const modules = [
  "file",
  "editor"
]

for (const module of modules) {
  try {
    router.use(require(`./${module}.js`));
  }
  catch (error) { console.log(`load ${module} error`, error); }
}

module.exports = router.routes();



================================================
FILE: src/routers/knowledge/category.js
================================================
const router = require("koa-router")();

// è·å– category åˆ—è¡¨
router.get("/categories", async ({ state, response }) => {
  return response.success(['core_directive', 'user_profile', 'planning', 'execution']);
});


module.exports = exports = router.routes();



================================================
FILE: src/routers/knowledge/index.js
================================================
const router = require("koa-router")();

router.prefix("/api/knowledge");

const modules = [
  "knowledge",
  "category",
]

for (const module of modules) {
  try {
    router.use(require(`./${module}.js`));
  }
  catch (error) { console.log(`load ${module} error`, error); }
}

module.exports = router.routes();



================================================
FILE: src/routers/knowledge/knowledge.js
================================================
const router = require("koa-router")();
const Knowledge = require("@src/models/Knowledge");
const { Op } = require('sequelize')

// æ–°å¢ Knowledge
router.post("/", async ({ state, request, response }) => {
  const body = request.body || {};
  const { content = '', category = '', agent_id } = body;
  try {
    const knowledge = await Knowledge.create({
      user_id: state.user.id,
      agent_id,
      content,
      category,
    });
    return response.success(knowledge);
  } catch (error) {
    console.error(error);
    return response.fail("Failed to create knowledge");
  }
});

// è·å– Knowledge åˆ—è¡¨
router.get("/", async ({ state, query, response }) => {
  const { agent_id } = query
  try {
    const knowledges = await Knowledge.findAll({
      where: { user_id: state.user.id, agent_id },
      order: [['update_at', 'DESC']]
    });

    let personal = []
    let system = []
    for (let item of knowledges) {
      if (item.dataValues.is_learned) {
        system.push(item)
      } else {
        personal.push(item)
      }
    }

    return response.success({ personal, system });
  } catch (error) {
    console.error(error);
    return response.fail("Failed to get knowledge list");
  }
});

// è·å–å•ä¸ª Knowledge
router.get("/detail/:id", async ({ state, params, response }) => {
  const { id } = params;
  try {
    const knowledge = await Knowledge.findOne({
      where: { id, user_id: state.user.id },
    });
    if (!knowledge) {
      return response.fail("Knowledge does not exist");
    }
    return response.success(knowledge);
  } catch (error) {
    console.error(error);
    return response.fail("Failed to get knowledge");
  }
});

// æ›´æ–° Knowledge
router.put("/:id", async ({ state, params, request, response }) => {
  const { id } = params;
  const body = request.body || {};
  const { content, category } = body;
  try {
    const knowledge = await Knowledge.findOne({
      where: { id, user_id: state.user.id },
    });
    if (!knowledge) {
      return response.fail("Knowledge does not exist");
    }
    const updateFields = {};
    if (content !== undefined) updateFields.content = content;
    if (category !== undefined) updateFields.category = category;
    knowledge.set(updateFields);
    await knowledge.save();
    return response.success(knowledge);
  } catch (error) {
    console.error(error);
    return response.fail("Failed to update knowledge");
  }
});

// åˆ é™¤ Knowledge
router.delete("/:id", async ({ state, params, response }) => {
  const { id } = params;
  try {
    const knowledge = await Knowledge.findOne({
      where: { id, user_id: state.user.id },
    });
    if (!knowledge) {
      return response.fail("Knowledge does not exist");
    }
    await knowledge.destroy();
    return response.success("Knowledge deleted successfully");
  } catch (error) {
    console.error(error);
    return response.fail("Failed to delete knowledge");
  }
});

module.exports = exports = router.routes();



================================================
FILE: src/routers/mcp_server/connect.js
================================================
const router = require("koa-router")();

const mcp_client = require("@src/mcp/client");

router.post("/connect", async ({ request, response }) => {
  const server = request.body;
  const connected = await mcp_client.checkMcpConnectivity(server);
  if (connected) {
    return response.success({ ok: true });
  }
  response.fail({
    ok: false,
    error: "Failed to connect to MCP server",
    details: "MCP server is not connected",
  });
});

module.exports = exports = router.routes();



================================================
FILE: src/routers/mcp_server/index.js
================================================
const router = require("koa-router")();

router.prefix("/api/mcp_server");

const modules = [
  "mcp_server",
  "connect"
]

for (const module of modules) {
  try {
    router.use(require(`./${module}.js`));
  }
  catch (error) { console.log(`load ${module} error`, error); }
}

module.exports = router.routes();



================================================
FILE: src/routers/mcp_server/mcp_server.js
================================================
const router = require("koa-router")();

const McpServer = require("@src/models/McpServer");

// Create a new mcp server
router.post("/", async ({ state, request, response }) => {
  const body = request.body || {};
  const user_id = state.user.id

  const { name, url, description, activate, type, command, registryUrl, args, env, api_key, is_default } = body

  const mcp_server = await McpServer.create({
    user_id,
    name,
    url,
    description,
    activate,
    type,
    command,
    registryUrl,
    args,
    env,
    api_key,
    is_default
  });

  return response.success(mcp_server);
});

router.get("/", async ({ state, response }) => {
  const user_id = state.user.id
  const mcp_servers = await McpServer.findAll({ where: { user_id }, order: [['create_at', 'DESC']] });
  return response.success(mcp_servers);
});

router.get("/active", async ({ state, response }) => {
  const user_id = state.user.id
  const mcp_servers = await McpServer.findAll({ where: { activate: true, user_id } });
  return response.success(mcp_servers);
})

// update mcp server
router.put("/:mcp_server_id", async ({ state, params, request, response }) => {
  const user_id = state.user.id
  const { mcp_server_id } = params;
  const body = request.body || {};

  const { name, url, description, activate, type, command, registryUrl, args, env, api_key, is_default } = body

  const mcp_server = await McpServer.findOne({
    where: { id: mcp_server_id, user_id }
  });
  if (!mcp_server) {
    return response.fail({}, "Mcp Server does not exist");
  }

  await mcp_server.update({
    name,
    url,
    description,
    activate,
    type,
    command,
    registryUrl,
    args,
    env,
    api_key,
    is_default
  });

  return response.success(mcp_server);
});

// delete mcp server
router.delete("/:mcp_server_id", async ({ state, params, response }) => {
  const user_id = state.user.id
  const { mcp_server_id } = params;

  const mcp_server = await McpServer.findOne({
    where: { id: mcp_server_id, user_id }
  });
  if (!mcp_server) {
    return response.fail({}, "Mcp Server does not exist");
  }

  await mcp_server.destroy();

  return response.success();
});

module.exports = exports = router.routes();



================================================
FILE: src/routers/membership_plan/index.js
================================================
const router = require("koa-router")();

router.prefix("/api/membership_plan");

const modules = [
  "membership_plan",
]

for (const module of modules) {
  try {
    router.use(require(`./${module}.js`));
  }
  catch (error) { console.log(`load ${module} error`, error); }
}

module.exports = router.routes();



================================================
FILE: src/routers/membership_plan/membership_plan.js
================================================
const router = require("koa-router")();
const forwardRequest = require('@src/utils/sub_server_forward_request')


router.get("/list", async (ctx) => {
  let res = await forwardRequest(ctx, "GET", "/api/membership_plan/list")
  return ctx.body = res;
})


module.exports = exports = router.routes();


================================================
FILE: src/routers/message/index.js
================================================
const router = require("koa-router")();

router.prefix("/api/message");

const modules = [
  "message",
]

for (const module of modules) {
  try {
    router.use(require(`./${module}.js`));
  }
  catch (error) { console.log(`load ${module} error`, error); }
}

module.exports = router.routes();



================================================
FILE: src/routers/message/message.js
================================================
const router = require("koa-router")();

const Message = require("@src/models/Message");
const Conversation = require("@src/models/Conversation")


// api/message/list?conversation_id=1234567890
/**
 * @swagger
 * /api/message/list:
 *   get:
 *     summary: Get message list
 *     tags:  
 *       - Message
 *     description: This endpoint retrieves a list of messages.
 *     parameters:
 *       - in: query
 *         name: conversation_id
 *         required: true
 *         schema:
 *           type: string
 *         description: The ID of the conversation to retrieve messages for.
 *     responses:
 *       200:
 *         description: A list of messages.
 */
router.get("/list", async ({ state, query, response }) => {
    const { conversation_id } = query;
    if (!conversation_id) {
        return response.fail({}, "Missing conversation_id");
    }

    const conversation = await Conversation.findOne({ where: { conversation_id } })

    const messages = await Message.findAll({
        where: { conversation_id: conversation_id },
        order: [['timestamp', 'ASC']] // æŒ‰timestampå‡åº
    });

    return response.success(messages);
});


module.exports = exports = router.routes();


================================================
FILE: src/routers/model/index.js
================================================
const router = require("koa-router")();

router.prefix("/api/model");

const modules = [
  "model",
]

for (const module of modules) {
  try {
    router.use(require(`./${module}.js`));
  }
  catch (error) { console.log(`load ${module} error`, error); }
}

module.exports = router.routes();



================================================
FILE: src/routers/model/model.js
================================================
const router = require("koa-router")();

const Model = require('@src/models/Model');
const Platform = require('@src/models/Platform');
const { Op } = require("sequelize");
// Create a new model
/**
 * @swagger
 * /api/model:
 *   post:
 *     summary: Create a new model
 *     tags:  
 *       - Model
 *     description: This endpoint creates a new model with the provided content.
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               platform_id:
 *                 type: string
 *                 description: Platform ID
 *               model_id:
 *                 type: string
 *                 description: model id
 *               model_name:
 *                 type: string
 *                 description: model name
 *               group_name:
 *                 type: string
 *                 description: group name
 *               model_types:
 *                 type: array
 * 
 *     responses:
 *       200:
 *         description: Successfully created a new platform
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   $ref: './schemas/model.json'
 *                 code:
 *                   type: integer
 *                   description: Status code
 *                 msg:
 *                   type: string
 *                   description: Message
 *                 
 */
router.post("/", async ({ state, request, response }) => {
    const body = request.body || {};
    const { platform_id, model_id, model_name, group_name,model_types } = body
    const model = await Model.create({
        platform_id: platform_id,
        model_id: model_id,
        model_name: model_name,
        group_name: group_name,
        model_types: model_types,
    });
    return response.success(model);
});

// Get model list by platform id
/**
 * @swagger
 * /api/model/platform/{platform_id}:
 *   get:
 *     summary: Get model list by platform id
 *     tags:  
 *       - Model
 *     description: This endpoint retrieves a list of models by platform id.
 *     parameters:
 *       - in: path
 *         name: platform_id
 *         required: true
 *         schema:
 *           type: string
 *         description: The ID of the platform
 *     responses:
 *       200:
 *         description: Successfully retrieved model list
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   type: array
 *                   items:
 *                     $ref: './schemas/model.json'
 *                 code:
 *                   type: integer
 *                   description: Status code
 *                 msg:
 *                   type: string
 *                   description: Message
 *                 
 */
router.get("/list/:platform_id", async ({ state, params, response }) => {
    const { platform_id } = params;
    const models = await Model.findAll({
        where: {
            platform_id: platform_id,
        }
    });
    return response.success(models);
});

// update model
/**
 * @swagger
 * /api/model/{id}:
 *   put:
 *     summary: Update model
 *     tags:  
 *       - Model
 *     description: This endpoint updates a specified model.
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: The ID of the model to be updated
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               model_name:
 *                 type: string
 *                 description: Model name
 *               group_name:
 *                 type: string
 *                 description: Group name
 *               model_types:
 *                 type: array
 *
 *
 */

router.put("/:id", async ({ state, params, request, response }) => {
    const { id } = params;
    const body = request.body || {};
    const { model_name, group_name,model_types } = body
    const model = await Model.findOne({
        where: {
            id: id
        }
    });
    if (!model) {
        return response.error("Model does not exist");
    }
    await model.update({
        model_name: model_name,
        group_name: group_name,
        model_types: model_types
    });
    return response.success(model);
});

// Delete model
/**
 * @swagger
 * /api/model/{id}:
 *   delete:
 *     summary: Delete model
 *     tags:  
 *       - Model
 *     description: This endpoint deletes a specified model.
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: The ID of the model to be deleted
 *     responses:
 *       200:
 *         description: Model deleted successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   $ref: './schemas/model.json'
 *                 code:
 *                   type: integer
 *                   description: Status code
 *                 msg:
 *                   type: string
 *                   description: Message
 */
router.delete("/:id", async ({ state, params, response }) => {
    const { id } = params;
    const model = await Model.findOne({
        where: {
            id: id,
        }
    });
    if (!model) {
        return response.error("Model does not exist");
    }
    await model.destroy();
    return response.success();
});

// get model list where platform is enabled
/**
 * @swagger
 * /api/model/enabled:
 *   get:
 *     summary: Get model list where platform is enabled
 *     tags:  
 *       - Model
 *     description: This endpoint retrieves a list of models where the platform is enabled.
 *     responses:
 *       200:
 *         description: Successfully retrieved model list
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   type: array
 *                   items:
 *                     $ref: './schemas/model_enable.json'
 *                 code:
 *                   type: integer
 *                   description: Status code
 *                 msg:
 *                   type: string
 *                   description: Message
 */
router.get("/enabled", async ({ response }) => {
    const platforms = await Platform.findAll({
        where: {
            is_enabled: true,
        },
    });
    let allModels = [];
    for(let platform of platforms){
        const models = await Model.findAll({
            where: {
                platform_id: platform.id,
            },
        });
        for(let model of models){
            allModels.push({
                ...model.dataValues,
                platform_name: platform.name,
                is_subscribe: platform.is_subscribe,
                requires_membership: model.requires_membership,
                membership_level: model.membership_level,
            });
        }
    }
    
    // Sort by sort_weight (descending) first, then by requires_membership (false first)
    allModels.sort((a, b) => {
        // First sort by sort_weight (descending)
        if (a.sort_weight !== b.sort_weight) {
            return (b.sort_weight || 0) - (a.sort_weight || 0);
        }
        // Then sort by requires_membership (false first)
        if (a.requires_membership !== b.requires_membership) {
            return a.requires_membership - b.requires_membership;
        }
        return 0;
    });
    
    return response.success(allModels);
});

module.exports = exports = router.routes();


================================================
FILE: src/routers/order/index.js
================================================
const router = require("koa-router")();

router.prefix("/api/order");

const modules = [
  "order",
]

for (const module of modules) {
  try {
    router.use(require(`./${module}.js`));
  }
  catch (error) { console.log(`load ${module} error`, error); }
}

module.exports = router.routes();


================================================
FILE: src/routers/order/order.js
================================================
const router = require("koa-router")();
const forwardRequest = require('@src/utils/sub_server_forward_request')

router.get("/list", async (ctx) => {
  let res = await forwardRequest(ctx, "GET", "/api/order/list")
  return ctx.body = res;
})

module.exports = exports = router.routes();


================================================
FILE: src/routers/payment/index.js
================================================
const router = require("koa-router")();

router.prefix("/api/payment");

const modules = [
  "payment",
]

for (const module of modules) {
  try {
    router.use(require(`./${module}.js`));
  }
  catch (error) { console.log(`load ${module} error`, error); }
}

module.exports = router.routes();


================================================
FILE: src/routers/payment/payment.js
================================================
const router = require("koa-router")();

const forwardRequest = require('@src/utils/sub_server_forward_request')

router.post("/create_mambership_plan_order", async (ctx) => {
  let res = await forwardRequest(ctx, "POST", "/api/payment/create_mambership_plan_order")
  return ctx.body = res;
})

//create_point_purchase_order
router.post("/create_point_purchase_order", async (ctx) => {
  let res = await forwardRequest(ctx, "POST", "/api/payment/create_point_purchase_order")
  return ctx.body = res;
})

router.get("/check_order_status", async (ctx) => {
  let res = await forwardRequest(ctx, "GET", "/api/payment/check_order_status")
  return ctx.body = res;
})

//check_order_status_by_id
router.get("/check_order_status_by_id", async (ctx) => {
  let res = await forwardRequest(ctx, "GET", "/api/payment/check_order_status_by_id")
  return ctx.body = res;
})

//create_membership_upgrade_order
router.post("/create_membership_upgrade_order", async (ctx) => {
  let res = await forwardRequest(ctx, "POST", "/api/payment/create_membership_upgrade_order")
  return ctx.body = res;
})


// /strip/create_mambership_plan_order
router.post("/strip/create_mambership_plan_order",async (ctx) => {
  let res =  await forwardRequest(ctx, "POST", "/api/payment/strip/create_mambership_plan_order")
  return ctx.body = res;
})
// /strip/create_point_purchase_order
router.post("/strip/create_point_purchase_order",async (ctx) => {
  let res =  await forwardRequest(ctx, "POST", "/api/payment/strip/create_point_purchase_order")
  return ctx.body = res;
})
// payment/strip/checkout-session
router.get("/strip/checkout-session",async (ctx) => {
  let res =  await forwardRequest(ctx, "GET", "/api/payment/strip/checkout-session")
  return ctx.body = res;
})

//get_subscription_info
router.get("/strip/get_subscription_info",async (ctx) => {
  let res =  await forwardRequest(ctx, "GET", "/api/payment/strip/get_subscription_info")
  return ctx.body = res;
})

//cancel_subscription post
router.post("/strip/cancel_subscription",async (ctx) => {
  let res =  await forwardRequest(ctx, "POST", "/api/payment/strip/cancel_subscription")
  return ctx.body = res;
})

//reactivate_subscription
router.post("/strip/reactivate_subscription",async (ctx) => {
  let res =  await forwardRequest(ctx, "POST", "/api/payment/strip/reactivate_subscription")
  return ctx.body = res;
})

//upgrade_subscription
router.post("/strip/upgrade_subscription",async (ctx) => {
  let res =  await forwardRequest(ctx, "POST", "/api/payment/strip/upgrade_subscription")
  return ctx.body = res;
})

//preview_upgrade
router.post("/strip/preview_upgrade",async (ctx) => {
  let res =  await forwardRequest(ctx, "POST", "/api/payment/strip/preview_upgrade")
  return ctx.body = res;
})

//downgrade_subscription
router.post("/stripe/downgrade_subscription",async (ctx) => {
  let res =  await forwardRequest(ctx, "POST", "/api/payment/stripe/downgrade_subscription")
  return ctx.body = res;
})

//cancel_downgrade
router.post("/stripe/cancel_downgrade",async (ctx) => {
  let res =  await forwardRequest(ctx, "POST", "/api/payment/stripe/cancel_downgrade")
  return ctx.body = res;
})





module.exports = exports = router.routes();


================================================
FILE: src/routers/platform/index.js
================================================
const router = require("koa-router")();

router.prefix("/api/platform");

const modules = [
  "platform",
]

for (const module of modules) {
  try {
    router.use(require(`./${module}.js`));
  }
  catch (error) { console.log(`load ${module} error`, error); }
}

module.exports = router.routes();



================================================
FILE: src/routers/platform/platform.js
================================================
const router = require("koa-router")();

const Platform = require("@src/models/Platform");
const Model = require("@src/models/Model");
const checkLlmApiAvailability = require("@src/utils/check_llm_api_availability");

// Create a new platform
/**
 * @swagger
 * /api/platform:
 *   post:
 *     summary: Create a new platform
 *     tags:  
 *       - Platform
 *     description: This endpoint creates a new platform with the provided content.
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               name:
 *                 type: string
 *                 description: Platform name
 *               logo_url:
 *                 type: string
 *                 description: Logo URL
 *               source_type:
 *                 type: string
 *                 description: Source type
 * 
 *     responses:
 *       200:
 *         description: Successfully created a new platform
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   $ref: './schemas/platform.json'
 *                 code:
 *                   type: integer
 *                   description: Status code
 *                 msg:
 *                   type: string
 *                   description: Message
 *                 
 */
router.post("/", async ({ state, request, response }) => {
  const body = request.body || {};
  const { name, logo_url, source_type } = body

  const platform = await Platform.create({
    name: name,
    logo_url: logo_url,
    source_type: source_type,
  });

  return response.success(platform);
});

// Get platform list
/**
 * @swagger
 * /api/platform:
 *   get:
 *     summary: Get platform list
 *     tags:  
 *       - Platform
 *     description: This endpoint retrieves the list of platforms.
 *     responses:
 *       200:
 *         description: Successfully retrieved the platform list
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   $ref: './schemas/platform.json'
 *                 code:
 *                   type: integer
 *                   description: Status code
 *                 msg:
 *                   type: string
 *                   description: Message
 */
router.get("/", async ({ response }) => {
  const platforms = await Platform.findAll({ order: [['create_at', 'DESC']] });
  return response.success(platforms);
});

// update platform
/**
 * @swagger
 * /api/platform/{platform_id}:
 *   put:
 *     summary: Update platform
 *     tags:  
 *       - Platform
 *     description: This endpoint updates the platform with the provided platform_id.
 *     parameters:
 *       - name: platform_id
 *         in: path
 *         required: true
 *         description: Unique identifier for the platform
 *         schema:
 *           type: string
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               api_key:
 *                 type: string
 *                 description: Platform api key
 *               api_url:
 *                 type: string
 *                 description: Platform api url
 *               name:
 *                 type: string
 *                 description: Platform name
 *               is_enabled:
 *                 type: boolean
 *                 description: Is platform enabled
 *
 *
 */
router.put("/:platform_id", async ({ state, params, request, response }) => {
  const { platform_id } = params;
  const body = request.body || {};

  const { api_key, api_url, name, is_enabled } = body

  const platform = await Platform.findOne({
    where: { id: platform_id }
  });
  if (!platform) {
    return response.fail({}, "Platform does not exist");
  }

  await platform.update({
    name: name,
    api_key: api_key,
    api_url: api_url,
    is_enabled: is_enabled
  });

  return response.success(platform);
});

// delete platform
/**
 * @swagger
 * /api/platform/{platform_id}:
 *   delete:
 *     summary: Delete platform
 *     tags:  
 *       - Platform
 *     description: This endpoint deletes the platform with the provided platform_id.
 *     parameters:
 *       - name: platform_id
 *         in: path
 *         required: true
 *         description: Unique identifier for the platform
 *         schema:
 *           type: string
 */
router.delete("/:platform_id", async ({ state, params, response }) => {
  const { platform_id } = params;

  const platform = await Platform.findOne({
    where: { id: platform_id }
  });
  if (!platform) {
    return response.fail({}, "Platform does not exist");
  }

  if (platform.source_type === "system") {
    return response.fail({}, "system platform cannot be deleted");
  }

  await platform.destroy();

  await Model.destroy({
    where: { platform_id: platform_id }
  });

  return response.success();
});

/**
 * @swagger
 * /api/platform/check_api_availability:
 *   post:
 *     summary: Check API availability
 *     tags:  
 *       - Platform
 *     description: This endpoint checks the availability of the API.
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               base_url:
 *                 type: string
 *                 description: Base URL
 *               api_key:
 *                 type: string
 *                 description: API key
 *               model:
 *                 type: string
 *                 description: Model
 *     responses:
 *       200:
 *         description: Successfully checked the API availability
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   type: object
 *                   properties:
 *                     status:
 *                       type: boolean
 *                       description: Status
 *                     message:
 *                       type: string
 *                       description: Message
 *                 code:
 *                   type: integer
 *                   description: Status code
 *                 msg:
 *                   type: string
 *                   description: Message
 */
router.post("/check_api_availability", async ({ request, response }) => {
  const body = request.body || {};
  const { base_url, api_key, model } = body
  const res = await checkLlmApiAvailability(base_url, api_key, model)
  return response.success(res)
})

module.exports = exports = router.routes();


================================================
FILE: src/routers/points_transaction/index.js
================================================
const router = require("koa-router")();

router.prefix("/api/points_transaction");

const modules = [
  "points_transaction",
]

for (const module of modules) {
  try {
    router.use(require(`./${module}.js`));
  }
  catch (error) { console.log(`load ${module} error`, error); }
}

module.exports = router.routes();


================================================
FILE: src/routers/points_transaction/points_transaction.js
================================================
const router = require("koa-router")();
const Conversation = require('@src/models/Conversation')

const forwardRequest = require('@src/utils/sub_server_forward_request')


router.get("/list", async (ctx) => {
  let res = await forwardRequest(ctx, "GET", "/api/points_transaction/list")

  for (let item of res.data.list) {
    if (item.source_id) {
      try {
        let conversation = await Conversation.findOne({ where: { conversation_id: item.source_id } })
        if (conversation) {
          item.conversation_title = conversation.dataValues.title
          item.description = conversation.dataValues.title
        }
      } catch (e) {

      }
    }
  }
  return ctx.body = res;
})


module.exports = exports = router.routes();


================================================
FILE: src/routers/recharge_product/index.js
================================================
const router = require("koa-router")();

router.prefix("/api/recharge_product");

const modules = [
  "recharge_product",
]

for (const module of modules) {
  try {
    router.use(require(`./${module}.js`));
  }
  catch (error) { console.log(`load ${module} error`, error); }
}

module.exports = router.routes();


================================================
FILE: src/routers/recharge_product/recharge_product.js
================================================
const router = require("koa-router")();
const axios = require("axios");
const SUB_SERVER_DOMAIN = process.env.SUB_SERVER_DOMAIN || 'https://app.lemonai.ai';
const forwardRequest = require('@src/utils/sub_server_forward_request')


router.get("/list",async (ctx) => {
  let res =  await forwardRequest(ctx, "GET", "/api/recharge_product/list")
  return ctx.body = res;
})


module.exports = exports = router.routes();


================================================
FILE: src/routers/runtime/index.js
================================================
// @ts-ignore
const router = require("koa-router")();

router.prefix("/api/runtime");

const modules = [
  "runtime",
]

for (const module of modules) {
  try {
    router.use(require(`./${module}.js`));
  }
  catch (error) { console.log(`load ${module} error`, error); }
}

module.exports = router.routes();



================================================
FILE: src/routers/runtime/runtime.js
================================================
const router = require("koa-router")();

const DockerRuntime = require("@src/runtime/DockerRuntime.local");

const RUNTIME_TYPE = process.env.RUNTIME_TYPE || 'local-docker';

const runtimeMap = {
  'docker': DockerRuntime,
}

const Runtime = runtimeMap[RUNTIME_TYPE]
/**
 * @swagger
 * /api/runtime/vscode-url:
 *   get:
 *     tags:
 *       - Runtime
 *     summary: Get the VSCode URL for the running container
 *     description: |
 *       This endpoint retrieves the URL for accessing the VSCode instance running in the Docker container.
 *     parameters:
 *       - in: query
 *         name: conversation_id
 *         required: true
 *         schema:
 *           type: string
 *         description: The ID of the conversation to retrieve messages for.
 *     responses:
 *       200:
 *         description: Successfully retrieved the VSCode URL
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   type: object
 *                   properties:
 *                     url:
 *                       type: string
 *                       description: URL for accessing the VSCode instance
 *                 code:
 *                   type: integer
 *                   description: Status code
 *                 msg:
 *                   type: string
 *                   description: Message
 */
router.get('/vscode-url', async ({ state, query, response }) => {
  const { conversation_id } = query;
  const user_id = state.user.id
  let dir_name = ''
  if (conversation_id) {
    dir_name = 'Conversation_' + conversation_id.slice(0, 6);
  }

  const runtime = new Runtime({ user_id, conversation_id })
  await runtime.connect_container()

  const vscode_port = 9002

  const vscode_url = runtime.get_vscode_url(dir_name);
  return response.success({ url: vscode_url });
});


module.exports = exports = router.routes();


================================================
FILE: src/routers/search_provider_setting/index.js
================================================
const router = require("koa-router")();

router.prefix("/api/search_provider_setting");

const modules = [
  "setting",
]

for (const module of modules) {
  try {
    router.use(require(`./${module}.js`));
  }
  catch (error) { console.log(`load ${module} error`, error); }
}

module.exports = router.routes();



================================================
FILE: src/routers/search_provider_setting/setting.js
================================================
const router = require("koa-router")();

const UserProviderConfig = require("@src/models/UserProviderConfig");
const UserSearchSetting = require("@src/models/UserSearchSetting");
const SearchProviderTable = require("@src/models/SearchProvider");
const TalivySearch = require("@src/tools/impl/web_search/TalivySearch");
const LocalSearch = require("@src/tools/impl/web_search/LocalSearch");
const CloudswaySearch = require("@src/tools/impl/web_search/CloudswaySearch");
// upsert user provider config
/**
 * @swagger
 * /api/search_provider_setting:
 *   put:
 *     summary: Upsert user provider config
 *     tags:
 *       - SearchProviderSetting
 *     description: This endpoint upserts user provider config with the provided content.
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               provider_id:
 *                 type: integer
 *                 description: Search provider id
 *               api_key:
 *                 type: string
 *                 description: Search provider api key
 *               endpoint:
 *                 type: string
 *                 description: Search provider endpoint
 *               include_date:
 *                 type: boolean
 *                 description: Include date in search
 *               cover_provider_search:
 *                 type: boolean
 *                 description: Cover provider search
 *               enable_enhanced_mode:
 *                 type: boolean
 *                 description: Enable enhanced mode
 *               result_count:
 *                 type: integer
 *                 description: Result count
 *               blacklist:
 *                 type: string
 *                 description: Blacklist
 *     responses:
 *       200:
 *         description: Successfully upserted user provider config
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   $ref: './schemas/provider_setting_result.json'
 *                 code:
 *                   type: integer
 *                   description: Status code
 *                 msg:
 *                   type: string
 *                   description: Message
 *
 */
router.put("/", async (ctx) => {
    const {
        provider_id,
        api_key,
        endpoint,
        include_date,
        cover_provider_search,
        enable_enhanced_mode,
        result_count,
        blacklist
    } = ctx.request.body;

    const user_id = ctx.state.user.id

    // Validate input
    if (!provider_id) {
        ctx.body = { code: 400, msg: "Provider ID is required" };
        return;
    }

    // Check if the provider exists
    const provider = await SearchProviderTable.findByPk(provider_id);
    if (!provider) {
        ctx.body = { code: 404, msg: "Provider not found" };
        return;
    }

    // æ£€æŸ¥ç”¨æˆ·æä¾›è€…é…ç½®è¡¨ä¸­æ˜¯å¦å­˜åœ¨è®°å½•
    const userConfig = await UserSearchSetting.findOne({
        where: { user_id } // if create user provider config, there be only one record
    });
    let config = null;
    if (!userConfig) {
        // æ·»åŠ æ–°çš„é…ç½®é¡¹
        [config] = await UserSearchSetting.upsert({
            provider_id,
            include_date,
            cover_provider_search,
            enable_enhanced_mode,
            result_count,
            blacklist,
            user_id,
        });
    } else {
        console.log('provider_id', provider_id)
        // æ›´æ–°æ–°çš„é…ç½®é¡¹
        await userConfig.update({
            provider_id,
            include_date,
            cover_provider_search,
            enable_enhanced_mode,
            result_count,
            blacklist,
        });
        config = userConfig;
    }
    console.log(api_key)
    // æ›´æ–°å’Œåˆ›å»ºç”¨æˆ·æä¾›è€…é…ç½®è¡¨ä¸­çš„è®°å½•
    let [userProviderConfig, created] = await UserProviderConfig.findOrCreate({
        where: { provider_id: provider_id, user_id },
        defaults: {
        }
    });
    // update api_key é€šè¿‡provider_id æ›´æ–°ã€‚å¦‚æœendpointä¸ä¸ºç©ºï¼Œåˆ™ä¹Ÿæ›´æ–°endpoint
    if (endpoint !== undefined && endpoint !== "") {
        await userProviderConfig.update({
            base_config: { api_key, endpoint }
        }, { where: { provider_id: provider_id, user_id } })
    } else if (api_key !== undefined && api_key !== "") {
        await userProviderConfig.update({
            base_config: { api_key }
        }, { where: { provider_id: provider_id, user_id } })
    }
    const requestBody = Object.assign({
        provider_id: provider_id,
        base_config: userProviderConfig.base_config,
        provider_name: provider.name,
        logo_url: provider.logo_url
    }, config.dataValues)

    ctx.body = { code: 200, data: requestBody, msg: "Successfully upserted user provider config" };
});

// Get user provider config
/**
 * @swagger
 * /api/search_provider_setting:
 *   get:
 *     summary: Get user provider config
 *     tags:
 *       - SearchProviderSetting
 *     description: This endpoint retrieves the user provider config.
 *     responses:
 *       200:
 *         description: Successfully retrieved user provider config
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   $ref: './schemas/provider_setting_result.json'
 *                 code:
 *                   type: integer
 *                   description: Status code
 *                 msg:
 *                   type: string
 *                   description: Message
 */
router.get("/", async (ctx) => {

    // Get user provider config
    const user_id = ctx.state.user.id
    const config = await UserSearchSetting.findOne({ where: { user_id } });

    if (!config) {
        ctx.body = { code: 1, msg: "User provider config not found" };
        return;
    }
    const userProviderConfig = await UserProviderConfig.findOne({
        where: { provider_id: config.provider_id, user_id }
    })
    const provider = await SearchProviderTable.findByPk(config.provider_id);
    if (!provider) {
        ctx.body = { code: 404, msg: "Provider not found" };
        return;
    }
    const requestBody = Object.assign({
        provider_name: provider.name,
        logo_url: provider.logo_url,
        base_config: userProviderConfig.dataValues.base_config
    }, config.dataValues);
    ctx.body = { code: 200, data: requestBody, msg: "Successfully retrieved user provider config" };
});


// Get current provider config list
/**
 * @swagger
 * /api/search_provider_setting/provider:
 *   get:
 *     summary: Get provider list
 *     tags:
 *       - SearchProviderSetting
 *     description: This endpoint retrieves the provider list.
 *     responses:
 *       200:
 *         description: Successfully retrieved provider list
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   $ref: './schemas/provider.json'
 *                 code:
 *                   type: integer
 *                   description: Status code
 *                 msg:
 *                   type: string
 *                   description: Message
 */
router.get("/configs", async (ctx) => {
    const user_id = ctx.state.user.id
    const providers = await UserProviderConfig.findAll({ where: { user_id } });
    ctx.body = { code: 200, data: providers, msg: "Successfully retrieved provider configs" };
});
// Get current provider templates list
/**
 * @swagger
 * /api/search_provider_setting/provider:
 *   get:
 *     summary: Get provider list
 *     tags:
 *       - SearchProviderSetting
 *     description: This endpoint retrieves the provider list.
 *     responses:
 *       200:
 *         description: Successfully retrieved provider list
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   $ref: './schemas/provider.json'
 *                 code:
 *                   type: integer
 *                   description: Status code
 *                 msg:
 *                   type: string
 *                   description: Message
 */
router.get("/templates", async (ctx) => {
    const providers = await SearchProviderTable.findAll();
    ctx.body = { code: 200, data: providers, msg: "Successfully retrieved provider templates" };
});


/**
 * @swagger
 * /api/search_provider_setting/check_search_provider:
 *   post:
 *     summary: Check search provider
 *     tags:
 *       - SearchProviderSetting
 *     description: This endpoint checks the search provider.
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               type:
 *                 type: string
 *                 description: Search provider type
 *               api_key:
 *                 type: string
 *                 description: Search provider api key
 *               engine:
 *                 type: string
 *                 description: Search provider engine
 *     responses:
 *       200:
 *         description: Successfully checked search provider
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   type: object
 *                   properties:
 *                     status:
 *                       type: boolean
 *                       description: Status
 *                     message:
 *                       type: string
 *                       description: Message
 */
router.post("/check_search_provider", async ({ request, response }) => {
    const { type, api_key = "", endpoint = "", engine = "" } = request.body;
    if (type === 'tavily') {
        const talivy = new TalivySearch({ key: api_key });
        const res = await talivy.check()
        response.success(res)
    } else if (type === 'local') {
        const local = new LocalSearch();
        const res = await local.check(engine)
        response.success(res)
    } else if (type === 'cloudsway') {
        const cloudsway = new CloudswaySearch({ access_key: api_key, endpoint: endpoint });
        const res = await cloudsway.check()
        response.success(res)
    } else {
        response.fail("Invalid search provider type")
    }
})

module.exports = exports = router.routes();


================================================
FILE: src/routers/user/index.js
================================================
const router = require("koa-router")();

router.prefix("/api/users");

const modules = [
  "users",
]

for (const module of modules) {
  try {
    router.use(require(`./${module}.js`));
  }
  catch (error) { console.log(`load ${module} error`, error); }
}

module.exports = router.routes();



================================================
FILE: src/routers/user/users.js
================================================
const router = require("koa-router")();

const forwardRequest = require('@src/utils/sub_server_forward_request')

router.get("/userinfo",async (ctx) => {
  let res =  await forwardRequest(ctx, "GET", "/api/users/userinfo")
  return ctx.body = res;
})

router.post("/google-auth", async (ctx) => {
  let res =  await forwardRequest(ctx, "POST", "/api/users/google-auth")
  return ctx.body = res;
});



//loginSMSCode
router.post("/login-sms-code", async (ctx) => {
  let res =  await forwardRequest(ctx, "POST", "/api/users/login-sms-code")
  return ctx.body = res;
});

//send-sms-code
router.post("/send-sms-code", async (ctx) => {
  let res =  await forwardRequest(ctx, "POST", "/api/users/send-sms-code")
  return ctx.body = res;
});
//verifySmsVerifyCode
router.post("/verifySmsVerifyCode", async (ctx) => {
  let res =  await forwardRequest(ctx, "POST", "/api/users/verifySmsVerifyCode")
  return ctx.body = res;
});
///api/users/updateUsername
router.post("/updateUsername", async (ctx) => {
  let res =  await forwardRequest(ctx, "POST", "/api/users/updateUsername")
  return ctx.body = res;
});

router.post("/sendEmailVerifyCode", async (ctx) => {
  let res =  await forwardRequest(ctx, "POST", "/api/users/sendEmailVerifyCode")
  return ctx.body = res;
});

router.post("/verifyEmailVerifyCode", async (ctx) => {
  return ctx.body =  await forwardRequest(ctx, "POST", "/api/users/verifyEmailVerifyCode")
});

router.post("/register", async (ctx) => {
  return ctx.body =  await forwardRequest(ctx, "POST", "/api/users/register")
});

//login
router.post("/login", async (ctx) => {
  return ctx.body = await forwardRequest(ctx, "POST", "/api/users/login")
});

//resetPassword
router.post("/resetPassword", async (ctx) => {
  return ctx.body =  await forwardRequest(ctx, "POST", "/api/users/resetPassword")
});

router.get('/auth/google', async (ctx) => {
  const query = ctx.query;
  const queryString = new URLSearchParams(query).toString();

  // è¯»å–ç¯å¢ƒå˜é‡ï¼Œåˆ¤æ–­æ˜¯ä¸æ˜¯å®¢æˆ·ç«¯
  // æ³¨æ„ï¼šè¿™é‡ŒæœåŠ¡ç«¯è¦èƒ½è¯»å– import.meta.env éœ€è¦ç›¸åº”é…ç½®ï¼Œæˆ–è€…é€šè¿‡ process.env ä¼ é€’
  // å¦‚æœä½ ç”¨çš„æ˜¯ Vite + SSRï¼Œå¯èƒ½è¦ä» ctx.env æˆ–è€…å…¶ä»–åœ°æ–¹æ‹¿
  // è¿™é‡Œå‡è®¾ä½ ç”¨ process.env.VITE_IS_CLIENT æ›¿ä»£
  const isClient = process.env.VITE_IS_CLIENT === 'true';
  console.log("isClient === ",isClient);
  if (isClient) {
    // æ˜¯å®¢æˆ·ç«¯ï¼Œè¿”å› HTML é¡µé¢
    const clientRedirectUrl = `http://localhost:51789/?${queryString}`;

    ctx.set('Content-Type', 'text/html; charset=utf-8');
    ctx.body = `
      <html>
        <head><title>ç™»å½•æˆåŠŸ</title></head>
        <body>
          <h2>ç™»å½•æˆåŠŸï¼Œæ­£åœ¨é€šçŸ¥å®¢æˆ·ç«¯ï¼Œè¯·ç¨å€™...</h2>
          <script>
            fetch("${clientRedirectUrl}", {
              method: "GET",
              mode: "no-cors"
            }).catch(() => {});
          </script>
        </body>
      </html>
    `;
  } else {
    // ä¸æ˜¯å®¢æˆ·ç«¯ï¼Œç›´æ¥é‡å®šå‘åˆ°å‰ç«¯é¡µé¢
    const redirectUrl = `http://localhost:5005/auth/google${queryString ? '?' + queryString : ''}`;
    ctx.redirect(redirectUrl);
  }
});


module.exports = router.routes();



================================================
FILE: src/routers/version/index.js
================================================
const router = require("koa-router")();

router.prefix("/api/version");

const modules = [
  "version",
]

for (const module of modules) {
  try {
    router.use(require(`./${module}.js`));
  }
  catch (error) { console.log(`load ${module} error`, error); }
}

module.exports = router.routes();


================================================
FILE: src/routers/version/version.js
================================================
const router = require('koa-router')();
const axios = require('axios');
const { version } = require('../../../package.json'); 

// Configure the GitHub API URL
const GITHUB_OWNER = 'hexdocom';
const GITHUB_REPO = 'lemonai';
const GITHUB_API_URL = `https://api.github.com/repos/${GITHUB_OWNER}/${GITHUB_REPO}/releases/latest`;

// Add proxy and GitHub token
const PROXY = process.env.HTTP_PROXY || process.env.HTTPS_PROXY || null;
const GITHUB_TOKEN = process.env.GITHUB_TOKEN || null;

// Compare version numbers
function compareVersions(localVersion, remoteVersion) {
  const parseVersion = (v) => v.split('.').map(Number);
  const local = parseVersion(localVersion);
  const remote = parseVersion(remoteVersion.replace(/^v/, '')); // Remove 'v' prefix in tag

  for (let i = 0; i < Math.max(local.length, remote.length); i++) {
    const l = local[i] || 0;
    const r = remote[i] || 0;
    if (l < r) return -1; // Remote version is newer
    if (l > r) return 1; // Local version is newer
  }
  return 0; // Versions are the same
}

// Fetch version information
async function checkForUpdates() {
  try {
    const config = {
      headers: {
        'User-Agent': 'Node.js Version Checker',
        'Accept': 'application/vnd.github.v3+json',
      },
      timeout: 5000, // 5 seconds timeout
    };

    if (GITHUB_TOKEN) {
      config.headers['Authorization'] = `token ${GITHUB_TOKEN}`;
    }

    if (PROXY) {
      config.proxy = {
        protocol: 'http',
        host: PROXY.replace('http://', '').split(':')[0],
        port: parseInt(PROXY.split(':')[1]),
      };
    }

    const response = await axios.get(GITHUB_API_URL, config);
    const release = response.data;
    const latestVersion = release.tag_name.replace(/^v/, ''); // Remove 'v' prefix in tag
    const comparison = compareVersions(version, latestVersion);

    return {
      localVersion: version,
      latestVersion: latestVersion,
      isLatest: comparison !== -1,
      updateUrl: comparison !== -1 ? null:release.html_url,
      message: comparison !== -1 ?  'Current version is up to date':`New version found! Latest version: ${latestVersion}`,
      body:  comparison !== -1?null:release.body,
    };
  } catch (error) {
    return {
      localVersion: version,
      latestVersion: null,
      isLatest: false,
      updateUrl: null,
      message: `Failed to check for updates: ${error.message}${error.code === 'ECONNREFUSED' ? ' (Possibly a network or proxy issue, please check configuration)' : ''}`,
      body: ""
    };
  }
}

/**
 * Get version information
 */
router.get('/', async (ctx) => {
  const versionInfo = await checkForUpdates();
  ctx.response.success(versionInfo);
});

module.exports = exports = router.routes();


================================================
FILE: src/runtime/action_execution_server.js
================================================
// action_execution_server.js

console.log('[DEBUG] Script started (top of file).'); // æ–°å¢

const Koa = require('koa');
const argv = require('minimist')(process.argv.slice(2));
const { koaBody } = require('koa-body');
const terminal_run = require('./terminal_run');
const browser = require('./browser')
const path = require('path');
const { run: vscode_init } = require('./plugins/vscode/index');
const { run: browser_init } = require('./plugins/browser/index');
const { getDirpath } = require('./utils/electron');
const WORKSPACE_DIR = getDirpath(process.env.WORKSPACE_DIR || 'workspace');

// Create Koa application instance
const app = new Koa();

// Register koaBody middleware first to parse POST request body
app.use(koaBody({
  multipart: true
}));

// Route handling
app.use(async ctx => {
  if (ctx.method === 'POST' && ctx.path === '/execute_action') {
    console.log(ctx.request.body)
    const { action, uuid } = ctx.request.body

    let result
    switch (action.type) {
      case 'terminal_run':
        action.params.cwd = path.resolve(__dirname, WORKSPACE_DIR, action.params.cwd || '.');
        result = await terminal_run(action, uuid);
        break;
      case 'browser':
        result = await browser(action, uuid);
        break;
      default:
        break;
    }

    ctx.body = {
      message: 'Received POST /action',
      data: result
    };
  } else {
    ctx.body = 'Koa server is running!';
  }
});

console.log('[DEBUG] Before async initialization block.'); // æ–°å¢

(async () => {
  console.log('[DEBUG] Inside async initialization block.'); // æ–°å¢
  try {
    const vscode_port = argv.vscode_port || 3001;
    console.log(`[ACTION_EXECUTION_SERVER] Attempting to initialize VS Code on port ${vscode_port}...`);
    await vscode_init('root', vscode_port);
    console.log('[ACTION_EXECUTION_SERVER] VS Code initialized successfully.');

    console.log('[ACTION_EXECUTION_SERVER] Attempting to initialize browser server on port 9000...');
    const browserInitResult = await browser_init('root', 9000);
    console.log('[ACTION_EXECUTION_SERVER] Browser server initialization result:', browserInitResult);
    console.log('[ACTION_EXECUTION_SERVER] Browser server initialized successfully.');

  } catch (err) {
    console.error('[ACTION_EXECUTION_SERVER] Initialization error caught!');
    console.error('Error message:', err.message);
    if (err.stdout) {
      console.error('Error stdout (from `exec` if any):', err.stdout);
    }
    if (err.stderr) {
      console.error('Error stderr (from `exec` if any):', err.stderr);
    }
    if (err.stack) {
      console.error('Error stack:', err.stack);
    }
    if (err.code) {
      console.error('Error code:', err.code);
    }
    if (err.syscall) {
      console.error('Error syscall:', err.syscall);
    }
  } finally {
    // æ— è®ºæˆåŠŸæˆ–å¤±è´¥éƒ½ä¼šæ‰§è¡Œï¼Œç¡®ä¿èƒ½çœ‹åˆ°è¿™ä¸ªæ—¥å¿—
    console.log('[DEBUG] Async initialization block finished (or caught error).'); // æ–°å¢
  }
})();

const port = argv.port || argv.p || 3000;

console.log('[DEBUG] Before app.listen.'); // æ–°å¢

app.listen(port, () => {
  console.log(`Server started on http://localhost:${port}`);
});


================================================
FILE: src/runtime/browser.js
================================================
const axios = require('axios')

async function browser(action, uuid) {
  const host = 'localhost'
  const host_port = 9000

  const request = {
    method: 'POST',
    url: `http://${host}:${host_port}/api/browser/task`,
    data: { prompt: action.params.question, llm_config: action.params.llm_config },
  };
  const response = await axios(request);
  //extracted_content
  const result_content = response.data.data.history.task;
  return {
    uuid,
    status: 'success',
    content: result_content,
    meta: {
      action_type: 'browser',
      json: { browser_history: response.data.data.history.browser_history, browser_history_screenshot: response.data.data.history.browser_history_screenshot }
    }
  };
}


module.exports = browser;


================================================
FILE: src/runtime/DockerRuntime.d.ts
================================================
// LocalRuntime.d.ts
export interface Memory {
  addMessage(
    role: string,
    content: string,
    type: string,
    memorized: boolean
  ): Promise<void>;
}

export interface ActionResult {
  status: "success" | "failure" | string; // Extended allowed values
  content?: string | any[]; // If content may be an array, also add
  error?: any;
  stderr?: any; // If there are additional properties, also add
}

export interface Action {
  type: string;
  params: Record<string, any>;
}

export interface DockerRuntime {
  memory: Memory;
  constructor(options?: { memory: Memory });
  handle_memory(result: ActionResult, action: Action): Promise<Memory>;
  execute_action(action: Action): Promise<ActionResult>;
  write_code(action: Action): Promise<ActionResult>;
  read_file(action: Action): Promise<ActionResult>;
}


================================================
FILE: src/runtime/DockerRuntime.js
================================================
const path = require('path');
const axios = require('axios');
const Docker = require('dockerode');
const os = require('os');
const DOCKER_HOST_ADDR = process.env.DOCKER_HOST_ADDR;
const ECI_SERVER_HOST = process.env.ECI_SERVER_HOST
const { write_code: util_write_code } = require('./utils/tools');
const { getDefaultModel } = require('@src/utils/default_model')
// const { createConf } = require('@src/utils/nginx')


const Message = require('@src/utils/message');

const tools = require("../tools/index.js");
const mcp_tool = require("@src/mcp/tool");
tools['mcp_tool'] = mcp_tool;

const { v4: uuidv4 } = require("uuid");
const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

const { find_available_tcp_port } = require('./utils/system');

const read_file = require('./read_file');

const { restrictFilepath } = require('./runtime.util');


EXECUTION_SERVER_PORT_RANGE = [30000, 39999]
VSCODE_PORT_RANGE = [40000, 49999]
APP_PORT_RANGE_1 = [50000, 54999]
APP_PORT_RANGE_2 = [55000, 59999]

/**
 * @typedef {import('./DockerRuntime').DockerRuntime} LocalRuntimeInterface
 * @typedef {import('./DockerRuntime').Action} Action
 * @typedef {import('./DockerRuntime').ActionResult} ActionResult
 * @typedef {import('./DockerRuntime').Memory} Memory
 */

class DockerRuntime {

  /**
   * åˆ›å»ºä¸€ä¸ªdockerè¿è¡Œæ—¶å®ä¾‹
   * @param {Object} [options={}] - é…ç½®é€‰é¡¹
   * @param {Memory} options.memory - è®°å¿†ç®¡ç†å®ä¾‹
   */
  constructor(context) {
    this.user_id = context.user_id
    // this.workspace_dir = workspace_dir;
    this.host_port = null;
    this.vscode_port = null;
    this.app_port_1 = null;
    this.app_port_2 = null;
    this.docker_host = null;
  }

  // è¦æ“ä½œå®¹å™¨å¿…é¡»å…ˆæ‰§è¡Œconnect_container
  async connect_container() {
    // æŸ¥çœ‹å®¹å™¨æ˜¯å¦å­˜åœ¨ï¼Œå¦‚æœä¸å­˜åœ¨ï¼Œåˆå§‹åŒ–å®¹å™¨ï¼Œå¦‚æœå­˜åœ¨è®¾ç½®å…¨å±€docker_host

    // å…ˆåˆ›å»ºä¸€ä¸ªï¼Œtodoæ£€æŸ¥æ˜¯å¦å­˜åœ¨

    const request = {
      method: 'POST',
      url: `${ECI_SERVER_HOST}/status`,
      data: { name: `user-${this.user_id}-lemon-runtime-sandbox` },
    };

    const response = await axios(request)

    if (response.data.TotalCount > 0) {
      this.docker_host = response.data.ContainerGroups[0].IntranetIp
    } else {
      await this.init_container();
    }

    this.host_port = 9001
    this.vscode_port = 9002
    this.app_port_1 = 10001
    this.app_port_2 = 10002

    return;
  }

  get_vscode_url(dir_name) {
    return `https://${this.user_id}-vscode.lemonai.ai?folder=/workspace/${dir_name}`
  }

  async find_available_port(port_range) {
    const port = await find_available_tcp_port(port_range[0], port_range[1]);
    return port
  }

  async init_container() {
    // åˆå§‹åŒ–å®¹å™¨
    console.log('DockerRuntime.init_container');
    const request = {
      method: 'POST',
      url: `${ECI_SERVER_HOST}/amd`,
      data: { name: `user-${this.user_id}-lemon-runtime-sandbox`, workspace: `user_${this.user_id}` },
    };
    try {
      const response = await axios(request);
      this.docker_host = response.data.IntranetIp
      // await createConf(this.docker_host, this.user_id)
    } catch (e) {
      throw e
    }

    return
  }

  async handle_memory(result, action, memory) {
    const type = action.type;
    const tool = tools[type];
    const memorized_type = new Set(['read_file', "write_code", "terminal_run"]);
    if (result.status === 'success') {
      const content = result.content || result.stderr;
      // handle memory
      const memorized = memorized_type.has(type) || (result.memorized || false);
      let action_memory = ""
      if (memorized && tool && tool.resolveMemory) {
        action_memory = tool.resolveMemory(action, content);
      }
      const meta = {
        action,
        action_memory,
        status: 'success'
      }
      await memory.addMessage('user', content, action.type, memorized, meta);
    }
    return memory;
  }

  /**
   * @param {Action} action 
   * @param {*} context 
   * @returns {Promise<ActionResult>}
   */
  async execute_action(action, context = {}, task_id) {
    const { type, params } = action;
    // æ ¹æ® action.type è°ƒç”¨å¯¹åº”çš„æ–¹æ³•
    console.log('action', action.type);
    const uuid = uuidv4();
    // action running message
    const tool = tools[type];
    if (tool && tool.getActionDescription) {
      const description = await tool.getActionDescription(params);
      const value = {
        uuid: uuid,
        content: description,
        status: 'running',
        meta: {
          task_id: task_id,
          action_type: type,
        },
        timestamp: new Date().valueOf()
      }
      const msg = Message.format({ uuid: uuid, status: 'running', content: description, action_type: type, task_id: task_id });
      // context.onTokenStream(msg)
      await this.callback(msg, context);
      Message.saveToDB(msg, context.conversation_id);
      await delay(500);
    }

    /**
     * @type {ActionResult}
     */
    let result;
    const dir_name = 'Conversation_' + context.conversation_id.slice(0, 6);
    switch (type) {
      case 'write_code':
        if (action.params.path) {
          action.params.origin_path = action.params.path;
          action.params.path = path.join(dir_name, action.params.path)
        }
        result = await this.write_code(action, uuid);
        break;
      case 'terminal_run':
        if (action.params.cwd) {
          action.params.cwd = path.join(dir_name, action.params.cwd)
        } else {
          action.params.cwd = `./${dir_name}`
        }
        result = await this._call_docker_action(action, uuid);
        break;
      case 'read_file':
        if (action.params.path) {
          action.params.path = path.join(dir_name, action.params.path)
        }
        result = await this.read_file(action, uuid);
        break;
      case 'browser':
        let model_info = await getDefaultModel(context.conversation_id)
        const llm_config = {
          model_name: model_info.model_name,
          api_url: model_info.base_url,
          api_key: model_info.api_key
        }
        // llm_config.api_url='http://host.docker.internal:3002/api/agent/v1'
        action.params.llm_config = llm_config
        action.params.conversation_id = context.conversation_id
        result = await this._call_docker_action(action, uuid)
        break;
      default:
        if (tool) {
          console.log('DockerRuntime.execute_action.tool', tool.name, params);
          try {
            const execute = tool.execute;
            params.conversation_id = context.conversation_id
            const execute_result = await execute(params, uuid, context);
            console.log(`${tool.name}.call.result`, execute_result);
            // console.log('LocalRuntime.execute_action.tool.execute', execute_result);
            const { content, meta = {} } = execute_result;
            result = { uuid, status: 'success', content, memorized: tool.memorized || false, meta };
          } catch (error) {
            result = { status: 'failure', error: error.message, content: '', stderr: '' };
          }
        } else {
          result = { status: 'failure', error: `Unknown action type: ${type}`, content: '', stderr: '' };
        }
    }
    // ä¿å­˜ action æ‰§è¡Œç»“æœåˆ° memory
    console.log('DockerRuntime.execute_action', result);
    await this.handle_memory(result, action, context.memory);
    // å›è°ƒå¤„ç†
    let meta_url = ''
    let meta_json = []
    let meta_file_path = ''
    let meta_content = ''
    if (result.meta) {
      meta_url = result.meta.url || ''
      meta_json = result.meta.json || []
      meta_file_path = result.meta.filepath || ''
      meta_content = result.meta.content || ''
    }
    const msg = Message.format({ status: result.status, memorized: result.memorized || '', content: result.content || '', action_type: type, task_id: task_id, uuid: uuid || '', url: meta_url, json: meta_json, filepath: meta_file_path, meta_content: meta_content, comments: result.comments });
    await this.callback(msg, context);
    await Message.saveToDB(msg, context.conversation_id);
    return result;
  }

  async _call_docker_action(action, uuid) {
    const host = this.docker_host
    const request = {
      method: 'POST',
      url: `http://${host}:${this.host_port}/execute_action`,
      data: { action: action, uuid: uuid },
    };
    try {
      const response = await axios(request);
      return response.data.data
    } catch (e) {
      let errorMsg = '';
      if (e.errors) {
        // å¦‚æœ e.errors æ˜¯å¯¹è±¡æˆ–æ•°ç»„ï¼Œè½¬æˆå­—ç¬¦ä¸²
        if (typeof e.errors === 'object') {
          errorMsg = JSON.stringify(e.errors);
        } else {
          errorMsg = e.errors.toString();
        }
      } else if (e.message) {
        errorMsg = e.message;
      } else {
        errorMsg = String(e);
      }

      return { uuid: uuid, status: 'failure', comments: `Failed to do ${action.type}: ${errorMsg}` };
    }
  }

  /**
   * @param {Action} action
   * @returns {Promise<ActionResult>}
   */
  async write_code(action, uuid) {
    return util_write_code(action, uuid, this.user_id);
  }

  /**
   * @param {Action} action
   * @returns {Promise<ActionResult>}
   */
  async read_file(action) {
    let { path: filepath } = action.params;
    filepath = await restrictFilepath(filepath, this.user_id);

    try {
      const content = await read_file(filepath);
      return { status: 'success', content, error: "", meta: { filepath: filepath } };
    } catch (error) {
      return { status: 'failure', content: "", error: `Failed to read file ${filepath}: ${error.message}` };
    }
  }

  async callback(result, context = {}) {
    const { onTokenStream } = context;
    if (onTokenStream) {
      onTokenStream(result);
    }
  }
}

module.exports = DockerRuntime;


================================================
FILE: src/runtime/DockerRuntime.local.js
================================================
const fs = require('fs').promises;
const path = require('path');
const axios = require('axios');
const Docker = require('dockerode');
const os = require('os');
const DOCKER_HOST_ADDR = process.env.DOCKER_HOST_ADDR;
const { write_code: util_write_code } = require('./utils/tools');
const { getDefaultModel } = require('@src/utils/default_model')

let dockerOptions = {};
if (os.platform() === 'win32') {
  // Windows: ä½¿ç”¨ named pipe
  dockerOptions.socketPath = '//./pipe/docker_engine';
} else {
  // Linux/macOS: ä½¿ç”¨é»˜è®¤çš„ Unix socket
  dockerOptions.socketPath = '/var/run/docker.sock';
}
const docker = new Docker(dockerOptions);

const Message = require('@src/utils/message');

const tools = require("../tools/index.js");
const { v4: uuidv4 } = require("uuid");
const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

const { find_available_tcp_port } = require('./utils/system');

const read_file = require('./read_file');

const { restrictFilepath } = require('./runtime.util');


EXECUTION_SERVER_PORT_RANGE = [30000, 39999]
VSCODE_PORT_RANGE = [40000, 49999]
APP_PORT_RANGE_1 = [50000, 54999]
APP_PORT_RANGE_2 = [55000, 59999]

/**
 * @typedef {import('./DockerRuntime').DockerRuntime} LocalRuntimeInterface
 * @typedef {import('./DockerRuntime').Action} Action
 * @typedef {import('./DockerRuntime').ActionResult} ActionResult
 * @typedef {import('./DockerRuntime').Memory} Memory
 */

class DockerRuntime {

  /**
   * åˆ›å»ºä¸€ä¸ªdockerè¿è¡Œæ—¶å®ä¾‹
   * @param {Object} [options={}] - é…ç½®é€‰é¡¹
   * @param {Memory} options.memory - è®°å¿†ç®¡ç†å®ä¾‹
   */
  constructor(context) {

    const { getDirpath } = require('@src/utils/electron');
    let workspace_dir = getDirpath(process.env.WORKSPACE_DIR || 'workspace');
    if (DOCKER_HOST_ADDR) {
      workspace_dir = process.env.ACTUAL_HOST_WORKSPACE_PATH;
    }
    this.user_id = context.user_id
    this.workspace_dir = workspace_dir;
    this.host_port = null;
    this.vscode_port = null;
    this.app_port_1 = null;
    this.app_port_2 = null;
  }

  // è¦æ“ä½œå®¹å™¨å¿…é¡»å…ˆæ‰§è¡Œconnect_container
  async connect_container() {
    // æŸ¥çœ‹å®¹å™¨æ˜¯å¦å­˜åœ¨ï¼Œå¦‚æœä¸å­˜åœ¨ï¼Œåˆå§‹åŒ–å®¹å™¨ï¼Œå¦‚æœå­˜åœ¨ä½†æ˜¯æ²¡å¯åŠ¨ï¼Œstartå®¹å™¨
    let container;
    try {
      container = docker.getContainer('lemon-runtime-sandbox')
      const container_info = await container.inspect();
      if (container_info.State.Status === 'exited') {
        console.log('DockerRuntime.connect_container.container exited, start container');
        await container.start();
      } else if (container_info.State.Status === 'running') {
        console.log('DockerRuntime.connect_container.container is running');
      }
    } catch (err) {
      console.log('DockerRuntime.connect_container.getContainer', err.message);
      container = await this.init_container();
    }

    let container_info = await container.inspect()
    this.host_port = Object.keys(container_info.NetworkSettings.Ports)[0].split('/')[0]
    this.vscode_port = Object.keys(container_info.NetworkSettings.Ports)[1].split('/')[0]
    this.app_port_1 = Object.keys(container_info.NetworkSettings.Ports)[2].split('/')[0]
    this.app_port_2 = Object.keys(container_info.NetworkSettings.Ports)[3].split('/')[0]

    // const cmdArgs = container_info.Config.Cmd;
    // // éå†å‘½ä»¤è¡Œå‚æ•°ï¼Œæ‰¾åˆ°å¯¹åº”çš„ç«¯å£å€¼
    // for (let i = 0; i < cmdArgs.length; i++) {
    //   if (cmdArgs[i] === '--port') {
    //     this.host_port = cmdArgs[i + 1];
    //   } else if (cmdArgs[i] === '--vscode_port') {
    //     this.vscode_port = cmdArgs[i + 1];
    //   }
    // }

    return container;
  }

  async find_available_port(port_range) {
    const port = await find_available_tcp_port(port_range[0], port_range[1]);
    return port
  }

  async init_container() {
    // åˆå§‹åŒ–å®¹å™¨
    console.log('DockerRuntime.init_container');

    const host_port = await this.find_available_port(EXECUTION_SERVER_PORT_RANGE);
    this.host_port = host_port
    const vscode_port = await this.find_available_port(VSCODE_PORT_RANGE);
    const app_port_1 = await this.find_available_port(APP_PORT_RANGE_1);
    const app_port_2 = await this.find_available_port(APP_PORT_RANGE_2);

    const PortBindingsMap = {}
    PortBindingsMap[`${host_port}/tcp`] = [{ HostPort: `${host_port}` }]
    PortBindingsMap[`${vscode_port}/tcp`] = [{ HostPort: `${vscode_port}` }]
    PortBindingsMap[`${app_port_1}/tcp`] = [{ HostPort: `${app_port_1}` }]
    PortBindingsMap[`${app_port_2}/tcp`] = [{ HostPort: `${app_port_2}` }]


    const exposedPortsMap = {}
    exposedPortsMap[`${host_port}/tcp`] = {}
    exposedPortsMap[`${vscode_port}/tcp`] = {}
    exposedPortsMap[`${app_port_1}/tcp`] = {}
    exposedPortsMap[`${app_port_2}/tcp`] = {}

    const imageName = 'hexdolemonai/lemon-runtime-sandbox:latest';
    await this.ensureImageExists(docker, imageName);

    const container = await docker.createContainer({
      Image: imageName,
      name: 'lemon-runtime-sandbox',                // å®¹å™¨åç§°
      Cmd: ['node', 'chataa/action_execution_server.js', '--port', `${host_port}`, '--vscode_port', `${vscode_port}`],  // å¯åŠ¨å‘½ä»¤
      WorkingDir: '/chataa/code',                // å®¹å™¨å†…å·¥ä½œç›®å½•
      ExposedPorts: exposedPortsMap,
      HostConfig: {
        Binds: [
          // æœ¬åœ°ç›®å½• : å®¹å™¨ç›®å½• : æ¨¡å¼ï¼ˆrw å¯è¯»å†™ / ro åªè¯»ï¼‰
          `${this.workspace_dir}:/workspace:rw`
        ],
        PortBindings: PortBindingsMap,
        AutoRemove: false,  // å¦‚éœ€å®¹å™¨é€€å‡ºåè‡ªåŠ¨åˆ é™¤ï¼Œå¯æ”¹ä¸º true
        // NetworkMode: 'host',
      },
    });
    // 2. å¯åŠ¨å®¹å™¨
    await container.start();
    return container;
  }

  async ensureImageExists(docker, imageName) {
    try {
      await docker.getImage(imageName).inspect();
      console.log(`[Docker] Image ${imageName} already exists`);
    } catch (err) {
      if (err.statusCode === 404) {
        console.log(`[Docker] Image ${imageName} not found locally, pulling from registry...`);
        await new Promise((resolve, reject) => {
          docker.pull(imageName, (err, stream) => {
            if (err) {
              return reject(new Error(`[Docker] Failed to pull image: ${err.message}`));
            }
            docker.modem.followProgress(stream, (err, res) => {
              if (err) return reject(new Error(`[Docker] Pull image progress error: ${err.message}`));
              resolve(res);
            });
          });
        });
        console.log(`[Docker] Image ${imageName} pulled successfully`);
      } else {
        throw new Error(`[Docker] Failed to inspect image: ${err.message}`);
      }
    }
  }

  async handle_memory(result, action, memory) {
    const type = action.type;
    const tool = tools[type];
    const memorized_type = new Set(['read_file', "write_code", "terminal_run"]);
    if (result.status === 'success') {
      const content = result.content || result.stderr;
      // handle memory
      const memorized = memorized_type.has(type)
      let action_memory = ""
      if (memorized && tool && tool.resolveMemory) {
        action_memory = tool.resolveMemory(action, content);
      }
      const meta = {
        action,
        action_memory,
        status: 'success'
      }
      await memory.addMessage('user', content, action.type, memorized, meta);
    }
    return memory;
  }

  /**
   * @param {Action} action 
   * @param {*} context 
   * @returns {Promise<ActionResult>}
   */
  async execute_action(action, context = {}, task_id) {
    const { type, params } = action;
    // æ ¹æ® action.type è°ƒç”¨å¯¹åº”çš„æ–¹æ³•
    console.log('action', action.type);
    const uuid = uuidv4();
    // action running message
    const tool = tools[type];
    if (tool && tool.getActionDescription) {
      const description = await tool.getActionDescription(params);
      const value = {
        uuid: uuid,
        content: description,
        status: 'running',
        meta: {
          task_id: task_id,
          action_type: type,
        },
        timestamp: new Date().valueOf()
      }
      const msg = Message.format({ uuid: uuid, status: 'running', content: description, action_type: type, task_id: task_id });
      // context.onTokenStream(msg)
      await this.callback(msg, context);
      Message.saveToDB(msg, context.conversation_id);
      await delay(500);
    }

    /**
     * @type {ActionResult}
     */
    let result;
    const dir_name = 'Conversation_' + context.conversation_id.slice(0, 6);
    switch (type) {
      case 'write_code':
        if (action.params.path) {
          action.params.origin_path = action.params.path;
          action.params.path = path.join(dir_name, action.params.path)
        }
        result = await this.write_code(action, uuid);
        break;
      case 'terminal_run':
        if (action.params.cwd) {
          action.params.origin_cwd = action.params.cwd;
          action.params.cwd = path.join(`user_${this.user_id}`, dir_name, action.params.cwd)
        } else {
          action.params.cwd = `./user_${this.user_id}/${dir_name}`
        }
        if (action.params.origin_cwd) {
          action.params.cwd = action.params.origin_cwd
        }
        result = await this._call_docker_action(action, uuid);
        break;
      case 'read_file':
        if (action.params.path) {
          action.params.path = path.join(dir_name, action.params.path)
        }
        result = await this.read_file(action, uuid);
        break;
      case 'browser':
        let model_info = await getDefaultModel(context.conversation_id)
        const llm_config = {
          model_name: model_info.model_name,
          api_url: model_info.base_url,
          api_key: model_info.api_key
        }
        // llm_config.api_url='http://host.docker.internal:3002/api/agent/v1'
        action.params.llm_config = llm_config
        action.params.conversation_id = context.conversation_id
        result = await this._call_docker_action(action, uuid)
        break;
      default:
        if (tool) {
          if (action.params.file_path) {
            action.params.file_path = path.join(__dirname, '../../workspace', `user_${this.user_id}`, dir_name, action.params.file_path)
          }
          console.log('DockerRuntime.execute_action.tool', tool.name, params);
          try {
            const execute = tool.execute;
            params.conversation_id = context.conversation_id
            const execute_result = await execute(params, uuid, context);
            console.log(`${tool.name}.call.result`, execute_result);
            // console.log('LocalRuntime.execute_action.tool.execute', execute_result);
            const { content, meta = {} } = execute_result;
            result = { uuid, status: 'success', content, memorized: tool.memorized || false, meta };
          } catch (error) {
            result = { status: 'failure', error: error.message, content: '', stderr: '' };
          }
        } else {
          result = { status: 'failure', error: `Unknown action type: ${type}`, content: '', stderr: '' };
        }
    }
    // ä¿å­˜ action æ‰§è¡Œç»“æœåˆ° memory
    console.log('DockerRuntime.execute_action', result);
    await this.handle_memory(result, action, context.memory);
    // å›è°ƒå¤„ç†
    let meta_url = ''
    let meta_json = []
    let meta_file_path = ''
    let meta_content = ''
    if (result.meta) {
      meta_url = result.meta.url || ''
      meta_json = result.meta.json || []
      meta_file_path = result.meta.filepath || ''
      meta_content = result.meta.content || ''
    }
    const msg = Message.format({ status: result.status, memorized: result.memorized || '', content: result.content || '', action_type: type, task_id: task_id, uuid: uuid || '', url: meta_url, json: meta_json, filepath: meta_file_path, meta_content: meta_content });
    await this.callback(msg, context);
    await Message.saveToDB(msg, context.conversation_id);
    return result;
  }

  async _call_docker_action(action, uuid) {
    const host = DOCKER_HOST_ADDR ? DOCKER_HOST_ADDR : 'localhost'
    const request = {
      method: 'POST',
      url: `http://${host}:${this.host_port}/execute_action`,
      data: { action: action, uuid: uuid },
    };
    const response = await axios(request);
    return response.data.data
  }

  /**
   * @param {Action} action
   * @returns {Promise<ActionResult>}
   */
  async write_code(action, uuid) {
    return util_write_code(action, uuid, this.user_id);
  }

  /**
   * @param {Action} action
   * @returns {Promise<ActionResult>}
   */
  async read_file(action) {
    let { path: filepath } = action.params;
    filepath = await restrictFilepath(filepath, this.user_id);

    try {
      const content = await read_file(filepath);
      return { status: 'success', content, error: "", meta: { filepath: filepath } };
    } catch (error) {
      return { status: 'failure', content: "", error: `Failed to read file ${filepath}: ${error.message}` };
    }
  }

  async callback(result, context = {}) {
    const { onTokenStream } = context;
    if (onTokenStream) {
      onTokenStream(result);
    }
  }
}

module.exports = DockerRuntime;


================================================
FILE: src/runtime/LocalRuntime.js
================================================
const fs = require('fs').promises;
const path = require('path');
const {write_code:util_write_code} = require('./utils/tools');
const tools = require("@src/tools/index.js");
const { v4: uuidv4 } = require("uuid");
const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

const Message = require('@src/utils/message');

const terminal_run = require('./terminal_run');
const read_file = require('./read_file');

const { restrictFilepath } = require('./runtime.util');

/**
 * @typedef {import('types/LocalRuntime').LocalRuntime} LocalRuntimeInterface
 * @typedef {import('types/LocalRuntime').Action} Action
 * @typedef {import('types/LocalRuntime').ActionResult} ActionResult
 * @typedef {import('types/LocalRuntime').Memory} Memory
 */

class LocalRuntime {

  /**
   * Create a local runtime instance
   * @param {Object} [options={}] - Configuration options
   * @param {Memory} options.memory - Memory management instance
   */
  constructor(options) {
    this.memory = null
  }

  async handle_memory(result, action, memory) {
    const type = action.type;
    const memorized_type = new Set(['read_file']);
    const { status, content, meta = {} } = result;
    if (status === 'success') {
      console.log('LocalRuntime.handle_memory.memory logging user prompt');
      const memorized = memorized_type.has(type) || (result.memorized || false);
      await memory.addMessage('user', content, type, memorized, meta);
    }
    return memory;
  }

  async callback(result, context = {}) {
    const { onTokenStream } = context;
    if (onTokenStream) {
      onTokenStream(result);
    }
  }

  /**
   * @param {Action} action 
   * @param {*} context 
   * @returns {Promise<ActionResult>}
   */
  async execute_action(action, context = {}, task_id) {
    const { type, params } = action;

    // Call the corresponding method based on action.type
    console.log('action', action.type);
    const uuid = uuidv4();

    // action running message
    const tool = tools[type];
    if (tool.getActionDescription) {
      const description = await tool.getActionDescription(params);
      const value = {
        uuid: uuid,
        content: description,
        status: 'running',
        meta: {
          task_id: task_id,
          action_type: type,
        },
        timestamp: new Date().valueOf()
      }
      const msg = Message.format({ uuid: uuid, status: 'running', content: description, action_type: type, task_id: task_id });
      context.onTokenStream(msg)
      await this.callback(msg, context);
      Message.saveToDB(msg, context.conversation_id);
      await delay(500);
    }

    /**
     * @type {ActionResult}
     */
    let result;
    switch (type) {
      case 'write_code':
        result = await this.write_code(action, uuid);
        break;
      case 'terminal_run':
        result = await terminal_run(action, uuid);
        break;
      case 'read_file':
        result = await this.read_file(action, uuid);
        break;
      default:
        if (tool) {
          console.log('LocalRuntime.execute_action.tool', tool.name, params);
          const execute = tool.execute;
          const execute_result = await execute(params);
          // console.log('LocalRuntime.execute_action.tool.execute', execute_result);
          const { content, meta = {} } = execute_result;
          result = { uuid, status: 'success', content, memorized: tool.memorized || false, meta };
        } else {
          result = { status: 'failure', error: `Unknown action type: ${type}`, content: '', stderr: '' };
        }
    }

    // Save action execution result to memory
    console.log('LocalRuntime.execute_action', result);
    await this.handle_memory(result, action, context.memory);
    // Callback processing
    let meta_url = ''
    let meta_json = []
    let meta_file_path = ''
    let meta_content = ''
    if (result.meta) {
      meta_url = result.meta.url || ''
      meta_json = result.meta.json || []
      meta_file_path = result.meta.filepath || ''
      meta_content = result.meta.content || ''
    }
    const msg = Message.format({ status: result.status, memorized: result.memorized || '', content: result.content || '', action_type: type, task_id: task_id, uuid: uuid || '', url: meta_url, json: meta_json, filepath: meta_file_path, meta_content: meta_content });
    await this.callback(msg, context);
    await Message.saveToDB(msg, context.conversation_id);
    return result;
  }

  /**
   * @param {Action} action
   * @returns {Promise<ActionResult>}
   */
  async write_code(action, uuid) {
    return util_write_code(action, uuid);
  }

  /**
   * @param {Action} action
   * @returns {Promise<ActionResult>}
   */
  async read_file(action, uuid) {
    let { path: filepath } = action.params;
    filepath = await restrictFilepath(filepath);

    try {
      const content = await read_file(filepath);
      return {
        uuid,
        status: 'success',
        content, error: "",
        meta: {
          action_type: action.type,
          filepath
        }
      };
    } catch (error) {
      return { status: 'failure', content: "", error: `Failed to read file ${filepath}: ${error.message}` };
    }
  }
}

module.exports = LocalRuntime;


================================================
FILE: src/runtime/LocalRuntime.test.js
================================================
require('module-alias/register');
require('dotenv').config();
const { params } = require('../agent/tools/browser_use');
const LocalRuntime = require('./LocalRuntime');
const LocalMemory = require('@src/agent/memory/LocalMemory');

const { resolveActions } = require("@src/utils/resolve");

const run = async () => {
  const memory = new LocalMemory({ taskId: 'demo' });
  const runtime = new LocalRuntime({ memory })
  // const content = `<terminal_run>
  // <cwd>.</cwd>
  // <command>ls</command>
  // <args></args>
  // </terminal_run>`
  // const content = "I will analyze the Excel file content and create a webpage to display the statistics of large model applications. First, I need to read the Excel file content, then generate the corresponding webpage code.\n\n<read_file>\n<path>LLM Large Model Dialogue Applications.xlsx</path>\n</read_file>\n\nPlease confirm if the Excel file content is correct, then I will continue to generate the webpage display code.";
  const content = `<terminal_run>
  <cwd>./</cwd>
  <command>ls</command>
  <args></args>
  </terminal_run>`
  // const content = `<terminal_run> <cwd>./</cwd> <command>nohup</command> <args>python3 -m http.server 8000 &</args> </terminal_run>`

  const actions = resolveActions(content);
  const action = actions[0];
  console.log(action);
  const r = await runtime.execute_action(action);
  console.log(r);
}

run();


================================================
FILE: src/runtime/read_file.js
================================================
const fs = require('fs').promises;
const path = require('path');
const xlsx = require('node-xlsx');

const { readXlsxOptimized } = require('./read_xlsx_optimized');

/**
 * Reads the content of a file asynchronously.
 * 
 * @param {string} filepath - The absolute or relative path to the file.
 * @returns {Promise<string>} A promise that resolves with the file content as a string or parsed data for xlsx files.
 * @throws {Error} If the file cannot be read (e.g., does not exist, permissions error).
 */
async function read_file(filepath) {
  try {
    // Resolve the path to ensure it's absolute if needed, though fs handles relative paths
    const absolute_path = path.resolve(filepath);
    // Basic file type detection based on extension
    const extension = path.extname(absolute_path).toLowerCase();
    console.log(`Reading file: ${absolute_path}, Type based on extension: ${extension}`);
    // xlsx file handling
    if (extension === '.xlsx') {
      // use node-xlsx to parse xlsx file and convert to markdown
      const result = readXlsxOptimized(absolute_path);
      return result.content;
    } else {
      // try reading as utf8
      const content = await fs.readFile(absolute_path, 'utf8');
      return content;
    }
  } catch (error) {
    console.error(`Error reading file at ${filepath}:`, error);
    throw new Error(`Failed to read file: ${error.message}`);
  }
}

module.exports = read_file;


================================================
FILE: src/runtime/read_xlsx_optimized.js
================================================
const fs = require('fs');
const xlsx = require('node-xlsx');

/**
 * å°† xlsx æ•°æ®è½¬æ¢ä¸º markdown æ ¼å¼
 * @param {Array} list - xlsx æ–‡ä»¶çš„æ•°æ®
 * @returns {string} markdown æ ¼å¼çš„æ•°æ®
 */
const xlsxToMarkdown = (list) => {
  if (!list || list.length === 0) return '';
  // 1. è·å–è¡¨å¤´
  const headers = list[0];
  // 2. ç”Ÿæˆåˆ†éš”ç¬¦
  const separator = headers.map(() => '---').join('|');
  // 3. ç”Ÿæˆè¡¨æ ¼å¤´éƒ¨
  let markdown = `|${headers.join('|')}|\n|${separator}|\n`;
  // 4. ç”Ÿæˆè¡¨æ ¼è¡Œ
  for (let i = 1; i < list.length; i++) {
    markdown += `|${list[i].join('|')}|\n`;
  }
  return markdown;
};

/**
 * ä¼˜åŒ–çš„ XLSX æ–‡ä»¶è¯»å–å™¨
 * æ”¯æŒå¤§æ–‡ä»¶å¤„ç†ï¼Œå½“å†…å®¹è¶…è¿‡æŒ‡å®šå­—ç¬¦æ•°æˆ–è¡Œæ•°æ—¶è¿”å›æ‘˜è¦
 */
class OptimizedXlsxReader {
  constructor(maxChars = 10000, maxRows = 30) {
    this.maxChars = maxChars;
    this.maxRows = maxRows;
  }

  /**
   * è¿‡æ»¤ç©ºè¡Œæ•°æ®
   * @param {Array} data - åŸå§‹æ•°æ®æ•°ç»„
   * @returns {Array} è¿‡æ»¤åçš„æ•°æ®æ•°ç»„
   */
  filterEmptyRows(data) {
    if (!data || data.length === 0) return [];

    const filteredData = [];
    for (const row of data) {
      // æ£€æŸ¥è¡Œæ˜¯å¦ä¸ºç©ºï¼ˆæ‰€æœ‰å•å…ƒæ ¼éƒ½ä¸ºç©ºã€nullã€undefinedæˆ–ç©ºå­—ç¬¦ä¸²ï¼‰
      const hasContent = row.some(cell => {
        return cell !== null && cell !== undefined && cell !== '';
      });

      if (hasContent) {
        filteredData.push(row);
      }
    }

    return filteredData;
  }

  /**
   * è¯»å– XLSX æ–‡ä»¶
   * @param {string} filePath - æ–‡ä»¶è·¯å¾„
   * @returns {Object} åŒ…å«å†…å®¹ã€æ˜¯å¦æˆªæ–­ã€ç»Ÿè®¡ä¿¡æ¯çš„å¯¹è±¡
   */
  readXlsxFile(filePath) {
    try {
      // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
      if (!fs.existsSync(filePath)) {
        throw new Error(`æ–‡ä»¶ä¸å­˜åœ¨: ${filePath}`);
      }

      // ä½¿ç”¨ node-xlsx è§£ææ–‡ä»¶
      const sheets = xlsx.parse(filePath);

      const result = {
        content: '',
        isTruncated: false,
        totalSheets: sheets.length,
        totalRows: 0,
        dataStructure: {},
        customMessage: ''
      };

      let fullContent = '';
      let totalRowCount = 0;

      // éå†æ‰€æœ‰å·¥ä½œè¡¨
      for (const sheet of sheets) {
        const { name, data } = sheet;

        // è¿‡æ»¤ç©ºè¡Œï¼Œè·å–å®é™…æœ‰æ•ˆæ•°æ®
        const filteredData = this.filterEmptyRows(data);
        const actualRowCount = filteredData.length;
        totalRowCount += actualRowCount;

        // åˆ†ææ•°æ®ç»“æ„ï¼ˆä½¿ç”¨è¿‡æ»¤åçš„æ•°æ®ï¼‰
        if (actualRowCount > 0) {
          result.dataStructure[name] = {
            rows: actualRowCount,
            columns: filteredData[0] ? filteredData[0].length : 0,
            headers: filteredData[0] || [],
            sampleData: filteredData.slice(0, 3) // å‰3è¡Œä½œä¸ºæ ·æœ¬
          };
        } else {
          // å¦‚æœæ²¡æœ‰æœ‰æ•ˆæ•°æ®ï¼Œä»ç„¶è®°å½•ç»“æ„ä¿¡æ¯
          result.dataStructure[name] = {
            rows: 0,
            columns: 0,
            headers: [],
            sampleData: []
          };
        }

        // æ£€æŸ¥æ˜¯å¦éœ€è¦é™åˆ¶è¡Œæ•°
        let processedData = filteredData;
        if (actualRowCount > this.maxRows) {
          // å¦‚æœæ•°æ®è¡Œæ•°è¶…è¿‡é™åˆ¶ï¼Œåªå–å‰maxRowsè¡Œ
          processedData = filteredData.slice(0, this.maxRows);
        }

        // ä½¿ç”¨åŸæœ‰çš„ markdown è½¬æ¢é€»è¾‘
        const markdown = xlsxToMarkdown(processedData);
        const markdownWithSheetName = `### Sheet: ${name}\n${markdown}`;
        fullContent += markdownWithSheetName + '\n\n';
      }

      result.totalRows = totalRowCount;

      // æ£€æŸ¥æ˜¯å¦éœ€è¦æˆªæ–­ï¼ˆåŸºäºå­—ç¬¦æ•°æˆ–è¡Œæ•°é™åˆ¶ï¼‰
      const shouldTruncate = fullContent.length > this.maxChars || totalRowCount > this.maxRows;

      if (!shouldTruncate) {
        // å†…å®¹æœªè¶…è¿‡é™åˆ¶ï¼Œè¿”å›å®Œæ•´å†…å®¹
        result.content = fullContent;
        result.isTruncated = false;
      } else {
        // å†…å®¹è¶…è¿‡é™åˆ¶ï¼Œè¿”å›æ‘˜è¦
        result.content = this.generateSummary(sheets, result.dataStructure);
        result.isTruncated = true;
        result.customMessage = this.getCustomMessage(result.totalSheets, result.totalRows);
      }

      return result;

    } catch (error) {
      throw new Error(`è¯»å– XLSX æ–‡ä»¶å¤±è´¥: ${error.message}`);
    }
  }

  /**
   * ç”Ÿæˆæ•°æ®æ‘˜è¦
   * @param {Array} sheets - å·¥ä½œè¡¨æ•°ç»„
   * @param {Object} dataStructure - æ•°æ®ç»“æ„ä¿¡æ¯
   * @returns {string} æ‘˜è¦å†…å®¹
   */
  generateSummary(sheets, dataStructure) {
    let summary = '=== XLSX æ–‡ä»¶æ•°æ®æ‘˜è¦ ===\n\n';

    // æ·»åŠ æ–‡ä»¶åŸºæœ¬ä¿¡æ¯å’Œå„å·¥ä½œè¡¨è¡Œæ•°æ¦‚è§ˆ
    summary += `æ–‡ä»¶åŒ…å« ${sheets.length} ä¸ªå·¥ä½œè¡¨ï¼Œå„å·¥ä½œè¡¨æ•°æ®è¡Œæ•°å¦‚ä¸‹ï¼š\n`;
    for (const sheet of sheets) {
      const { name } = sheet;
      const structure = dataStructure[name];
      if (structure) {
        summary += `- ${name}: ${structure.rows} è¡Œ\n`;
      }
    }
    summary += '\n';

    // éå†æ¯ä¸ªå·¥ä½œè¡¨ç”Ÿæˆè¯¦ç»†æ‘˜è¦
    for (const sheet of sheets) {
      const { name, data } = sheet;
      const structure = dataStructure[name];

      if (!structure) continue;

      summary += `--- å·¥ä½œè¡¨: ${name} (${structure.rows} è¡Œæ•°æ®) ---\n`;
      summary += `åˆ—æ•°: ${structure.columns}\n`;

      // æ·»åŠ è¡¨å¤´ä¿¡æ¯
      if (structure.headers && structure.headers.length > 0) {
        summary += `è¡¨å¤´: `;
        for (const header of structure.headers) {
          if (header !== undefined && header !== null) {
            summary += `${header} | `;
          }
        }
        summary += '\n';
      }

      // æ·»åŠ æ ·æœ¬æ•°æ® (å‰3è¡Œ)
      summary += `æ ·æœ¬æ•°æ® (å‰3è¡Œ):\n`;
      for (const sampleRow of structure.sampleData) {
        let rowContent = '';
        for (const cell of sampleRow) {
          if (cell !== undefined && cell !== null) {
            rowContent += `${cell} | `;
          } else {
            rowContent += ' | ';
          }
        }
        summary += rowContent + '\n';
      }
      summary += '\n';
    }

    return summary;
  }

  /**
   * è·å–è‡ªå®šä¹‰æç¤ºæ¶ˆæ¯
   * @param {number} totalSheets - æ€»å·¥ä½œè¡¨æ•°
   * @param {number} totalRows - æ€»è¡Œæ•°
   * @returns {string} è‡ªå®šä¹‰æ¶ˆæ¯
   */
  getCustomMessage(totalSheets, totalRows) {
    return `
æ•°æ®é‡è¾ƒå¤§ï¼Œå·²è¿”å›æ‘˜è¦ä¿¡æ¯ã€‚
- æ€»å·¥ä½œè¡¨æ•°: ${totalSheets}
- æ€»æ•°æ®è¡Œæ•°: ${totalRows}

å»ºè®®ï¼š
1. æ ¹æ®è¡¨å¤´ä¿¡æ¯ç¡®å®šæ•°æ®å­—æ®µå«ä¹‰
2. åŸºäºä¸Šè¿°æ•°æ®ç»“æ„ç¼–å†™ä»£ç è¿›è¡Œæ•°æ®å¤„ç†
`.trim();
  }

  /**
   * è®¾ç½®æœ€å¤§å­—ç¬¦æ•°é™åˆ¶
   * @param {number} maxChars - æœ€å¤§å­—ç¬¦æ•°
   */
  setMaxChars(maxChars) {
    this.maxChars = maxChars;
  }

  /**
   * è®¾ç½®æœ€å¤§è¡Œæ•°é™åˆ¶
   * @param {number} maxRows - æœ€å¤§è¡Œæ•°
   */
  setMaxRows(maxRows) {
    this.maxRows = maxRows;
  }

  /**
   * è·å–å½“å‰æœ€å¤§å­—ç¬¦æ•°é™åˆ¶
   * @returns {number} æœ€å¤§å­—ç¬¦æ•°
   */
  getMaxChars() {
    return this.maxChars;
  }

  /**
   * è·å–å½“å‰æœ€å¤§è¡Œæ•°é™åˆ¶
   * @returns {number} æœ€å¤§è¡Œæ•°
   */
  getMaxRows() {
    return this.maxRows;
  }
}

/**
 * ä¾¿æ·å‡½æ•°ï¼šè¯»å– XLSX æ–‡ä»¶
 * @param {string} filePath - æ–‡ä»¶è·¯å¾„
 * @param {number} maxChars - æœ€å¤§å­—ç¬¦æ•°é™åˆ¶ï¼Œé»˜è®¤ 10000
 * @param {number} maxRows - æœ€å¤§è¡Œæ•°é™åˆ¶ï¼Œé»˜è®¤ 30
 * @returns {Object} è¯»å–ç»“æœ
 */
function readXlsxOptimized(filePath, maxChars = 10000, maxRows = 30) {
  const reader = new OptimizedXlsxReader(maxChars, maxRows);
  return reader.readXlsxFile(filePath);
}

module.exports = {
  OptimizedXlsxReader,
  readXlsxOptimized,
  xlsxToMarkdown
};



================================================
FILE: src/runtime/runtime.util.js
================================================
const path = require('path');

const { getDirpath } = require('./utils/electron');
const resolveWorkspaceDir = async (user_id) => {
  const WORKSPACE_DIR = getDirpath(process.env.WORKSPACE_DIR || 'workspace', user_id);
  return WORKSPACE_DIR;
}

/**
 * restrict filepath to workspace dir
 * @param {string} filepath 
 * @returns {Promise<string>}
 */
const restrictFilepath = async (filepath, user_id) => {
  const workspace_dir = await resolveWorkspaceDir(user_id);

  const resolvedPath = path.resolve(filepath);
  const resolvedWorkspace = path.resolve(workspace_dir);
  if (resolvedPath.startsWith(resolvedWorkspace)) {
    filepath = resolvedPath;
  } else {
    filepath = path.resolve(workspace_dir, filepath);
  }
  return filepath;
}

module.exports = {
  resolveWorkspaceDir,
  restrictFilepath
}


================================================
FILE: src/runtime/terminal_run.js
================================================
const { exec, spawn } = require('child_process');
const { restrictFilepath } = require('./runtime.util');

const runCommand = (command, args, cwd) => {
  return new Promise((resolve, reject) => {
    if (Array.isArray(args)) {
      args = args.join(' ');
    }
    const fullCommand = `${command} ${args}`;
    console.log('fullCommand', fullCommand, 'cwd', cwd);

    // Handle nohup command
    if (command.includes('nohup')) {
      // Use shell to execute nohup command
      const child = spawn('sh', ['-c', fullCommand], {
        cwd,
        detached: true,
        stdio: ['ignore', 'ignore', 'ignore'] // Ignore all standard input output
      });
      child.unref(); // Allow parent process to exit independently of child process
      resolve({
        stdout: `Background process started, PID: ${child.pid}, output redirected to nohup.out`,
        stderr: ''
      });
    } else {
      exec(fullCommand, { cwd }, (error, stdout, stderr) => {
        if (error) {
          reject({ error: error.message, stderr });
          return;
        }
        resolve({ stdout, stderr });
      });
    }
  });
}

const terminal_run = async (action, uuid) => {
  const { command, args = [], cwd = '.' } = action.params;
  const executionDir = await restrictFilepath(cwd);
  try {
    const result = await runCommand(command, args, executionDir);
    return {
      uuid,
      status: 'success',
      content: result.stdout || 'Execution result has no return content',
      stderr: result.stderr,
      meta: {
        action_type: action.type,
      }
    };
  } catch (e) {
    console.error('Error executing command:', e);
    return { status: 'failure', error: e.stderr || e.message, content: '' };
  }
}

module.exports = terminal_run;




================================================
FILE: src/runtime/plugins/browser/index.js
================================================
[Binary file]


================================================
FILE: src/runtime/plugins/vscode/index.js
================================================
[Binary file]


================================================
FILE: src/runtime/plugins/vscode/settings.json
================================================
{
    "workbench.colorTheme": "Default Dark Modern",
    "workbench.startupEditor": "none"
}



================================================
FILE: src/runtime/utils/electron.js
================================================
// const { app } = require('electron');
const resolve = require('path').resolve;
const resourcesPath = process.resourcesPath;
console.log('LEMON_AI_PATH', process.env.LEMON_AI_PATH);
const LEMON_AI_PATH = process.env.LEMON_AI_PATH;

const getFilepath = (dir = 'database', filename) => {

  let filepath = resolve(__dirname, '../../../', dir, filename);
  if (resourcesPath && resourcesPath.indexOf('node_modules') === -1) {
    filepath = resolve(resourcesPath, dir, filename);
  }

  if (LEMON_AI_PATH) {
    filepath = resolve(LEMON_AI_PATH, dir, filename);
  }
  console.log('filepath', filepath);
  return filepath;
}


//å¤„ç†æ–‡ä»¶å¤¹è·¯å¾„
const getDirpath = (dir, user_id) => {

  let filepath = resolve(__dirname, '../../../', dir);
  if (process.env.ACTUAL_HOST_WORKSPACE_PATH) {
    filepath = resolve(__dirname, '../../../../', dir);
  }
  if (user_id) {
    filepath = resolve(filepath, `user_${user_id}`)
  }
  if (resourcesPath && resourcesPath.indexOf('node_modules') === -1) {
    filepath = resolve(resourcesPath, dir);
  }

  if (LEMON_AI_PATH) {
    filepath = resolve(LEMON_AI_PATH, dir);
  }
  return filepath;
}

module.exports = exports = {
  getFilepath,
  getDirpath
}


================================================
FILE: src/runtime/utils/system.js
================================================
const net = require('net');

async function find_available_tcp_port(min_port = 30000, max_port = 39999, max_attempts = 10) {

  /**
  Find an available TCP port in a specified range.

  Args:
      min_port (int): The lower bound of the port range (default: 30000)
      max_port (int): The upper bound of the port range (default: 39999)
      max_attempts (int): Maximum number of attempts to find an available port (default: 10)

  Returns:
      int: An available port number, or -1 if none found after max_attempts
  
   */
  let port = Math.floor(Math.random() * (max_port - min_port + 1)) + min_port;
  let attempts = 0;
  while (attempts < max_attempts) {
    return new Promise((resolve, reject) => {
      const server = net.createServer();
      server.listen(port, () => {
        server.close(() => resolve(port));
      });
      server.on('error', () => {
        attempts++;
        if (attempts === max_attempts) {
          resolve(-1);
        } else {
          port = Math.floor(Math.random() * (max_port - min_port + 1)) + min_port;
        }
      });
    });
  }
}

module.exports = {
  find_available_tcp_port
};


================================================
FILE: src/runtime/utils/tools.js
================================================
const { restrictFilepath } = require('../runtime.util');
const fs = require('fs').promises;;
const path = require('path');

const write_file = async (filepath, content) => {
  // Ensure the directory exists
  const dir = path.dirname(filepath);
  try {
    await fs.mkdir(dir, { recursive: true });
  } catch (err) {
    if (err.code !== 'EXIST') {
      throw err;
    }
  }
  return fs.writeFile(filepath, content);
}

const write_code = async (action, uuid, user_id) => {
  let { path: filepath, content } = action.params;
  filepath = await restrictFilepath(filepath, user_id);
  await write_file(filepath, content);
  // const result = await executeCode(filepath);
  // return result;
  return {
    uuid,
    status: 'success',
    content: `File ${filepath} written successfully.`,
    meta: {
      action_type: action.type,
      filepath
    }
  };
}

module.exports = {
  write_code
};


================================================
FILE: src/swagger/swagger.js
================================================
const router = require('koa-router')() // Import router function   
const swaggerJSDoc = require('swagger-jsdoc')
const path = require('path')
const swaggerDefinition = {
    openapi: '3.0.0',
    info: {
        title: 'chataa',
        version: '1.0.0',
        description: 'API',
    },
};
const options = {
    swaggerDefinition,
    apis: [path.join(__dirname, '../routers/*/*.js')], // Write the address where the router with annotations is stored, best path.join()
};
const swaggerSpec = swaggerJSDoc(options)
// Get the generated annotations file through the router
router.get('/swagger.json', async function (ctx) {
    ctx.set('Content-Type', 'application/json');
    ctx.body = swaggerSpec;
})
module.exports = router


================================================
FILE: src/template/core_principle.dynamic.txt
================================================
[Binary file]


================================================
FILE: src/template/core_principle.static.txt
================================================
**Your Core Principle**: Before planning any step, you MUST first consult the `=== Best Practices Memory ===` section. These are the highest priority guidelines set by the user. You must strictly adhere to these practices, even if they differ from your general knowledge. **Please pay special attention: Requirements within `Best Practices Memory` regarding the "final deliverable format" (e.g., HTML mimicking PDF layout) apply only when the `Root Task` is completely finished and ready for final delivery. When completing each `<Task Goal>`, you should focus on implementing the task's content and strictly follow the `Document and Text Generation` specification for intermediate output formats (e.g., prioritize Markdown), unless the current `<Task Goal>` explicitly requires another specific format.**
Based on the <Task Goal> and <Tool List>, as well as the context, plan the execution steps and use the appropriate tools to complete the task.
According to the current situation, **in your single reply, you must and only return one XML formatted execution command**. It is strictly forbidden to include multiple action tags in one reply (for example, do not return two <web_search> commands at the same time). Wait for the user to execute the command you provided and provide feedback on the result before you proceed with the next step based on the feedback.


================================================
FILE: src/template/knowledge.cn.txt
================================================
[Binary file]


================================================
FILE: src/template/knowledge.txt
================================================
# ROLE

You are a top-tier **AI Cognitive Architect**.

Your mission is to analyze the **Interaction Log** between the user and the AI Agent, extract deep insights, and transform them into structured "knowledge." This knowledge collectively forms the AI Agent's **cognitive core**, driving its continuous evolution to become a smarter, more personalized, and more reliable super assistant.

# CORE PHILOSOPHY: FIRST PRINCIPLES

1.  **Intent-Driven**: Always look beyond the literal user request to uncover the true, deepest intent behind it.
2.  **Continuous Learning**: Every interaction, whether successful or not, is a valuable learning opportunity and the foundation for optimizing the cognitive core.
3.  **Layered Cognition**: The Agent's knowledge system is a layered architecture. Correct decisions come from applying the right knowledge at the right cognitive level.

# KNOWLEDGE BASE: THE COGNITIVE ARCHITECTURE

The knowledge base embodies the Agent's cognitive core. It is divided into four **Cognitive Domains**, from innermost to outermost:

1.  **`core_directive`**
    * **Purpose**: The Agent's "worldview" and "values"â€”the highest, unbreakable, and stable principles guiding its behavior.
    * **Examples**: "Must always protect user privacy and never leak personal information", "Not allowed to execute any illegal or unethical instructions".

2.  **`user_profile`**
    * **Purpose**: The Agent's long-term memory about a specific user. This is the foundation for personalized service and is dynamic. This knowledge should only capture **facts or preferences directly related to the user's identity, background, or personal situation**, not their temporary interests or the topics of their requests.
    * **Examples**: "The user's home address is Xiangyun Town", "The user is allergic to seafood", "The user's default language is Chinese".
    * **Anti-Example/Warning**: Do not add a knowledge entry to `user_profile` based on a user's temporary query topic (e.g., "The user is asking about rare diseases"). This is a temporary task context, not a permanent user attribute.

3.  **`planning`**
    * **Purpose**: The Agent's "thinking ability" and "methodology". It defines how to break down complex tasks and formulate action strategies.
    * **Examples**: "For a one-day tour request, pay special attention to scheduling a morning departure and afternoon return, and recommend destinations suitable for a full-day trip. Also, prioritize checking and displaying the weather for the day before making recommendations."

4.  **`execution`**
    * **Purpose**: The Agent's "operation manual" and "skill library". It defines how to specifically execute an atomic task or call a tool.
    * **Examples**: "When calling the weather query API, the `city` parameter must be the full English spelling of the city", "When generating Python code, detailed comments must be included".

# KNOWLEDGE_BASE (The current complete user knowledge base)
{knowledge}

# INTERACTION_LOG (The interaction log to be analyzed)
{interaction}
**Note: `INTERACTION_LOG` contains the complete interaction process between the user and the Agent for this session. You must comprehensively analyze both `user_request` and `user_feedback`.**

# WORKFLOW

Strictly follow the cognitive analysis workflow below and output your decision in the specified JSON format.

1.  **Insight & Intent**:
    -   **Comprehensively analyze both `user_request` and `user_feedback` in the `INTERACTION_LOG`.**
    -   **Critical Rule**: If the user's interaction is a simple query (e.g., asking for information, a direct instruction, or a basic conversational greeting) that does not contain new, actionable information for the Agent to learn, then the cognitive analysis should conclude that no new knowledge needs to be added, modified, or deleted. The goal is to learn, not to record every single interaction.
    -   **Processing `user_request` (original request):**
        * Identify information explicitly mentioned by the user that can be included as **facts, preferences, or background information** in `user_profile`, or as **specific task constraints** in `planning`.
        * **Do NOT** infer general planning principles or operational rules from the `user_request` alone. A single request like 'ä½ æ˜¯è°' does not constitute a learning event unless it's a correction to a previous, incorrect answer by the Agent.
    -   **Processing `user_feedback`:**
        * **Crucially**, identify explicit corrections, dissatisfaction, new requirements, or clear information that the Agent needs to learn, as provided by the user in response to the Agent's previous output.
        * User feedback is the **primary trigger** for updating or revising the Agent's `core_directive`, `planning`, or `execution` knowledge. **If there is no `user_feedback` in the log, only consider adding to `user_profile` based on the original request, or conclude with `NO_ACTION`.**
    -   **Priority:** User feedback (`user_feedback`) takes precedence over the original request (`user_request`) when it comes to correcting Agent behavior or principles.

2.  **Categorize to Cognitive Domain**:
    -   Clearly map the analyzed user intent to one of the four cognitive domains above.

3.  **Decide Action**:
    -   Based on your analysis, choose the most appropriate action from [`ADD`, `MODIFY`, `DELETE`, `NO_ACTION`].
    -   **Only perform `ADD`, `MODIFY`, or `DELETE` if you identify new, actionable information that the Agent needs to learn, record, correct, or adjust to improve its future behavior.**
    -   **Otherwise, perform `NO_ACTION`**. This action is for cases where the user's interaction does not provide any new insights or correct existing Agent behavior.
    -   Use `ADD` if the information does not already exist in the knowledge base.
    -   Use `MODIFY` if existing knowledge needs to be updated (provide `target_knowledge_id`).
    -   Use `DELETE` if existing knowledge needs to be removed (provide `target_knowledge_id`).

4.  **Generate Knowledge Entry**:
    -   Construct the final JSON output. `new_knowledge` must be a **universal, concise, and actionable** principle.
    -   **IMPORTANT: All knowledge entries must be written in English only. Never use Chinese or any other language.**
    -   Ensure the generated knowledge entry is specific, useful, and can directly guide the Agent's future behavior.

# OUTPUT_FORMAT (Strictly follow this JSON structure)
Output a JSON object containing the following fields:
-   `reasoning`: (string) A detailed explanation of your decision, reflecting your thought process.
-   `operations`: (array) A list of operation instructions. Each operation object includes:
    -   `action`: (string) "ADD", "MODIFY", "DELETE", or "NO_ACTION".
    -   `category`: (string) "core_directive", "user_profile", "planning", or "execution".
    -   `target_knowledge_id`: (string, required only for MODIFY or DELETE) The id of the knowledge to operate on.
    -   `new_knowledge`: (string, required only for ADD or MODIFY) The full text of the new or modified knowledge entry.


================================================
FILE: src/template/planning.search.cn.txt
================================================
[Binary file]


================================================
FILE: src/template/planning.search.txt
================================================
# Role & Goal

You will act as a world-class expert in Information Research and Search Strategy.
Your core mission is to analyze the [User Requirement] and design a detailed, actionable plan for gathering information through searches, API calls, and file reading.
**Important**: As a research planning expert, your role is limited to creating the information gathering plan. You **do not perform any of the searches or data collection** listed in the plan. The final plan will be handed off to another agent for execution.
Please pay attention to [Uploaded files]
if [Previous Result] is not empty, continue with previous result to complete the goal.

**Important**: The output language must be consistent with the [User Requirement] language:
If [User Requirement] is in Chinese, then the output language must be in Chinese.
If [User Requirement] is in English, then the output language must be in English.

# Core Guiding Principle: The Ultimate Authority
**Absolute Rule:** The provided `best_practice_knowledge` is the highest priority directive. It represents the ultimate source of truth and strategic direction for this task. You must follow it unconditionally.
- **Execute Only Search-Related Operations**: Strictly plan according to the search sources and search strategies specified in `best_practice_knowledge`.
- **Ignore Non-Search Operations**: If `best_practice_knowledge` contains code modification, implementation, creation, or other non-information gathering operations, completely ignore those parts.
- Focus on Information Collection: Only focus on search, query, and read tasks to obtain information from specified sources.

# [Constraints]
- Focus only on information gathering activities. Do not include implementation, testing, or deployment tasks.
- Prioritize existing data sources (files, databases, APIs) before external searches.
- Consider rate limits and API quotas when planning multiple API calls.
- Pay attention to data privacy and access permissions when planning file access.

==== Current System Environment ===
{system}
====

# Efficient Information Acquisition Principles

1.  **Direct Acquisition Strategy:** Prioritize the most direct ways to obtain information, avoiding unnecessary intermediate steps.
2.  **Concise and Efficient:** Generate simple search plans for simple queries; use phased strategies for complex requirements.
3.  **Practical Orientation:**
- **Immediacy:** Prioritize search methods that can get results immediately (web search, existing APIs, etc.)
- **Directness:** Search for target information directly, not how to search first
- **Result-Oriented:** Every search task should directly produce useful information
4.  **Search Priority:**
- First priority: Direct web search for information
- Second priority: Direct calls to existing APIs
- Third priority: Query documentation then call APIs
5.  **Avoid Over-Planning:** Don't break down simple information queries into too many unnecessary steps.
{experiencePrompt}

# Workflow

You must strictly follow the process below:
**Part 1: Internal Analysis Process (Not to be displayed in the final output)**

1.  **Extract Search Strategy:** Extract all guidance related to search, query, and read operations from `best_practice_knowledge`, ignoring any code modification or implementation instructions.
2.  **Identify Specified Search Sources:** Strictly plan according to the information sources specified in `best_practice_knowledge` (file paths, API endpoints, database queries, etc.).
3.  **Define Search Objectives:** Based on [User Requirement] and the search strategies in `best_practice_knowledge`, clarify the specific information needed from each source.
4.  **Plan Search Sequence:** Arrange the execution order of search tasks according to the priorities and dependencies in `best_practice_knowledge`.

**Part 2: Search Planning & Output Generation**

1.  **Create Main Tasks:** Based on user requirements, identify the main information collection tasks that need to be performed.
2.  **List Specific Objectives:** For each task, list the specific information objectives that need to be obtained, clearly specifying the required output format and content.
3.  **Strictly Limit to Search Operations:** All tasks must be strictly limited to searching, querying, reading, and extracting information. Even if `best_practice_knowledge` contains other operations, ignore them and focus only on the information collection portions.
4.  **Strictly adhere to the output format:** This is the most critical rule. Your final response must contain only the content composed of "phases" and "task lists" as defined in the OUTPUT FORMAT. Do not add any introductions, explanations, summaries, or additional text.
5.  Include all information sources needed to address the main requirement comprehensively.

**Part3: Efficient Search Strategies:**
- Simple queries: Direct web search for information
- Data queries: Prioritize existing APIs, query API documentation first if needed then call
- File queries: Direct file reading
- Complex queries: Use phased approach but avoid over-segmentation

**Part4: Planning Requirements:**
- Aim for maximum information with minimum steps
- Each task must produce actually usable information
- Avoid "searching for the sake of searching" ineffective steps
- Prioritize core information that users care about most

# OUTPUT FORMAT

**ã€Absolute Ruleã€‘** Your response must strictly begin and end with this format. No text is allowed outside of this format.
## [Task Name]
- [Specific Objective 1]
- [Specific Objective 2]
- [Specific Objective 3]
- Output: [Final specific content and format to be output]

**Example:**
## JD Stock Information Query
- Obtain JD stock symbol
- Get current stock price and change percentage
- Get today's opening, highest, and lowest prices
- Get trading volume data
- Output: JD.com (JD) Current Price $XX.XX Change +/-X.X% Open $XX.XX High $XX.XX Low $XX.XX Volume XXX million shares

[Previous results]
{previous}

# INPUTS

[Uploaded files]
{files}

[Best Practice Knowledge]
{best_practice_knowledge}

[User Requirement]
{goal}



================================================
FILE: src/template/planning.txt
================================================
# Role & Goal

You will act as a world-class expert in Strategic Planning and Project Management (PM).
Your core mission is to analyze the [User Requirement], design a detailed, actionable, and lean task plan.
**Important**: As a planning expert, your role is limited to creating the plan. You **do not perform any of the tasks** listed in the plan, including the final delivery. The final plan will be handed off to another agent for execution.
Please pay attention to [Uploaded files]
if [Previous Result] is not empty, continue with previous result to complete the goal.

**Important**: The output language must be consistent with the [User Requirement] language:
If [User Requirement] is in Chinese, then the output language must be in Chinese.
If [User Requirement] is in English, then the output language must be in English.

# Core Guiding Principle: The Ultimate Authority
**Absolute Rule:** The provided `best_practice_knowledge` is the highest priority directive. It represents the ultimate source of truth and strategic direction for this task. You must follow it unconditionally.
- If any part of the `best_practice_knowledge` conflicts with the "General Action Principles" below, the `best_practice_knowledge` **always** prevails.
- The "General Action Principles" are to be used as supplementary guidelines only when the `best_practice_knowledge` does not provide specific instructions on a matter.

---
**[Critical Non-Interruptible Override Rule]**
**Since this Agent is non-interruptible and cannot receive real-time user feedback, you must perform the following actions:**
1. **Ignore** all steps in the `best_practice_knowledge` that require **asking, consulting, waiting for user feedback, or waiting for user input**.
2. When a design parameter requiring user input is encountered, you must **immediately substitute** the missing information by **making the most reasonable, contextually optimal assumption** based on the overall `best_practice_knowledge` and the specific [User Requirement]. **This assumption must be made explicit and visible within the description of the relevant task.**
---

# [Constraints]
- **CRITICAL EXECUTION CONSTRAINT:** All scripts and programs planned for execution *must* be **non-interactive** and designed to **terminate automatically**. The Executor Agent *cannot* handle user input, interactive prompts (like REPLs), or persistent processes (like web servers). Do not plan any task that requires real-time user interaction. **If the user asks for an interactive program, you MUST make a reasonable assumption to create a non-interactive version** (e.g., taking input from command-line arguments or a file).
- Validation testing cannot be performed at this time. Please do not add a testing and validation process in the final stage, and do not perform deployment.
- **Planning for HTML:** If the goal requires HTML generation, the plan must consolidate this into **one single, comprehensive task** for the *executing agent*. The planner itself MUST NOT generate any HTML code.
- **The final plan MUST only utilize the tools and capabilities available in the [Executor Capabilities].**

==== Current System Environment ===
{system}
====

# General Action Principles

1.  **Begin with the End in Mind:** The final deliverable is the sole objective of all tasks.
2.  **MECE (Mutually Exclusive, Collectively Exhaustive):** Ensure the task breakdown has no omissions and no overlaps.
3.  **Lean Execution:** Plan only the essential tasks required to deliver core value, eliminating all unnecessary steps. **In case of conflict, Lean Execution (Principle 3) takes absolute priority over MECE (Principle 2).**
4.  **Content Requirements:**
- **Specificity:** Every task must be a concrete, executable action.
- **Completeness:** Cover the entire process from start to finish.
- **Logicality:** Arrange tasks in a logical execution sequence.
- **Measurability:** Task descriptions must be clear to easily determine their completion status.
5.  **Adaptive Principle:** You should automatically adjust the granularity of task decomposition according to the complexity of the User Requirement. For simple and clear requirements, a highly summarized plan should be provided.
{experiencePrompt}

# Workflow

You must strictly follow the process below:
**Part 1: Internal Thought Process (Not to be displayed in the final output)**

1.  **Internalize the Core Guiding Principle:** Before any other analysis, first, thoroughly study and fully comprehend the `best_practice_knowledge`. This knowledge must act as the primary lens and filter through which you view the user's requirement and construct the entire plan.
2.  **Analyze Executor Capabilities: Review the [Executor Capabilities] list to understand the exact tools the executor can use. The subsequent plan must be strictly limited to these capabilities.**
3.  **Analyze & Define Objectives (O & KRs):** Based on the Core Guiding Principle and the [User Requirement], distill a clear Objective and measurable Key Results. This OKR structure is your internal logical backbone and **must never appear in the final output**.
4.  **Identify Dependencies & Milestones:** Internally identify critical task dependencies and project milestones, ensuring they align with the strategy dictated by the `best_practice_knowledge`.
5.  **Anticipate Risks & Constraints:** Based on the [Constraints] and common sense, briefly consider potential risks. Implicitly incorporate mitigation steps into the task planning.

**Part 2: Execution Planning & Output Generation**

1.  **Decompose into Phases:** Based on your internal OKR concept, break down the entire project from beginning to end into several logically coherent **Phases**. These phases will become the ## headings in the output.
2.  **Create Actionable Tasks:** Under each phase, list specific to-do items that start with a verb. **(Ensure tasks describe the 'goal' or 'what', not the 'how' or specific implementation details)**
3.  **Strictly control the output format:** Unless the task explicitly requires a specific format (e.g., the delivery phase requires a final itinerary in HTML), all task lists and intermediate content must strictly follow the Markdown format defined in the OUTPUT FORMAT. This means that no HTML code should appear during the planning and decomposition phases.
4.  **Strictly adhere to the output format:** This is the most critical rule. Your final response must contain only the content composed of "phases" and "task lists" as defined in the OUTPUT FORMAT. Do not add any introductions, explanations, summaries, headings (such as "Task List"), objectives, key results, or any other additional text.
5.  Do not omit key information from the main objective in the task planning content.


**Part3: Decomposition ideas:**
Information collection stage: search, research, data collection, etc.
Analysis and processing stage: sorting, analysis, screening, verification, etc.
Execution and production stage: creation, development, writing, design, etc.
Delivery stage: final output and submission to users

**Part4: Planning requirements: **
Adjust the decomposition granularity according to the complexity of the problem
Ensure that each step has clear outputs or milestones
Consider the dependencies between tasks
The last step is always to deliver to the user

# OUTPUT FORMAT

**ã€Absolute Ruleã€‘** Your response must strictly begin and end with this format. No text is allowed outside of this format.
## [Content of Phase 1]
- [Task 1]
- [Task 2]
## [Content of Phase 2]
- [Task 1]
- [And so on...]

[Previous results]
{previous}

# INPUTS

[Uploaded files]
{files}

[Best Practice Knowledge]
{best_practice_knowledge}

**[Executor Capabilities]**
**[Executor Capabilities & Planning Mandate]**

**Your Primary Mandate:** You are a *strategist*, not an *operator*. Your plan must describe the *goal* of each task (the "what"), not the specific tool to be used (the "how").

**CRITICAL RULE: You are strictly forbidden from mentioning specific tool names** (like `web_search`, `write_code`, `terminal_run`, etc.) or **specific implementation details** (like library names `ast.literal_eval`, algorithm names, or specific API modules) in your final Markdown plan output.

The Executor is responsible for selecting the best tool and implementation for the task you define. Trust it to do its job.

* **Good Task (Your Goal):** `- [Analyze the attached PDF reports to extract key financial figures.]`
* **Bad Task (Forbidden):** `- [Use document_query to analyze the PDF reports...]`
* **Good Task (Your Goal):** `- [Implement a safe expression evaluation engine for the calculator.]`
* **Bad Task (Forbidden):** `- [Implement the engine using the 'ast.literal_eval' module...]`

**Executor Capabilities (For Your Awareness Only):**
To help you create a realistic and achievable plan, be aware that the Executor *has the ability* to:
* Search the public internet for information.
* Read the raw content of simple text/data files (TXT, JSON, MD, XLSX).
* Write new files (like Python scripts, HTML pages, or Markdown reports).
* Execute system commands (like running Python scripts or installing dependencies).
* Potentially use specialized, proprietary tools (`mcp_tool`) for specific tasks, which the Executor will choose automatically if it's a better fit.
**{executor_capabilities}**

[User Requirement]
{goal}


================================================
FILE: src/template/search.template.txt
================================================
# Core Directives

You are a world-class expert in information analysis and synthesis. Please strictly follow the following four directives to process the user input:
1. Target-Focused: Deeply understand the [Search Target] and treat it as the sole guiding principle. In the [Original Text], only select, extract, integrate, and synthesize information that is strongly related to the target.
2. Logical Synthesis: Do not simply list information. You need to identify the inherent connections between different pieces of information from various sources, and reorganize them into a coherent, logical whole.
3. Source-Grounded: Ensure that all the content you generate can be traced back to the [Original Text]. Allow reasonable summarization and abstraction, but strictly prohibit introducing new facts, data, or opinions that are not present in the original text.
4. Gap Identification: If the [Original Text] does not provide enough information to answer the [Search Target] question, you must clearly identify the gaps in the provided information, such as "The provided information does not contain related information about [certain topic]."

# Role

You are a world-class expert in information analysis and synthesis. Your primary responsibility is to ensure the accuracy and traceability of the information.

# Task Instruction

Please strictly follow the [Core Directives] and deeply analyze the [Search Result Original Text] provided by the user. Based on the [Search Target] and [Output Format Requirements], generate a concise, comprehensive, and fully traceable summary.

# Input Information

====== Search Target ======
{goal}

====== Search Result Original Text ======
{search_context}
======

# Output Format Requirements

## 1. Core Requirements

- The content must be completely based on the [Search Result Original Text] and not deviate from it.

## 2. Language Style

- Objective, neutral, and concise
- Avoid using subjective language (e.g. "amazing", "great") or ambiguous words
- Use a descriptive tone to summarize the facts



================================================
FILE: src/template/thinking.txt
================================================
You are an intelligent assistant, an AI helper capable of guiding users in interacting with computers, writing code, and solving tasks.
You should always output with valid xml format content
Your Primary main task is to complete <Task Goal>, do not deviate from the goal to complete the <Root Task>
**Your Core Principle**: Before planning any step, you MUST first consult the `=== Best Practices Memory ===` section. These are the highest priority guidelines set by the user. You must strictly adhere to these practices, even if they differ from your general knowledge. **Please pay special attention: Requirements within `Best Practices Memory` regarding the "final deliverable format" (e.g., HTML mimicking PDF layout) apply only when the `Root Task` is completely finished and ready for final delivery. When completing each `<Task Goal>`, you should focus on implementing the task's content and strictly follow the `Document and Text Generation` specification for intermediate output formats (e.g., prioritize Markdown), unless the current `<Task Goal>` explicitly requires another specific format.**
**Tool-First Approach: Always prioritize using built-in tools (`web_search`, `read_file`) for information retrieval and simple file operations. `write_code` is a powerful but 'expensive' tool; use it only when the task is clearly about software creation or data transformation beyond the scope of other tools.**

**When faced with complex, multi-step tasks, you MUST first attempt to solve them by strategically combining built-in tools** (like `web_search`, `read_file`).
**Only resort to `write_code`** when the task's logic (e.g., complex data manipulation, computations) cannot be achieved by the available tools.
If you determine `write_code` is necessary, you MUST first use the `write_code` tool to create a script (e.g., a Python file). After successfully writing the file, you MUST use `terminal_run` to execute that script in a subsequent, separate action. **CRITICAL: All scripts and commands executed via `terminal_run` MUST be non-interactive and designed to terminate automatically upon completion. Do not create persistent processes (e.g., web servers, background listeners) or commands that require user input.** It is strictly forbidden to use single-line execution commands like `python3 -c` for any task that involves multiple logical steps or file operations.

Based on the <Task Goal> and <Tool List>, as well as the context, plan the execution steps and use the appropriate tools to complete the task.
According to the current situation, **in your single reply, you must and only return one XML formatted execution command**. It is strictly forbidden to include multiple action tags in one reply (for example, do not return two <web_search> commands at the same time). Wait for the user to execute the command you provided and provide feedback on the result before you proceed with the next step based on the feedback.

==== Current System Environment ===
{system}
====

=== Best Practices Memory ===
{best_practices_knowledge}
=== END ===

== !!! Implementation Specification ==
==== Execution and Process Management ====
**CRITICAL: All executed commands and scripts MUST be non-interactive and terminate automatically.** Your purpose is to complete the `<Task Goal>` and return a result, not to start a persistent service or an interactive session.
* **Strictly Prohibited:** Do not generate commands that start persistent services (e.g., `npm run serve`, or running a Flask/FastAPI server like `python app.py`), run in the background (e.g., using `&`), or require user input during execution (e.g., interactive prompts, REPLs).
* **Required:** All code written (e.g., in Python, Node.js) must be designed to run, perform its specific task (like processing a file, fetching data, or generating content), and then exit successfully on its own.
* **Correct Example:** A Python script that reads `input.json`, processes it, and saves `output.json`.
* **Incorrect Example:** A Python script that starts a web server using `app.run()` and waits for connections.

==== Scripting Languages ====
Generate code as you would write it in a normal editor, including execution and return statements, to achieve the requirement and obtain results.
==== Web Code ====
Generate complete HTML code, including the full implementation of structure, style, and logic. The code should be as concise and efficient as possible, and should not contain any comments.
Use Vue 3 + Tailwind CSS, referencing CDN resources for dependencies. Write clear, standardized, responsive, and fully functional web code.
Default style for display web pages
1. Use Bento Grid style visual design, with soft color matching
2. Emphasize oversized fonts or numbers to highlight the core points. There are oversized visual elements in the picture to emphasize the key points, which contrast with the proportion of small elements
3. Simple line graphics as data visualization or illustration elements
4. Use highlight colors to create a sense of technology with gradual transparency, but different highlight colors should not fade with each other
5. Imitate the dynamic effects of Apple's official website, scroll down with the mouse to match the dynamic effects
6. Data can refer to online chart components, and the style needs to be consistent with the theme
7. Use HTML5, Tailwindcss 3.0+ (introduced through CDN) and necessary JavaScript
8. Coding principles: Define dynamic data in script first, and render data in template by `v-for` to avoid a lot of repeated code
9. Use professional icon libraries such as FontAwesome or Material lcons (introduced through CDN)
10. Avoid using emoji as the main icon
11. Do not omit content points
12. **IMPORTANT**: When generating HTML code for the write_code tool, you **MUST** wrap the entire HTML content within a <![CDATA[...]]> section. This is to ensure the response is a valid XML while preserving the HTML tags correctly.

==== Document and Text Generation ====
When the task requires generating documents, reports, plans, or general textual content (e.g., itineraries, summaries, articles) and no specific format is explicitly stated, **you MUST prioritize generating content in Markdown (.md) format. If Markdown is not suitable or explicitly requested otherwise, then generate in HTML (.html) format. If the task explicitly requests PDF, or any other specific format, you MUST strictly adhere to that specified format.** Markdown is preferred for its versatility and readability.
**Important and strict supplement: Unless the current<Task Goal>explicitly instructs to generate HTML as its primary output, or you have received a clear "generate final HTML" instruction from the user, it is strictly prohibited to generate HTML format files in any intermediate steps.**

==== File System ====
All file paths for tools (e.g., `write_code`, `read_file`, `terminal_run`) **must be relative paths**.
Your current working directory is automatically set for this conversation. All relative paths are based on this directory, and you should not be concerned with its absolute location as the system handles it during execution.
**Correct Examples:**
  * `"output.txt"`
  * `"upload/data.csv"`
**Strictly Prohibited:**
  * Do not hardcode any absolute paths. For example, never use paths starting with `/workspace/`, `/app/`, or `/Users/` or `/Conversation_xxxxxx/`.

**IMPORTANT - File Reading Limitations:**
The `read_file` tool **CANNOT** read binary files (PDF, DOCX, DOC, PPTX, PPT, JPG, PNG, etc.). For these file types:
1. **Required**: Write Python code using appropriate libraries (e.g., PyPDF2 for PDF, python-docx for Word documents, python-pptx for PowerPoint, Pillow for images)
2. **Never**: Use `read_file` for binary formats - it will fail

The `read_file` tool is only for plain text files: TXT, CSV, XLSX, JSON, MD, source code files, configuration files, etc.
====


==== Task Completion ====
If you believe the <Task Goal> Of <Main Task> is complete, please use the finish tool to return a task completion explanation in XML format:
<finish>
<message><Task result explanation></message>
</finish>
=== END ===

=== Previous Conversation ===
{previous}

=== MEMORY Context ===
{memory}
=== END ===

=== Files already uploaded by the user ===
{files}
=== END ===

{tools}

=== Example Return Format ===
// All text nodes MUST always be wrapped in <![CDATA[ ... ]]>, regardless of content.
// you MUST wrap the content in a <![CDATA[...]]> section to ensure the XML is valid.

**<web_search>
<query>search word</query>
<num_results>3</num_results>
</web_search>**

<write_code>
<path>filepath</path>
<content>
<![CDATA[
// code full content here
]]>
</content>
</write_code>
=== END ===

=== Task Goal ===
{requirement}
=== END ===

=== Error Feedback ===
{reflection}
=== END ===

please response with xml format with action and params


================================================
FILE: src/tools/browser.js
================================================
const browser = {
  name: "browser",
  description: "Interact with the browser. Use it ONLY when you need to interact with a webpage.",
  params: {
    type: "object",
    properties: {
      question: {
        description: "What you want to do with a browser",
        type: "string"
      }
    },
    required: ["question"]
  },
  getActionDescription({ question }) {
    return question;
  }
};

module.exports = browser;


================================================
FILE: src/tools/index.js
================================================
const fs = require('fs');
const path = require('path');

/**
 * @typedef {import('types/Tool').Tool } Tool
 */

/** @type {Object.<string, Tool>} */
const tools = {};
const ignored = new Set(['browser_use']);

const files = fs.readdirSync(__dirname);
const filterFn = file => {
  return (file.indexOf('.') !== 0) && (file !== path.basename(__filename)) && (file.slice(-3) === '.js');
}
for (const file of files.filter(filterFn)) {
  try {
    const def = require(path.join(__dirname, file));
    const tool = def.name || path.basename(file, '.js');
    if (ignored.has(tool)) continue
    tools[tool] = def;
  } catch (error) {
    console.error(`Error loading from ${file}:`, error);
  }
}

module.exports = tools;


================================================
FILE: src/tools/read_file.js
================================================
const read_file = {
  name: "read_file",
  description: "Read the content of a specified file path and return, supports txt, md, xlsx, json formats",
  params: {
    type: "object",
    properties: {
      path: {
        description: "The path of the file to read.",
        type: "string"
      }
    },
    required: ["path"]
  },
  getActionDescription({ path }) {
    return path;
  }
};

module.exports = read_file;


================================================
FILE: src/tools/terminal_run.js
================================================
const TerminalRun = {
  name: "terminal_run",
  description: "Execute a specified command in the terminal and return the result",
  params: {
    type: "object",
    properties: {
      command: {
        description: "The command to execute",
        type: "string"
      },
      args: {
        description: "Command arguments list",
        type: "string",
      },
      cwd: {
        description: "Command working directory",
        type: "string"
      }
    },
    required: ["command"]
  },
  getActionDescription({ command, args = "", cwd }) {
    return `${command} ${args}`;
  }
};

module.exports = TerminalRun;


================================================
FILE: src/tools/WebSearch.js
================================================
const TalivySearch = require('./impl/web_search/TalivySearch');
const LocalSearch = require('./impl/web_search/LocalSearch');
const CloudswaySearch = require('./impl/web_search/CloudswaySearch');
const UserProviderConfig = require('@src/models/UserProviderConfig');
const SearchProvider = require('@src/models/SearchProvider');
const UserSearchSetting = require('@src/models/UserSearchSetting');
const sub_server_request = require('@src/utils/sub_server_request')

/** @type {import('types/Tool').Tool} */
const WebSearchTool = {
    name: "web_search", // Snake_case is common for LLM function names
    description: `Use this tool to search the web for information`,
    params: {
        type: "object",
        properties: {
            query: {
                type: "string",
                description: "the search key words split with space",
            },
            num_results: {
                type: "integer",
                description: "Optional. The desired number of search results (default: 3).",
            }
        },
        required: ["query"], // Only 'query' is mandatory
    },
    memorized: true,

    /**
     * Gets the description of the web search action.
     * @param {object} args - The arguments for the search.
     * @param {string} args.query - The search query.
     * @param {number} [args.num_results=3] - Optional number of results.
     * @returns {Promise<string>} A promise resolving to a string containing the action description.
     */
    getActionDescription: async ({ query, num_results = 3 }) => {
        return query;
    },

    /**
     * Executes the web search.
     * @param {object} args - The arguments for the search.
     * @param {string} args.query - The search query.
     * @param {number} [args.num_results=3] - Optional number of results.
     * @param {string} args.conversation_id
     * @returns {Promise<Object>} A promise resolving to a string containing the search results.
     */
    execute: async ({ query, num_results = 3, conversation_id = "" }) => {
        try {
            // å¦‚æœè®¾ç½®äº†ï¼Œé»˜è®¤èµ°è®¾ç½®
            let userSearchSetting = await UserSearchSetting.findOne()
            num_results = userSearchSetting.dataValues.result_count || 3

            console.log(`[WebSearchTool] Searching for: "${query}" (max ${num_results} results)`);
            if (!query || typeof query !== 'string' || query.trim() === '') {
                throw new Error("WebSearchTool Error: 'query' parameter must be a non-empty string.");
            }
            if (typeof num_results !== 'number' || !Number.isInteger(num_results) || num_results <= 0) {
                console.warn(`[WebSearchTool] Invalid num_results value (${num_results}), defaulting to 3.`);
                num_results = 3;
            }

            // åˆ¤æ–­å½“å‰è®¾ç½®
            const searchProvider = await SearchProvider.findOne({ where: { id: userSearchSetting.provider_id } })
            let json = {}
            let content = ''
            let obj
            switch (searchProvider.name) {
                case 'Tavily':
                    obj = await doTalivySearch(query, num_results)
                    json = obj.json
                    content = obj.content
                    break;
                case 'Cloudsway':
                    obj = await doCloudswaySearch(query, num_results)
                    json = obj.json
                    content = obj.content
                    break;
                case 'Baidu':
                    obj = await doLocalSearch(query, 'baidu', num_results)
                    json = obj.json
                    content = obj.content
                    break;
                case 'Bing':
                    obj = await doLocalSearch(query, 'bing', num_results)
                    json = obj.json
                    content = obj.content
                    break;
                case 'Lemon':
                    obj = await doLemonSearch(query, num_results, conversation_id)
                    json = obj.json
                    content = obj.content
                    break;
            }
            return {
                content,
                meta: { json }
            }
        } catch (error) {
            console.error(`[WebSearchTool] Error during execution for query "${query}":`, error);
            // Return a user-friendly error message or re-throw for the agent to handle
            throw new Error(`Error performing web search for "${query}". Please check the logs or try again. Details: ${error.message || 'Unknown error'}`);
        }
    },
};

async function doTalivySearch(query, num_results) {
    let userSearchSetting = await UserSearchSetting.findOne()
    const userProviderConfig = await UserProviderConfig.findOne({ where: { provider_id: userSearchSetting.provider_id } })
    let tavily_api_key = userProviderConfig.base_config.api_key

    const talivy = new TalivySearch({ key: tavily_api_key });
    const results = await talivy.search(query, { max_results: num_results });
    // console.log(`[WebSearchTool] Search results for "${query}":`, results);

    const formatted = await talivy.formatContent();
    const json = await talivy.formatJSON();
    const content = `Web search results for "${query}":\n\n${formatted}`;

    return { json, content }
}

async function doLemonSearch(query, num_results, conversation_id) {
    return sub_server_request('/api/sub_server/search', {
        query,
        num_results,
        conversation_id
    })
}

async function doCloudswaySearch(query, num_results) {
    let userSearchSetting = await UserSearchSetting.findOne()
    const userProviderConfig = await UserProviderConfig.findOne({ where: { provider_id: userSearchSetting.provider_id } })
    let cloudsway_access_key = userProviderConfig.base_config.api_key
    let cloudsway_endpoint = userProviderConfig.base_config.endpoint
    const cloudsway = new CloudswaySearch({ access_key: cloudsway_access_key, endpoint: cloudsway_endpoint });
    const results = await cloudsway.search(query, { max_results: num_results });
    // console.log(`[WebSearchTool] Search results for "${query}":`, results);
    const formatted = await cloudsway.formatContent();
    const json = await cloudsway.formatJSON();
    const content = `Web search results for "${query}":\n\n${formatted}`;
    console.log(`[WebSearchTool] doCloudswaySearch Search results for "${query}":`, results)
    return { json, content }
}


async function doLocalSearch(query, engine_name, num_results) {
    const localSearch = new LocalSearch()
    const results = await localSearch.search(query, { uid: 'user1', max_results: num_results, engine: engine_name });
    let formatted = await localSearch.formatContent()
    const json = await localSearch.formatJSON();
    const content = `Web search results for "${query}":\n\n${formatted}`;

    return { json, content }
}


module.exports = WebSearchTool;


================================================
FILE: src/tools/write_code.js
================================================
const { json2xml } = require('@src/utils/format');

const WriteCode = {
  name: "write_code",
  description: "Write html/node/python code to complete task, write markdown to generate requirement/report/design , use python3 code with PyPDF2 to read PDF files",
  params: {
    type: "object",
    properties: {
      path: {
        description: "The path of the file to write.",
        type: "string"
      },
      content: {
        description: "The code content to write.",
        type: "string"
      }
    },
    required: ["path", "content"]
  },
  getActionDescription({ path }) {
    return path;
  },
  /**
   * è‡ªå®šä¹‰è®°å¿†å†…å®¹
   * @param {*} action 
   * @param {*} content 
   * @returns 
   */
  resolveMemory(action = {}, content) {
    const filepath = action.params.origin_path || action.params.path;
    const memory = {
      type: 'write_code',
      status: 'success',
      path: filepath
    }
    return json2xml(memory);
  }
};

module.exports = WriteCode;


================================================
FILE: src/tools/impl/web_search/CloudswaySearch.js
================================================
const axios = require('axios');

const HOST = 'https://searchapi.cloudsway.net/search/{endpoint}/base';

class CloudswaySearch {
    constructor({access_key: ACCESS_KEY, endpoint: ENDPOINT}) {
        this.ACCESS_KEY = ACCESS_KEY;
        this.ENDPOINT = ENDPOINT;
        this.baseUrl = HOST.replace('{endpoint}', this.ENDPOINT);
    }

    async search(query, options = {}) {
        const defaultOptions = {
            count: 1,
            safeSearch: 'Strict'
        };

        const requestOptions = {
            ...defaultOptions,
            ...options,
            q: query,
            count: options.max_results || 1 // override default count
        };

        try {
            const url = new URL(this.baseUrl);
            Object.entries(requestOptions).forEach(([key, value]) => {
                if (value !== undefined && value !== null) {
                    url.searchParams.append(key, value);
                }
            });

            const response = await axios.get(url.toString(), {
                headers: {
                    'Authorization': `Bearer ${this.ACCESS_KEY}`,
                    'Content-Type': 'application/json'
                }
            });
            this.result = response.data;
            return this.result;
        } catch (error) {
            console.error('Cloudsway Search error:', error);
            throw error;
        }
    }

    async formatContent() {
        const {queryContext, webPages} = this.result;
        const list = [];
        for (const item of webPages?.value || []) {
            const description = `URL: ${item.url || 'N/A'}\nTitle: ${item.name || item.title || 'N/A'}\nContent: ${item.snippet || item.content || 'N/A'}\n`;
            list.push(description);
        }
        return list.join('======\n======');
    }

    async formatJSON() {
        const {queryContext,webPages = []} = this.result;
        let result = []
        for (const item of webPages?.value|| []) {
            result.push({
                url: item.url,
                title: item.name,
                content: item.snippet
            });
        }
        return result;
    }

    async check() {
        try {
            const testQuery = "test connection";
            const url = new URL(this.baseUrl);
            url.searchParams.append('q', testQuery);
            url.searchParams.append('max_results', '1');
            url.searchParams.append('search_depth', 'basic');

            const response = await axios.get(url.toString(), {
                headers: {
                    'Authorization': `Bearer ${this.ACCESS_KEY}`,
                    'Content-Type': 'application/json'
                }
            });

            if (response.status === 200) {
                return {status: 'success', message: 'Cloudsway Search API connection successful.'};
            } else {
                return {status: 'fail', message: `Cloudsway Search API returned status: ${response.status}`};
            }
        } catch (error) {
            if (error.response) {
                if (error.response.status === 401) {
                    return {status: 'fail', message: 'Cloudsway Search API key is invalid or unauthorized.'};
                } else {
                    return {
                        status: 'fail',
                        message: `Cloudsway Search API error: ${error.response.status} - ${error.response.statusText || 'Unknown error'}`
                    };
                }
            } else if (error.request) {
                return {
                    status: 'fail',
                    message: 'No response received from Cloudsway Search API. Check network connection.'
                };
            } else {
                return {status: 'fail', message: `An unexpected error occurred: ${error.message}`};
            }
        }
    }
}

module.exports = CloudswaySearch;


================================================
FILE: src/tools/impl/web_search/GoogleSearch.js
================================================
const { google } = require('googleapis');

class GoogleSearch {
  constructor({ key: API_KEY, cx: SEARCH_ENGINE_ID }) {
    this.API_KEY = API_KEY;
    this.SEARCH_ENGINE_ID = SEARCH_ENGINE_ID;
    this.customsearch = google.customsearch('v1');
  }

  async search(query, options = {}) {
    if (!this.SEARCH_ENGINE_ID) {
      throw new Error('Google Search Engine ID (cx) is required. Please set GOOGLE_SEARCH_ENGINE_ID environment variable.');
    }

    const defaultOptions = {
      start: 1,
      num: 10,
      safe: 'medium',
      lr: 'lang_zh-CN|lang_en'
    };

    const requestOptions = {
      auth: this.API_KEY,
      cx: this.SEARCH_ENGINE_ID,
      q: query,
      ...defaultOptions,
      ...options
    };

    try {
      // Set 1 minute timeout
      const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => reject(new Error('Google search timeout after 1 minute')), 60000);
      });

      const searchPromise = this.customsearch.cse.list(requestOptions);

      const response = await Promise.race([searchPromise, timeoutPromise]);
      this.result = response.data;
      return this.result;
    } catch (error) {
      if (error.message.includes('timeout')) {
        console.error('Google search timed out after 1 minute');
      } else {
        console.error('GoogleSearch error:', error);
      }
      throw error;
    }
  }

  async formatContent() {
    if (!this.result || !this.result.items) {
      return 'No search results found.';
    }

    const list = [];
    for (const item of this.result.items) {
      const description = `URL: ${item.link}\nTitle: ${item.title}\nContent: ${item.snippet}\n`;
      list.push(description);
    }
    return list.join('======\n======');
  }

  async formatJSON() {
    if (!this.result || !this.result.items) {
      return [];
    }

    return this.result.items.map(item => ({
      url: item.link,
      title: item.title,
      content: item.snippet,
      displayUrl: item.displayLink
    }));
  }

  async check() {
    try {
      const testQuery = "test connection";
      const response = await this.customsearch.cse.list({
        auth: this.API_KEY,
        cx: this.SEARCH_ENGINE_ID,
        q: testQuery,
        num: 1
      });

      if (response.data) {
        return { status: 'success', message: 'Google Custom Search API connection successful.' };
      } else {
        return { status: 'fail', message: 'Google Custom Search API returned no response' };
      }
    } catch (error) {
      if (error.response && error.response.status === 400) {
        return { status: 'fail', message: 'Google Custom Search API key or Search Engine ID is invalid.' };
      } else if (error.response && error.response.status === 403) {
        return { status: 'fail', message: 'Google Custom Search API daily quota exceeded or access denied.' };
      } else if (error.response) {
        return { status: 'fail', message: `Google Custom Search API error: ${error.response.status} - ${error.response.statusText || 'Unknown error'}` };
      } else {
        return { status: 'fail', message: `An unexpected error occurred: ${error.message}` };
      }
    }
  }
}

module.exports = GoogleSearch;


================================================
FILE: src/tools/impl/web_search/GoogleSearch.run.js
================================================
require('dotenv').config();
require('module-alias/register')

const GoogleSearch = require('@src/tools/impl/web_search/GoogleSearch.js')

const run = async () => {
  const tool = new GoogleSearch({ 
    key: process.env.GOOGLE_API_KEY,
    cx: process.env.GOOGLE_SEARCH_ENGINE_ID
  })
  const result = await tool.search('åŒ—äº¬ä»Šæ—¥å¤©æ°”', { num: 3 })
  // console.log(JSON.stringify(result, null, 2))
  const formatted = await tool.formatContent()
  console.log(formatted)
}

run()


================================================
FILE: src/tools/impl/web_search/LocalSearch.js
================================================
const {chromium} = require('playwright');
const cheerio = require('cheerio');
const path = require('path');

class LocalSearchServer {
    constructor() {
    }

    static instance = null;
    browser = null; // å…¨å±€å…±äº«çš„ browser å®ä¾‹
    contexts = new Map(); // å­˜å‚¨ context å®ä¾‹ï¼ŒæŒ‰ uid ç®¡ç†
    maxConcurrentPages = 10; // æœ€å¤§å¹¶å‘é¡µé¢æ•°
    activePages = 0; // å½“å‰æ´»è·ƒé¡µé¢æ•°
    result = null; // å­˜å‚¨æœ€è¿‘ä¸€æ¬¡æœç´¢ç»“æœ
    
    static getInstance() {
        if (!LocalSearchServer.instance) {
            LocalSearchServer.instance = new LocalSearchServer();
        }
        return LocalSearchServer.instance;
    }

    // åˆå§‹åŒ–å…¨å±€ browser
    async initializeBrowser() {
        if (!this.browser) {
            let isClinet = ['t','1','T'].includes(process.env.VITE_IS_CLIENT.slice(0, 1)); // ture|1|True
            if(isClinet){ //the client use browser of projects
                this.browser = await chromium.launch({
                    headless: true,
                    args: ['--no-sandbox'],
                    executablePath: this.getExecutablePath() // browser executable path
                });
            }else{
                this.browser = await chromium.launch({
                    headless: true,
                    args: ['--no-sandbox'],
                });
            }
            this.browser.on('disconnected', () => {
                this.browser = null;
                this.contexts.clear();
            });
        }
        return this.browser;
    }

    // è·å–æˆ–åˆ›å»º context
    async getOrCreateContext(uid) {
        let context = this.contexts.get(uid);
        if (!context) {
            const browser = await this.initializeBrowser();
            context = await browser.newContext({
                userAgent:
                // 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
                // ä¿®æ”¹UserAgent
                    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
            });
            this.contexts.set(uid, context);
            context.on('close', () => {
                this.contexts.delete(uid);
            });
        }
        return context;
    }

    // ç­‰å¾…å¯ç”¨é¡µé¢æ§½ä½
    async waitForPageSlot() {
        while (this.activePages >= this.maxConcurrentPages) {
            await new Promise((resolve) => setTimeout(resolve, 100));
        }
        this.activePages++;
    }

    // é‡Šæ”¾é¡µé¢æ§½ä½
    releasePageSlot() {
        this.activePages--;
    }

    // è§£æ Bing æœç´¢ç»“æœ å½“å‰HTMLè§£ææ—¥æœŸ 2025/5/13
    parseBingSearchResults(html) {
        const $ = cheerio.load(html);
        const results = [];

        $('li.b_algo').each((index, element) => {
            const $element = $(element);
            const titleElement = $element.find('h2 a');
            const title = titleElement.text().trim();
            const url = titleElement.attr('href');

            let content = '';
            // ä¼˜å…ˆå°è¯• p.b_lineclamp3
            let contentElement = $element.find('p.b_lineclamp3');
            if (contentElement.length) {
                const contentClone = contentElement.clone();
                const dateSpan = contentClone.find('span.news_dt');
                if (dateSpan.length) {
                    dateSpan.remove();
                }
                content = contentClone.text().trim().replace(/\s+/g, ' ');
            } else {
                // å°è¯• b_caption ä¸‹çš„ p
                contentElement = $element.find('.b_caption p');
                if (contentElement.length) {
                    const contentClone = contentElement.clone();
                    const dateSpan = contentClone.find('span.news_dt');
                    if (dateSpan.length) {
                        dateSpan.remove();
                    }
                    content = contentClone.text().trim().replace(/\s+/g, ' ');
                } else {
                    // å°è¯• b_dList ä¸‹çš„ span
                    const listItems = $element.find('.b_dList .lisn_olitem span');
                    if (listItems.length) {
                        const contents = [];
                        listItems.each((i, item) => {
                            const $item = $(item);
                            // ä¼˜å…ˆä½¿ç”¨ title å±æ€§ï¼ˆå®Œæ•´æ–‡æœ¬ï¼‰ï¼Œå¦åˆ™ä½¿ç”¨æ–‡æœ¬å†…å®¹
                            const text = $item.attr('title') || $item.text().trim();
                            if (text) {
                                contents.push(text);
                            }
                        });
                        content = contents.join(' ').trim().replace(/\s+/g, ' ');
                    }
                }
            }

            if (title && url) {
                results.push({
                    url,
                    title,
                    content: content || '',
                });
            }
        });

        return results;
    }

    // è§£æ Baidu æœç´¢ç»“æœ å½“å‰HTMLè§£ææ—¥æœŸ 2025/6/3
    parseBaiduSearchResults(html) {
  const $ = cheerio.load(html);
  const results = [];

  // åªåŒ¹é…é¡¶å±‚å®¹å™¨ï¼Œé¿å…åµŒå¥—
  $('div.result.c-container:not(.c-container *), div.result-op.c-container:not(.c-container *)').each((index, element) => {
    const $element = $(element);
    // æ ‡é¢˜é€‰æ‹©å™¨ï¼šæ’é™¤ç›¸å…³é“¾æ¥çš„æ ‡é¢˜
    const titleElement = $element.find('h3.t a, .title_2X7ZC a, ._sc-title_1g9za_66 a, .cosc-title-a:not(.exta-link-pc_3aUAb *)').first();
    const title = titleElement
      .clone()
      .text()
      .trim();
    const url = titleElement.attr('href');
    // æ‘˜è¦é€‰æ‹©å™¨ï¼šç™¾åº¦htmlé¡µé¢ä¸­æ‘˜è¦å…ƒç´ æ ¼å¼æœ‰å¾ˆå¤šï¼Œè¿™é‡Œå°è¯•å¤šä¸ªé€‰æ‹©å™¨(ä¸å…¨) æ‰€ä»¥ä¼šå‡ºç°æŸäº›æ²¡æœ‰æ‘˜è¦çš„æƒ…å†µ
    const contentElement = $element.find(
      '.summary-text_560AW, .cos-line-clamp-3 > span:not(.cos-color-text-minor), .c-abstract, .c-span18, [class*="summary-text"], p.common-content_4dXMi, .cos-line-clamp-2'
    ).first();
    const content = contentElement
      .clone()
      .text()
      .trim()
      .replace(/\s+/g, ' ');

    // è¿‡æ»¤æ¡ä»¶ å¿…é¡»æœ‰æ ‡é¢˜ã€é“¾æ¥å’Œæ‘˜è¦
    if (title && url && content) {
      results.push({
        url,
        title,
        content: content || '',
      });
    }
  });

  // å»é‡ç»“æœï¼ŒåŸºäº url å’Œ title
  const uniqueResults = Array.from(
    new Map(results.map(item => [`${item.url}|${item.title}`, item])).values()
  );

  // è°ƒè¯•æ—¥å¿—
  if (uniqueResults.length === 0) {
    console.warn('No results parsed. HTML snippet:', html.slice(0, 500));
  }
  // console.log('æŸ¥æ‰¾ç»“æœ', JSON.stringify(uniqueResults, null, 2));

  return uniqueResults;
}

    // å†…éƒ¨æ–¹æ³•ï¼šåŠ è½½ URL å¹¶è¿”å› HTML
    async #openUrlInSearchWindow(uid, url) {
        await this.waitForPageSlot();
        const context = await this.getOrCreateContext(uid);
        let page;

        try {
            page = await context.newPage();
            await page.goto(url, {waitUntil: 'networkidle'});
            // ç­‰å¾…æœç´¢ç»“æœæˆ–åˆ—è¡¨åŠ è½½
            // await Promise.race([
            //   page.waitForSelector('li.b_algo', { timeout: 10000 }),
            //   page.waitForSelector('.b_dList', { timeout: 10000 }),
            // ]).catch(() => {
            //   console.warn('No b_algo or b_dList elements found, proceeding with available content');
            // });

            // æ¨¡æ‹Ÿäººç±»è¡Œä¸ºï¼ˆå¦‚æ»šåŠ¨ï¼‰ä»¥è§¦å‘åŠ¨æ€å†…å®¹
            await page.evaluate(() => window.scrollTo(0, document.body.scrollHeight));
            // é¢å¤–ç­‰å¾…åŠ¨æ€å†…å®¹
            await page.waitForTimeout(2000);
            const html = await page.content();
            return html;
        } finally {
            if (page) await page.close();
            this.releasePageSlot();
        }
    }

    /**
     * æœç´¢æ¥å£ core function
     è¾“å…¥ï¼š
     args:
     query: string
     options: {
     uid: string, // ç”¨æˆ· ID default: 'default'
     max_results: number, // æœ€å¤§ç»“æœæ•° default: 3
     engine: string, // bing or baidu; default: 'bing'
     }
     è¾“å‡ºï¼š

     result:{
     query: string
     results: list of { title: string, url: string, content: string }
     };

     example:
     input: query:'å››æœˆæ—¥æœ¬æ—…è¡Œä¹‹æ—…'
     options:{ uid: 'user1',max_results: 3 , engine : 'bing'}
     output: result:{
     query: 'å››æœˆæ—¥æœ¬æ—…è¡Œä¹‹æ—…',
     results: [
     {
     url: 'https://blog.oilart.me/4%E6%9C%88%E6%97%A5%E6%9C%AC%E5%A5%BD%E5%8E%BB%E8%99%95/',
     title: '10å¤§4æœˆå¿…è¨ªæ—¥æœ¬æ™¯é»ï¼šè³æ«»ã€ç¥­å…¸ã€è¸é’å…¨æ”»ç•¥ ...',
     content: 'Â· æœ¬ç¯‡æ–‡ç« å°‡ç‚ºæ‚¨ç²¾é¸10å€‹å››æœˆå¿…è¨ªçš„æ—¥æœ¬æ™¯é»ï¼Œç„¡è«–æ‚¨æ˜¯æƒ³æ²‰æµ¸åœ¨æµªæ¼«çš„æ«»èŠ±é›¨ä¸­ï¼Œæˆ–æ˜¯æ„Ÿå—ç†±é¬§çš„ç¥­å…¸æ°›åœï¼Œéƒ½èƒ½åœ¨é€™è£¡æ‰¾åˆ°å®Œç¾çš„æ—…éŠéˆæ„Ÿã€‚ è®“æˆ‘å€‘ä¸€èµ·å±•é–‹ä¸€å ´å……æ»¿é©šå–œçš„æ˜¥æ—¥ä¹‹æ—…å§ ï¼ ä¸€å€‹äººä¸‰å¤©å…©å¤œçš„è¡Œç¨‹è¡£ç‰©ã€ â€¦'
     },
     {
     url: 'https://injapan.cc/4%e6%9c%88%e9%81%a9%e5%90%88%e5%8e%bb%e6%97%a5%e6%9c%ac%e5%93%aa%e8%a3%a1%e7%8e%a9%ef%bc%9f',
     title: '4æœˆé©åˆå»æ—¥æœ¬å“ªè£¡ç©ï¼Ÿæ«»èŠ±ç››é–‹æ™‚ç¯€ï¼Œæ·±å…¥æ¢ç´¢æ—¥æœ¬ ...',
     content: 'Â· ä¸è«–æ‚¨é¸æ“‡å“ªå€‹åŸå¸‚ï¼Œåœ¨4æœˆçš„æ—¥æœ¬æ—…è¡Œï¼Œæ‚¨éƒ½èƒ½é«”é©—åˆ°ä»¤äººé›£å¿˜çš„è³æ«»ä¹‹æ—…ã€‚ æ²‰æµ¸åœ¨ç²‰ç´…è‰²çš„èŠ±æµ·ä¸­ï¼Œæ¬£è³å¤§è‡ªç„¶çš„å£¯è§€å¥‡æ™¯ï¼Œç•™ä¸‹æ°¸æ†çš„å›æ†¶ã€‚ Photos provided by â€¦'
     },
     {
     url: 'https://roasterpig.blogspot.com/2025/04/japan-april-travel.html',
     title: '4æœˆæ—¥æœ¬è‡ªç”±è¡Œ é¿å‘é˜²è¸©é›·æ”»ç•¥ï¼šå¤©æ°£èˆ‡è¡£æœç©¿æ­ ...',
     content: 'Â· å››æœˆæ˜¯å»æ—¥æœ¬æ—…éŠçš„é‡é ­æˆ²ï¼Œæ«»èŠ±ç››é–‹çš„å­£ç¯€ã€‚ å»æ—¥æœ¬ç©çš„äººè‚¯å®šä¸å°‘ï¼Œä¸éä½ çŸ¥é“ï¼Œæ—¥æœ¬çš„æ—…éŠè¦å®šç™¼ç”Ÿä»€éº¼è®ŠåŒ–å—ï¼Ÿ æ«»èŠ±å­£ç¯€æ­£ç››é–‹ï¼Œå››æœˆå»æ—¥æœ¬æ—…è¡Œè¦æ³¨æ„ä»€éº¼ï¼Ÿ'
     }
     ]
     }
     */
    async search(query, options = {}) {
        const defaultOptions = {
            uid: 'default', // é»˜è®¤ç”¨æˆ· ID
            max_results: 5, // æœ€å¤§ç»“æœæ•°
            engine: 'bing', // é»˜è®¤æœç´¢å¼•æ“
        };

        const requestOptions = {
            ...defaultOptions,
            ...options,
            query,
        };

        try {
            let url;
            let results;
            if (requestOptions.engine.toLowerCase() === 'baidu') {
                url = `https://www.baidu.com/s?wd=${encodeURIComponent(requestOptions.query)}`;
                const html = await this.#openUrlInSearchWindow(requestOptions.uid, url);
                // require('fs').writeFileSync('baidu.html', html);
                // console.log('html:', html)
                results = this.parseBaiduSearchResults(html);
            } else {
                url = `https://www.bing.com/search?q=${encodeURIComponent(requestOptions.query)}`;
                const html = await this.#openUrlInSearchWindow(requestOptions.uid, url);
                results = this.parseBingSearchResults(html);
            }

            this.result = {
                query: requestOptions.query,
                results: results.slice(0, requestOptions.max_results),
            };
            return this.result;
        } catch (error) {
            console.error(`LocalSearchServer ${requestOptions.engine} æœç´¢é”™è¯¯:`, error);
            throw error;
        }
    }

    // æ ¼å¼åŒ–ä¸ºå­—ç¬¦ä¸²
    async formatContent() {
        if (!this.result || !this.result.results) {
            return '';
        }
        const {query, results = []} = this.result;
        const list = results.map((item) =>
            `URL: ${item.url}\nTitle: ${item.title}\ncontent: ${item.content}\n`
        );
        return `Query: ${query}\n${list.join('======\n======')}`;
    }

    // æ ¼å¼åŒ–ä¸º JSON
    async formatJSON() {
        if (!this.result || !this.result.results) {
            return [];
        }
        return this.result.results;
    }

    /**
     * æ£€æŸ¥æœç´¢åŠŸèƒ½æ˜¯å¦æ­£å¸¸è¿è¡Œã€‚
     * é€šè¿‡æ‰§è¡Œç®€å•çš„ Bing å’Œ Baidu æœç´¢æ¥éªŒè¯çˆ¬å–å’Œè§£ææ˜¯å¦æˆåŠŸã€‚
     * @returns {Promise<{status: string, message: string}>} è¿”å›åŒ…å«çŠ¶æ€å’Œæ¶ˆæ¯çš„å¯¹è±¡ã€‚
     */
    async check(engine) {
        const testQuery = "test search functionality";
        const checkResult = {status: 'fail', message: 'No engine specified or invalid engine.'};
        const uidPrefix = 'check-'; // Consistent UID prefix for cleanup

        if (!engine) {
            return checkResult;
        }

        const lowercasedEngine = engine.toLowerCase();

        try {
            if (lowercasedEngine === 'bing') {
                console.log('Performing Bing search check...');
                const bingResult = await this.search(testQuery, {
                    engine: 'bing',
                    max_results: 1,
                    uid: `${uidPrefix}bing`
                });
                if (bingResult && bingResult.results && bingResult.results.length > 0) {
                    checkResult.status = 'success';
                    checkResult.message = 'Bing search successful.';
                } else {
                    checkResult.status = 'fail';
                    checkResult.message = 'Bing search returned no results or an unexpected format.';
                }
            } else if (lowercasedEngine === 'baidu') {
                console.log('Performing Baidu search check...');
                const baiduResult = await this.search(testQuery, {
                    engine: 'baidu',
                    max_results: 1,
                    uid: `${uidPrefix}baidu`
                });
                if (baiduResult && baiduResult.results && baiduResult.results.length > 0) {
                    checkResult.status = 'success';
                    checkResult.message = 'Baidu search successful.';
                } else {
                    checkResult.status = 'fail';
                    checkResult.message = 'Baidu search returned no results or an unexpected format.';
                }
            } else {
                checkResult.status = 'fail';
                checkResult.message = `Unsupported engine: ${engine}. Please use 'bing' or 'baidu'.`;
            }
        } catch (error) {
            checkResult.status = 'fail';
            checkResult.message = `Search failed for ${lowercasedEngine}: ${error.message}`;
        } finally {
            // Ensure cleanup of the specific context used for this check
            if (this.contexts.has(`${uidPrefix}${lowercasedEngine}`)) {
                await this.contexts.get(`${uidPrefix}${lowercasedEngine}`).close();
            }
        }

        return checkResult;
    }


    // æ¸…ç†æ‰€æœ‰èµ„æº
    async cleanup() {
        for (const context of this.contexts.values()) {
            await context.close();
        }
        if (this.browser) {
            await this.browser.close();
            this.browser = null;
        }
        this.contexts.clear();
        this.activePages = 0;
        this.result = null;
    }

    getExecutablePath = ()=>{
        //  åˆ¤æ–­å½“å‰å¹³å°
        switch (process.platform) {
            case 'win32':
                return path.join(process.resourcesPath,'browser/chromium/chrome-win/headless_shell.exe')
            case 'darwin':
                return path.join(process.resourcesPath,'browser/chromium/chrome-mac/headless_shell');
            default:
                throw new Error('Unsupported platform');
        }
    }
}


module.exports = LocalSearchServer;


================================================
FILE: src/tools/impl/web_search/LocalSearch.run.js
================================================

const LocalSearchServer  = require('./LocalSearch');

(async () => {
  try {
    // æ‰“å¼€å¤šä¸ª URLï¼Œå¤ç”¨ browser å’Œ context
    // const result = await LocalSearchServer.search('Travel to Japan in April',{ uid: 'user1',max_results: 3 , engine : 'bing'});
    // 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
    const tools = new LocalSearchServer()
    const result = await tools.search('DeepSeekå¯¹æ¯”Grok',{ uid: 'user1',max_results: 10 , engine : 'baidu'});
    let r = await tools.formatContent()
    console.log(r)
    /**
    è¾“å…¥ç¤ºä¾‹ï¼š
    args:
      query: string
      options: {
        uid: string, // ç”¨æˆ· ID default: 'default'
        max_results: number, // æœ€å¤§ç»“æœæ•° default: 3
        engine: string, // æœç´¢å¼•æ“ bing or baidu; default: 'bing'
       }
    è¾“å‡ºç¤ºä¾‹ï¼š
    args:
      result:{
        query: string
        results: list of { title: string, url: string, content: string }
      };
     
     */
    //console.log('ç»“æœ', result);
    // // ä¿å­˜ HTML åˆ°æ–‡ä»¶temp.html


    console.log('\n\n\n-------------------------------------------------------------------------------------------------------------------------------------');
    console.log('Closed user1 context.');
    // æ¸…ç†æ‰€æœ‰èµ„æº
    await tools.cleanup();
  } catch (error) {
    console.error('Error:', error);
  }
})();


================================================
FILE: src/tools/impl/web_search/TalivySearch.js
================================================
const axios = require('axios');
// const { resolveAxiosInstance } = require('@utils/network');
const HOST = 'https://api.tavily.com/search';

class TalivySearch {
  constructor({ key: API_KEY }) {
    this.API_KEY = API_KEY;
    this.baseUrl = HOST;
  }

  async search(query, options = {}) {
    const defaultOptions = {
      topic: 'general',
      search_depth: 'basic',
      max_results: 1,
      include_raw_content: true,
      include_images: false,
      include_image_descriptions: false,
      include_domains: [],
      exclude_domains: []
    };

    const requestOptions = {
      ...defaultOptions,
      ...options,
      query
    };

    try {
      // @ts-ignore
      const response = await axios.post(this.baseUrl, requestOptions, {
        headers: {
          'Authorization': `Bearer ${this.API_KEY}`,
          'Content-Type': 'application/json'
        }
      });

      this.result = response.data
      return this.result;
    } catch (error) {
      console.error('TalivySearch error:', error);
      throw error;
    }
  }

  async formatContent() {
    const { query, num_results, results = [] } = this.result;
    const list = []
    for (const item of results) {
      const description = `URL: ${item.url}\nTitle: ${item.title}\nContent: ${item.content}\n`;
      list.push(description);
    }
    return list.join('======\n======');
  }

  async formatJSON() {
    const { results = [] } = this.result;
    return results;
  }

  /**
   * æ£€æŸ¥æœç´¢åŠŸèƒ½æ˜¯å¦æ­£å¸¸è¿è¡Œã€‚
   * é€šè¿‡æ‰§è¡Œä¸€ä¸ªç®€å•çš„æœç´¢æ¥éªŒè¯APIå¯†é’¥å’Œè¿æ¥ã€‚
   * @returns {Promise<{status: string, message: string}>} è¿”å›åŒ…å«çŠ¶æ€å’Œæ¶ˆæ¯çš„å¯¹è±¡ã€‚
   */
  async check() {
    try {
      // å°è¯•æ‰§è¡Œä¸€ä¸ªéå¸¸ç®€å•çš„æœç´¢ï¼Œåªè·å–ä¸€ä¸ªç»“æœ
      const testQuery = "test connection";
      const response = await axios.post(this.baseUrl, {
        query: testQuery,
        max_results: 1,
        search_depth: 'basic'
      }, {
        headers: {
          'Authorization': `Bearer ${this.API_KEY}`,
          'Content-Type': 'application/json'
        }
      });

      if (response.status === 200) {
        // å¦‚æœAPIè¿”å›200ï¼Œå³ä½¿æ²¡æœ‰ç»“æœï¼Œä¹Ÿè®¤ä¸ºè¿æ¥æˆåŠŸ
        return { status: 'success', message: 'Tavily Search API connection successful.' };
      } else {
        return { status: 'fail', message: `Tavily Search API returned status: ${response.status}` };
      }
    } catch (error) {
      if (error.response) {
        // APIè¿”å›äº†é”™è¯¯å“åº”ï¼ˆä¾‹å¦‚401ï¼Œ403ï¼Œ404ç­‰ï¼‰
        if (error.response.status === 401) {
          return { status: 'fail', message: 'Tavily Search API key is invalid or unauthorized.' };
        } else {
          return { status: 'fail', message: `Tavily Search API error: ${error.response.status} - ${error.response.statusText || 'Unknown error'}` };
        }
      } else if (error.request) {
        // è¯·æ±‚å·²å‘å‡ºä½†æœªæ”¶åˆ°å“åº”ï¼ˆä¾‹å¦‚ç½‘ç»œé—®é¢˜ï¼‰
        return { status: 'fail', message: 'No response received from Tavily Search API. Check network connection.' };
      } else {
        // å…¶ä»–é”™è¯¯
        return { status: 'fail', message: `An unexpected error occurred: ${error.message}` };
      }
    }
  }
}

module.exports = TalivySearch;


================================================
FILE: src/tools/impl/web_search/TalivySearch.run.js
================================================
require('dotenv').config();
require('module-alias/register')

const TalivySearch = require('@src/tools/impl/web_search/TalivySearch.js')

const run = async () => {
  const tool = new TalivySearch({ key: process.env.TAVILY_KEY })
  const result = await tool.search('åŒ—äº¬ä»Šæ—¥å¤©æ°”', { max_results: 3 })
  // console.log(JSON.stringify(result, null, 2))
  const formatted = await tool.formatContent()
  console.log(formatted)
}

run()


================================================
FILE: src/utils/check_llm_api_availability.js
================================================
async function checkLlmApiAvailability(baseUrl, apiKey='', model) {
  if (!baseUrl) {
    return { status: false, message: 'Base URL is required.' };
  }
  const api_url = baseUrl + '/chat/completions'
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), 8000);

  try {
    const response = await fetch(api_url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${apiKey}` // API key is usually passed as Bearer
      },
      body: JSON.stringify({
        // This is a simple example request body for the OpenAI Chat Completion API
        // **Important: Adjust according to your actual LLM API documentation**
        model: model, // Replace with the model name you are testing
        messages: [{
          role: "user",
          content: "hello" // A simple request content for testing
        }],
        max_tokens: 5, // Send a very small request to minimize resource usage and response time
        enable_thinking:false
      }),
      signal: controller.signal
    });

    if (response.ok) { // HTTP status code in the 200-299 range
      const data = await response.json();
      // Further check the response data, e.g., whether expected fields or error info exist
      // Different LLM API responses may vary, adjust as needed
      if (data && data.choices && data.choices.length > 0) {
        return { status: true, message: 'LLM API call succeeded.' };
      } else {
        return { status: false, message: 'LLM API call succeeded, but response data is not as expected.' };
      }
    } else {
      const errorText = await response.text();
      return { status: false, message: `LLM API call failed, HTTP status: ${response.status}, error: ${errorText}` };
    }
  } catch (error) {
    if (error.name === 'AbortError') {
      return { status: false, message: `LLM API call timed out: ${error.message}` };
    } else {
      return { status: false, message: `Network or other error occurred during LLM API call: ${error.message}` };
    }
  }
}

module.exports = exports = checkLlmApiAvailability;


================================================
FILE: src/utils/debug.js
================================================
// utils/safeExit.js
const path = require('path');
const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

function getCallerInfo() {
  const stack = new Error().stack.split('\n').slice(2); // è·³è¿‡ Error å’Œ safeExit è‡ªèº«
  const info = [];

  for (let i = 0; i < stack.length; i++) {
    const line = stack[i].trim();
    const match = line.match(/\(?(.+):(\d+):(\d+)\)?$/); // è§£ææ–‡ä»¶ã€è¡Œå·
    if (match) {
      const fullPath = match[1];
      const lineNumber = match[2];
      const columnNumber = match[3];
      info.push({
        file: path.relative(process.cwd(), fullPath),
        line: lineNumber,
        column: columnNumber,
        raw: line,
      });
    }
  }

  return info;
}

const safeExit = async (code = 0, message = '') => {
  const timestamp = new Date().toISOString();
  const callerStack = getCallerInfo();

  console.log('\n======== Safe Exit Triggered ========');
  console.log(`ğŸ•’ Time: ${timestamp}`);
  console.log(`ğŸ’¥ Exit Code: ${code}`);
  if (message) console.log(`ğŸ“¢ Message: ${message}`);

  if (callerStack.length) {
    console.log(`ğŸ“ Call Stack:`);
    callerStack.forEach((frame, index) => {
      console.log(`  ${index + 1}. ${frame.file}:${frame.line}:${frame.column}`);
    });
  } else {
    console.log(`âš ï¸ Stack trace not found`);
  }

  console.log('=====================================\n');
  await delay(1000);
  process.exit(code);
}

module.exports = {
  safeExit
};



================================================
FILE: src/utils/default_model.js
================================================
require('dotenv').config()
require("module-alias/register");
const DefaultModelSetting = require('@src/models/DefaultModelSetting');
const Model = require('@src/models/Model');
const Plantform = require('@src/models/Platform');
const Conversation = require('@src/models/Conversation')

const _defaultModelCache = {};

const _fetchDefaultModel = async (type = 'assistant') => {
  const defaultModelSetting = await DefaultModelSetting.findOne({ where: { setting_type: type } });
  if (!defaultModelSetting) return null;
  const model = await Model.findOne({ where: { id: defaultModelSetting.dataValues.model_id } });
  if (!model) return null;
  const model_name = model.dataValues.model_id;
  const platform = await Plantform.findOne({ where: { id: model.dataValues.platform_id } });
  if (!platform) return null;

  const api_key = platform.dataValues.api_key;
  const base_url = platform.dataValues.api_url
  let api_url = platform.dataValues.api_url;
  if (type === 'assistant') {
    api_url = platform.dataValues.api_url + '/chat/completions';
  }
  const platform_name = platform.dataValues.name;

  return { model_name, platform_name, api_key, api_url, base_url: base_url, is_subscribe: false };
};

const getDefaultModel = async (conversation_id) => {
  const conversation = await Conversation.findOne({ where: { conversation_id } })
  const model = await Model.findOne({ where: { id: conversation.dataValues.model_id } });
  if (!model) return null;
  const model_name = model.dataValues.model_id;
  const platform = await Plantform.findOne({ where: { id: model.dataValues.platform_id } });
  if (!platform) return null;

  const api_key = platform.dataValues.api_key;
  const base_url = platform.dataValues.api_url
  let api_url = platform.dataValues.api_url;
  api_url = platform.dataValues.api_url + '/chat/completions';
  const platform_name = platform.dataValues.name;

  return { model_name, platform_name, api_key, api_url, base_url: base_url, is_subscribe: platform.is_subscribe };
};

const getCustomModel = async (model_id) => {

  const model = await Model.findOne({ where: { model_id: model_id } });
  if (!model) return null;
  const model_name = model.dataValues.model_id;
  const platform = await Plantform.findOne({ where: { id: model.dataValues.platform_id } });
  if (!platform) return null;

  const api_key = platform.dataValues.api_key;
  const base_url = platform.dataValues.api_url
  let api_url = platform.dataValues.api_url;
  api_url = platform.dataValues.api_url + '/chat/completions';
  const platform_name = platform.dataValues.name;

  return { model_name, platform_name, api_key, api_url, base_url: base_url, is_subscribe: false };

};

const updateDefaultModel = async (type = 'assistant') => {
  const modelInfo = await _fetchDefaultModel(type);
  if (modelInfo) {
    _defaultModelCache[type] = modelInfo;
  }
  return modelInfo;
};

module.exports = {
  getDefaultModel,
  updateDefaultModel,
  getCustomModel,
};


================================================
FILE: src/utils/electron.js
================================================
// const { app } = require('electron');
const resolve = require('path').resolve;
const resourcesPath = process.resourcesPath;
console.log('LEMON_AI_PATH', process.env.LEMON_AI_PATH);
const LEMON_AI_PATH = process.env.LEMON_AI_PATH;

const getFilepath = (dir = 'database', filename) => {

  let filepath = resolve(__dirname, '../../', dir, filename);
  if (resourcesPath && resourcesPath.indexOf('node_modules') === -1) {
    filepath = resolve(resourcesPath, dir, filename);
  }

  if (LEMON_AI_PATH) {
    filepath = resolve(LEMON_AI_PATH, dir, filename);
  }
  console.log('filepath', filepath);
  return filepath;
}


//å¤„ç†æ–‡ä»¶å¤¹è·¯å¾„
const getDirpath = (dir, user_id) => {
  let filepath = resolve(__dirname, '../../', dir);
  if (user_id) {
    filepath = resolve(filepath, `user_${user_id}`)
  }
  if (resourcesPath && resourcesPath.indexOf('node_modules') === -1) {
    filepath = resolve(resourcesPath, dir);
  }

  if (LEMON_AI_PATH) {
    filepath = resolve(LEMON_AI_PATH, dir);
  }
  return filepath;
}

module.exports = exports = {
  getFilepath,
  getDirpath
}


================================================
FILE: src/utils/errors.js
================================================
/**
 * éœ€è¦æš‚åœçš„é”™è¯¯ç±»
 * ç”¨äºæ ‡è¯†éœ€è¦æš‚åœè€Œä¸æ˜¯è®©LLMä¿®å¤çš„é”™è¯¯
 */
class PauseRequiredError extends Error {
  constructor(message) {
    super(message);
    this.name = this.constructor.name;
    this.requiresPause = true;
    Error.captureStackTrace(this, this.constructor);
  }
}

/**
 * åˆ¤æ–­é”™è¯¯æ˜¯å¦ä¸ºéœ€è¦æš‚åœçš„é”™è¯¯ç±»å‹
 * @param {Error} error - è¦æ£€æŸ¥çš„é”™è¯¯å¯¹è±¡
 * @returns {boolean} - æ˜¯å¦ä¸ºéœ€è¦æš‚åœçš„é”™è¯¯
 */
function isPauseRequiredError(error) {
  if (error instanceof PauseRequiredError) {
    return true;
  }

  // æ£€æŸ¥é”™è¯¯æ¶ˆæ¯
  if (error && error.message) {
    // ç§¯åˆ†ä¸è¶³é”™è¯¯
    if (error.message.includes('Insufficient credits balance')) {
      return true;
    }

    // LLM è°ƒç”¨é”™è¯¯ (400/429)
    if (error.message.startsWith('ERR_BAD_REQUEST')) {
      return true;
    }
  }

  return false;
}

module.exports = {
  PauseRequiredError,
  isPauseRequiredError
};



================================================
FILE: src/utils/file_type_response.js
================================================


const imgTypeDict = { 'png': 'image/png', 'jpg': 'image/jpeg', 'jpeg': 'image/jpeg', 'gif': 'image/gif', 'webp': 'image/webp', 'svg': 'image/svg+xml' }
const officeTypeDict = { "pdf": "application/pdf", "xlsx": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", "docx": "application/vnd.openxmlformats-officedocument.wordprocessingml.document" }
function getContentTypeByFileName(/** @type {string} */ fileName) {
    const fileExtendName = fileName.split('.').pop();
    if (imgTypeDict[fileExtendName]) {
        return imgTypeDict[fileExtendName];
    } else if (officeTypeDict[fileExtendName]) {
        return officeTypeDict[fileExtendName];
    } else {
        return 'text/csv; charset=utf-8';
    }
}

module.exports = exports = {
    getContentTypeByFileName
}


================================================
FILE: src/utils/filePathHelper.js
================================================
const path = require('path');
const { getDirpath } = require('@src/utils/electron');

/**
 * è§£ææ–‡ä»¶è·¯å¾„ä¸ºç»å¯¹è·¯å¾„
 * @param {string} filepath - æ–‡ä»¶è·¯å¾„
 * @param {Object} state - åŒ…å«ç”¨æˆ·ä¿¡æ¯çš„çŠ¶æ€å¯¹è±¡
 * @returns {string} ç»å¯¹è·¯å¾„
 */
const resolveAbsolutePath = (filepath, state = {}) => {
  const userId = state.user?.id;
  let workspace_dir = process.env.WORKSPACE_DIR || 'workspace';
  if(process.env.DOCKER_HOST_ADDR){
    workspace_dir = "../"+workspace_dir;
  }
  const WORKSPACE_DIR = getDirpath(workspace_dir, userId);
  return path.join(WORKSPACE_DIR, filepath);
};

/**
 * æå–ç›¸å¯¹è·¯å¾„ï¼ˆä»Conversationå¼€å§‹ï¼‰
 * @param {string} filepath - å®Œæ•´æ–‡ä»¶è·¯å¾„
 * @returns {string} ç›¸å¯¹è·¯å¾„
 */
const extractRelativePath = (filepath) => {
  if (!filepath) return filepath;

  // å¦‚æœè·¯å¾„åŒ…å« Conversationï¼Œä»é‚£é‡Œå¼€å§‹æå–
  if (filepath.includes('Conversation')) {
    return filepath.substring(filepath.indexOf('Conversation'));
  }

  // å¦‚æœå·²ç»æ˜¯ç›¸å¯¹è·¯å¾„ï¼Œç›´æ¥è¿”å›
  if (!path.isAbsolute(filepath)) {
    return filepath;
  }

  // å°è¯•æå– workspace ä¹‹åçš„è·¯å¾„
  const workspaceIndex = filepath.lastIndexOf('workspace');
  if (workspaceIndex !== -1) {
    const afterWorkspace = filepath.substring(workspaceIndex + 'workspace'.length);
    return afterWorkspace.startsWith('/') ? afterWorkspace.substring(1) : afterWorkspace;
  }

  return filepath;
};

/**
 * æ ‡å‡†åŒ–æ–‡ä»¶è·¯å¾„
 * @param {string} filepath - æ–‡ä»¶è·¯å¾„
 * @returns {string} æ ‡å‡†åŒ–åçš„è·¯å¾„
 */
const normalizePath = (filepath) => {
  if (!filepath) return filepath;

  // ç»Ÿä¸€ä½¿ç”¨æ­£æ–œæ 
  return filepath.replace(/\\/g, '/');
};

module.exports = {
  resolveAbsolutePath,
  extractRelativePath,
  normalizePath
};


================================================
FILE: src/utils/format.js
================================================
/**
 * å°† JSON å¯¹è±¡è½¬æ¢ä¸º XML å­—ç¬¦ä¸²
 * @param {Object} obj - è¦è½¬æ¢çš„ JSON å¯¹è±¡
 * @returns {string} - è½¬æ¢åçš„ XML å­—ç¬¦ä¸²
 */
const json2xml = (obj) => {
  // å¤„ç†åŸºæœ¬æ•°æ®ç±»å‹
  if (typeof obj !== 'object') {
    return String(obj);
  }

  // å¤„ç†æ•°ç»„
  if (Array.isArray(obj)) {
    return obj.map(item => json2xml(item)).join('\n');
  }

  // å¤„ç†å¯¹è±¡
  return Object.entries(obj).map(([key, value]) => {
    // å¤„ç† null å’Œ undefined
    if (value === null || value === undefined) {
      return `<${key}/>\n`;
    }

    // å¤„ç†æ™®é€šèŠ‚ç‚¹
    const content = json2xml(value);
    // å¦‚æœå†…å®¹ä¸­å·²ç»åŒ…å«æ¢è¡Œç¬¦ï¼Œéœ€è¦å¯¹å†…å®¹è¿›è¡Œç¼©è¿›å¤„ç†
    const formattedContent = content.includes('\n')
      ? content.split('\n').map(line => line ? `  ${line}` : line).join('\n')
      : content;
    return `<${key}>\n${formattedContent}\n</${key}>`;
  }).join('\n');
}

module.exports = exports = {
  json2xml
}



================================================
FILE: src/utils/function.call.js
================================================
require('module-alias/register');
require('dotenv').config();

const tools = require("@src/tools/index");

const convertTool = (tool) => {
  const fn = {
    type: 'function',
    function: {
      name: tool.name,
      description: tool.description,
      parameters: tool.params
    }
  }
  return fn;
}

const resolveFunctionCall = async () => {
  const list = Object.values(tools);
  // @ts-ignore
  return list.map(convertTool);
}

module.exports = exports = resolveFunctionCall;


================================================
FILE: src/utils/get_sub_server_token_usage.js
================================================
const Conversation = require('@src/models/Conversation')

const conversation_token_usage = async (token_usage, conversation_id) => {
  const { input_tokens, output_tokens } = token_usage
  if (conversation_id) {
    const conversation = await Conversation.findOne({ where: { conversation_id: conversation_id } })
    if (conversation) {
      conversation.input_tokens = conversation.input_tokens + input_tokens
      conversation.output_tokens = conversation.output_tokens + output_tokens
      await conversation.save()
    }
  }
}

module.exports = exports = conversation_token_usage;




================================================
FILE: src/utils/img_upload.js
================================================
require('dotenv').config()
const fs = require('fs').promises;
const path = require('path');
const { takeScreenshot } = require('./screen_shot');

/**
 * File upload utility class (local storage)
 */
class ImgUploader {
    constructor() {
        console.log('File upload utility initialized successfully (local storage mode)');
    }

    /**
     * Generate unique file name
     * @param {string} originalName - Original file name
     * @param {string} prefix - File prefix
     * @returns {string} Unique file name
     */
    generateUniqueFileName(originalName, prefix = 'screenshots') {
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const randomStr = Math.random().toString(36).substring(2, 8);
        const ext = path.extname(originalName);
        const name = path.basename(originalName, ext);

        return `${prefix}/${name}${ext}`;
    }

    /**
     * Save file to public folder
     * @param {string|Buffer} file - File path, Buffer or base64 string
     * @param {Object} options - Upload options
     * @param {string} [options.objectName] - File name
     * @param {string} [options.prefix] - File prefix (subfolder)
     * @returns {Promise<Object>} Save result
     */
    async uploadFile(file, options = {}) {
        const {
            objectName,
            prefix = 'uploads'
        } = options;

        try {
            let buffer;
            let fileName;

            // Handle file input
            if (typeof file === 'string') {
                // Check if it's a base64 string
                if (file.startsWith('data:image/')) {
                    const matches = file.match(/^data:([^;]+);base64,(.+)$/);
                    if (matches) {
                        const mimeType = matches[1];
                        const base64Data = matches[2];
                        buffer = Buffer.from(base64Data, 'base64');
                        // Determine file extension based on MIME type
                        const ext = this.getExtensionFromMimeType(mimeType);
                        fileName = options.fileName || `screenshot-${Date.now()}${ext}`;
                    } else {
                        throw new Error('Invalid base64 data format');
                    }
                } else {
                    // File path
                    buffer = await fs.readFile(file);
                    fileName = path.basename(file);
                }
            } else if (Buffer.isBuffer(file)) {
                // Buffer
                buffer = file;
                fileName = options.fileName || `file-${Date.now()}`;
            } else {
                throw new Error('Unsupported file type');
            }

            // Generate file name
            const finalFileName = objectName || this.generateUniqueFileName(fileName, prefix);

            // Build save path (ensure it's under the project root's public folder)
            const projectRoot = path.resolve(__dirname, '../../');
            const publicDir = path.join(projectRoot, 'public');
            const targetDir = path.join(publicDir, path.dirname(finalFileName));
            const targetPath = path.join(publicDir, finalFileName);

            // Ensure target directory exists
            await fs.mkdir(targetDir, { recursive: true });

            console.log(`Starting to save file locally: ${targetPath}`);

            // Save file to public folder
            await fs.writeFile(targetPath, buffer);

            // Generate access URL (relative to public folder path)
            const url = `http://localhost:5005/${finalFileName.replace(/\\/g, '/')}`;

            console.log('File saved successfully:', url);

            return {
                success: true,
                url: url,
                objectName: finalFileName,
                localPath: targetPath,
                size: buffer.length,
                fileName: fileName
            };

        } catch (error) {
            console.error('File save failed:', error.message);
            return {
                success: false,
                error: error.message,
                fileName: typeof file === 'string' ? path.basename(file) : 'unknown'
            };
        }
    }

    /**
     * Get Content-Type based on file name
     * @param {string} fileName - File name
     * @returns {string} Content-Type
     */
    getContentType(fileName) {
        const ext = path.extname(fileName).toLowerCase();
        const mimeTypes = {
            '.png': 'image/png',
            '.jpg': 'image/jpeg',
            '.jpeg': 'image/jpeg',
            '.gif': 'image/gif',
            '.webp': 'image/webp',
            '.svg': 'image/svg+xml',
            '.pdf': 'application/pdf',
            '.txt': 'text/plain',
            '.json': 'application/json',
            '.xml': 'application/xml',
            '.html': 'text/html',
            '.css': 'text/css',
            '.js': 'application/javascript'
        };

        return mimeTypes[ext] || 'application/octet-stream';
    }

    /**
     * Get file extension based on MIME type
     * @param {string} mimeType - MIME type
     * @returns {string} File extension
     */
    getExtensionFromMimeType(mimeType) {
        const extensionMap = {
            'image/png': '.png',
            'image/jpeg': '.jpg',
            'image/jpg': '.jpg',
            'image/gif': '.gif',
            'image/webp': '.webp',
            'image/svg+xml': '.svg',
            'application/pdf': '.pdf',
            'text/plain': '.txt',
            'application/json': '.json',
            'application/xml': '.xml',
            'text/html': '.html',
            'text/css': '.css',
            'application/javascript': '.js'
        };

        return extensionMap[mimeType] || '.png'; // Default to png
    }

    /**
     * Generate web page screenshot and save to public folder
     * @param {string} url - Web page URL to screenshot
     * @param {Object} screenshotOptions - Screenshot options
     * @param {Object} uploadOptions - Upload options
     * @returns {Promise<Object>} Screenshot save result
     */
    async takeScreenshotAndUpload(url, screenshotOptions = {}, uploadOptions = {}) {
        try {
            console.log(`Starting to generate web page screenshot: ${url}`);

            // Generate screenshot
            const screenshotResult = await takeScreenshot(url, screenshotOptions);

            if (!screenshotResult.success) {
                return {
                    success: false,
                    error: screenshotResult.error,
                    url: url
                };
            }

            // Save screenshot to public folder
            const uploadResult = await this.uploadFile(screenshotResult.buffer, {
                fileName: path.basename(screenshotResult.outputPath),
                prefix: 'screenshots',
                ...uploadOptions
            });

            if (uploadResult.success) {
                // Clean up temporary screenshot file
                try {
                    await fs.unlink(screenshotResult.outputPath);
                    console.log('Temporary screenshot file cleaned up');
                } catch (cleanupError) {
                    console.warn('Failed to clean up temporary file:', cleanupError.message);
                }
            }

            return {
                success: uploadResult.success,
                screenshotUrl: uploadResult.url,
                screenshotInfo: screenshotResult.pageInfo,
                screenshotOptions: screenshotResult.options,
                originalUrl: url,
                error: uploadResult.error
            };

        } catch (error) {
            console.error('Screenshot save failed:', error.message);
            return {
                success: false,
                error: error.message,
                url: url
            };
        }
    }

    /**
     * Generate multiple screenshots and save in batch
     * @param {Array} urls - URL array
     * @param {Object} screenshotOptions - Screenshot options
     * @param {Object} uploadOptions - Upload options
     * @returns {Promise<Array>} Batch save results
     */
    async takeMultipleScreenshotsAndUpload(urls, screenshotOptions = {}, uploadOptions = {}) {
        const results = [];

        for (let i = 0; i < urls.length; i++) {
            const url = urls[i];
            console.log(`\nProcessing URL ${i + 1}/${urls.length}: ${url}`);

            const result = await this.takeScreenshotAndUpload(url, screenshotOptions, uploadOptions);
            results.push(result);

            // Add delay to avoid too fast requests
            if (i < urls.length - 1 && screenshotOptions.delay) {
                await new Promise(resolve => setTimeout(resolve, screenshotOptions.delay));
            }
        }

        return results;
    }

    /**
     * Delete local file
     * @param {string} fileName - File name (relative to public folder)
     * @returns {Promise<Object>} Delete result
     */
    async deleteFile(fileName) {
        try {
            const projectRoot = path.resolve(__dirname, '../../');
            const publicDir = path.join(projectRoot, 'public');
            const filePath = path.join(publicDir, fileName);

            await fs.unlink(filePath);
            console.log('File deleted successfully:', fileName);

            return {
                success: true,
                fileName: fileName,
                localPath: filePath
            };

        } catch (error) {
            console.error('File deletion failed:', error.message);
            return {
                success: false,
                error: error.message,
                fileName: fileName
            };
        }
    }

    /**
     * Get file access URL
     * @param {string} fileName - File name (relative to public folder)
     * @returns {string} File access URL
     */
    getFileUrl(fileName) {
        // Return relative path URL
        return `/${fileName.replace(/\\/g, '/')}`;
    }

    /**
     * Check if file exists
     * @param {string} fileName - File name (relative to public folder)
     * @returns {Promise<boolean>} Whether file exists
     */
    async fileExists(fileName) {
        try {
            const projectRoot = path.resolve(__dirname, '../../');
            const publicDir = path.join(projectRoot, 'public');
            const filePath = path.join(publicDir, fileName);

            await fs.access(filePath);
            return true;
        } catch (error) {
            return false;
        }
    }

    /**
     * Save base64 image to public folder
     * @param {string} base64Data - Base64 format image data
     * @param {Object} options - Save options
     * @param {string} [options.prefix] - File prefix, defaults to 'screenshots'
     * @param {string} [options.fileName] - Custom file name
     * @returns {Promise<Object>} Save result
     */
    async uploadBase64Image(base64Data, options = {}) {
        try {
            if (!base64Data || typeof base64Data !== 'string' || !base64Data.startsWith('data:image/')) {
                throw new Error('Invalid base64 image data');
            }

            const uploadOptions = {
                prefix: 'screenshots',
                ...options
            };

            const result = await this.uploadFile(base64Data, uploadOptions);
            if (result.success) {
                console.log('Base64 image saved successfully:', result.url);
            }
            return result;
        } catch (error) {
            console.error('Base64 image save failed:', error.message);
            return {
                success: false,
                error: error.message
            };
        }
    }

    /**
     * Save AI-generated image result to public folder
     * @param {Object} imageResult - AI-generated image result
     * @param {Object} uploadOptions - Save options
     * @returns {Promise<Object>} AI-generated image save result
     */
    async uploadGeneratedImageToOSS(imageResult, uploadOptions = {}) {
        try {
            console.log(`ğŸ¨ Starting to save AI-generated image locally`);

            if (!imageResult || !imageResult.success) {
                return {
                    success: false,
                    error: imageResult?.error || 'Invalid image generation result',
                    imageResult: imageResult
                };
            }

            const imageData = imageResult.data;
            const imageUrl = imageData.imageUrl;
            const metadata = imageData.metadata || {};
            const prompt = imageData.originalPrompt || imageData.prompt || 'unknown';

            // Generate file name
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const shortPrompt = prompt.substring(0, 30).replace(/[^a-zA-Z0-9\u4e00-\u9fa5]/g, '_');
            const fileName = uploadOptions.fileName || `ai_image_${shortPrompt}_${timestamp}.png`;

            // Prepare save options
            const finalUploadOptions = {
                fileName: fileName,
                prefix: 'ai-generated-images',
                ...uploadOptions
            };

            // Save image to public folder
            const uploadResult = await this.uploadFile(imageUrl, finalUploadOptions);

            if (!uploadResult.success) {
                return {
                    success: false,
                    error: uploadResult.error,
                    originalImageUrl: imageUrl,
                    imageResult: imageResult
                };
            }

            console.log('AI-generated image saved successfully:', uploadResult.url);

            return {
                success: true,
                imageUrl: uploadResult.url,
                originalImageUrl: imageUrl,
                imageInfo: {
                    prompt: prompt,
                    metadata: metadata,
                    fileName: uploadResult.fileName,
                    objectName: uploadResult.objectName,
                    size: uploadResult.size
                },
                originalResult: imageResult,
                uploadInfo: {
                    url: uploadResult.url,
                    objectName: uploadResult.objectName,
                    localPath: uploadResult.localPath
                }
            };

        } catch (error) {
            console.error('AI-generated image save failed:', error.message);
            return {
                success: false,
                error: error.message,
                imageResult: imageResult
            };
        }
    }
}

// Create singleton instance
const imgUploader = new ImgUploader();


module.exports = {
    ImgUploader,
    imgUploader,
    // Convenience methods
    uploadFile: (file, options) => imgUploader.uploadFile(file, options),
    uploadBase64Image: (base64Data, options) => imgUploader.uploadBase64Image(base64Data, options),
}; 


================================================
FILE: src/utils/json.js
================================================
const resolveThinking = require('@src/utils/thinking.js')

const parseJSON = (content) => {
  content = content.trim();
  if (content.startsWith('<think>')) {
    const { thinking: _, content: output } = resolveThinking(content);
    content = output;
  }

  const startIndex = content.indexOf('```json');
  const endIndex = content.lastIndexOf('```');
  if (startIndex !== -1 && endIndex > startIndex) {
    content = content.substring(startIndex + '```json'.length, endIndex).trim();
  }

  try {
    return JSON.parse(content);
  } catch (err) {
    if (content === 'ERR_BAD_REQUEST') {
      throw new Error(`Large model call failed`);
    } else {
      console.log('JSON parse failed for content:', content);
      throw new Error(`parseJSON failed: ${err.message}`);
    }
  }
}

module.exports = exports = parseJSON;


================================================
FILE: src/utils/jwt.js
================================================
// https://github.com/auth0/node-jsonwebtoken
const jwt = require('jsonwebtoken');
const JWT_SECRET = process.env.JWT_SECRET || 'local';

const encodeToken = (info = {}) => {
  const token = jwt.sign(info, JWT_SECRET);
  return token;
}

const decodeToken = token => {
  try {
    const decoded = jwt.verify(token, JWT_SECRET);
    return decoded;
  } catch (error) {
    return null;
  }
}

module.exports = exports = {
  encodeToken,
  decodeToken
};


================================================
FILE: src/utils/llm.js
================================================
const { getDefaultModel } = require('@src/utils/default_model')

const createLLMInstance = require("@src/completion/llm.one.js");
const parseJSON = require("./json.js");
const { PauseRequiredError } = require("@src/utils/errors");

const calcToken = require('@src/completion/calc.token.js')
const Conversation = require('@src/models/Conversation.js')


const defaultOnTokenStream = (ch) => {
  process.stdout.write(ch);
}

const DEFAULT_MODEL_TYPE = "assistant";

const LLM_LOGS = require('@src/models/LLMLogs.js');

/**
 * @param {*} prompt 
 * @param {*} model_type 
 * @param {*} options 
 * @param {*} onTokenStream 
 * @returns {Promise<Object>}
 */
const call = async (prompt, conversation_id, model_type = DEFAULT_MODEL_TYPE, options = { temperature: 0 }, onTokenStream = defaultOnTokenStream) => {
  const model_info = await getDefaultModel(conversation_id)
  const model = `provider#${model_info.platform_name}#${model_info.model_name}`;
  const llm = await createLLMInstance(model, onTokenStream, { model_info });
  // åˆ¤æ–­æ¨¡å‹
  if (model_info.model_name === 'deepseek-v3-250324') {
    options.max_tokens = 16000;
  } else if (model_info.model_name === 'deepseek-v3-1-250821') {
    options.max_tokens = 32000;
  }
  
  const { response_format, messages = [], ...restOptions } = options;
  const context = { messages };

  // call qwen3 model with no_think
  if (prompt && model_info.model_name.indexOf('qwen3') > -1) {
    prompt = '/no_think' + prompt;
  }

  const content = await llm.completion(prompt, context, restOptions);

  // å¤„ç† ERR_BAD_REQUEST é”™è¯¯
  if (typeof content === 'string' && content.startsWith('ERR_BAD_REQUEST')) {
    throw new PauseRequiredError("LLM Call Failed");
  }

  const inputPrompt = messages.map(item => item.content).join('\n') + '\n' + prompt;
  const input_tokens = calcToken(inputPrompt)
  const output_tokens = calcToken(content)
  if (conversation_id) {
    const conversation = await Conversation.findOne({ where: { conversation_id: conversation_id } })
    if (conversation) {
      // @ts-ignore
      conversation.input_tokens = conversation.input_tokens + input_tokens
      // @ts-ignore
      conversation.output_tokens = conversation.output_tokens + output_tokens
      await conversation.save()
    }
  }

  if (response_format === 'json') {
    const json = parseJSON(content);
    // @ts-ignore
    await LLM_LOGS.create({ model, prompt, messages, content, json, conversation_id });
    return json;
  }
  // @ts-ignore
  await LLM_LOGS.create({ model, prompt, messages, content, conversation_id });
  //return content
  return content;
}

module.exports = exports = call;



================================================
FILE: src/utils/markdown.js
================================================
const marked = require('marked');

const resolveMarkdown = async (markdown) => {

  const tokens = marked.lexer(markdown);
  const list = [];
  let title = '';
  let content = '';
  for (const token of tokens) {
    if (token.type === 'heading') {
      if (title) {
        list.push({ title, content });
        title = '';
        content = '';
      }
      title = token.text;
    } else {
      content += token.raw;
    }
  }
  if (title && content) {
    list.push({ title, content });
  }
  return list.map(item => {
    // @ts-ignore
    item.description = item.title + '\n' + item.content;
    return item;
  })
}

module.exports = exports = {
  resolveMarkdown
}


================================================
FILE: src/utils/message.js
================================================
// utils/message.js
const MessageTable = require('@src/models/Message');
const Conversation = require('@src/models/Conversation')
class Message {
  /**
   * æ„å»ºæ¶ˆæ¯æ ¼å¼
   * @param {Object} params å‚æ•°å¯¹è±¡
   * @param {('success'|'failure'|'running')} params.status æˆåŠŸæˆ–å¤±è´¥
   * @param {string} [params.content] æ–‡æœ¬å†…å®¹
   * @param {string} [params.task_id]
   * @param {('plan'|'task'|'auto_reply'|'finish'|'search'|'file'|'terminal'|'todo'|'browser'|'question'|'finish_summery'|'progress')} [params.action_type]
   * @param {string} [params.filepath]
   * @param {string} [params.url]
   * @param {Array} [params.json]
   * @param {string} [params.comments]
   * @param {boolean} [params.memorized]
   * @param {string} [params.role]
   * @param {string} [params.uuid] 
   * @param {string} [params.meta_content]
   * @returns {Object}
   */
  static format({ status, content = '', task_id = '', action_type = '', filepath = '', url = '', json = [], comments = '', memorized = '', uuid = '', role = 'assistant', meta_content = '', pid = '', type = '', is_active = true }) {
    return {
      role,
      uuid,
      status,
      content,
      comments,
      memorized,
      timestamp: new Date().valueOf(),
      type,
      meta: {
        pid,
        task_id,
        action_type,
        filepath,
        url,
        json,
        content: meta_content,
        is_active
      }
    };
  }

  /**
   * å­˜å‚¨æ¶ˆæ¯åˆ°æ•°æ®åº“
   * @param {Object} messageData æ¶ˆæ¯æ•°æ®ï¼ˆä¸ format è¿”å›ç»“æ„ç›¸åŒï¼‰
   * @returns {Promise<MessageTable>}
   */
  static async saveToDB(messageData, conversation_id) {
    try {
      const conversation = await Conversation.findOne({ where: { conversation_id } })
      return await MessageTable.create({
        role: messageData.role,
        uuid: messageData.uuid,
        conversation_id: conversation_id,
        timestamp: messageData.timestamp,
        status: messageData.status,
        content: messageData.content,
        meta: JSON.stringify(messageData.meta),
        comments: messageData.comments,
        memorized: messageData.memorized,
        user_id: conversation.dataValues.user_id,
      });
    } catch (err) {
      console.error('ä¿å­˜æ¶ˆæ¯å¤±è´¥:', err);
      throw err;
    }
  }
  static async updateToDB(messageData, conversation_id) {
  }
}

module.exports = Message;



================================================
FILE: src/utils/network.js
================================================
const axios = require('axios');

const proxy = {
  protocol: process.env.PROXY_PROTOCOL || 'http',
  host: process.env.PROXY_HOST,
  port: process.env.PROXY_PROT
}

const resolveAxiosInstance = () => {
  if (process.env.PROXY_HOST) {
    const instance = axios.create({
      proxy: proxy
    });
    return instance;
  }
  return axios.create({});
}

module.exports = exports = {
  resolveAxiosInstance
}


================================================
FILE: src/utils/planning.js
================================================

const getTodoMd = async (taskData) => {
  const markdownOutput = convertArrayToMarkdownTodo(taskData);
  return markdownOutput
}

function convertArrayToMarkdownTodo(data) {
  let markdown = "## TODO List\n";

  /**
   * è§£æä»»åŠ¡çš„æ ‡é¢˜å’Œæè¿°
   * @param {Object} task - ä»»åŠ¡å¯¹è±¡
   * @returns {Object} åŒ…å« title å’Œ description çš„å¯¹è±¡
   */
  function parseTaskTitleAndDescription(task) {
    let title = task.title || "";
    let description = task.description || "";

    // å¦‚æœæ²¡æœ‰ title æˆ– descriptionï¼Œä» requirement ä¸­æ‹†åˆ†
    if ((!title || !description) && task.requirement) {
      const lines = task.requirement.split('\n').filter(line => line.trim());
      if (lines.length > 0) {
        // ç¬¬ä¸€è¡Œä½œä¸º title
        if (!title) {
          title = lines[0].trim();
        }
        // å‰©ä¸‹çš„è¡Œä½œä¸º description
        if (!description && lines.length > 1) {
          description = lines.slice(1).join('\n').trim();
        }
      }
    }

    return { title, description };
  }

  /**
   * é€’å½’å¤„ç†å•ä¸ªä»»åŠ¡èŠ‚ç‚¹ï¼Œæ”¯æŒå¤šå±‚çº§å­ä»»åŠ¡
   * @param {Object} task - ä»»åŠ¡å¯¹è±¡
   * @param {number} depth - å½“å‰æ·±åº¦ï¼Œç”¨äºæ§åˆ¶ç¼©è¿›
   */
  function formatTask(task, depth = 0) {
    const indent = "  ".repeat(depth); // æ¯å±‚ç¼©è¿›2ä¸ªç©ºæ ¼
    const checkbox = task.status === "pending" ? "[ ]" : "[x]";
    const { title, description } = parseTaskTitleAndDescription(task);

    // æ„å»ºä»»åŠ¡æè¿°
    let taskText = title;
    if (description && description !== title) {
      taskText += `: ${description}`;
    }

    let result = `${indent}- ${checkbox} ${taskText}\n`;

    // é€’å½’å¤„ç†å­ä»»åŠ¡
    if (task.children && Array.isArray(task.children) && task.children.length > 0) {
      for (const child of task.children) {
        result += formatTask(child, depth + 1);
      }
    }

    return result;
  }

  // å¤„ç†æ‰€æœ‰é¡¶çº§ä»»åŠ¡
  if (Array.isArray(data)) {
    data.forEach(item => {
      markdown += formatTask(item);
    });
  }

  return markdown;
}

module.exports = exports = {
  getTodoMd
}


================================================
FILE: src/utils/resolve.js
================================================
// https://github.com/NaturalIntelligence/fast-xml-parser
const { XMLParser, XMLBuilder, XMLValidator } = require("fast-xml-parser");
const parser = new XMLParser({
  stopNodes: ["write_code.content", "revise_plan.tasks"],
  ignoreAttributes: false,
});

const resolveXML = (content) => {
  // è¾“å…¥éªŒè¯
  if (!content || typeof content !== 'string') {
    throw new Error('XMLå†…å®¹å¿…é¡»æ˜¯éç©ºå­—ç¬¦ä¸²');
  }

  // è§£æXMLå†…å®¹
  const result = parser.parse(content);

  // é€šç”¨CDATAå¤„ç†å‡½æ•°
  const processCDATA = (text) => {
    if (!text || typeof text !== 'string') return text;
    const trimmed = text.trim();
    if (trimmed.startsWith('<![CDATA[') && trimmed.endsWith(']]>')) {
      return trimmed.slice(9, -3); // ç§»é™¤ <![CDATA[ å’Œ ]]>
    }
    return text;
  };

  // å¤„ç†write_code.contentçš„CDATA
  if (result.write_code?.content) {
    result.write_code.content = processCDATA(result.write_code.content);
  }

  // å¤„ç†revise_plan.tasksçš„CDATAå’ŒJSONè§£æ
  if (result.revise_plan?.tasks) {
    result.revise_plan.tasks = processCDATA(result.revise_plan.tasks);

    // å°è¯•è§£æJSON
    if (typeof result.revise_plan.tasks === 'string') {
      try {
        result.revise_plan.tasks = JSON.parse(result.revise_plan.tasks);
      } catch (error) {
        console.warn('JSON è§£æå¤±è´¥:', error.message);
        console.warn('åŸå§‹å†…å®¹:', result.revise_plan.tasks);
        return {
          'parse_error': {
            'message': `JSON è§£æå¤±è´¥: ${error.message}; è¯·æ³¨æ„ tasks çš„ JSON Array æ ¼å¼æ˜¯å¦æ­£ç¡®`,
            'content': result.revise_plan.tasks
          }
        }
      }
    }
  }

  return result;
}

const resolveActions = xml => {
  try {
    const resolved = resolveXML(xml);
    const actions = []
    for (let key in resolved) {
      const value = resolved[key];
      const action = {
        type: key,
        params: value
      }
      actions.push(action);
    }
    return actions;
  } catch (err) {
    console.log(err);
    return [];
  }
}

module.exports = {
  resolveXML,
  resolveActions
};


================================================
FILE: src/utils/screen_shot.js
================================================
const { chromium } = require('playwright');
const path = require('path');
const fs = require('fs').promises;

/**
 * ä½¿ç”¨ Playwright ç”Ÿæˆç½‘é¡µæˆªå›¾
 * @param {string} url - è¦æˆªå›¾çš„ç½‘é¡µURL
 * @param {Object} [options] - æˆªå›¾é€‰é¡¹
 * @param {string} [options.outputPath] - è¾“å‡ºæ–‡ä»¶è·¯å¾„ (å¯é€‰ï¼Œé»˜è®¤ç”Ÿæˆæ—¶é—´æˆ³æ–‡ä»¶å)
 * @param {number} [options.width=1920] - æµè§ˆå™¨çª—å£å®½åº¦
 * @param {number} [options.height=1080] - æµè§ˆå™¨çª—å£é«˜åº¦
 * @param {number} [options.timeout=30000] - é¡µé¢åŠ è½½è¶…æ—¶æ—¶é—´ (ms)
 * @param {boolean} [options.fullPage=true] - æ˜¯å¦æˆªå–å®Œæ•´é¡µé¢
 * @param {'png'|'jpeg'} [options.format='png'] - å›¾ç‰‡æ ¼å¼
 * @param {number} [options.quality=90] - å›¾ç‰‡è´¨é‡ 0-100 (ä»…å¯¹jpegæœ‰æ•ˆ)
 * @param {boolean} [options.headless=true] - æ˜¯å¦æ— å¤´æ¨¡å¼
 * @param {number} [options.waitTime=2000] - é¡µé¢åŠ è½½åç­‰å¾…æ—¶é—´ (ms)
 * @param {string} [options.accessToken] - è®¿é—®ä»¤ç‰Œï¼Œç”¨äºè®¾ç½®è¯·æ±‚å¤´
 * @param {string} [options.conversation_id] - ä¼šè¯IDï¼Œç”¨äºæ‹¼æ¥æ–‡ä»¶å
 * @returns {Promise<Object>} è¿”å›æˆªå›¾ä¿¡æ¯
 */
async function takeScreenshot(url, options = {}) {
    const {
        outputPath,
        width = 1920,
        height = 1080,
        timeout = 30000,
        fullPage = true,
        format = 'png',
        quality = 90,
        headless = true,
        waitTime = 2000,
        accessToken, // ä½ çš„ token
        conversation_id,
    } = options;
    const localStorageKey = 'access_token' // localStorage çš„ key

    let browser = null;
    let page = null;

    try {
        browser = await chromium.launch({ headless });
        page = await browser.newPage({ viewport: { width, height } });
        page.setDefaultTimeout(timeout);

        // 1. å…ˆè®¿é—®åŒæºé¡µé¢ï¼ˆå¦‚é¦–é¡µï¼‰
        const baseUrl = url.split('/').slice(0, 3).join('/');
        try {
            await page.goto(baseUrl, { waitUntil: 'domcontentloaded', timeout: 10000 });
        } catch (error) {
            console.log('è®¿é—®åŸºç¡€é¡µé¢å¤±è´¥ï¼Œç»§ç»­å°è¯•ç›´æ¥è®¿é—®ç›®æ ‡é¡µé¢');
        }

        // 2. è®¾ç½® localStorage
        if (accessToken) {
            try {
                await page.evaluate(
                    ([key, value]) => localStorage.setItem(key, value),
                    [localStorageKey, accessToken]
                );
            } catch (error) {
                console.log('è®¾ç½®localStorageå¤±è´¥:', error.message);
            }
        }

        // 3. è·³è½¬åˆ°ç›®æ ‡é¡µé¢
        console.log(`æ­£åœ¨è®¿é—®: ${url}`);
        
        // å°è¯•å¤šç§ç­‰å¾…ç­–ç•¥
        let pageLoaded = false;
        const waitStrategies = [
            { waitUntil: 'domcontentloaded', timeout: 15000 },
            { waitUntil: 'load', timeout: 20000 },
            { waitUntil: 'networkidle', timeout: 30000 }
        ];

        for (const strategy of waitStrategies) {
            try {
                await page.goto(url, strategy);
                pageLoaded = true;
                console.log(`é¡µé¢åŠ è½½æˆåŠŸï¼Œä½¿ç”¨ç­–ç•¥: ${strategy.waitUntil}`);
                break;
            } catch (error) {
                console.log(`ç­–ç•¥ ${strategy.waitUntil} å¤±è´¥: ${error.message}`);
                if (strategy === waitStrategies[waitStrategies.length - 1]) {
                    throw error; // æœ€åä¸€ä¸ªç­–ç•¥ä¹Ÿå¤±è´¥äº†
                }
            }
        }

        // ç­‰å¾…æŒ‡å®šæ—¶é—´ï¼Œç¡®ä¿é¡µé¢å®Œå…¨åŠ è½½
        if (waitTime > 0) {
            console.log(`ç­‰å¾… ${waitTime}ms ç¡®ä¿é¡µé¢å®Œå…¨åŠ è½½...`);
            await page.waitForTimeout(waitTime);
        }

        // æ£€æŸ¥é¡µé¢æ˜¯å¦çœŸçš„åŠ è½½äº†å†…å®¹
        const pageContent = await page.content();
        if (!pageContent || pageContent.length < 100) {
            throw new Error('é¡µé¢å†…å®¹ä¸ºç©ºæˆ–è¿‡å°‘ï¼Œå¯èƒ½åŠ è½½å¤±è´¥');
        }

        // ç”Ÿæˆè¾“å‡ºæ–‡ä»¶è·¯å¾„
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const defaultFileName = `screenshot-${conversation_id}.${format}`;
        const finalOutputPath = outputPath || path.join(__dirname, '../../public', 'screenshots', defaultFileName);

        // ç¡®ä¿è¾“å‡ºç›®å½•å­˜åœ¨
        const outputDir = path.dirname(finalOutputPath);
        await fs.mkdir(outputDir, { recursive: true });

        // ç”Ÿæˆæˆªå›¾
        console.log(`æ­£åœ¨ç”Ÿæˆæˆªå›¾: ${finalOutputPath}`);
        const screenshotBuffer = await page.screenshot({
            path: finalOutputPath,
            fullPage: fullPage,
            type: format === 'jpeg' ? 'jpeg' : 'png',
            quality: format === 'jpeg' ? quality : undefined
        });

        // è·å–é¡µé¢ä¿¡æ¯
        const pageInfo = {
            title: await page.title(),
            url: page.url(),
            viewport: await page.viewportSize()
        };

        console.log('æˆªå›¾ç”ŸæˆæˆåŠŸ!');

        return {
            success: true,
            outputPath: finalOutputPath,
            buffer: screenshotBuffer,
            pageInfo: pageInfo,
            options: {
                width,
                height,
                fullPage,
                format,
                quality
            }
        };

    } catch (error) {
        console.error('æˆªå›¾ç”Ÿæˆå¤±è´¥:', error.message);
        
        // å°è¯•è·å–æ›´å¤šé”™è¯¯ä¿¡æ¯
        if (page) {
            try {
                const currentUrl = page.url();
                const title = await page.title();
                console.error(`å½“å‰é¡µé¢URL: ${currentUrl}`);
                console.error(`é¡µé¢æ ‡é¢˜: ${title}`);
            } catch (e) {
                console.error('æ— æ³•è·å–é¡µé¢ä¿¡æ¯:', e.message);
            }
        }

        return {
            success: false,
            error: error.message,
            url: url
        };
    } finally {
        // æ¸…ç†èµ„æº
        if (page) {
            await page.close();
        }
        if (browser) {
            await browser.close();
        }
    }
}

/**
 * æ‰¹é‡ç”Ÿæˆæˆªå›¾
 * @param {Array} urls - URLæ•°ç»„
 * @param {Object} options - æˆªå›¾é€‰é¡¹
 * @returns {Promise<Array>} è¿”å›æˆªå›¾ç»“æœæ•°ç»„
 */
async function takeMultipleScreenshots(urls, options = {}) {
    const results = [];

    for (let i = 0; i < urls.length; i++) {
        const url = urls[i];
        console.log(`\nå¤„ç†ç¬¬ ${i + 1}/${urls.length} ä¸ªURL: ${url}`);

        const result = await takeScreenshot(url, {
            ...options,
            outputPath: options.outputPath ?
                options.outputPath.replace('.png', `-${i + 1}.png`) :
                undefined
        });

        results.push(result);

        // æ·»åŠ å»¶è¿Ÿé¿å…è¿‡å¿«è¯·æ±‚
        if (i < urls.length - 1 && options.delay) {
            await new Promise(resolve => setTimeout(resolve, options.delay));
        }
    }

    return results;
}

/**
 * ç”ŸæˆPDFç‰ˆæœ¬ï¼ˆå¯é€‰åŠŸèƒ½ï¼‰
 * @param {string} url - è¦è½¬æ¢çš„ç½‘é¡µURL
 * @param {Object} options - PDFé€‰é¡¹
 * @returns {Promise<Object>} è¿”å›PDFç”Ÿæˆç»“æœ
 */
async function generatePDF(url, options = {}) {
    const {
        outputPath,
        width = 1920,
        height = 1080,
        timeout = 30000,
        headless = true,
        waitTime = 2000
    } = options;

    let browser = null;
    let page = null;

    try {
        browser = await chromium.launch({ headless: headless });
        page = await browser.newPage({ viewport: { width, height } });
        page.setDefaultTimeout(timeout);

        await page.goto(url, { waitUntil: 'networkidle' });

        if (waitTime > 0) {
            await page.waitForTimeout(waitTime);
        }

        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const defaultFileName = `page-${timestamp}.pdf`;
        const finalOutputPath = outputPath || path.join(process.cwd(), 'screenshots', defaultFileName);

        const outputDir = path.dirname(finalOutputPath);
        await fs.mkdir(outputDir, { recursive: true });

        await page.pdf({
            path: finalOutputPath,
            format: 'A4',
            printBackground: true
        });

        return {
            success: true,
            outputPath: finalOutputPath,
            url: url
        };

    } catch (error) {
        return {
            success: false,
            error: error.message,
            url: url
        };
    } finally {
        if (page) await page.close();
        if (browser) await browser.close();
    }
}

module.exports = {
    takeScreenshot,
    takeMultipleScreenshots,
    generatePDF
};



================================================
FILE: src/utils/stream.util.js
================================================
const { PassThrough } = require("stream");
const { v4: uuidv4 } = require("uuid");

const handleStream = (responseType = 'sse', response, debug = true) => {
  const stream = new PassThrough();
  let onTokenStream = new Function();

  if (responseType === "openai-sse") {
    // è®¾ç½®å“åº”å¤´ response
    response.type = "text/event-stream";
    response.set("Cache-Control", "no-cache");
    response.set("Connection", "keep-alive");
    onTokenStream = (token, model = "gpt") => {
      debug && process.stdout.write(token);
      if (typeof token === "object") {
        token = JSON.stringify(token);
      }
      const encoded = JSON.stringify({
        id: uuidv4(),
        object: "chat.completion.chunk",
        created: parseInt((Date.now() / 1000).toFixed(0)),
        model: model,
        choices: [
          {
            index: 0,
            delta: { role: "assistant", content: token },
            finish_reason: null,
          }
        ]
      });
      stream.write(`data: ${encoded}\n\n`);
    };
  }

  if (responseType === 'sse') {
    // è®¾ç½®å“åº”å¤´ response
    response.type = "text/event-stream";
    response.set("Cache-Control", "no-cache");
    response.set("Connection", "keep-alive");
    onTokenStream = (token) => {
      // console.log('token', token);
      if (typeof token === 'object') {
        token = JSON.stringify(token);
        debug && process.stdout.write(token);
      }
      const encoded = Buffer.from(token).toString("base64");
      // const encoded = token;
      stream.write("event: message\n");
      stream.write(`data: ${encoded}\n\n`);
    };
  }

  if (responseType === 'stream') {
    // è®¾ç½®å“åº”å¤´
    response.set("Content-Type", "text/plain");
    response.set("Transfer-Encoding", "chunked");
    onTokenStream = (token) => {
      stream.write(token);
    };
  }

  return { stream, onTokenStream };
}

module.exports = exports = handleStream


================================================
FILE: src/utils/sub_server_forward_request.js
================================================
require('dotenv').config()
const axios = require('axios')
const SUB_SERVER_DOMAIN = process.env.SUB_SERVER_DOMAIN || 'https://app.lemonai.ai';
async function forwardRequest(ctx, method, path) {
  const url = `${SUB_SERVER_DOMAIN}${path}`;
  const config = {
    method,
    maxBodyLength: Infinity,
    url,
    headers: {
      authorization: ctx.headers['authorization'],
    },
  };

  if (method.toUpperCase() === 'GET') {
    config.params = ctx.query; // GET è¯·æ±‚é€šè¿‡ query ä¼ å‚
  } else {
    config.data = ctx.request.body; // POSTã€PUT ç­‰é€šè¿‡ body ä¼ å‚
  }

  const result = await axios.request(config);
  return result.data;
}

module.exports = exports = forwardRequest;


================================================
FILE: src/utils/sub_server_request.js
================================================
require('dotenv').config()
const globals = require('@src/globals');
const axios = require('axios')
const SUB_SERVER_DOMAIN = process.env.SUB_SERVER_DOMAIN || 'https://app.lemonai.ai';
async function sub_server_request(url, data) {
  const full_url = `${SUB_SERVER_DOMAIN}${url}`
  const token = globals.getToken()
  const config = {
    method: "post",
    maxBodyLength: Infinity,
    url:full_url,
    data,
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${token}` // ä½¿ç”¨ä¼ å…¥çš„ token
    },
  };
  console.log("======== config =========",config)
  try {
    const result = await axios.request(config);
    return result.data.data;
  } catch (error) {
    console.error(`Error calling ${url}:`, error.response ? error.response.data : error.message);
    throw error; // æŠ›å‡ºé”™è¯¯ä»¥ä¾¿ä¸Šå±‚æ•è·å¤„ç†
  }
}

module.exports = exports = sub_server_request;


================================================
FILE: src/utils/template.js
================================================
const extractTemplateVariables = (template) => {
  const regex = /(?<!\\)\{([^}]+)\}/g; // ä½¿ç”¨è´Ÿå‘å›æº¯æ–­è¨€æ¥åŒ¹é…éè½¬ä¹‰çš„å¤§æ‹¬å·
  const set = new Set();
  const variables = [];
  let match;

  while ((match = regex.exec(template))) {
    const variable = match[1].trim();
    if (variable.startsWith('\\')) {
      // å¦‚æœå˜é‡ä»¥è½¬ä¹‰ç¬¦\å¼€å¤´ï¼Œåˆ™å»æ‰è½¬ä¹‰ç¬¦
      variables.push(variable.substring(1));
    } else {
      variables.push(variable);
      set.add(variable);
    }
  }
  return Array.from(set);
}

const preprocessValue = (value, variables) => {
  for (const variable of variables) {
    if (value[variable] === undefined) {
      value[variable] = '';
    }
    if (typeof value[variable] !== 'string') {
      value[variable] = JSON.stringify(value[variable]);
    }
  }
  return value;
}

const parseTemplate = (template, data) => {
  return template.replace(/\{([^}]+)\}/g, (match, variable) => {
    const trimmedVariable = variable.trim();
    if (data.hasOwnProperty(trimmedVariable)) {
      return data[trimmedVariable];
    } else {
      // å¦‚æœå˜é‡æœªåœ¨æ•°æ®å¯¹è±¡ä¸­æ‰¾åˆ°ï¼Œä¿ç•™åŸå§‹æ¨¡æ¿å˜é‡
      return match;
    }
  });
}

const resolveTemplate = async (template, value = {}) => {
  const variables = extractTemplateVariables(template);
  preprocessValue(value, variables);
  const prompt = parseTemplate(template, value);
  return prompt;
}

const fs = require('fs');
const path = require('path');
// ç¡®ä¿ä¸´æ—¶ç›®å½•å­˜åœ¨
const { getDirpath } = require('@src/utils/electron');
const cache_dir = getDirpath('Caches/template');
fs.mkdirSync(cache_dir, { recursive: true }); // åˆ›å»ºç›®å½•ï¼Œå¦‚æœå·²å­˜åœ¨åˆ™ä¸åšä»»ä½•æ“ä½œ

const loadTemplate = async (filename) => {
  try {
    const cache_file = path.resolve(cache_dir, filename);
    console.log('cache_file', cache_file);
    if (fs.existsSync(cache_file)) {
      return fs.readFileSync(cache_file, 'utf8');
    }
    const filepath = path.resolve(__dirname, '../template', filename);
    const template = fs.readFileSync(filepath, 'utf8');
    return template
  } catch (error) {
    return ''
  }
}

module.exports = exports = {
  extractTemplateVariables,
  resolveTemplate,
  loadTemplate
}


================================================
FILE: src/utils/text_to_image.js
================================================
[Binary file]


================================================
FILE: src/utils/thinking.js
================================================
// resolve thinking content and output content
const resolveThinking = (content) => {
  content = content.trim();
  let thinking = '';
  let output = '';
  if (content.startsWith('<think>') && content.indexOf('</think>') !== -1) {
    const end = content.indexOf('</think>');
    thinking = content.slice(0, end + 8).trim();
    output = content.slice(end + 8).trim();
  }
  return { thinking, content: output };
}

module.exports = resolveThinking;


================================================
FILE: src/utils/validate.js
================================================
const validateOptions = (options, rules) => {
  // console.log(Object.keys(rules));
  for (const key in rules) {
    const rule = rules[key];
    // è‡ªå®šä¹‰æ ¡éªŒè§„åˆ™
    if (typeof rule.message === 'function') {
      const message = rule.message(options, key)
      if (message) {
        return message
      }
    }
    // å¿…å¡«æ ¡éªŒ
    if (rule.required && !options[key]) {
      return rule.message || `è¯·å‘Šè¯‰æˆ‘ ${key} çš„ç›¸å…³ä¿¡æ¯`;
    }
  }
}

module.exports = exports = {
  validateOptions
};


================================================
FILE: src/utils/versionManager.js
================================================
const FileVersion = require("@src/models/FileVersion");
const fs = require('fs');
const { extractRelativePath, resolveAbsolutePath } = require('./filePathHelper');

/**
 * åˆ›å»ºæ–‡ä»¶ç‰ˆæœ¬ - ç®€åŒ–çš„API
 * @param {string} filepath - æ–‡ä»¶è·¯å¾„ï¼ˆè‡ªåŠ¨å¤„ç†ç›¸å¯¹/ç»å¯¹è·¯å¾„ï¼‰
 * @param {string} conversation_id - ä¼šè¯ID
 * @param {Object} options - å¯é€‰å‚æ•°
 * @returns {Promise<Object>} ç‰ˆæœ¬ä¿¡æ¯
 */
const createVersion = async (filepath, conversation_id, options = {}) => {
  if (!filepath || !conversation_id) {
    throw new Error('filepath and conversation_id are required');
  }

  const {
    content = null,
    user_id = null,
    state = null,
    action = 'AIç¼–è¾‘',
    metadata = {}
  } = options;

  try {
    // è‡ªåŠ¨å¤„ç†è·¯å¾„
    const relativePath = extractRelativePath(filepath);
    // å¦‚æœæ²¡æœ‰æä¾› contentï¼Œå°è¯•è¯»å–æ–‡ä»¶
    let fileContent = content;
    if (!fileContent) {
      const absolutePath = state ? resolveAbsolutePath(relativePath, state) : filepath;
      if (fs.existsSync(absolutePath)) {
        fileContent = fs.readFileSync(absolutePath, 'utf-8');
      } else {
        throw new Error(`File not found: ${absolutePath}`);
      }
    }

    // æŸ¥è¯¢æœ€æ–°ç‰ˆæœ¬å·
    const latestVersion = await FileVersion.findOne({
      where: { conversation_id, filepath: relativePath },
      order: [['version', 'DESC']]
    });

    const nextVersion = latestVersion ? latestVersion.version + 1 : 1;

    // æ‰¹é‡æ›´æ–°æ‰€æœ‰ç‰ˆæœ¬çš„activeçŠ¶æ€
    await FileVersion.update(
      { active: false },
      { where: { conversation_id, filepath: relativePath } }
    );

    // åˆ›å»ºæ–°ç‰ˆæœ¬
    const newVersion = await FileVersion.create({
      user_id,
      conversation_id,
      filepath: relativePath,
      content: fileContent,
      version: nextVersion,
      active: true,
      action,
      metadata: JSON.stringify(metadata)
    });

    console.log(`[Version] Created v${nextVersion} for ${relativePath}`);

    return {
      id: newVersion.id,
      version: newVersion.version,
      filepath: relativePath
    };
  } catch (error) {
    console.error('[Version] Create failed:', error);
    throw error;
  }
};

/**
 * è·å–ç‰ˆæœ¬åˆ—è¡¨ - ç®€åŒ–çš„API
 */
const getVersions = async (conversation_id, filepath) => {
  if (!conversation_id || !filepath) {
    throw new Error('conversation_id and filepath are required');
  }

  const relativePath = extractRelativePath(filepath);

  try {
    return await FileVersion.findAll({
      where: { conversation_id, filepath: relativePath },
      attributes: ['id', 'version', 'create_at', 'active'],
      order: [['version', 'ASC']]
    });
  } catch (error) {
    console.error('[Version] Get versions failed:', error);
    throw error;
  }
};

/**
 * åˆ‡æ¢ç‰ˆæœ¬ - ç®€åŒ–çš„API
 */
const switchToVersion = async (version_id, conversation_id, filepath, state = null) => {
  if (!version_id || !conversation_id || !filepath) {
    throw new Error('version_id, conversation_id and filepath are required');
  }

  const relativePath = extractRelativePath(filepath);

  try {
    // è·å–ç›®æ ‡ç‰ˆæœ¬
    const targetVersion = await FileVersion.findOne({
      where: { id: version_id }
    });

    if (!targetVersion) {
      throw new Error('Version not found');
    }

    // æ‰¹é‡æ›´æ–°activeçŠ¶æ€
    await FileVersion.update(
      { active: false },
      { where: { conversation_id, filepath: relativePath } }
    );

    await FileVersion.update(
      { active: true },
      { where: { id: version_id } }
    );

    // å†™å…¥æ–‡ä»¶ï¼ˆå¦‚æœæä¾›äº†stateï¼‰
    if (state) {
      const absolutePath = resolveAbsolutePath(relativePath, state);
      if (absolutePath && fs.existsSync(require('path').dirname(absolutePath))) {
        fs.writeFileSync(absolutePath, targetVersion.content);
        console.log(`[Version] Switched to v${targetVersion.version}`);
      }
    }

    return {
      version_id,
      version: targetVersion.version,
      content: targetVersion.content
    };
  } catch (error) {
    console.error('[Version] Switch failed:', error);
    throw error;
  }
};

/**
 * è·å–å½“å‰æ¿€æ´»ç‰ˆæœ¬
 */
const getActiveVersion = async (conversation_id, filepath) => {
  if (!conversation_id || !filepath) {
    throw new Error('conversation_id and filepath are required');
  }

  const relativePath = extractRelativePath(filepath);

  try {
    return await FileVersion.findOne({
      where: { conversation_id, filepath: relativePath, active: true },
      attributes: ['id', 'version', 'content', 'create_at', 'action']
    });
  } catch (error) {
    console.error('[Version] Get active version failed:', error);
    throw error;
  }
};

/**
 * å¿«é€Ÿåˆ›å»ºç‰ˆæœ¬ï¼ˆæœ€ç®€åŒ–çš„APIï¼‰
 * @example
 * await quickCreateVersion(filepath, conversation_id, state);
 */
const quickCreateVersion = async (filepath, conversation_id, state) => {
  return createVersion(filepath, conversation_id, { state, action: 'æ‰‹åŠ¨ä¿å­˜' });
};

/**
 * AIç¼–è¾‘ååˆ›å»ºç‰ˆæœ¬
 * @example
 * await createAIVersion(filepath, conversation_id, { requirement: 'ä¿®å¤bug' });
 */
const createAIVersion = async (filepath, conversation_id, metadata = {}) => {
  return createVersion(filepath, conversation_id, {
    action: 'AIç¼–è¾‘',
    metadata
  });
};

const createFilesVersion = async (conversation_id, files, suffix = '.html', state = null) => {
  try {
    const htmlFiles = files.filter(file => file?.filepath?.endsWith(suffix));
    for (const file of htmlFiles) {
      const filepath = extractRelativePath(file.filepath);
      const exists = await FileVersion.findOne({ where: { conversation_id, filepath } });
      if (exists) {
        continue;
      }
      await createVersion(filepath, conversation_id, { state, action: 'Agent Coding' });
    }
  } catch (error) {
    console.error('[Version] Create files version failed:', error);
  }
};

module.exports = {
  createVersion,
  getVersions,
  switchToVersion,
  getActiveVersion,
  quickCreateVersion,
  createAIVersion,
  createFilesVersion
};


================================================
FILE: src/xml/index.js
================================================
const { parseXML } = require('./resolve.xml.optimize.js');

const resolveXML = (content) => {
  if (!content || typeof content !== 'string') {
    throw new Error('XMLå†…å®¹å¿…é¡»æ˜¯éç©ºå­—ç¬¦ä¸²');
  }

  try {
    return parseXML(content, undefined, {});
  } catch (error) {
    console.error('[resolveXML] è§£æå¤±è´¥:', error.message);
    throw new Error(`XML è§£æå¤±è´¥: ${error.message}`);
  }
};

const resolveActions = xml => {
  try {
    const resolved = resolveXML(xml);
    const actions = []
    for (let key in resolved) {
      let value = resolved[key];
      const action = {
        type: key,
        params: value
      }
      actions.push(action);
    }
    return actions;
  } catch (err) {
    console.log(err);
    return [];
  }
}

module.exports = {
  resolveXML,
  resolveActions
};


================================================
FILE: src/xml/resolve.xml.optimize.js
================================================
/**
 * æµå¼ XML è§£æå™¨
 * action æ ‡ç­¾ä»¥åŠå¯¹åº”çš„ params å­—æ®µ
 */

const defaultActions = [
  ['finish', ['message']],
  ['write_code', ['path', 'content']],
  ['write_file', ['path', 'content']],
  ['read_file', ['path']],
  ['revise_plan', ['mode', 'reason', 'tasks']],
  ['terminal_run', ['command', 'args']],
  ['web_search', ['topic', 'query', 'num_results']],
  ['browser', ['question']],
  ['mcp_tool', ['name', 'arguments']],
  ['evaluation', ['status', 'comments']],
  ['document_query', ['query', 'conversation_id']],
  ['document_upload', ['file_path', 'conversation_id', 'file_name']]
];

class StreamingXMLParser {
  constructor(onChunk, actions = defaultActions, options = {}) {
    this.actions = new Map(actions.map(([name, fields]) => [name, new Set(fields)]));
    this.onChunk = onChunk;
    this.result = {};

    this.currentAction = null;
    this.currentField = null;
    this.fieldStartPos = -1;
    this.buffer = '';
    this.streamedLength = 0; // å·²ç»æµå¼è¾“å‡ºçš„é•¿åº¦
    this.debug = options.debug || false; // è°ƒè¯•é€‰é¡¹
  }

  /**
   * è·å–ä½ç½®å‰åçš„æ–‡æœ¬é¢„è§ˆ
   */
  _getContextPreview(pos, prefix = 30, suffix = 30) {
    const start = Math.max(0, pos - prefix);
    const end = Math.min(this.buffer.length, pos + suffix);
    const before = this.buffer.substring(start, pos).replace(/\n/g, '\\n');
    const after = this.buffer.substring(pos, end).replace(/\n/g, '\\n');
    return `...${before}â–ˆ${after}...`;
  }

  /**
   * è°ƒè¯•æ—¥å¿—
   */
  _log(message, data = {}) {
    if (!this.debug) return;
    console.log(`[XML Parser] ${message}`);
    if (Object.keys(data).length > 0) {
      console.log('  ', JSON.stringify(data, null, 2).replace(/\n/g, '\n  '));
    }
  }

  /**
   * æµå¼è¾“å…¥
   * @param {*} chunk 
   */
  feed(chunk) {
    this.buffer += chunk;
    this.parse();
  }

  /**
   * å¤„ç† field é—­åˆæ ‡ç­¾
   */
  _handleFieldClose(closePos) {
    const content = this.buffer.substring(this.fieldStartPos, closePos);
    const closeTag = `</${this.currentField}>`;
    const newPos = closePos + closeTag.length;

    this._log(`âœ… Field é—­åˆ: ${this.currentAction}.${this.currentField}`, {
      pos: closePos,
      newPos: newPos,
      contentLength: content.length,
      contentPreview: content.substring(0, 100).replace(/\n/g, '\\n'),
      context: this._getContextPreview(closePos)
    });

    // æµå¼è¾“å‡ºå‰©ä½™å†…å®¹
    this._streamRemainingContent(content, true);

    // ä¿å­˜ç»“æœ
    this.result[this.currentAction] = this.result[this.currentAction] || {};
    this.result[this.currentAction][this.currentField] = content;

    this.currentField = null;
    this.fieldStartPos = -1;
    this.streamedLength = 0;

    return newPos;
  }

  /**
   * æµå¼è¾“å‡ºå†…å®¹
   */
  _streamRemainingContent(content, isComplete) {
    if (!this.onChunk) return;

    const newContent = content.substring(this.streamedLength);
    if (newContent) {
      this.onChunk({
        action: this.currentAction,
        field: this.currentField,
        chunk: newContent,
        isComplete
      });

      if (!isComplete) {
        this.streamedLength = content.length;
      }
    }
  }

  /**
   * è§£æ field å†…éƒ¨å†…å®¹
   */
  _parseInsideField(pos) {
    const closeTag = `</${this.currentField}>`;
    const closePos = this.buffer.indexOf(closeTag, pos);

    if (closePos !== -1) {
      // æ‰¾åˆ°é—­åˆæ ‡ç­¾
      return this._handleFieldClose(closePos);
    }

    // æœªæ‰¾åˆ°é—­åˆæ ‡ç­¾ï¼Œè¾“å‡ºå¢é‡å†…å®¹
    const currentContent = this.buffer.substring(this.fieldStartPos);
    this._streamRemainingContent(currentContent, false);

    this._log(`â¸ï¸  ç­‰å¾…æ›´å¤šæ•°æ® (field: ${this.currentField})`, {
      pos: pos,
      searchingFor: closeTag,
      bufferedContentLength: currentContent.length,
      streamedLength: this.streamedLength,
      bufferEnd: this.buffer.length
    });

    return -1; // è¡¨ç¤ºéœ€è¦ç­‰å¾…æ›´å¤šæ•°æ®
  }

  /**
   * å¤„ç† action é—­åˆæ ‡ç­¾
   */
  _handleActionClose(pos) {
    const closeTag = `</${this.currentAction}>`;
    const newPos = pos + closeTag.length;

    this._log(`âœ… Action é—­åˆ: ${this.currentAction}`, {
      pos: pos,
      newPos: newPos,
      closeTag: closeTag,
      context: this._getContextPreview(pos)
    });

    this.currentAction = null;
    return newPos;
  }

  /**
   * å¤„ç† field å¼€å§‹æ ‡ç­¾
   */
  _handleFieldStart(tagName, tagLength, pos) {
    const newPos = pos + tagLength;

    this._log(`ğŸ†• Field å¼€å§‹: ${this.currentAction}.${tagName}`, {
      pos: pos,
      newPos: newPos,
      tag: `<${tagName}>`,
      context: this._getContextPreview(pos)
    });

    this.currentField = tagName;
    this.fieldStartPos = newPos;
    this.streamedLength = 0;
    return newPos;
  }

  /**
   * è§£æ action å†…éƒ¨å†…å®¹
   */
  _parseInsideAction(pos) {
    const substr = this.buffer.substring(pos);
    const tagMatch = substr.match(/^<(\w+)>/);
    const closingTagMatch = substr.match(/^<\/(\w+)>/);

    if (!tagMatch && !closingTagMatch) {
      // æ²¡æœ‰åŒ¹é…åˆ°ä»»ä½•æ ‡ç­¾
      return pos + 1;
    }

    // ä¼˜å…ˆæ£€æŸ¥é—­åˆæ ‡ç­¾
    if (closingTagMatch) {
      const closingTagName = closingTagMatch[1];
      if (closingTagName === this.currentAction) {
        this._log(`ğŸ” Actionå†…éƒ¨æ£€æµ‹åˆ°é—­åˆæ ‡ç­¾`, {
          pos: pos,
          closingTag: `</${closingTagName}>`,
          context: this._getContextPreview(pos)
        });
        return this._handleActionClose(pos);
      }
      // é—­åˆæ ‡ç­¾ä¸åŒ¹é…ï¼Œè·³è¿‡
      return pos + 1;
    }

    // å¤„ç†å¼€å§‹æ ‡ç­¾
    const tagName = tagMatch[1];

    this._log(`ğŸ” Actionå†…éƒ¨æ£€æµ‹åˆ°å¼€å§‹æ ‡ç­¾`, {
      pos: pos,
      tagName: tagName,
      currentAction: this.currentAction,
      isValidField: this.actions.get(this.currentAction).has(tagName),
      context: this._getContextPreview(pos)
    });

    if (this.actions.get(this.currentAction).has(tagName)) {
      return this._handleFieldStart(tagName, tagMatch[0].length, pos);
    }

    this._log(`â­ï¸  è·³è¿‡éfieldæ ‡ç­¾: <${tagName}>`, {
      pos: pos,
      expectedFields: Array.from(this.actions.get(this.currentAction))
    });

    return pos + 1;
  }

  /**
   * å¤„ç† action å¼€å§‹æ ‡ç­¾
   */
  _handleActionStart(tagName, tagLength, pos) {
    const newPos = pos + tagLength;

    this._log(`ğŸ†• Action å¼€å§‹: ${tagName}`, {
      pos: pos,
      newPos: newPos,
      match: this.buffer.substring(pos, newPos),
      tag: `<${tagName}>`,
      context: this._getContextPreview(pos)
    });

    this.currentAction = tagName;
    this.result[tagName] = this.result[tagName] || {};
    return newPos;
  }

  /**
   * æŸ¥æ‰¾ action å¼€å§‹æ ‡ç­¾
   */
  _findActionStart(pos) {
    const tagMatch = this.buffer.substring(pos).match(/^<(\w+)>/);

    if (!tagMatch) {
      return pos + 1;
    }

    const tagName = tagMatch[1];

    if (this.actions.has(tagName)) {
      return this._handleActionStart(tagName, tagMatch[0].length, pos);
    }

    return pos + 1;
  }

  /**
   * æ¸…ç†å·²å¤„ç†çš„ buffer
   */
  _cleanupBuffer(pos) {
    if (pos > 0 && !this.currentField) {
      const cleaned = pos;
      this.buffer = this.buffer.substring(pos);
      if (this.fieldStartPos !== -1) {
        this.fieldStartPos -= pos;
      }

      this._log(`ğŸ—‘ï¸  æ¸…ç† buffer`, {
        cleanedBytes: cleaned,
        remainingBytes: this.buffer.length,
        remainingPreview: this.buffer.substring(0, 100).replace(/\n/g, '\\n')
      });
    }
  }

  /**
   * ä¸»è§£æå¾ªç¯
   */
  parse() {
    let pos = 0;

    // æ•°æ®æ‰«æ
    while (pos < this.buffer.length) {
      if (this.currentField) {
        const newPos = this._parseInsideField(pos);
        if (newPos === -1) break; // ç­‰å¾…æ›´å¤šæ•°æ®
        pos = newPos;
      } else if (this.currentAction) {
        // åœ¨ action å†…éƒ¨, è§£æ action å†…éƒ¨å†…å®¹
        pos = this._parseInsideAction(pos);
      } else {
        // æŸ¥æ‰¾ action å¼€å§‹æ ‡ç­¾, æ‰¾åˆ° action å¼€å§‹æ ‡ç­¾å, ä¼šè§¦å‘ _handleActionStart
        pos = this._findActionStart(pos);
      }
    }

    this._cleanupBuffer(pos);
  }

  end() {
    // å¤„ç†å‰©ä½™çš„ buffer
    if (this.buffer.length > 0) {
      this.parse();
    }

    return this.result;
  }

  getResult() {
    return this.result;
  }
}

/** ç§»é™¤ CDATA åŒ…è£¹ */
const stripCDATA = (text) => {
  if (!text || typeof text !== 'string') return text;
  const trimmed = text.trim();
  if (trimmed.startsWith('<![CDATA[') && trimmed.endsWith(']]>')) {
    return trimmed.slice(9, -3);
  }
  return text;
};

/**
 * è§£æå®Œæ•´çš„ XML æ–‡æ¡£
 * @param {string} xml - XML æ–‡æ¡£
 * @param {Array} actions - action å®šä¹‰æ•°ç»„
 * @param {Object} options - é€‰é¡¹ { debug: boolean }
 * @returns {Object} - è§£æç»“æœ
 */
const parseXML = (xml, actions, options) => {
  const parser = new StreamingXMLParser(null, actions, options);
  parser.feed(xml);
  const result = parser.end();
  if (result?.write_code?.content) {
    result.write_code.content = stripCDATA(result.write_code.content);
  }
  return result;
}

/**
 * æµå¼è§£æ XML
 * @param {Function} onChunk - æµå¼å›è°ƒå‡½æ•°
 * @param {Array} actions - action å®šä¹‰æ•°ç»„
 * @param {Object} options - é€‰é¡¹ { debug: boolean }
 * @returns {StreamingXMLParser} - è§£æå™¨å®ä¾‹
 */
const createStreamingParser = (onChunk, actions, options) => {
  return new StreamingXMLParser(onChunk, actions, options);
}

module.exports = {
  StreamingXMLParser,
  parseXML,
  createStreamingParser,
  stripCDATA
};


================================================
FILE: test/api/platform/platform.test.js
================================================
const request = require("supertest");
const sinon = require("sinon");
const { expect } = require("chai");

const app = require("../../../src/app"); // reference to your app instance in the project
const Platform = require("@src/models/Platform");

describe("Platform Routes", () => {
  let server;

  before(() => {
    server = app.listen();
  });

  after(() => {
    server.close();
  });

  afterEach(() => {
    sinon.restore();
  });

  it("should create a platform", async () => {
    const mockData = { id: 1, name: "Test", logo_url: "http://logo", source_type: "user" };
    sinon.stub(Platform, "create").resolves(mockData);

    const res = await request(server)
      .post("/api/platform")
      .send({ name: "Test", logo_url: "http://logo", source_type: "user" });

    expect(res.status).to.equal(200);
    expect(res.body.data.name).to.equal("Test");
  });

  it("should return list of platforms", async () => {
    sinon.stub(Platform, "findAll").resolves([{ id: 1, name: "Platform 1" }]);

    const res = await request(server).get("/api/platform");

    expect(res.status).to.equal(200);
    expect(res.body.data).to.be.an("array");
    expect(res.body.data[0].name).to.equal("Platform 1");
  });

  it("should update a platform", async () => {
    const mockPlatform = {
      id: 1,
      update: sinon.stub().resolvesThis(),
    };
    sinon.stub(Platform, "findOne").resolves(mockPlatform);

    const res = await request(server)
      .put("/api/platform/1")
      .send({ api_key: "123", api_url: "http://api" });

    expect(res.status).to.equal(200);
    expect(mockPlatform.update.calledOnce).to.be.true;
  });

  it("should not update if platform does not exist", async () => {
    sinon.stub(Platform, "findOne").resolves(null);

    const res = await request(server)
      .put("/api/platform/1")
      .send({ api_key: "123", api_url: "http://api" });

    expect(res.status).to.equal(200);
    expect(res.body.msg).to.equal("Platform does not exist");
  });

  it("should delete a platform", async () => {
    const mockPlatform = {
      id: 1,
      source_type: "user",
      destroy: sinon.stub().resolves(),
    };
    sinon.stub(Platform, "findOne").resolves(mockPlatform);

    const res = await request(server).delete("/api/platform/1");

    expect(res.status).to.equal(200);
    expect(mockPlatform.destroy.calledOnce).to.be.true;
  });

  it("should not delete a system platform", async () => {
    const mockPlatform = {
      id: 1,
      source_type: "system",
    };
    sinon.stub(Platform, "findOne").resolves(mockPlatform);

    const res = await request(server).delete("/api/platform/1");

    expect(res.status).to.equal(200);
    expect(res.body.msg).to.equal("system platform cannot be deleted");
  });

  it("should not delete non-existent platform", async () => {
    sinon.stub(Platform, "findOne").resolves(null);

    const res = await request(server).delete("/api/platform/1");

    expect(res.status).to.equal(200);
    expect(res.body.msg).to.equal("Platform does not exist");
  });
});



================================================
FILE: types/LocalRuntime.d.ts
================================================
// LocalRuntime.d.ts
export interface Memory {
  addMessage(
    role: string,
    content: string,
    type: string,
    memorized: boolean,
    meta: any
  ): Promise<void>;
}

export interface ActionResult {
  uuid?: string;
  status: "success" | "failure" | string; // Extended allowed values
  content: string; // Text content
  error?: any;
  stderr?: any; // Additional properties can be added if needed
  memorized?: boolean; // Whether the result is memorized
  meta?: any; // Extended properties
}

export interface Action {
  type: string;
  params: Record<string, any>;
}

export interface LocalRuntime {
  memory: Memory;
  constructor(options?: { memory: Memory });
  handle_memory(result: ActionResult, action: Action): Promise<Memory>;
  execute_action(action: Action): Promise<ActionResult>;
  write_code(action: Action): Promise<ActionResult>;
  read_file(action: Action): Promise<ActionResult>;
}



================================================
FILE: types/Tool.d.ts
================================================
/**
 * Describes a single parameter for a tool.
 * Follows a subset of JSON Schema principles.
 */
export interface ToolParameter {
  type: "string" | "number" | "boolean" | "integer" | "array" | "object"; // Data type
  description: string; // Description for the LLM to understand the parameter
  items?: ToolParameter; // If type is 'array', describes the items in the array
  properties?: { [key: string]: ToolParameter }; // If type is 'object', describes the properties
  required?: string[]; // If type is 'object', lists required properties within it
  enum?: (string | number | boolean)[]; // Optional list of allowed values
}

/**
 * Defines the schema for the parameters object required by the tool's execute function.
 */
export interface ToolParameters {
  type: "object";
  properties: {
    [key: string]: ToolParameter; // Map parameter names to their definitions
  };
  required?: string[]; // List of parameter names that are mandatory
}

import { ActionResult } from "types/LocalRuntime";

/**
 * Represents an executable tool that the LLM Agent can use.
 */
export interface Tool {
  /**
   * A unique, descriptive name for the tool (used by the LLM to identify it).
   * Conventionally uses snake_case or camelCase.
   */
  name: string;

  /**
   * A detailed description of what the tool does, when it should be used,
   * and what kind of output it provides. Crucial for the LLM's planning.
   */
  description: string;

  /**
   * A JSON Schema-like definition of the parameters the tool's `execute` function expects.
   * This helps the LLM generate the correct arguments.
   */
  params: ToolParameters;

  /**
   * Indicates whether the tool's output should be included in the task memory
   * Useful for tools that provide contextual information that can be used for future tasks.
   */
  memorized?: boolean;

  /**
   * A function that generates a description of the tool's action based on the provided arguments.
   */
  getActionDescription?: (args: Record<string, any>) => Promise<string>;

  /**
   * The asynchronous function that performs the tool's action.
   * @param args - An object containing the arguments extracted by the LLM, matching the `parameters` schema.
   * @returns A Promise resolving to a string result that the LLM can understand and use.
   *          Should handle potential errors internally or throw errors that the agent can catch.
   */
  execute: (
    args: Record<string, any>,
    uuid: string,
    context: any
  ) => Promise<ActionResult>;
}



================================================
FILE: .github/workflows/app_docker_build_push.yml
================================================
[Binary file]


================================================
FILE: .trae/rules/project_rules.md
================================================
[Empty file]

